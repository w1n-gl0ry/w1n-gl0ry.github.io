<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AFL源码及流程分析 | LYYL' Blog</title>
  <meta name="keywords" content="AFL, 源码分析">
  <meta name="author" content="LYYL">
  <meta name="copyright" content="LYYL">
  <meta name="format-detection" content="telephone=no">
  <meta name="theme-color" content="#0d0d0d">
  <meta name="description"
    content="源码文件结构这里我们直接在AFL的网站上下载最新的代码之后，即得到如下的文件夹 12345lyyl@lyyl:~&#x2F;Desktop&#x2F;afl&#x2F;afl-2.52b$ lsafl-analyze    afl-as.c   afl-clang++  afl-fuzz.c  afl-gcc.c     afl-plot       afl-tmin     alloc-inl.h  debug.h">
  <meta property="og:type" content="article">
  <meta property="og:title" content="AFL源码及流程分析">
  <meta property="og:url" content="https://www.lyyl.online/posts/95726211.html">
  <meta property="og:site_name" content="LYYL&#39; Blog">
  <meta property="og:description"
    content="源码文件结构这里我们直接在AFL的网站上下载最新的代码之后，即得到如下的文件夹 12345lyyl@lyyl:~&#x2F;Desktop&#x2F;afl&#x2F;afl-2.52b$ lsafl-analyze    afl-as.c   afl-clang++  afl-fuzz.c  afl-gcc.c     afl-plot       afl-tmin     alloc-inl.h  debug.h">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:image" content="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-3.jpeg">
  <meta property="article:published_time" content="2022-05-26T07:20:45.000Z">
  <meta property="article:modified_time" content="2022-05-26T07:56:59.322Z">
  <meta property="article:author" content="LYYL">
  <meta property="article:tag" content="LYYL, Blog, Pwn, pwn">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-3.jpeg">
  <link rel="shortcut icon" href="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png">
  <link rel="canonical" href="https://www.lyyl.online/posts/95726211">
  <link rel="preconnect" href="//cdn.jsdelivr.net" />
  <link rel="preconnect" href="//www.google-analytics.com" crossorigin="" />
  <link rel="preconnect" href="//busuanzi.ibruce.info" />
  <link rel="stylesheet" href="/css/index.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print"
    onload="this.media='all'">
  <script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>(adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: 'ca-pub-8740935439028405',
      enable_page_level_ads: 'true'
    });</script>
  <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-MBZHBXMDJ2"></script>
  <script>window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-MBZHBXMDJ2');
  </script>
  <script>const GLOBAL_CONFIG = {
      root: '/',
      algolia: undefined,
      localSearch: undefined,
      translate: undefined,
      noticeOutdate: undefined,
      highlight: { "plugin": "highlighjs", "highlightCopy": true, "highlightLang": true, "highlightHeightLimit": 200 },
      copy: {
        success: '复制成功',
        error: '复制错误',
        noSupport: '浏览器不支持'
      },
      relativeDate: {
        homepage: false,
        post: false
      },
      runtime: '',
      date_suffix: {
        just: '刚刚',
        min: '分钟前',
        hour: '小时前',
        day: '天前',
        month: '个月前'
      },
      copyright: undefined,
      lightbox: 'fancybox',
      Snackbar: undefined,
      source: {
        jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
        justifiedGallery: {
          js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
          css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
        },
        fancybox: {
          js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
          css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
        }
      },
      isPhotoFigcaption: false,
      islazyload: false,
      isanchor: false
    }</script>
  <script id="config-diff">var GLOBAL_CONFIG_SITE = {
      title: 'AFL源码及流程分析',
      isPost: true,
      isHome: false,
      isHighlightShrink: false,
      isToc: true,
      postUpdate: '2022-05-26 15:56:59'
    }</script><noscript>
    <style type="text/css">
      #nav {
        opacity: 1
      }

      .justified-gallery img {
        opacity: 1
      }

      #recent-posts time,
      #post-meta time {
        display: inline !important
      }
    </style>
  </noscript>
  <script>(win => {
                               win.saveToLocal = {
                                 set: function setWithExpiry(key, value, ttl) {
                                   if (ttl === 0) return
                                   const now = new Date()
                                   const expiryDay = ttl * 86400000
                                   const item = {
                                     value: value,
                                     expiry: now.getTime() + expiryDay,
                                   }
                                   localStorage.setItem(key, JSON.stringify(item))
                                 },

                                 get: function getWithExpiry(key) {
                                   const itemStr = localStorage.getItem(key)

                                   if (!itemStr) {
                                     return undefined
                                   }
                                   const item = JSON.parse(itemStr)
                                   const now = new Date()

                                   if (now.getTime() > item.expiry) {
                                     localStorage.removeItem(key)
                                     return undefined
                                   }
                                   return item.value
                                 }
                               }

                               win.getScript = url => new Promise((resolve, reject) => {
                                 const script = document.createElement('script')
                                 script.src = url
                                 script.async = true
                                 script.onerror = reject
                                 script.onload = script.onreadystatechange = function () {
                                   const loadState = this.readyState
                                   if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                                   script.onload = script.onreadystatechange = null
                                   resolve()
                                 }
                                 document.head.appendChild(script)
                               })

                               win.activateDarkMode = function () {
                                 document.documentElement.setAttribute('data-theme', 'dark')
                                 if (document.querySelector('meta[name="theme-color"]') !== null) {
                                   document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
                                 }
                               }
                               win.activateLightMode = function () {
                                 document.documentElement.setAttribute('data-theme', 'light')
                                 if (document.querySelector('meta[name="theme-color"]') !== null) {
                                   document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
                                 }
                               }
                               const t = saveToLocal.get('theme')

                               if (t === 'dark') activateDarkMode()
                               else if (t === 'light') activateLightMode()

                               const asideStatus = saveToLocal.get('aside-status')
                               if (asideStatus !== undefined) {
                                 if (asideStatus === 'hide') {
                                   document.documentElement.classList.add('hide-aside')
                                 } else {
                                   document.documentElement.classList.remove('hide-aside')
                                 }
                               }

                               const detectApple = () => {
                                 if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
                                   document.documentElement.classList.add('apple')
                                 }
                               }
                               detectApple()
                             })(window)</script>
  <meta name="generator" content="Hexo 6.2.0">
</head>

<body>
  <div id="sidebar">
    <div id="menu-mask"></div>
    <div id="sidebar-menus">
      <div class="avatar-img is-center"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png"
          onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar" /></div>
      <div class="site-data">
        <div class="data-item is-center">
          <div class="data-item-link"><a href="/archives/">
              <div class="headline">文章</div>
              <div class="length-num">27</div>
            </a></div>
        </div>
        <div class="data-item is-center">
          <div class="data-item-link"><a href="/categories/">
              <div class="headline">分类</div>
              <div class="length-num">5</div>
            </a></div>
        </div>
      </div>
      <hr />
      <div class="menus_items">
        <div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a>
        </div>
        <div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span>
              Archives</span></a></div>
        <div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span>
              Categories</span></a></div>
        <div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span>
              About</span></a></div>
      </div>
    </div>
  </div>
  <div class="post" id="body-wrap">
    <header class="post-bg" id="page-header"
      style="background-image: url('https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-3.jpeg')">
      <nav id="nav"><span id="blog_name"><a id="site-name" href="/">LYYL' Blog</a></span>
        <div id="menus">
          <div class="menus_items">
            <div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span>
                  Home</span></a></div>
            <div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span>
                  Archives</span></a></div>
            <div class="menus_item"><a class="site-page" href="/categories/"><i
                  class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div>
            <div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span>
                  About</span></a></div>
          </div>
          <div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div>
        </div>
      </nav>
      <div id="post-info">
        <h1 class="post-title">AFL源码及流程分析</h1>
        <div id="post-meta">
          <div class="meta-firstline"><span class="post-meta-date"><i
                class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time
                datetime="2022-05-26T07:20:45.000Z" title="undefined 2022-05-26 15:20:45">2022-05-26</time></span><span
              class="post-meta-categories"><span class="post-meta-separator">|</span><i
                class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories"
                href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span></div>
          <div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i
                class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span
                class="word-count">20.9k</span><span class="post-meta-separator">|</span><i
                class="far fa-clock fa-fw post-meta-icon"></i><span
                class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span
              class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AFL源码及流程分析"><i
                class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span
                id="busuanzi_value_page_pv"></span></span></div>
        </div>
      </div>
    </header>
    <main class="layout" id="content-inner">
      <div id="post">
        <article class="post-content" id="article-container">
          <h1 id="源码文件结构"><a href="#源码文件结构" class="headerlink" title="源码文件结构"></a>源码文件结构</h1>
          <p>这里我们直接在AFL的网站上下载最新的代码之后，即得到如下的文件夹</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">lyyl@lyyl:~/Desktop/afl/afl<span class="number">-2.52b</span>$ ls</span><br><span class="line">afl-analyze    afl-as.c   afl-clang++  afl-fuzz.c  afl-gcc.c     afl-plot       afl-tmin     alloc-inl.h  debug.h       experimental   libtokencap  qemu_mode            testcases</span><br><span class="line">afl-analyze.c  afl-as.h   afl-cmin     afl-g++     afl-gotcpu    afl-showmap    afl-tmin.c   as           dictionaries  hash.h         llvm_mode    QuickStartGuide.txt  test-instr.c</span><br><span class="line">afl-as         afl-clang  afl-fuzz     afl-gcc     afl-gotcpu.c  afl-showmap.c  afl-whatsup  config.h     docs          libdislocator  Makefile     README               types.h</span><br><span class="line">lyyl@lyyl:~/Desktop/afl/afl<span class="number">-2.52b</span>$</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里主要的代码位于afl-fuzz.c这个文件中是整个afl的核心代码。这里我们先来看一下各个模块的主要功能以及作用</p>
          <table>
            <thead>
              <tr>
                <th>afl-as.c，afl-as.h，afl-gcc.c</th>
                <th>普通的插桩模式，gcc和clang都适用。</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>llvm_mode</td>
                <td>llvm插桩模式，只适用于clang</td>
              </tr>
              <tr>
                <td>qemu_mode</td>
                <td>qemu插桩模式的，针对的是二进制文件</td>
              </tr>
              <tr>
                <td>afl-fuzz.c</td>
                <td>fuzzer实现的核心代码，是整个AFL的核心</td>
              </tr>
              <tr>
                <td>libdislocator</td>
                <td>简单的内存检测的工具</td>
              </tr>
              <tr>
                <td>libtokencap</td>
                <td>语法的关键字提取并生成相应的字典文件</td>
              </tr>
              <tr>
                <td>afl-analyze.c</td>
                <td>对测试样例的字典进行分析</td>
              </tr>
              <tr>
                <td>afl-cmin</td>
                <td>对fuzzing用到的语料库进行一个精简的操作</td>
              </tr>
              <tr>
                <td>afl-tmin.c</td>
                <td>对fuzzing中用到的测试用例进行最小化的操作</td>
              </tr>
              <tr>
                <td>afl-gotcpu.c</td>
                <td>统计CPU的占用率</td>
              </tr>
              <tr>
                <td>afl-plot</td>
                <td>绘制报告图标</td>
              </tr>
              <tr>
                <td>afl-showmap.c</td>
                <td>打印目标程序单轮fuzz之后的tuple也就是路径信息</td>
              </tr>
              <tr>
                <td>afl-whatsup</td>
                <td>各个并行的例程的fuzzing结果统计</td>
              </tr>
              <tr>
                <td>alloc-inl.h</td>
                <td>定义带有检测功能的内存分配以及释放的操作</td>
              </tr>
              <tr>
                <td>config.h</td>
                <td>配置信息</td>
              </tr>
              <tr>
                <td>debug.h</td>
                <td>跟提示信息相关的一些宏定义</td>
              </tr>
              <tr>
                <td>Hash.h</td>
                <td>hash函数的实现以及定义</td>
              </tr>
              <tr>
                <td>Types.h</td>
                <td>部分的类型以及宏定义</td>
              </tr>
              <tr>
                <td>test-instr.c</td>
                <td>作为测试的目标程序</td>
              </tr>
              <tr>
                <td>Docs</td>
                <td>项目的一些相关的文档</td>
              </tr>
              <tr>
                <td>experimental</td>
                <td>一些新特性的实验研究</td>
              </tr>
            </tbody>
          </table>
          <h1 id="Main函数"><a href="#Main函数" class="headerlink" title="Main函数"></a>Main函数</h1>
          <p>这里我们先来看一下main函数，该函数定义在afl-fuzz.c文件中，整个main函数共分为5个部分</p>
          <ul>
            <li>参数处理：主要是根据用户启动afl二进制程序是传入的参数进行相应的mode等配置设置</li>
            <li>初始化：获取特殊环境变量的值、设置输出文件夹、设置共享内存、读取测试用例等</li>
            <li>Dry Run：第一次运行，即首轮Fuz</li>
            <li>Main Loop：循环Fuzz运行</li>
            <li>Exit：Fuzz结束之后的保存测试结果等</li>
          </ul>
          <h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2>
          <p>这里是通过一个while循环来实现参数处理逻辑的。主要的代码如</p>
          <ul>
            <li>main函数参数处理部分源码 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;+i:o:f:m:t:T:dnCB:S:M:x:Q&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  <span class="built_in">FATAL</span>(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            <span class="built_in">FATAL</span>(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        <span class="built_in">read_bitmap</span>(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里我们可以将AFL的参数总结如下</p>
          <ul>
            <li>-i, -o：分别更改全局变量<code>in_dir</code>以及<code>out_dir</code>的值。表示的就是输入文件夹以及输出文件夹的位置。</li>
            <li>-M，-S：更改全局变量<code>sync_id</code> 的值，用来进行并行设置</li>
            <li>-f：指定临时的输出文件，更改全局变量<code>out_file</code> 的值。</li>
            <li>-x：更改全局变量<code>extras_dir</code> 的值，表示的是用户指定的字典</li>
            <li>-t：<code>%u%c</code> 的格式分别读取到全局变量<code>exec_tmout</code> 与局部变量<code>suffix</code>
              变量中，最终改变的是<code>timeout_given</code> 的值</li>
            <li>-m：<code>%llu%c</code> 的格式分别读取到全局变量<code>mem_limit</code> 与局部变量<code>suffix</code>
              中，这里最小的内存不能小于5M，最大不超过2000M</li>
            <li>-d：更改全局变量<code>skip_deterministic</code> 与<code>use_splicing</code> 的值，表示的是跳过确定性变异过程</li>
            <li>-B：更改全局变量<code>in_bitmap</code> 的值，表示指定bitmap，并将其读取到<code>in_bitmap</code>
              中。这表示我们可以选择自己该兴趣的bitmap然后从其开始进行变异</li>
            <li>-C：更改全局变量<code>crash_mode</code> 的值，这里我们可以将一个崩溃的测试用例输入到AFL中，此时不发生崩溃的或者执行路径没有明显变化的变异样本将会被丢弃</li>
            <li>-n：更改全局变量<code>dumb_mode</code> 的值，表示不再进行插桩</li>
            <li>-T：指定banner</li>
            <li>-Q：更改全局变量<code>qemu_mode</code> 的值，表示的是进入到qemu插桩模式中</li>
          </ul>
          <h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>
          <ul>
            <li>main函数中初始化相关部分代码如下 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_signal_handlers</span>();</span><br><span class="line">  <span class="built_in">check_asan_opts</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id) <span class="built_in">fix_up_sync</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)  <span class="built_in">FATAL</span>(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">    hang_tmout = <span class="built_in">atoi</span>(<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout) <span class="built_in">FATAL</span>(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;LD_PRELOAD&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">save_cmdline</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fix_up_banner</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_if_tty</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">get_core_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  <span class="built_in">bind_to_free_cpu</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_crash_handling</span>();</span><br><span class="line">  <span class="built_in">check_cpu_governor</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_post</span>();</span><br><span class="line">  <span class="built_in">setup_shm</span>();</span><br><span class="line">  <span class="built_in">init_count_class16</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_dirs_fds</span>();</span><br><span class="line">  <span class="built_in">read_testcases</span>();</span><br><span class="line">  <span class="built_in">load_auto</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pivot_inputs</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extras_dir) <span class="built_in">load_extras</span>(extras_dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) <span class="built_in">find_timeout</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">detect_file_args</span>(argv + optind + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!out_file) <span class="built_in">setup_stdio_file</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_binary</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line">  start_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = <span class="built_in">get_qemu_argv</span>(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>在这一部分将会检查前面我们设置的参数是否存在某些冲突或者错误，例如这里的输入输出文件夹必须要要指定。</p>
          <p>之后调用<code>setup_shm</code> 函数进行了共享内存的设置，这里是通过<code>shmget</code>
            函数进行共享内存的分配的。并初始化了<code>virgin_bits,virgin_tmout,virgin_crash,trace_bits</code>等变量。</p>
          <h3 id="测试用例读取"><a href="#测试用例读取" class="headerlink" title="测试用例读取"></a>测试用例读取</h3>
          <p>在初始化过程中还会存在一个比较重要的函数就是<code>read_testcases</code> ，函数的功能就是从输入文件夹中读取所有的测试用例，并将其加入到队列中。函数的关键部分的代码如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">nl_cnt = <span class="built_in">scandir</span>(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"><span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123; <span class="comment">// shuffle_queue通过环境变量进行定义的</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ACTF</span>(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">  <span class="built_in">shuffle_ptrs</span>((<span class="type">void</span>**)nl, nl_cnt); <span class="comment">// 随机打乱顺序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8* dfn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lstat</span>(fn, &amp;st) || <span class="built_in">access</span>(fn, R_OK))</span><br><span class="line">      <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">S_ISREG</span>(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.txt&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">ck_free</span>(fn);</span><br><span class="line">      <span class="built_in">ck_free</span>(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            <span class="built_in">DMS</span>(st.st_size), <span class="built_in">DMS</span>(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">       is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">       fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">       and probably very time-consuming. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ck_free</span>(dfn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add_to_queue</span>(fn, st.st_size, passed_det);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里的<code>scandir</code>
            函数调用的作用是扫描in_dir的目录结构，经过第三个参数也就是select函数的挑选之后，按照第四个参数给定的排序规则存储到第二个参数指向的内存空间中。这里我们的排序参数是<code>alphasort</code>
            其就是按照字母顺序进行一个排序。</p>
          <p>
            接着就是判断是否要随机打乱顺序。之后对获取得到的文件路径依次调用access函数看是否可以访问，以及是否可以访问对应的<code>in_dir/.state/deterministic_done/file_name</code>
            文件，如果这个文件存在那么这里表示的是确定性变异已经完成了，此时这个文件送入队列的时候就会标记<code>passed_det</code> 表示跳过确定性变异的阶段。</p>
          <p>读取完毕测试用例之后即会调用<code>load_auto</code> 函数在<code>in_dir/.state/auto_extras/auto_%06u</code>
            所表示的文件，对其调用<code>maybe_add_auto</code> 函数按照规则加入到字典中。</p>
          <p><code>pivot_inputs</code> 函数用于在输出文件夹中创建测试用例的硬链接。这里的命名规则如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">// 如果SIMPLE_FILE定义了</span></span><br><span class="line"><span class="string">&quot;in_dir/queue/id:%06u&quot;</span> % id</span><br><span class="line"><span class="comment">// 如果SIMPLE_FILE没有定义</span></span><br><span class="line"><span class="string">&quot;in_dir/queue/id:%06u,orig:%s&quot;</span> % id, use_name</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>如果测试用例标记了跳过确定性变异，那么就生成对应的<code>out_dir/queue/.state/deterministic_done/file_name</code>
            文件。最后调用<code>nuke_resume_dir</code> 函数删除<code>out_dir/_resume/.state/</code> 下面的所有的临时文件夹。</p>
          <p>后续还包含设置启动时间，检查目标程序的信息等步骤。</p>
          <h2 id="Dry-Run"><a href="#Dry-Run" class="headerlink" title="Dry Run"></a>Dry Run</h2>
          <p>在一切都准备好之后，接下来就开始跑第一轮的fuzz，代码如下</p>
          <ul>
            <li>main函数DryRun部分 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="built_in">perform_dry_run</span>(use_argv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">show_init_stats</span>();</span><br><span class="line"></span><br><span class="line">seek_to = <span class="built_in">find_start_position</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">save_auto</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">  start_time += <span class="number">4000</span>;</span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">&#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里首先调用的是<code>perform_dry_run</code> 函数，该函数就会依次读取queue中的内容，对其中的每一个测试文件调用<code>calibrate_case</code>
            函数进行校准。此时目标程序至少执行一次测试用例。然后根据返回结果来判断发生错误的类型。</p>
          <p>接着调用的是<code>cull_queue</code> 函数，该函数的作用是精简队列，也就是执行优胜者策略，选出最受欢迎的优胜者测试用例。</p>
          <p>接着调用<code>show_init_stats</code> 函数输出这一轮的Fuzz相关的信息。输出完毕之后调用<code>find_start_position</code>
            函数从<code>out_dir/fuzzer_stats</code> 中<code>cur_path</code>
            找到当前的测试用例，并从这个测试用例开始。接着调用<code>write_stats_file</code> 函数更新<code>out_dir/fuzzer_stats</code>
            文件，这里我们可以看到<code>out_dir/fuzzer_stats</code> 文件中存储的信息</p>
          <ul>
            <li><code>out_dir/fuzzer_stats</code> 文件内容 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">&quot;start_time        : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_update       : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;fuzzer_pid        : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;cycles_done       : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;execs_done        : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;execs_per_sec     : %0.02f\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_total       : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_favored     : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_found       : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_imported    : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;max_depth         : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;cur_path          : %u\n&quot;</span> <span class="comment">/* Must match find_start_position() */</span></span><br><span class="line">           <span class="string">&quot;pending_favs      : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;pending_total     : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;variable_paths    : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;stability         : %0.02f%%\n&quot;</span></span><br><span class="line">           <span class="string">&quot;bitmap_cvg        : %0.02f%%\n&quot;</span></span><br><span class="line">           <span class="string">&quot;unique_crashes    : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;unique_hangs      : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_path         : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_crash        : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_hang         : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;execs_since_crash : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;exec_timeout      : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;afl_banner        : %s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;afl_version       : &quot;</span> VERSION <span class="string">&quot;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;target_mode       : %s%s%s%s%s%s%s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;command_line      : %s\n&quot;</span>,</span><br><span class="line">           start_time / <span class="number">1000</span>, <span class="built_in">get_cur_time</span>() / <span class="number">1000</span>, <span class="built_in">getpid</span>(),</span><br><span class="line">           queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps,</span><br><span class="line">           queued_paths, queued_favored, queued_discovered, queued_imported,</span><br><span class="line">           max_depth, current_entry, pending_favored, pending_not_fuzzed,</span><br><span class="line">           queued_variable, stability, bitmap_cvg, unique_crashes,</span><br><span class="line">           unique_hangs, last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>,</span><br><span class="line">           last_hang_time / <span class="number">1000</span>, total_execs - last_crash_execs,</span><br><span class="line">           exec_tmout, use_banner,</span><br><span class="line">           qemu_mode ? <span class="string">&quot;qemu &quot;</span> : <span class="string">&quot;&quot;</span>, dumb_mode ? <span class="string">&quot; dumb &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           no_forkserver ? <span class="string">&quot;no_forksrv &quot;</span> : <span class="string">&quot;&quot;</span>, crash_mode ? <span class="string">&quot;crash &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           persistent_mode ? <span class="string">&quot;persistent &quot;</span> : <span class="string">&quot;&quot;</span>, deferred_mode ? <span class="string">&quot;deferred &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">            persistent_mode || deferred_mode) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">           orig_cmdline);</span><br><span class="line">           <span class="comment">/* ignore errors */</span></span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>更新完毕文件内容之后即调用<code>save_auto</code> 函数保存这一轮产生的Token的信息。这些Token和词法分析中的Token概念相似，用来作为字典指导变异。</p>
          <h2 id="Main-Loop"><a href="#Main-Loop" class="headerlink" title="Main Loop"></a>Main Loop</h2>
          <p>前面需要首先执行一次Fuzz的目的实际上就是去判断我们输入的测试用例的情况，如果存在某些错误的话，那么这里将会直接Stop。执行完毕首轮Fuzz之后接下来就进入到了Main Loop中，也就是Fuzz的主逻辑中。
          </p>
          <ul>
            <li>main函数中Main Loop部分代码 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = queue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        <span class="built_in">ACTF</span>(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">getenv</span>(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = <span class="built_in">fuzz_one</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>首先这里会调用<code>cull_queue</code> 函数，也就是在每次循环之前都会进行一下队列的精简。</p>
          <p>接着存在一个对<code>queue_cur</code> 的判断，如果<code>queue_cur</code>
            是空的话，那么就表示当前的队列已经遍历完毕了因此这里需要初始化到队列的首部进行重新遍历。在进行队列初始化的时候会判断当前队列和上一个队列是否完全相同，如果完全相同的话，那么就表示这一轮的Fuzz是没有效果的，这里就需要进行变异策略的重组。
          </p>
          <p>接着调用<code>fuzz_one</code> 函数对目标程序执行一次Fuzz，Fuzz结束之后会首先去判断<code>stop_soon</code>
            的值也就是是否结束Fuzz，如果不结束的话那么就移动<code>queue_cur</code> 队列指针指向下一个测试用例，继续执行循环。</p>
          <p>这里有两种方式去设置<code>stop_soon</code> 的值，一种是程序错误，另一种是用户发送某些信号例如ctrl-c，通过handler对<code>stop_soon</code> 进行了设置。
          </p>
          <h2 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h2>
          <p>这一部分就是退出AFL的过程了，这里就保存一些相关的文件例如bitmap等，然后关闭程序</p>
          <ul>
            <li>main函数Exit部分代码 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="built_in">write_bitmap</span>();</span><br><span class="line"><span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">save_auto</span>();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line"></span><br><span class="line"><span class="built_in">SAYF</span>(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">     stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">get_cur_time</span>() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(plot_file);</span><br><span class="line"><span class="built_in">destroy_queue</span>();</span><br><span class="line"><span class="built_in">destroy_extras</span>();</span><br><span class="line"><span class="built_in">ck_free</span>(target_path);</span><br><span class="line"><span class="built_in">ck_free</span>(sync_id);</span><br><span class="line"></span><br><span class="line"><span class="built_in">alloc_report</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">OKF</span>(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里会先保存bitmap、以及当前的fuzz的状态以及Token的信息。接着释放一些全局变量的内存，之后调用exit进行退出。</p>
          <h1 id="DryRun与MainLoop代码中的一些关键函数"><a href="#DryRun与MainLoop代码中的一些关键函数" class="headerlink"
              title="DryRun与MainLoop代码中的一些关键函数"></a>DryRun与MainLoop代码中的一些关键函数</h1>
          <p>前面我们只是分析了一下main函数的整体的流程，对于一些细节的部分和一些关键的函数，我们这里再分析一下</p>
          <h2 id="calibrate-case-函数"><a href="#calibrate-case-函数" class="headerlink"
              title="calibrate_case 函数"></a>calibrate_case 函数</h2>
          <p>前面我们说到在进行第一次Fuzz Run的时候也就是DryRun的时候首先会调用<code>perform_dry_run</code> 函数去对测试用例进行校准。这里我们需要看一下这个测试用例的校准的函数。
          </p>
          <ul>
            <li>calibrate_case函数 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Calibrate a new test case. This is done when processing the input directory</span></span><br><span class="line"><span class="comment">   to warn about flaky or otherwise problematic test cases early on; and when</span></span><br><span class="line"><span class="comment">   new paths are discovered to detect variable behavior and so on. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem,</span></span></span><br><span class="line"><span class="params"><span class="function">                         u32 handicap, u8 from_queue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>,</span><br><span class="line">      first_run = (q-&gt;exec_cksum == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8* old_sn = stage_name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span></span><br><span class="line"><span class="comment">     trying to calibrate already-added finds. This helps avoid trouble due</span></span><br><span class="line"><span class="comment">     to intermittent latency. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout = <span class="built_in">MAX</span>(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line">  stage_max  = fast_cal ? <span class="number">3</span> : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span></span><br><span class="line"><span class="comment">     count its spin-up time toward binary calibration. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    <span class="built_in">init_forkserver</span>(argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_cksum) <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  start_us = <span class="built_in">get_cur_time_us</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write_to_testcase</span>(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">    fault = <span class="built_in">run_target</span>(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">       we want to bail out quickly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode) <span class="keyword">goto</span> abort_calibration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !<span class="built_in">count_bytes</span>(trace_bits)) &#123;</span><br><span class="line">      fault = FAULT_NOINST;</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;</span><br><span class="line"></span><br><span class="line">      u8 hnb = <span class="built_in">has_new_bits</span>(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">            stage_max    = CAL_CYCLES_LONG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum = cksum;</span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us = <span class="built_in">get_cur_time_us</span>();</span><br><span class="line"></span><br><span class="line">  total_cal_us     += stop_us - start_us;</span><br><span class="line">  total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OK, let&#x27;s collect some stats about the performance of this test case.</span></span><br><span class="line"><span class="comment">     This is used for fuzzing air time calculations in calculate_score(). */</span></span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     = (stop_us - start_us) / stage_max;</span><br><span class="line">  q-&gt;bitmap_size = <span class="built_in">count_bytes</span>(trace_bits);</span><br><span class="line">  q-&gt;handicap    = handicap;</span><br><span class="line">  q-&gt;cal_failed  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_bitmap_score</span>(q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If this case didn&#x27;t result in new output from the instrumentation, tell</span></span><br><span class="line"><span class="comment">     parent. This is a non-critical problem, but something to warn the user</span></span><br><span class="line"><span class="comment">     about. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault = FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected) &#123;</span><br><span class="line"></span><br><span class="line">    var_byte_count = <span class="built_in">count_bytes</span>(var_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">      <span class="built_in">mark_as_variable</span>(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur  = old_sc;</span><br><span class="line">  stage_max  = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里会首先调用<code>init_forkserver</code> 函数来确保forkserver已经开启，至于这里的<code>forkserver</code> 是什么这里还没有分析。</p>
          <p>如果这里不是第一次运行的话，那么就将<code>trace_bits</code> 拷贝到<code>first_trace</code>
            的内存空间中。<br>之后会执行一个for循环，也就是对测试用例的校准执行的不只一次。最大执行的次数为<code>stage_max</code></p>
          <p>之后会调用<code>write_to_testcase</code> 函数将测试用例的内容写入到测试文件中，这里写入的内容<code>use_mem</code>
            其实就是函数调用之前读取的队列中的测试用例的内容。这里写入的测试文件是通过<code>out_file</code> 这个变量进行控制的。</p>
          <p>之后就会调用<code>run_target</code> 函数启动目标程序执行测试用例。这里启动的方式有两种</p>
          <ol>
            <li>如果处于dump mode，或者forkserver没有开启的话，那么这里由此函数所在的线程fork启动目标程序执行测试用例。</li>
            <li>如果forkserver开启，那么这里只需要给forkserver发送消息，由forkserver fork产生一个新的进程及启动目标程序。当前进程和forkserver之间采用pipe管道进行通信</li>
          </ol>
          <p>执行Fuzz过程中的路径信息会保存在<code>trace_bits</code> 中。在执行结束之后会对<code>trace_bits</code> 的内存空间做一个<code>hash32</code>
            ，也就是会去判断在本次执行过程中有没有产生新的路径，这里之前路径的hash信息保存在<code>q-&gt;exec_cksum</code>
            中。这里如果在执行过程中产生了新的路径，那么这里会首先调用<code>has_new_bits</code> 函数，函数这里会去判断当前的路径信息和之前的路径信息<code>virgin_bits</code>
            是否产生了不同，如果产生了变化的话就会更新<code>virgin_bits</code>
            的信息。注意到这里产生新路径的判断方式即现在的bit位不是0，但是之前的bits位0xff（这里表示的是之前的bit位是0，也就是不存在这样的元组）那么这里就产生了新的路径</p>
          <blockquote>
            <p>这里需要提前了解一下路径信息的存储方式，这里实际上在白皮书上讲到过，也就是对于A→B这样的路径来说，这里存储的是<code>shared_mem[(A&gt;&gt;1)^B]++</code>
              ，也就是存在路径之后相应的bits位就肯定不是0了。</p>
          </blockquote>
          <p>那么就会分为以下两种情况进行处理</p>
          <ol>
            <li>如果<code>q-&gt;exec_cksum</code> 为空，也就是第一次运行这个测试用例，那么就更新<code>q-&gt;exec_cksum</code>
              以及将<code>trace_bits</code> 拷贝到<code>first_trace</code> 中</li>
            <li>如果不为空，那么确实产生了新的路径信息。那么这里就会将测试的论述调大即设置<code>stage_max</code> 的值为<code>CAL_CYCLES_LONG</code></li>
          </ol>
          <p>当当前的测试用例的<code>stage_max</code> 轮测试都跑完之后，即调用<code>update_bitmap_score</code> 函数来计算当前测试用例的分数。</p>
          <p>如果产生了新的路径，那么标记这个测试用例为<code>variable</code> ，测试之后的结果如果<code>new_bits</code> 那么就表示有新路径产生。</p>
          <h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h2>
          <p>该函数是样本选择的重要函数，也是AFL中优胜者策略的重要组成部分，我们看一下这个函数</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">/* The second part of the mechanism discussed above is a routine that</span></span><br><span class="line"><span class="comment">   goes over top_rated[] entries, and then sequentially grabs winners for</span></span><br><span class="line"><span class="comment">   previously-unseen bytes (temp_v) and marks them as favored, at least</span></span><br><span class="line"><span class="comment">   until the next run. The favored entries are given more air time during</span></span><br><span class="line"><span class="comment">   all fuzzing steps. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cull_queue</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* q;</span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line"></span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line"></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  q = queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="built_in">mark_as_redundant</span>(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里首先初始化了队列，将每个测试用例的<code>favored</code>
            成员变量置为0。接着遍历整个路径元组，对于每一个路径，这里AFL认为第一次遍历得到的优胜者测试用例是更加受欢迎的，也就是<code>favored</code>
            。在<code>update_bitmap_score</code>中我们可以知道这里<code>trace_mini</code>
            数组中是用1bit包含了路径有没有被命中的信息。那么这里<code>temp_v</code>
            表示的就是当前测试用例没有被命中的路径数组的信息。也就是说这里永远会选择第一个遍历得到的优胜者测试用例。将其<code>favored</code>
            成员变量设置为1。对于受欢迎的优胜者测试用例，如果没有被Fuzz过，那么这里将会通过<code>pending_favored</code>计算此类的测试用例的数量，以便在之后优先Fuzz。</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">/* Mark / unmark as redundant (edge-only). This is not used for restoring state,</span></span><br><span class="line"><span class="comment">   but may be useful for post-processing datasets. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mark_as_redundant</span><span class="params">(<span class="keyword">struct</span> queue_entry* q, u8 state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* fn;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state == q-&gt;fs_redundant) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  q-&gt;fs_redundant = state;</span><br><span class="line"></span><br><span class="line">  fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue/.state/redundant_edges/%s&quot;</span>, out_dir, fn + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlink</span>(fn)) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to remove &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>从上面的分析中我们实际上可以看到并不是所有的优胜者测试用例都是受欢迎的，对于不太受欢迎的优胜者测试用例，那么这里会调用<code>mark_as_redundant</code>
            函数将其放入到<code>queue/.state/redundant_edges</code> 文件夹下面，同理，如果被重新欢迎了，那么就将其从这个路径中删除。</p>
          <h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h2>
          <p>前面我们说到在第一次Fuzz也就是Dry Run执行完毕之后，即进入到了Main Loop中，每一次循环都会首先执行<code>cull_queue</code>
            进行队列的精简，然后调用<code>fuzz_one</code>
            函数开始本次的Fuzz。我们来看一下<code>fuzz_one</code>函数，这个函数非常的长，大概有2k行代码。这里如果Fuzz执行成功之后即返回0，如果跳过当前的测试用例或者Fuzz执行失败那么这里返回1。
          </p>
          <h3 id="按照策略跳过某些测试用例"><a href="#按照策略跳过某些测试用例" class="headerlink" title="按照策略跳过某些测试用例"></a>按照策略跳过某些测试用例</h3>
          <p>这里首先会按照一定的概率跳过一些测试用例，这里代码如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (pending_favored) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">     possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">     cases. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">      <span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 这里UR的宏定义实际上就是产生一个随机数</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">     The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">     lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 75%</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 95%</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里如果<code>pending_favored</code>
            的值大于0，也就是队列中存在受欢迎的优胜者测试用例还没有被Fuzz过。那么这里如果当前的测试用例已经被fuzz过了或者当前的测试用例不是受欢迎的优胜者，那么这里将会存在99%的概率跳过这个测试用例。</p>
          <p>如果队列中所有的受欢迎的优胜者测试用例都被Fuzz过了，那么这里对于队列中的不感兴趣的测试用例，如果当前的测试用例没有被fuzz过，那么将会存在75%的概率跳过这个测试用例；否则以95%的概率跳过这个测试用例。
          </p>
          <h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3>
          <p>
            接着来要干的事情就是将测试用例读取到内存中。这里实际上是分配了两个内存空间，也就是in_buf/origin_in以及out_buf，其中in_buf/origin_in则是将测试用例以文件映射的方式mmap到了一个地址空间中。而out_buf则是按照文件的大小申请了相应大小的内存。
          </p>
          <p>接下来对之前我们调用<code>calibrate_case</code> 函数对测试用例的校准结果进行了判断，如果校准的失败次数小于<code>CAL_CHANCES</code>
            也就是3次，那么这里将会重新调用<code>calibrate_case</code> 进行校准。</p>
          <p>接下来即进行剪枝的操作</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">/************</span></span><br><span class="line"><span class="comment"> * TRIMMING *</span></span><br><span class="line"><span class="comment"> ************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123; <span class="comment">// dumb_mode表示不再进行插桩</span></span><br><span class="line"></span><br><span class="line">  u8 res = <span class="built_in">trim_case</span>(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">  queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>也就是这里如果当前的测试用例没有被剪枝过的话，那么这里将会调用<code>trim_case</code> 函数进行剪枝的操作。注意到的是这里必须要在插桩模式下才会执行剪枝的操作。</p>
          <p>剪枝结束之后，这里将当前的测试用例写会到磁盘中，然后更新其对应的<code>trace_bits</code>
            和<code>top_rated</code>数组。剪枝结束之后更新out_buf的内容为新的in_buf的内容。</p>
          <h3 id="打分"><a href="#打分" class="headerlink" title="打分"></a>打分</h3>
          <p>剪枝结束之后对当前的测试用例调用<code>calculate_score</code> 函数进行打分。这一部分的代码如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * PERFORMANCE SCORE *</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line">orig_perf = perf_score = <span class="built_in">calculate_score</span>(queue_cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span></span><br><span class="line"><span class="comment">   this entry ourselves (was_fuzzed), or if it has gone through deterministic</span></span><br><span class="line"><span class="comment">   testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">   for this master instance. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">doing_det = <span class="number">1</span>;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>
            这里如果在启动参数中设置了跳过确定性变异，或者当前的测试用例已经被fuzz过了或者说测试用例被标记了要跳过当前测试用例的确定性变异的过程的话，那么这里就会跳过确定性变异的过程进入到随机变异的过程中。这里我们看一下<code>calculate_score</code>
            函数</p>
          <ul>
            <li>calculate_score函数内容 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Calculate case desirability score to adjust the length of havoc fuzzing.</span></span><br><span class="line"><span class="comment">   A helper function for fuzz_one(). Maybe some of these constants should</span></span><br><span class="line"><span class="comment">   go into config.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">calculate_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 avg_exec_us = total_cal_us / total_cal_cycles;</span><br><span class="line">  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;</span><br><span class="line">  u32 perf_score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on execution speed of this path, compared to the</span></span><br><span class="line"><span class="comment">     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are</span></span><br><span class="line"><span class="comment">     less expensive to fuzz, so we&#x27;re giving them more air time. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.1</span> &gt; avg_exec_us) perf_score = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.25</span> &gt; avg_exec_us) perf_score = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.5</span> &gt; avg_exec_us) perf_score = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.75</span> &gt; avg_exec_us) perf_score = <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">4</span> &lt; avg_exec_us) perf_score = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">3</span> &lt; avg_exec_us) perf_score = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">2</span> &lt; avg_exec_us) perf_score = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on bitmap size. The working theory is that better</span></span><br><span class="line"><span class="comment">     coverage translates to better targets. Multiplier from 0.25x to 3x. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.3</span> &gt; avg_bitmap_size) perf_score *= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.5</span> &gt; avg_bitmap_size) perf_score *= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.75</span> &gt; avg_bitmap_size) perf_score *= <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">3</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">2</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">1.5</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on handicap. Handicap is proportional to how late</span></span><br><span class="line"><span class="comment">     in the game we learned about this path. Latecomers are allowed to run</span></span><br><span class="line"><span class="comment">     for a bit longer until they catch up with the rest. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;handicap &gt;= <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    q-&gt;handicap -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;handicap) &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    q-&gt;handicap--;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Final adjustment based on input depth, under the assumption that fuzzing</span></span><br><span class="line"><span class="comment">     deeper test cases is more likely to reveal stuff that can&#x27;t be</span></span><br><span class="line"><span class="comment">     discovered with traditional fuzzers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (q-&gt;depth) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">3</span>:   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> ... <span class="number">7</span>:   perf_score *= <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">13</span>:  perf_score *= <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span> ... <span class="number">25</span>: perf_score *= <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:        perf_score *= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that we don&#x27;t go over limit. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (perf_score &gt; HAVOC_MAX_MULT * <span class="number">100</span>) perf_score = HAVOC_MAX_MULT * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> perf_score;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>
            从打分的规则来看（分数越高越好），我们可以看到执行速度越快、发现路径的数量越多、最近发现新路径的以及发现的路径越深的则分数更高。这里分数越高的测试用例在之后的随机变异也就是<code>RANDOM HAVOC</code>
            阶段将会执行变异越多的轮次。也就是分数越高的随机变异的机会就越多。</p>
          <h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3>
          <p>这里之所以代码这么长，大部分的代码都是集中在这个变异策略上。这里一共存在六种变异的策略。这里不同变异策略的详细实现还没有进行分析</p>
          <ol>
            <li>SIMPLE BITFLIP</li>
            <li>ARITHMETIC INC/DEC</li>
            <li>INTERESTING VALUES</li>
            <li>DICTIONARY STUFF</li>
            <li>RANDOM HAVOC</li>
            <li>SPLICING</li>
          </ol>
          <p>这里在执行完毕每一次的变异策略之后都会调用<code>common_fuzz_stuff</code> 函数来将变异之后的样本投递到目标程序当中。并对结果进行一个评估。</p>
          <h2 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h2>
          <p>这里只是一个简单的方法进行剪枝的操作。</p>
          <ul>
            <li>trim_case源码 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Trim all new test cases to save cycles when doing deterministic checks. The</span></span><br><span class="line"><span class="comment">   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of</span></span><br><span class="line"><span class="comment">   file size, to keep the stage short and sweet. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">trim_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* in_buf)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">64</span>];</span><br><span class="line">  <span class="type">static</span> u8 clean_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  needs_write = <span class="number">0</span>, fault = <span class="number">0</span>;</span><br><span class="line">  u32 trim_exec = <span class="number">0</span>;</span><br><span class="line">  u32 remove_len;</span><br><span class="line">  u32 len_p2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although the trimmer will be less useful when variable behavior is</span></span><br><span class="line"><span class="comment">     detected, it will still work to some extent, so we don&#x27;t check for</span></span><br><span class="line"><span class="comment">     this. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;len &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_name = tmp;</span><br><span class="line">  bytes_trim_in += q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select initial chunk len, starting with large steps. */</span></span><br><span class="line"></span><br><span class="line">  len_p2 = <span class="built_in">next_p2</span>(q-&gt;len); <span class="comment">// 获取最接近的2^n 的n值</span></span><br><span class="line"></span><br><span class="line">  remove_len = <span class="built_in">MAX</span>(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES); <span class="comment">// 16  4 也就是这里最大值是4字节或者文件大小的1/4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Continue until the number of steps gets too high or the stepover</span></span><br><span class="line"><span class="comment">     gets too small. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (remove_len &gt;= <span class="built_in">MAX</span>(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) &#123;</span><br><span class="line"></span><br><span class="line">    u32 remove_pos = remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;trim %s/%s&quot;</span>, <span class="built_in">DI</span>(remove_len), <span class="built_in">DI</span>(remove_len));</span><br><span class="line"></span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = q-&gt;len / remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (remove_pos &lt; q-&gt;len) &#123;</span><br><span class="line"></span><br><span class="line">      u32 trim_avail = <span class="built_in">MIN</span>(remove_len, q-&gt;len - remove_pos);</span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">write_with_gap</span>(in_buf, q-&gt;len, remove_pos, trim_avail); <span class="comment">// 将removs_pos开启长度为trim_avail的内容跳过，其余部分写入到out_fd中</span></span><br><span class="line"></span><br><span class="line">      fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line">      trim_execs++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon || fault == FAULT_ERROR) <span class="keyword">goto</span> abort_trimming;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Note that we don&#x27;t keep track of crashes or hangs here; maybe TODO? */</span></span><br><span class="line"></span><br><span class="line">      cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If the deletion had no impact on the trace, make it permanent. This</span></span><br><span class="line"><span class="comment">         isn&#x27;t perfect for variable-path inputs, but we&#x27;re just making a</span></span><br><span class="line"><span class="comment">         best-effort pass, so it&#x27;s not a big deal if we end up with false</span></span><br><span class="line"><span class="comment">         negatives every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum == q-&gt;exec_cksum) &#123; <span class="comment">// 如果对路径没有影响，那么这里即删除这部分内容</span></span><br><span class="line"></span><br><span class="line">        u32 move_tail = q-&gt;len - remove_pos - trim_avail;</span><br><span class="line"></span><br><span class="line">        q-&gt;len -= trim_avail;</span><br><span class="line">        len_p2  = <span class="built_in">next_p2</span>(q-&gt;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memmove</span>(in_buf + remove_pos, in_buf + remove_pos + trim_avail, </span><br><span class="line">                move_tail);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Let&#x27;s save a clean trace, which will be needed by</span></span><br><span class="line"><span class="comment">           update_bitmap_score once we&#x27;re done with the trimming stuff. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needs_write) &#123;</span><br><span class="line"></span><br><span class="line">          needs_write = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> remove_pos += remove_len;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Since this can be slow, update the screen every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(trim_exec++ % stats_update_freq)) <span class="built_in">show_stats</span>();</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have made changes to in_buf, we also need to update the on-disk</span></span><br><span class="line"><span class="comment">     version of the test case. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needs_write) &#123;</span><br><span class="line"></span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unlink</span>(q-&gt;fname); <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_write</span>(fd, in_buf, q-&gt;len, q-&gt;fname);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);</span><br><span class="line">    <span class="built_in">update_bitmap_score</span>(q);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">abort_trimming:</span><br><span class="line"></span><br><span class="line">  bytes_trim_out += q-&gt;len;</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里只对大文件进行剪枝操作，小于5字节大小的文件不会执行剪枝操作。这里首先是设置了一个大步即一开始的<code>remove_len</code>
            按照这个长度划分文件为一个个的块，依次尝试删除这个块，如果删除之后对文件执行之后的路径没有任何影响的话，那么就将这种删除进行保留。所有的块遍历结束之后这里将<code>remove_len&gt;&gt;1</code>
          </p>
          <p>如果文件内容发生了改变，那么这里就将更改之后的文件写入到磁盘中，并且这里会更新起相应的<code>trace_bits</code> 及其对应的分数。</p>
          <h2 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink"
              title="update_bitmap_score"></a>update_bitmap_score</h2>
          <p>该函数的主要作用就是找出一个测试用例，该测试用例对于某组路径触发的消耗最小。</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">/* When we bump into a new path, we call this to see if the path appears</span></span><br><span class="line"><span class="comment">   more &quot;favorable&quot; than any of the existing ones. The purpose of the</span></span><br><span class="line"><span class="comment">   &quot;favorables&quot; is to have a minimal set of paths that trigger all the bits</span></span><br><span class="line"><span class="comment">   seen in the bitmap so far, and focus on fuzzing them at the expense of</span></span><br><span class="line"><span class="comment">   the rest.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The first step of the process is to maintain a list of top_rated[] entries</span></span><br><span class="line"><span class="comment">   for every byte in the bitmap. We win that slot if there is no previous</span></span><br><span class="line"><span class="comment">   contender, or if the contender has a more favorable speed x size factor. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">            previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">           <span class="built_in">ck_free</span>(top_rated[i]-&gt;trace_mini);</span><br><span class="line">           top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">       top_rated[i] = q;</span><br><span class="line">       q-&gt;tc_ref++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = <span class="built_in">ck_alloc</span>(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         <span class="built_in">minimize_bits</span>(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里的做法就是对于给定的测试用例，依次按照bytes遍历其<code>trace_bits</code>
            ，如果之前对于当前路径有一个最优的测试用例，那么这里就会进行性能比较，涉及到两个元素也就是执行时间以及文件大小，如果当前的测试用例更优的话，那么就更新<code>top_rated</code>
            元组中的数据，表示对于这组路径来说当前的测试用例的开销是最小的。</p>
          <p>
            这里实际上反映的是AFL的优胜者策略，也就是执行时间越短、文件大小越小的测试用例对于当前的元组来说就是一个优胜者，这里<code>tc_ref</code>成员变量表示的是当前的测试用例被认为是优胜者的次数。如果是优胜者那么就会将其trace_bits进行压缩，只保留命中信息而去掉命中次数的信息，也就是<code>trace_mini</code>
            。</p>
          <h2 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink"
              title="common_fuzz_stuff"></a>common_fuzz_stuff</h2>
          <p>该函数在每一次变异结束之后都会被调用用来执行变异之后的测试用例。我们看一下这个函数。</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">/* Write a modified test case, run program, process results. Handle</span></span><br><span class="line"><span class="comment">   error conditions, returning 1 if it&#x27;s time to bail out. This is</span></span><br><span class="line"><span class="comment">   a helper function for fuzz_one(). */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="type">char</span>** argv, u8* out_buf, u32 len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line"></span><br><span class="line">    out_buf = <span class="built_in">post_handler</span>(out_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write_to_testcase</span>(out_buf, len);</span><br><span class="line"></span><br><span class="line">  fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line"></span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line"></span><br><span class="line">  queued_discovered += <span class="built_in">save_if_interesting</span>(argv, out_buf, len, fault);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里的这个<code>post_handler</code> 函数不知道是做什么的。这里首先会调用<code>write_to_testcase</code>
            函数来将测试用例写入到磁盘文件中。接着调用<code>run_target</code> 函数来启动目标程序执行这个测试用例。</p>
          <p>测试用例执行完毕中之后，这里会调用<code>save_if_interesting</code> 函数来决定是否保存当前的这个变异之后的测试用例。</p>
          <h2 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink"
              title="save_if_interesting"></a>save_if_interesting</h2>
          <p>该函数就是用来决定是否保存输入的测试用例的，在变异之后的样本测试中会触发调用。我们来看一下这个函数。</p>
          <ul>
            <li><code>save_if_interesting</code> 函数源码 <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Check if the result of an execve() during routine fuzzing is interesting,</span></span><br><span class="line"><span class="comment">   save or queue the input test case for further analysis if so. Returns 1 if</span></span><br><span class="line"><span class="comment">   entry is saved, 0 otherwise. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">save_if_interesting</span><span class="params">(<span class="type">char</span>** argv, <span class="type">void</span>* mem, u32 len, u8 fault)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8  *fn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  u8  hnb;</span><br><span class="line">  s32 fd;</span><br><span class="line">  u8  keeping = <span class="number">0</span>, res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == crash_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep only if there are new bits in the map, add to queue for</span></span><br><span class="line"><span class="comment">       future fuzzing, etc. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(hnb = <span class="built_in">has_new_bits</span>(virgin_bits))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (crash_mode) total_crashes++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">    fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue/id:%06u,%s&quot;</span>, out_dir, queued_paths,</span><br><span class="line">                      <span class="built_in">describe_op</span>(hnb));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, queued_paths);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">add_to_queue</span>(fn, len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hnb == <span class="number">2</span>) &#123;</span><br><span class="line">      queue_top-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">      queued_with_cov++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue_top-&gt;exec_cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to calibrate inline; this also calls update_bitmap_score() when</span></span><br><span class="line"><span class="comment">       successful. */</span></span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">calibrate_case</span>(argv, queue_top, mem, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    <span class="built_in">ck_write</span>(fd, mem, len, fn);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    keeping = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (fault) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Timeouts are not very interesting, but we&#x27;re still obliged to keep</span></span><br><span class="line"><span class="comment">         a handful of samples. We use the presence of new bits in the</span></span><br><span class="line"><span class="comment">         hang-specific bitmap as a signal of uniqueness. In &quot;dumb&quot; mode, we</span></span><br><span class="line"><span class="comment">         just keep everything. */</span></span><br><span class="line"></span><br><span class="line">      total_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_hangs &gt;= KEEP_UNIQUE_HANG) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__x86_64__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_new_bits</span>(virgin_tmout)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      unique_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Before saving, we make sure that it&#x27;s a genuine hang by re-running</span></span><br><span class="line"><span class="comment">         the target with a more generous timeout (unless the default timeout</span></span><br><span class="line"><span class="comment">         is already generous). */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (exec_tmout &lt; hang_tmout) &#123;</span><br><span class="line"></span><br><span class="line">        u8 new_fault;</span><br><span class="line">        <span class="built_in">write_to_testcase</span>(mem, len);</span><br><span class="line">        new_fault = <span class="built_in">run_target</span>(argv, hang_tmout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A corner case that one user reported bumping into: increasing the</span></span><br><span class="line"><span class="comment">           timeout actually uncovers a crash. Make sure we don&#x27;t discard it if</span></span><br><span class="line"><span class="comment">           so. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stop_soon &amp;&amp; new_fault == FAULT_CRASH) <span class="keyword">goto</span> keep_as_crash;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stop_soon || new_fault != FAULT_TMOUT) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/hangs/id:%06llu,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs, <span class="built_in">describe_op</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/hangs/id_%06llu&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_hangs++;</span><br><span class="line"></span><br><span class="line">      last_hang_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line"></span><br><span class="line">keep_as_crash:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This is handled in a manner roughly similar to timeouts,</span></span><br><span class="line"><span class="comment">         except for slightly different limits and no need to re-run test</span></span><br><span class="line"><span class="comment">         cases. */</span></span><br><span class="line"></span><br><span class="line">      total_crashes++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_crashes &gt;= KEEP_UNIQUE_CRASH) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__x86_64__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_new_bits</span>(virgin_crash)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!unique_crashes) <span class="built_in">write_crash_readme</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_crashes, kill_signal, <span class="built_in">describe_op</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/crashes/id_%06llu_%02u&quot;</span>, out_dir, unique_crashes,</span><br><span class="line">                        kill_signal);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_crashes++;</span><br><span class="line"></span><br><span class="line">      last_crash_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line">      last_crash_execs = total_execs;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR: <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re here, we apparently want to save the crash or hang</span></span><br><span class="line"><span class="comment">     test case, too. */</span></span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">  <span class="built_in">ck_write</span>(fd, mem, len, fn);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里是根据在调用目标程序执行变异之后的测试用例时所返回的结果分类进行分析的。</p>
          <ol>
            <li>返回的结果是<code>crash_mode</code> 。这里在<code>run_target</code>
              中没有找到相应的返回结果的情况。这里我们找到crash_mode的赋值的位置只有当我们设置-C参数的时候，crash_mode会被赋值为<code>FAULT_CRASH</code>
              。这里针对crash_mode的解释可以看参数处理部分。 这里如果返回的结果是crash_mode的话，首先会调用<code>has_new_bits</code>
              函数来判断是否产生了新路径。这里再次复习一下产生新路径的判断方式就是trace_bits中是否有新的Bytes不为0。如果产生了新的路径，此时就会将这个测试用例加入到队列中，调用<code>calibrate_case</code>
              函数来校准测试用例，最后将变异之后的样本写入到磁盘文件中，注意到这里写入到的磁盘文件是在<code>queue</code>也就是队列的目录下，会参与接下来的Fuzz。注意到这里的命名也是特殊设计的，其保留了当前测试用例得到的方式。
            </li>
            <li>返回的结果是<code>FAULT_TMOUT</code>，也就是超时，这里如果是dump
              mode那么就会保存下来所有的测试用例。实际上这里的超时并不是那么受欢迎。但是这里还是去判断是否产生了新路径。没有产生新路径的话，那么这里就直接返回了。如果产生了新的路径，这里会再次执行一遍目标程序来保证是真正的超时，如果再次时候的时候返回的结果是CRASH，那么这里进入到crash的逻辑中进行处理。否则这里接下来就会将该测试用例写入到<code>hang</code>目录下。
            </li>
            <li>返回的结果是<code>FAULT_CRASH</code>，也就是此时出现了Crash，如果不是<code>dumb_mode</code>
              的话，那么这里还是会判断是否产生了新的路径，如果没有产生新的路径的话，这里直接返回了。否则这里将会将当前的测试用例保存到<code>crashes</code>目录下</li>
          </ol>
          <h2 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h2>
          <p>这实际上是一个很重要的函数，用来判断在运行过程中是否产生了新的路径，是基于路径覆盖的指导变异的基础。关键部分的代码如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(*current) &amp;&amp; <span class="built_in">unlikely</span>(*current &amp; *virgin)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">likely</span>(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__x86_64__ */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里我们看到<code>virgin</code>
            表示的是运行之前的bitsmap，而current表示的则是运行之后的bitsmap。这里<code>==</code>操作符的优先级要高于<code>&amp;&amp;</code>
            。也就是说ret=2的时候表示的是产生了新的路径。而ret=1则表示的是命令某一条路径的次数发生了变化。这里只要产生了新的路径就会立即返回，也就是说命中某一条路径的次数的变化的优先级要低于产生新的路径。</p>
          <p>这里需要注意的是命中次数并不是我们平常理解的命中次数，而是存在一个桶的概念，只有命中次数从一个桶转换到另一个桶的时候才会认为是命中次数的变化。例如从<code>[32 ... 127]</code>
            转换到<code>[128 ... 255]</code> 。</p>
          <h1 id="变异策略"><a href="#变异策略" class="headerlink" title="变异策略"></a>变异策略</h1>
          <p>通过前面的分析这里我们知道一共存在有六种变异策略。</p>
          <ol>
            <li>SIMPLE BITFLIP</li>
            <li>ARITHMETIC INC/DEC</li>
            <li>INTERESTING VALUES</li>
            <li>DICTIONARY STUFF</li>
            <li>RANDOM HAVOC</li>
            <li>SPLICING</li>
          </ol>
          <p>这里我们依次进行一下分析</p>
          <h2 id="SIMPLE-BITFLIP"><a href="#SIMPLE-BITFLIP" class="headerlink" title="SIMPLE BITFLIP"></a>SIMPLE BITFLIP
          </h2>
          <p>从名称这里也可以看出来是一个简单的bit翻转，这里对bit翻转操作的定义如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里传入的第一个参数是out_buf也就是要变异的测试用例文件内容，而第二个参数传入的是<code>stage_cur</code>
            也就是当前变异的轮数，该值从0增涨到特定的长度。我们看到这里实际上每一次变异都是以8bit也就是以一个bit为单位的。</p>
          <p>实际上这里在执行SIMPLE BITFLIP变异的时候这里并不只是执行一次FLIP_BIT函数，而是分为好几轮。</p>
          <h3 id="bitflip-1-1"><a href="#bitflip-1-1" class="headerlink" title="bitflip 1/1"></a>bitflip 1/1</h3>
          <ul>
            <li>
              <p>bitflip 1/1这一部分的代码如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Single walking bit. */</span></span><br><span class="line"></span><br><span class="line">stage_short = <span class="string">&quot;flip1&quot;</span>;</span><br><span class="line">stage_max   = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 1/1&quot;</span>;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While flipping the least significant bit in every byte, pull of an extra</span></span><br><span class="line"><span class="comment">     trick to detect possible syntax tokens. In essence, the idea is that if</span></span><br><span class="line"><span class="comment">     you have a binary blob like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     xxxxxxxxIHDRxxxxxxxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ...and changing the leading and trailing bytes causes variable or no</span></span><br><span class="line"><span class="comment">     changes in program flow, but touching any character in the &quot;IHDR&quot; string</span></span><br><span class="line"><span class="comment">     always produces the same, distinctive path, it&#x27;s highly likely that</span></span><br><span class="line"><span class="comment">     &quot;IHDR&quot; is an atomically-checked magic value of special significance to</span></span><br><span class="line"><span class="comment">     the fuzzed format.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We do this here, rather than as a separate stage, because it&#x27;s a nice</span></span><br><span class="line"><span class="comment">     way to keep the operation approximately &quot;free&quot; (i.e., no extra execs).</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     Empirically, performing the check when flipping the least significant bit</span></span><br><span class="line"><span class="comment">     is advantageous, compared to doing it at the time of more disruptive</span></span><br><span class="line"><span class="comment">     changes, where the program flow may be affected in more violent ways.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The caveat is that we won&#x27;t generate dictionaries in the -d mode or -S</span></span><br><span class="line"><span class="comment">     mode - but that&#x27;s probably a fair trade-off.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     This won&#x27;t work particularly well with paths that exhibit variable</span></span><br><span class="line"><span class="comment">     behavior, but fails gracefully, so we&#x27;ll carry out the checks anyway.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">         final character and force output. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">      a_len++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">        <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">         worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">        <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">      a_len = <span class="number">0</span>;</span><br><span class="line">      prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">       any difference - we don&#x27;t want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];        </span><br><span class="line">      a_len++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP1] += stage_max;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这一部分的主要作用实际上是分析Token，例如固定文件结构前面的magic number。因为我们知道如果目标程序只处理特定类型的文件的话，那么在处理之前就会首先去判断文件开始的magic
            number以确定文件的类型。如果在Fuzz过程中magic number被改变，那么相较于magic number正确的情况就会产生比较大的路径变化，并且由于magic
            number一般为四字节，因此这里改变前四个字节中的任意一个实际上最后得到的路径信息都是相同的。因此这里通过前期的bit翻转来确定某些Token以改进AFL对固定结构的Fuzz效果。</p>
          <p>这里如果对一个文件来说我们知道其固定字节的长度不超过4字节，那么这里我们就可以更改MAX_AUTO_EXTRA全局变量，不过这就需要重新编译AFL。</p>
          <p>
            这里每次变异结束之后都会进行一个复原，至于上面说的路径信息的比对则是在每8次翻转之后才进行一个操作。也就是这里对每一个字节的最低bit位进行翻转的结果进行一个判断。如果得到的路径信息和之前的checksum不同，并且接下来连续的几个字节的bit翻转之后的路径信息相同，那么就将这几个字节加入到字典中。
          </p>
          <h3 id="bitflip-2-1"><a href="#bitflip-2-1" class="headerlink" title="bitflip 2/1"></a>bitflip 2/1</h3>
          <ul>
            <li>
              <p>bitflip 2/1这一部分的代码如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Two walking bits. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 2/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip2&quot;</span>;</span><br><span class="line">stage_max   = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP2] += stage_max;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>从这里我们其实可以看到，这次是每次翻转2bit，步长是1bit。也就是这里开始进入到了真正的bit翻转的变异过程。</p>
          <h3 id="bitflip-4-1"><a href="#bitflip-4-1" class="headerlink" title="bitflip 4/1"></a>bitflip 4/1</h3>
          <ul>
            <li>
              <p>bitflip 4/1</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Four walking bits. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 4/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip4&quot;</span>;</span><br><span class="line">stage_max   = (len &lt;&lt; <span class="number">3</span>) - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP4] += stage_max;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>步长为1bit，然后每次翻转4bit。</p>
          <h3 id="bitflip-8-8"><a href="#bitflip-8-8" class="headerlink" title="bitflip 8/8"></a>bitflip 8/8</h3>
          <p>实际上这个函数用来初始化<code>eff_map</code>，该map用来指导之后的变异。</p>
          <ul>
            <li>
              <p>bitflip 8/8部分的代码如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Effector map setup. These macros calculate:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     EFF_APOS      - position of a particular file offset in the map.</span></span><br><span class="line"><span class="comment">     EFF_ALEN      - length of a map with a particular number of bytes.</span></span><br><span class="line"><span class="comment">     EFF_SPAN_ALEN - map span for a sequence of bytes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_APOS(_p)          ((_p) &gt;&gt; EFF_MAP_SCALE2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_REM(_x)           ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize effector map for the next step (see comments below). Always</span></span><br><span class="line"><span class="comment">     flag first and last byte as doing something. */</span></span><br><span class="line"></span><br><span class="line">  eff_map    = <span class="built_in">ck_alloc</span>(<span class="built_in">EFF_ALEN</span>(len));</span><br><span class="line">  eff_map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">EFF_APOS</span>(len - <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    eff_map[<span class="built_in">EFF_APOS</span>(len - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    eff_cnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Walking byte. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 8/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;flip8&quot;</span>;</span><br><span class="line">  stage_max   = len;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur;</span><br><span class="line"></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We also use this stage to pull off a simple trick: we identify</span></span><br><span class="line"><span class="comment">       bytes that seem to have no effect on the current execution path</span></span><br><span class="line"><span class="comment">       even when fully flipped - and we skip them during more expensive</span></span><br><span class="line"><span class="comment">       deterministic stages, such as arithmetics or known ints. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(stage_cur)]) &#123;</span><br><span class="line"></span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">         without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">        cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cksum = ~queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">        eff_map[<span class="built_in">EFF_APOS</span>(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">        eff_cnt++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the effector map is more than EFF_MAX_PERC dense, just flag the</span></span><br><span class="line"><span class="comment">     whole thing as worth fuzzing, since we wouldn&#x27;t be saving much time</span></span><br><span class="line"><span class="comment">     anyway. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (eff_cnt != <span class="built_in">EFF_ALEN</span>(len) &amp;&amp;</span><br><span class="line">      eff_cnt * <span class="number">100</span> / <span class="built_in">EFF_ALEN</span>(len) &gt; EFF_MAX_PERC) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, <span class="built_in">EFF_ALEN</span>(len));</span><br><span class="line"></span><br><span class="line">    blocks_eff_select += <span class="built_in">EFF_ALEN</span>(len);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    blocks_eff_select += eff_cnt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  blocks_eff_total += <span class="built_in">EFF_ALEN</span>(len);</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP8] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two walking bytes. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_bitflip;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>首先创建了一个<code>eff_map</code>，其大小为测试用例的字节数。然后这里将第一个元素和最后一个元素设置为1，其余设置为0。</p>
          <p>那么接下来就进入到循环中，也就是不断的变异中，这里我们看到此时步长是1字节，每次翻转一个字节。翻转之后即执行<code>common_fuzz_stuff</code>
            函数，在执行完毕之后会根据<code>eff_map</code> 中对应字节来判断，在第一次运行的时候实际上<code>eff_map</code>
            相应的位置表示的就是当前index对应的字节是否被翻转过。如果没有被翻转过的话，那么这里就会检查路径信息。如果本次变异之后的测试用例导致了路径信息的变化，那么就将<code>eff_map</code> 置为1。
          </p>
          <p>实际上这里<code>eff_map</code> 表就表示测试用例中有价值的字节的位置。如果其对应的<code>eff_map</code>
            中的值为1的话，那么就认为这个字节的变异是有意义的，如果当前的字节是没有意义的话，那么就会在之后的变异过程中跳过对这个字节的变异。</p>
          <p>但是这里存在两个特例</p>
          <ol>
            <li>如果当前测试用例文件大小小于128字节，那么这里就会将当前测试用例的所有字节标记为有意义的。</li>
            <li>如果当前测试用例文件的90%及之上的字节都是有意义的，那么整个文件的所有字节都是有意义的。</li>
          </ol>
          <h3 id="bitflip-16-8"><a href="#bitflip-16-8" class="headerlink" title="bitflip 16/8"></a>bitflip 16/8</h3>
          <p>注意到从这里开始，如果当前的测试用例文件小于2字节的话，那么接下来的变异都不会继续执行了。</p>
          <ul>
            <li>
              <p>bitflip 16/8的代码如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line">stage_name  = <span class="string">&quot;bitflip 16/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip16&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)] &amp;&amp; !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP16] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">goto</span> skip_bitflip;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里就会用到之前我们计算的<code>eff_map</code> 的信息，这里我们看到此时的步长是1字节，每次翻转2字节的内容。对于<code>eff_map</code>
            中连续为0的两个字节，那么不会对这两个字节执行变异的操作。</p>
          <h3 id="bitflip-32-8"><a href="#bitflip-32-8" class="headerlink" title="bitflip 32/8"></a>bitflip 32/8</h3>
          <p>这里如果测试用例的文件小于4字节的话，那么接下来的变异都不会继续执行了</p>
          <ul>
            <li>
              <p>bitflip 32/8</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* Four walking bytes. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 32/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip32&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)] &amp;&amp; !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">      !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">2</span>)] &amp;&amp; !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP32] += stage_max;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里的逻辑实际上和<code>bitflip 16/8</code>相同，只不过这里的步长是1字节，每次翻转4字节的内容。而对于<code>eff_map</code>
            中连续为0的四个字节，那么就不会对这四个字节执行变异的操作。</p>
          <h2 id="ARITHMETIC-INC-DEC"><a href="#ARITHMETIC-INC-DEC" class="headerlink"
              title="ARITHMETIC INC/DEC"></a>ARITHMETIC INC/DEC</h2>
          <p>这里如果在AFL启动的时候设置了<code>AFL_NO_ARITH</code> 环境变量的话，那么这里就不会执行本次变异。</p>
          <h3 id="arith-8-8"><a href="#arith-8-8" class="headerlink" title="arith 8/8"></a>arith 8/8</h3>
          <ul>
            <li>
              <p>arith 8/8 部分的代码如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* 8-bit arithmetics. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;arith 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;arith8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = <span class="number">2</span> * len * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)]) &#123;</span><br><span class="line">    stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">    u8 r = orig ^ (orig + j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do arithmetic operations only if the result couldn&#x27;t be a product</span></span><br><span class="line"><span class="comment">       of a bitflip. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">could_be_bitflip</span>(r)) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = j;</span><br><span class="line">      out_buf[i] = orig + j;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    r =  orig ^ (orig - j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">could_be_bitflip</span>(r)) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = -j;</span><br><span class="line">      out_buf[i] = orig - j;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_ARITH8] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 16-bit arithmetics, both endians. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_arith;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>我们看到这里的步长是1字节，每次对1字节进行算数运算。这里的算数运算的逻辑如下</p>
          <p>首先这里会根据<code>eff_map</code>来对当前字节是否有价值进行变异进行一个判断，如果有价值的话，那么就会执行如下的变异策略</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">u8 r = orig ^ (orig + j);</span><br><span class="line">r =  orig ^ (orig - j);</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里的<code>orig</code> 表示的是当前需要进行运算的字节，这里的j表示的是一个算数，该算数从0递增到<code>ARITH_MAX=35</code>
            。这里计算得到结果之后会调用<code>could_be_bitflip</code> 函数对这个字节能否执行bit翻转进行一个判断。这里判断的逻辑是运算之后的字节的值不和之前bit翻转时候的值相同，以减少重复。
          </p>
          <h3 id="arith-16-8"><a href="#arith-16-8" class="headerlink" title="arith 16/8"></a>arith 16/8</h3>
          <p>这里的逻辑也是相对比较简单的，这里的步长还是1字节，而对于每两个字节都对其尝试了<code>-35,35</code>之内的数值的加减，同时这里考虑了大小端。当然这里也使用了<code>eff_map</code>
            中的信息</p>
          <h3 id="arith-32-8"><a href="#arith-32-8" class="headerlink" title="arith 32/8"></a>arith 32/8</h3>
          <p>与<code>arith 16/8</code> 相同，只不过这里变成了四字节的<code>-35,35</code>之内的数值的加减</p>
          <h2 id="INTERESTING-VALUES"><a href="#INTERESTING-VALUES" class="headerlink"
              title="INTERESTING VALUES"></a>INTERESTING VALUES</h2>
          <p>这里在全局变量中定义了一些感兴趣的数值，实际上这些数值表示了一些临界值。</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="type">static</span> s8  interesting_8[]  = &#123; INTERESTING_8 &#125;;</span><br><span class="line"><span class="type">static</span> s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;</span><br><span class="line"><span class="type">static</span> s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <h3 id="interest-8-8"><a href="#interest-8-8" class="headerlink" title="interest 8/8"></a>interest 8/8</h3>
          <ul>
            <li>
              <p>interest 8/8 代码如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line">stage_name  = <span class="string">&quot;interest 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;int8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len * <span class="built_in">sizeof</span>(interesting_8);</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setting 8-bit integers. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)]) &#123;</span><br><span class="line">    stage_max -= <span class="built_in">sizeof</span>(interesting_8);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">could_be_bitflip</span>(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">        <span class="built_in">could_be_arith</span>(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_val = interesting_8[j];</span><br><span class="line">    out_buf[i] = interesting_8[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_INTEREST8] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setting 16-bit integers, both endians. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_arith || len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_interest;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里就是将测试用例中的某一个字节替换为上述定义的一些字节，这里是每次替换1字节。那么在替换之前还是会检查是否和之前的变异重复。</p>
          <h3 id="interest-16-8"><a href="#interest-16-8" class="headerlink" title="interest 16/8"></a>interest 16/8
          </h3>
          <p>和<code>interest 8/8</code> 相同，只不过这里每次替换两字节。</p>
          <h3 id="interest-32-8"><a href="#interest-32-8" class="headerlink" title="interest 32/8"></a>interest 32/8
          </h3>
          <p>同理，这里每次替换四字节</p>
          <h2 id="DICTIONARY-STUFF"><a href="#DICTIONARY-STUFF" class="headerlink"
              title="DICTIONARY STUFF"></a>DICTIONARY STUFF</h2>
          <p>在这一个阶段将会采用字典中的数据来替换测试用例中的某些数据。这里一共分为三种模式，如下</p>
          <h3 id="user-extras-over"><a href="#user-extras-over" class="headerlink" title="user extras (over)"></a>user
            extras (over)</h3>
          <ul>
            <li>
              <p><code>user extras (over)</code> 代码部分如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="keyword">if</span> (!extras_cnt) <span class="keyword">goto</span> skip_user_extras;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Overwrite with user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;user extras (over)&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;ext_UO&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = extras_cnt * len;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extras are sorted by size, from smallest to largest. This means</span></span><br><span class="line"><span class="comment">       that we don&#x27;t have to worry about restoring the buffer in</span></span><br><span class="line"><span class="comment">       between writes at a particular offset determined by the outer</span></span><br><span class="line"><span class="comment">       loop. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also</span></span><br><span class="line"><span class="comment">         skip them if there&#x27;s no room to insert the payload, if the token</span></span><br><span class="line"><span class="comment">         is redundant, or if its entire span has no bytes set in the effector</span></span><br><span class="line"><span class="comment">         map. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; <span class="built_in">UR</span>(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">          extras[j].len &gt; len - i ||</span><br><span class="line">          !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + <span class="built_in">EFF_APOS</span>(i), <span class="number">1</span>, <span class="built_in">EFF_SPAN_ALEN</span>(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_len = extras[j].len;</span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里我们看到该部分的操作就是，步长为1字节，然后依次将字典中的字符串替换到out_buf+index的位置。这里收到eff_map的影响。</p>
          <p>并且这里会检查字典中的Token的数量，如果其大于<code>MAX_DET_EXTRAS=200</code> ，那么对Token就会存在一个概率，计算如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="built_in">UR</span>(extras_cnt) &gt;= MAX_DET_EXTRAS <span class="comment">// 这里UR就是产生一个0-extras_cnt的随机值。</span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>也就是这个概率随着字典中Token数量的增大而减小。</p>
          <h3 id="user-extras-insert"><a href="#user-extras-insert" class="headerlink"
              title="user extras (insert)"></a>user extras (insert)</h3>
          <p>那么这里就是插入操作，也就是步长为1字节，将字典中的字符串插入到相应的位置，这里很明显不会收到eff_map的影响。并且这里不受字典长度的限制</p>
          <h3 id="auto-extras-over"><a href="#auto-extras-over" class="headerlink" title="auto extras (over)"></a>auto
            extras (over)</h3>
          <p>注意到这里的字典从<code>extras</code> 替换为了<code>a_extras</code>
            ，也就是这一步的字典使用的实际上是我们前面在进行bitflip的时候所自动生成的字典信息。这里将以1字节为步长，将相应位置替换为字典中的字符串。</p>
          <h2 id="RANDOM-HAVOC"><a href="#RANDOM-HAVOC" class="headerlink" title="RANDOM HAVOC"></a>RANDOM HAVOC</h2>
          <p>这一部分就是随机变异的内容，在这一步中将会在下面的几种变异方式中随机选择一种</p>
          <ul>
            <li>随机选取测试用例中的1bit进行翻转</li>
            <li>随机选取测试用例中的1字节替换为<code>interesting_8</code> 中随机选取的一个值</li>
            <li>随机选取测试用例中的2字节，随机选取大小端，替换为<code>interesting_16</code> 中随机选取的一个值</li>
            <li>随机选取测试用例中的4字节，随机选取大小端，替换为<code>interesting_32</code> 中随机选取的一个值</li>
            <li>随机选取测试用例中的1字节，对其减去1-35中的一个随机数</li>
            <li>随机选取测试用例中的1字节，对其加上1-35中的一个随机数</li>
            <li>随机选取测试用例中的2字节，随机选取大小端，对其减去1-35中的一个随机数</li>
            <li>随机选取测试用例中的2字节，随机选取大小端，对其加上1-35中的一个随机数</li>
            <li>随机选取测试用例中的4字节，随机选取大小端，对其减去1-35中的一个随机数</li>
            <li>随机选取测试用例中的4字节，随机选取大小端，对其加上1-35中的一个随机数</li>
            <li>随机选取测试用例中的1字节，将其异或1-255之间的一个随机值</li>
            <li>随机选取测试用例中的一段字节，将其删除</li>
            <li>随机选取测试用例中的一个位置，以75%的概率插入测试用例中的一段随机位置、随机长度的字符串，以25%的概率插入一段随机数</li>
            <li>随机选取测试用例中的一个位置，以75%的概率替换为测试用例中的一段随机位置、随机长度的字符串，以25%的概率替换为一段随机数</li>
            <li>如果字典不为空（系统字典+用户字典），那么随机选取一个字典，随机选取字典中的一个字符串，将其替换到测试用例中的随机位置</li>
            <li>如果字典不为空（系统字典+用户字典），那么随机选取一个字典，随机选取字典中的一个字符串，将其插入到测试用例中的随机位置</li>
          </ul>
          <h2 id="SPLICING"><a href="#SPLICING" class="headerlink" title="SPLICING"></a>SPLICING</h2>
          <ul>
            <li>
              <p>Splicing部分代码如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="comment">/* This is a last-resort strategy triggered by a full round with no findings.</span></span><br><span class="line"><span class="comment">     It takes the current input file, randomly selects another input, and</span></span><br><span class="line"><span class="comment">     splices them together at some offset, then relies on the havoc</span></span><br><span class="line"><span class="comment">     code to mutate that blob. */</span></span><br><span class="line"></span><br><span class="line">retry_splicing:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">      queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* target;</span><br><span class="line">    u32 tid, split_at;</span><br><span class="line">    u8* new_buf;</span><br><span class="line">    s32 f_diff, l_diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First of all, if we&#x27;ve modified in_buf for havoc, let&#x27;s clean that</span></span><br><span class="line"><span class="comment">       up... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_buf != orig_in) &#123;</span><br><span class="line">      <span class="built_in">ck_free</span>(in_buf);</span><br><span class="line">      in_buf = orig_in;</span><br><span class="line">      len = queue_cur-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123; tid = <span class="built_in">UR</span>(queued_paths); &#125; <span class="keyword">while</span> (tid == current_entry);</span><br><span class="line"></span><br><span class="line">    splicing_with = tid;</span><br><span class="line">    target = queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123; target = target-&gt;next_100; tid -= <span class="number">100</span>; &#125;</span><br><span class="line">    <span class="keyword">while</span> (tid--) target = target-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that the target has a reasonable length. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="number">2</span> || target == queue_cur)) &#123;</span><br><span class="line">      target = target-&gt;next;</span><br><span class="line">      splicing_with++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">goto</span> retry_splicing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the testcase into a new buffer. */</span></span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(target-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">    new_buf = <span class="built_in">ck_alloc_nozero</span>(target-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_read</span>(fd, new_buf, target-&gt;len, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find a suitable splicing location, somewhere between the first and</span></span><br><span class="line"><span class="comment">       the last differing byte. Bail out if the difference is just a single</span></span><br><span class="line"><span class="comment">       byte or so. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">locate_diffs</span>(in_buf, new_buf, <span class="built_in">MIN</span>(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f_diff &lt; <span class="number">0</span> || l_diff &lt; <span class="number">2</span> || f_diff == l_diff) &#123;</span><br><span class="line">      <span class="built_in">ck_free</span>(new_buf);</span><br><span class="line">      <span class="keyword">goto</span> retry_splicing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split somewhere between the first and last differing byte. */</span></span><br><span class="line"></span><br><span class="line">    split_at = f_diff + <span class="built_in">UR</span>(l_diff - f_diff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the thing. */</span></span><br><span class="line"></span><br><span class="line">    len = target-&gt;len;</span><br><span class="line">    <span class="built_in">memcpy</span>(new_buf, in_buf, split_at);</span><br><span class="line">    in_buf = new_buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(out_buf);</span><br><span class="line">    out_buf = <span class="built_in">ck_alloc_nozero</span>(len);</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这一部分做的事测试用例之间的切割和重组。</p>
          <p>具体来说，这里首先是随机选取了另一个测试用例，然后调用<code>locate_diffs</code>
            函数，在这两个测试用例的第一个不同的字节到最后一个不同的字节之间随机选取一个位置，将这两个测试用例分别分为两个部分，将当前测试用例的第一部分和随机选取的测试用例的第二部分进行一个重组。</p>
          <p>这里的<code>locate_diffs</code> 实际上就是循环遍历长度最小的测试用例，然后字符之间进行比较。</p>
          <h1 id="路径信息的获取和分析"><a href="#路径信息的获取和分析" class="headerlink" title="路径信息的获取和分析"></a>路径信息的获取和分析</h1>
          <p>这里前面实际上一直存在一个问题，就是问什么我们调用完run_target之后，就能够获取得到运行过程中的路径信息呢。这里我们先来看一下初始化时候的函数也就是<code>setup_shm</code> 函数</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = <span class="built_in">shmget</span>(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">atexit</span>(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) <span class="built_in">setenv</span>(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p><code>shmget</code> 函数会初始化一段<code>MAP_SIZE</code> 大小的共享内存。这里<code>IPC_PRIVATE</code>
            的值是0，那么这里就会创建新的共享对象，这里返回的结果是共享内存的标识符。<code>IPC_CREAT|IPC_EXCL</code>
            标识符表示的则是如果内核中不存在键值与key相等的共享内存，那么这里将会建立一个新的消息队列，如果存在这样的共享内存那么就会报错。</p>
          <p>注意到这里如果不是<code>dumb_mode</code> 的话，那么就会将获取得到的共享内存的标识写入到环境变量中即<code>SHM_ENV_VAR</code> 。</p>
          <p>之后将调用<code>shmat</code>函数将创建的共享内存对象映射到调用进程的地址空间中，也就是<code>trace_bits</code> 指向的内存空间，这里看到是我们保存路径信息的地方。</p>
          <p>这里在每次调用<code>run_target</code>开始Fuzz的时候会首先调用如下的代码</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>即将<code>trace_bits</code> 信息全部清空。那么之后无论是该进程调用fork还是和forkserver进行通信的话，就没有再操作<code>trace_bits</code>
            这一块内存空间了。</p>
          <p>要想知道接下来的操作，我们这里还需要再看一下<code>afl-as.c</code> 文件的内容</p>
          <h1 id="插桩部分源码分析"><a href="#插桩部分源码分析" class="headerlink" title="插桩部分源码分析"></a>插桩部分源码分析</h1>
          <p>这一部分的主要代码是afl-as.c</p>
          <h2 id="什么时候进行插桩"><a href="#什么时候进行插桩" class="headerlink" title="什么时候进行插桩"></a>什么时候进行插桩</h2>
          <h3 id="插桩位置1-基本块的开始"><a href="#插桩位置1-基本块的开始" class="headerlink" title="插桩位置1-基本块的开始"></a>插桩位置1-基本块的开始</h3>
          <p>从前面的源码文件结构中我们实际上可以知道，该部分的代码实现的主要就是插桩功能。Main函数的逻辑比较简单，这里主要功能的实现就是<code>add_instrumentation</code>
            函数，这里我们看一下函数的功能，这里首先从<code>input_file</code> 中读取数据，将修改后的文件的内容写入到<code>modified_file</code> 中。</p>
          <p>这里会依次的读取文件中的每一行的内容。在符合条件的情况下，会按照64位或者32位的方式插入一段代码，如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = <span class="number">0</span>;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fputs</span>(line, outf);</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>那么这里是在哪写地方进行插入呢，这里实际上只有在.text段才会执行插入的操作，如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">    !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">    !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">    !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">  instr_ok = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>; </span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>我们这里看一下其他的成员变量的赋值过程，以了解在什么时候执行插入的操作，首先这里<code>pass_thru</code> 成员变量</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">    <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">    <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里实际上是在之前的<code>edit_params</code> 函数中触发调用的，这里我们可以看到只是判断了一下输入文件的路径。一般情况下这里<code>pass_thru</code>
            的值应该是0。接下来我们看一下<code>skip_intel</code> 成员变量</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>
            这里表示的是接下来的汇编的格式，这里att_syntax表示的是AT&amp;T格式的汇编代码，而intel_syntax则表示的是Intel格式的汇编代码，这里我们看到实际上只有针对AT&amp;T格式的汇编代码才会执行插入的操作。接下来我们看一下<code>skip_app</code>
            成员变量</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里在汇编文件中，<code>#APP</code> 和<code>#NO_APP</code>
            这两个标签中间包裹的内容实际上是我们在代码中插入的內联汇编的代码，也就是这里不会对內联汇编进行插入操作。我们这里再来看一下<code>skip_csect</code></p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里如果是64位的话，那么对汇编中的32位的汇编代码不进行插入，同理对于32位程序，汇编中的64位汇编代码不会进行插入。<code>instrument_next</code>
            这个变量则是一个关键的变量，实际上这里由于我们处理的是汇编文件，在产生汇编的时候，这里基本块已经都分配好了，<code>instrument_next</code>
            则表示的是下一次是否插入，其赋值则是通过查找当前是否是一个块的开始来判断的，这里代码如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">          &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">           label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">           That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">           processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">           typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">           about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">           .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">           MacOS X). */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>注意到这里并不是所有的基本块都会进行代码的插入，实际上这里存在一个概率<code>inst_ratio</code>
            虽然默认的值是100，但是我们可以更改这个值。注意这里判断的实际上就是切分的Block，我们这里可以看一个例子，源码如下</p>
          <ul>
            <li>
              <p>例子的源码</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>注意到这里只有在保留调试信息的时候才会保留本地符号也就是.L开头的符号，我们这里生成汇编的命令如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">gcc -g -m64 -S -o test.s test.c</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <ul>
            <li>
              <p>生成的部分汇编如下</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .file <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line">        .loc <span class="number">1</span> <span class="number">3</span> <span class="number">12</span></span><br><span class="line">        .cfi_startproc</span><br><span class="line">        endbr64</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        subq    $<span class="number">16</span>, %rsp</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line">        movl    $<span class="number">0</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">.LBB2:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">6</span> <span class="number">13</span></span><br><span class="line">        movl    $<span class="number">1</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line">        movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        leaq    .<span class="built_in">LC0</span>(%rip), %rdi</span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">.LBE2:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">9</span> <span class="number">12</span></span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
            <li>
              <p>另一种形式的汇编</p>
              <figure class="highlight cpp">
                <table>
                  <tr>
                    <td class="gutter">
                      <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                    </td>
                    <td class="code">
                      <pre><span class="line">.L3:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">8</span> <span class="number">9</span> discriminator <span class="number">3</span></span><br><span class="line">        movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        leaq    .<span class="built_in">LC0</span>(%rip), %rdi</span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">5</span> <span class="number">24</span> discriminator <span class="number">3</span></span><br><span class="line">        addl    $<span class="number">1</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">5</span> <span class="number">5</span> discriminator <span class="number">1</span></span><br><span class="line">        cmpl    $<span class="number">4</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">        jle     .L3</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">11</span> <span class="number">1</span></span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br></pre>
                    </td>
                  </tr>
                </table>
              </figure>
            </li>
          </ul>
          <p>这里我们需要注意的是这里call并不会作为基本块划分的条件。同时这里条件跳转也不会进行基本块的划分。</p>
          <p>也就是这里.LFB0表示的是一个函数的开始部分，同时应该也表示一个基本块的开始，也就是Local Function Begin，后面的0表示的是函数的index的值。那么下面的<code>.LBB2</code>
            则就表示的是一个基本块的开始，同时index=2。也就是这里在每个基本块的开始进行了代码的插入。</p>
          <h3 id="插桩位置2-条件跳转之后"><a href="#插桩位置2-条件跳转之后" class="headerlink" title="插桩位置2-条件跳转之后"></a>插桩位置2-条件跳转之后</h3>
          <p>同时这里还存在另一处的插桩代码如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">            <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">    ins_lines++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>也就是这里对与条件跳转，在条件跳转之后有一定的几率去进行插桩，这里几率默认的则是100。这里只在条件跳转语句之后插桩是没有问题的，因为跳转的目标一定是一个基本块的开始，我们之前已经在其起始位置插桩完成了。</p>
          <h3 id="插桩位置3-结尾"><a href="#插桩位置3-结尾" class="headerlink" title="插桩位置3-结尾"></a>插桩位置3-结尾</h3>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>注意到这里在整个文件处理完毕之后还会插入一段内容。</p>
          <h2 id="插桩的内容"><a href="#插桩的内容" class="headerlink" title="插桩的内容"></a>插桩的内容</h2>
          <p>这里通过前面的分析我们知道一共插入了两种内容，分别是<code>trampoline_fmt_64</code> 以及<code>main_payload_64</code>
            这里从插入的位置来看，我们实际上就可以推测出<code>trampoline_fmt_64</code> 负责跳转到路径记录的函数，而<code>main_payload_64</code>
            则包含了一些初始化或者记录路径信息的函数。这里我们分别来看一下，需要注意的是这里只是针对64位下的代码。</p>
          <h3 id="trampoline-fmt-64"><a href="#trampoline-fmt-64" class="headerlink"
              title="trampoline_fmt_64"></a>trampoline_fmt_64</h3>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里逻辑很简单，即调用了<code>__afl_maybe_log</code>函数，我们看一下这个函数</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line"><span class="string">&quot;  seto %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p><code>lahf</code> 指令是将<code>EFLAGS</code> 寄存器数组的低字节拷贝到AH寄存器中。<code>seto</code>
            指令则是如果出现溢出的话，那么就将al设置为1。接着判断了<code>__afl_area_ptr</code> 的值是否被设置了。如果没有设置的话，那么就会跳转到<code>__afl_setup</code>
            部分去执行，我们看一下</p>
          <h3 id="afl-setup"><a href="#afl-setup" class="headerlink" title="__afl_setup"></a>__afl_setup</h3>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="string">&quot;.AFL_SHM_ENV:\n&quot;</span></span><br><span class="line"><span class="string">&quot;  .asciz \&quot;&quot;</span> SHM_ENV_VAR <span class="string">&quot;\&quot;\n&quot;</span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne __afl_return\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __APPLE__</span></span><br><span class="line"><span class="string">&quot;  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  (%rdx), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span><br><span class="line"><span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup_first\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_store\n&quot;</span> </span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里<code>AFL_SHM_ENV</code> 是环境变量的字符串。这里如果<code>__afl_area_ptr</code>设置了，那么就跳转到<code>__afl_store</code>
            部分去执行，如果没有设置，那么就会执行如下的代码</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="string">&quot;__afl_setup_first:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span></span><br><span class="line"><span class="string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax,   0(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r8,   40(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r9,   48(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r10,  56(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r11,  64(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span></span><br><span class="line"><span class="string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  %rsp, %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  subq  $16, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;getenv&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testq %rax, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  %rax, %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;atoi&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;shmat&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpq $-1, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Store the address of the SHM region. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, (%rdx)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"><span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>在保存了一些寄存器数组之后，这里即调用了<code>getenv</code> 函数来获取<code>AFL_SHM_ENV</code>
            的值，这里我们通过前面的分析实际上这里<code>AFL_SHM_ENV</code>保存的是共享内存的id值。拿到id值之后这里即调用<code>shmat</code>
            函数，将其映射到了本次的进程内存中。注意到这里的内存地址直接保存到了<code>__afl_area_ptr</code>
            函数中。也就是这里<code>__afl_area_ptr</code>实际上表示的就是路径信息的内存空间。</p>
          <p>接下来会启动fork_server。这里会调用fork函数</p>
          <h3 id="afl-forkserver"><a href="#afl-forkserver" class="headerlink"
              title="__afl_forkserver"></a>__afl_forkserver</h3>
          <p>这里父进程会一直陷入到循环中，通过pipe管道来接受消息。也就是前面和Fuzz进行通信的部分。</p>
          <h3 id="afl-store"><a href="#afl-store" class="headerlink" title="__afl_store"></a>__afl_store</h3>
          <p>这里子进程则会开始记录信息的过程，我们看一下这一部分的代码</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span></span><br><span class="line"><span class="string">&quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span></span><br><span class="line"><span class="string">&quot;     and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line"><span class="string">&quot;  movl __afl_prev_loc, %edi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorl %ecx, %edi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  shrl $1, %ecx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl %ecx, __afl_prev_loc\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  movl %ecx, %edi\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line"><span class="string">&quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  incb (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_return:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  addb $127, %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;  sahf\n&quot;</span></span><br><span class="line"><span class="string">&quot;  ret\n&quot;</span></span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>这里我们看到路径的上一个基本块被保存在<code>__afl_prev_loc</code> 全局变量中，而当前基本块的ID则保存在ecx中，实际上这里的ecx的值是通过我们在插桩的时候传入进来的，如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                <span class="built_in">R</span>(MAP_SIZE));</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>
            也就是这里传入了一个MAP_SIZE大小的随机数作为当前基本块的一个ID。这里我们就可以看到路径记录方面的内容。如果这里不对路径命中进行计数的话，那么这里只会将命中的路径的值设置为1。如果需要统计计数的话，那么这里则会直接对相应位置采取加的操作。
          </p>
          <h2 id="命中次数的计算"><a href="#命中次数的计算" class="headerlink" title="命中次数的计算"></a>命中次数的计算</h2>
          <p>这里前面我们分析到，命中一组路径元组的话，其在trace_bits中相应位置的值就会增加，但是这并不表示最终的命中次数的结果。每一次<code>run_target</code>
            函数执行完毕获取得到trace_bits之后都会进行一个处理，即调用<code>classify_counts</code> 函数</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">classify_counts</span><span class="params">(u64* mem)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(*mem)) &#123;</span><br><span class="line"></span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">      mem16[<span class="number">2</span>] = count_class_lookup16[mem16[<span class="number">2</span>]];</span><br><span class="line">      mem16[<span class="number">3</span>] = count_class_lookup16[mem16[<span class="number">3</span>]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mem++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u16 count_class_lookup16[<span class="number">65536</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">init_count_class16</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 b1, b2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++) </span><br><span class="line">    <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">      count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] = </span><br><span class="line">        (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        count_class_lookup8[b2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>实际上这里和32位下面的处理是相同的。这里32位的count_class如下</p>
          <figure class="highlight cpp">
            <table>
              <tr>
                <td class="gutter">
                  <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre>
                </td>
              </tr>
            </table>
          </figure>

          <p>也就是模糊了命中次数这个概念，而是用一个范围来表示命中次数。这个范围在AFL表示为一个桶。也就是命中次数从一个桶转换到另一个桶才会被认为命中次数发生了改变。</p>
          <h1 id="AFL总结"><a href="#AFL总结" class="headerlink" title="AFL总结"></a>AFL总结</h1>
          <p>这里对于一些无关的参数处理或者说初始化我们跳过，只关注核心的部分</p>
          <ol>
            <li>
              <p>首先这里进行共享内存的初始化，通过调用<code>shmget</code>
                分配了MAP_SIZE大小的共享内存，分别被AFL进程和目标进程映射到各自的地址空间中，作为记录路径信息的内存空间。这里记录路径信息的时候对于每个基本块都随机分配了一个MAP_SIZE中的随机值。而对于A→B这样的路径元组其对应的MAP中的位置为<code>shared_mem[(A&gt;&gt;1)^B]</code>
                。</p>
              <p>这里目标进程通过插桩的方式插入相应的路径记录信息的代码，以及Forserver的代码。</p>
            </li>
            <li>
              <p>
                初始化完成之后，对于所有的测试用例会首先进行第一轮的Fuzz，也就是DryRun，第一次运行的目的是对测试用例进行校准，初始化所有测试用例的当前的路径信息，并依据这个路径信息执行优胜者策略。这里优胜者测试用例的选择是对于某一个特定的路径元组例如A→B，执行时间最短并且文件最小的则是当前路径元组的优胜者。但是并不是所有的优胜者都会被欢迎。AFL只会欢迎第一次看到的优胜者测试用例。
              </p>
            </li>
            <li>
              <p>接下来就是主Fuzz循环，每次循环之前都会执行样本选择，也就是执行优胜者策略。之后按照相应的策略选择当前这一轮要执行Fuzz的测试用例样本，具体的策略如下</p>
              <ol>
                <li>
                  <p>如果队列中存在还没有被Fuzz的受欢迎的优胜者测试用例</p>
                  <ol>
                    <li>当前的测试用例已经被Fuzz过了或者当前的测试用例不是受欢迎的优胜者测试用例，那么将会有99%的概率跳过这个测试用例</li>
                  </ol>
                  <p>也就是这里会以很大的概率去寻找还没有被Fuzz的受欢迎的优胜者测试用例</p>
                </li>
                <li>
                  <p>如果队列中所有受欢迎的优胜者测试用例都被Fuzz了</p>
                  <ol>
                    <li>如果当前的测试用例是受欢迎的优胜者，那么选择当前的测试用例</li>
                    <li>如果当前的测试用例不是受欢迎的优胜者并且测试用例的总数大于10<ol>
                        <li>当前的测试用例没有被Fuzz过，75%的概率跳过这个测试用例</li>
                        <li>当前测试用例被Fuzz过，95%概率跳过这个测试用例</li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              <p>
                对当前测试用例执行剪枝操作，主要目的是减少测试用例文件的大小。具体的策略是首先选择一个大的步长，依次删除测试用例文件中相应的部分，观察路径信息是否发生变化，如果没有发生变化那么就将这一块内容从测试用例中删除。之后依次减少步长，直到达到最小步长，之后将更改之后的文件写入到磁盘文件，更新优胜者队列。更改之后的文件作为结下来要Fuzz的文件
              </p>
              <p>5字节一下的文件不会执行剪枝操作。</p>
            </li>
            <li>
              <p>之后对当前的这个测试用例进行打分，执行速度越快、发现路径的数量越多、最近发现新路径的以及发现的路径越深的则分数更高，在后续的随机变异中将会获取得到更多的执行轮数。</p>
            </li>
            <li>
              <p>接下来就是变异的操作了。这里会涉及到6种类型的遍历。分别是bit翻转、算数加减、interesting数值运算、字典替换、随机变异、不同测试用例之间的拼接。这里我们要注意几个变异策略的作用</p>
              <ol>
                <li>第一次变异即步长为1，每次翻转1bit是用来探测固定结构的，也就是探测类似于Magic
                  Number等。这里如果前几个字节的最后一个bit翻转之后所得到的路径信息相同，那么我们就可以认为这几个字节为一个Token，也就是固定字节。</li>
                <li>步长为1字节，每次翻转1字节则是用来初始化eff_map的，该map会指导后续的遍历过程。也就是对于翻转后路径信息不变的字节，那么在之后的变异过程中也不会再对这个字节进行变异。</li>
                <li>INTERESTING VALUES实际上也是一种算数运算操作，不过这里的算数则是一些边界值</li>
              </ol>
            </li>
            <li>
              <p>
                每次变异都会将变异的文件写入到磁盘文件中，之后执行目标程序。如果变异之后的样本产生了新的路径或者路径元组命中次数发生了变化，那么这里就会将变异之后的文件写入到测试用例文件夹中。如果没有发生hangs或者crash，那么就会将这个变异之后的测试用例加入到队列中。之后继续从第4步开始执行直至退出。
              </p>
            </li>
          </ol>
          <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
          <p><a target="_blank" rel="noopener external nofollow noreferrer"
              href="https://xidoo.top/2022/01/afl-white-book/#0-%E8%AE%BE%E8%AE%A1%E9%99%88%E8%BF%B0-design-statement">AFL
              白皮书翻译与读书笔记</a></p>
        </article>
        <div class="post-copyright">
          <div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span
              class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">LYYL</a></span>
          </div>
          <div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span
              class="post-copyright-info"><a
                href="https://www.lyyl.online/posts/95726211.html">https://www.lyyl.online/posts/95726211.html</a></span>
          </div>
          <div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span
              class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a
                href="https://www.lyyl.online" target="_blank">LYYL' Blog</a>！</span></div>
        </div>
        <div class="tag_share">
          <div class="post-meta__tag-list"></div>
          <div class="post_share">
            <div class="social-share" data-image="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-3.jpeg"
              data-sites="facebook,twitter,wechat,weibo,qq"></div>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"
              media="print" onload="this.media='all'">
            <script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script>
          </div>
        </div>
        <nav class="pagination-post" id="pagination">
          <div class="prev-post pull-full"><a href="/posts/1029211104.html"><img class="prev-cover"
                src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-37.jpeg"
                onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post">
              <div class="pagination-info">
                <div class="label">上一篇</div>
                <div class="prev_info">V8 重新入门-2019 starCTF oob 题解</div>
              </div>
            </a></div>
        </nav>
        <hr />
        <div id="post-comment">
          <div class="comment-head">
            <div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div>
          </div>
          <div class="comment-wrap">
            <div>
              <div id="disqus_thread"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="aside-content" id="aside-content">
        <div class="card-widget card-info">
          <div class="is-center">
            <div class="avatar-img"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png"
                onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" /></div>
            <div class="author-info__name">LYYL</div>
            <div class="author-info__description">毋忧拂意，毋喜快心，毋恃久安，毋惮初难。</div>
          </div>
          <div class="card-info-data">
            <div class="card-info-data-item is-center"><a href="/archives/">
                <div class="headline">文章</div>
                <div class="length-num">27</div>
              </a></div>
            <div class="card-info-data-item is-center"><a href="/categories/">
                <div class="headline">分类</div>
                <div class="length-num">5</div>
              </a></div>
          </div><a class="button--animated" id="card-info-btn" target="_blank"
            rel="noopener external nofollow noreferrer" href="https://github.com/liuzhongchina521"><i
              class="fab fa-github"></i><span>Follow Me</span></a>
          <div class="card-info-social-icons is-center"><a class="social-icon"
              href="https://github.com/liuzhongchina521" rel="external nofollow noreferrer" target="_blank"
              title="Github"><i class="fab fa-github"></i></a><a class="social-icon"
              href="mailto:liuzhongchina521@gmail.com" rel="external nofollow noreferrer" target="_blank"
              title="Email"><i class="fas fa-envelope"></i></a></div>
        </div>
        <div class="card-widget card-announcement">
          <div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div>
          <div class="announcement_content">博客内容为Notion导出markdown，如有错误敬请谅解。</div>
        </div>
        <div class="sticky_layout">
          <div class="card-widget" id="card-toc">
            <div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div>
            <div class="toc-content">
              <ol class="toc">
                <li class="toc-item toc-level-1"><a class="toc-link"
                    href="#%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span
                      class="toc-text">源码文件结构</span></a></li>
                <li class="toc-item toc-level-1"><a class="toc-link" href="#Main%E5%87%BD%E6%95%B0"><span
                      class="toc-text">Main函数</span></a>
                  <ol class="toc-child">
                    <li class="toc-item toc-level-2"><a class="toc-link"
                        href="#%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">参数处理</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span
                          class="toc-text">初始化</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link"
                            href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AF%BB%E5%8F%96"><span
                              class="toc-text">测试用例读取</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#Dry-Run"><span class="toc-text">Dry
                          Run</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#Main-Loop"><span class="toc-text">Main
                          Loop</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#Exit"><span
                          class="toc-text">Exit</span></a></li>
                  </ol>
                </li>
                <li class="toc-item toc-level-1"><a class="toc-link"
                    href="#DryRun%E4%B8%8EMainLoop%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span
                      class="toc-text">DryRun与MainLoop代码中的一些关键函数</span></a>
                  <ol class="toc-child">
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#calibrate-case-%E5%87%BD%E6%95%B0"><span
                          class="toc-text">calibrate_case 函数</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#cull-queue"><span
                          class="toc-text">cull_queue</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#fuzz-one"><span
                          class="toc-text">fuzz_one</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link"
                            href="#%E6%8C%89%E7%85%A7%E7%AD%96%E7%95%A5%E8%B7%B3%E8%BF%87%E6%9F%90%E4%BA%9B%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span
                              class="toc-text">按照策略跳过某些测试用例</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D"><span
                              class="toc-text">剪枝</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%88%86"><span
                              class="toc-text">打分</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%BC%82"><span
                              class="toc-text">变异</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#trim-case"><span
                          class="toc-text">trim_case</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#update-bitmap-score"><span
                          class="toc-text">update_bitmap_score</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#common-fuzz-stuff"><span
                          class="toc-text">common_fuzz_stuff</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#save-if-interesting"><span
                          class="toc-text">save_if_interesting</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#has-new-bits"><span
                          class="toc-text">has_new_bits</span></a></li>
                  </ol>
                </li>
                <li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E5%BC%82%E7%AD%96%E7%95%A5"><span
                      class="toc-text">变异策略</span></a>
                  <ol class="toc-child">
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#SIMPLE-BITFLIP"><span
                          class="toc-text">SIMPLE BITFLIP</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#bitflip-1-1"><span
                              class="toc-text">bitflip 1&#x2F;1</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#bitflip-2-1"><span
                              class="toc-text">bitflip 2&#x2F;1</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#bitflip-4-1"><span
                              class="toc-text">bitflip 4&#x2F;1</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#bitflip-8-8"><span
                              class="toc-text">bitflip 8&#x2F;8</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#bitflip-16-8"><span
                              class="toc-text">bitflip 16&#x2F;8</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#bitflip-32-8"><span
                              class="toc-text">bitflip 32&#x2F;8</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#ARITHMETIC-INC-DEC"><span
                          class="toc-text">ARITHMETIC INC&#x2F;DEC</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#arith-8-8"><span
                              class="toc-text">arith 8&#x2F;8</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#arith-16-8"><span
                              class="toc-text">arith 16&#x2F;8</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#arith-32-8"><span
                              class="toc-text">arith 32&#x2F;8</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#INTERESTING-VALUES"><span
                          class="toc-text">INTERESTING VALUES</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#interest-8-8"><span
                              class="toc-text">interest 8&#x2F;8</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#interest-16-8"><span
                              class="toc-text">interest 16&#x2F;8</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#interest-32-8"><span
                              class="toc-text">interest 32&#x2F;8</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#DICTIONARY-STUFF"><span
                          class="toc-text">DICTIONARY STUFF</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#user-extras-over"><span
                              class="toc-text">user extras (over)</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#user-extras-insert"><span
                              class="toc-text">user extras (insert)</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#auto-extras-over"><span
                              class="toc-text">auto extras (over)</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#RANDOM-HAVOC"><span
                          class="toc-text">RANDOM HAVOC</span></a></li>
                    <li class="toc-item toc-level-2"><a class="toc-link" href="#SPLICING"><span
                          class="toc-text">SPLICING</span></a></li>
                  </ol>
                </li>
                <li class="toc-item toc-level-1"><a class="toc-link"
                    href="#%E8%B7%AF%E5%BE%84%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90"><span
                      class="toc-text">路径信息的获取和分析</span></a></li>
                <li class="toc-item toc-level-1"><a class="toc-link"
                    href="#%E6%8F%92%E6%A1%A9%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span
                      class="toc-text">插桩部分源码分析</span></a>
                  <ol class="toc-child">
                    <li class="toc-item toc-level-2"><a class="toc-link"
                        href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E6%8F%92%E6%A1%A9"><span
                          class="toc-text">什么时候进行插桩</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link"
                            href="#%E6%8F%92%E6%A1%A9%E4%BD%8D%E7%BD%AE1-%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84%E5%BC%80%E5%A7%8B"><span
                              class="toc-text">插桩位置1-基本块的开始</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link"
                            href="#%E6%8F%92%E6%A1%A9%E4%BD%8D%E7%BD%AE2-%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E4%B9%8B%E5%90%8E"><span
                              class="toc-text">插桩位置2-条件跳转之后</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link"
                            href="#%E6%8F%92%E6%A1%A9%E4%BD%8D%E7%BD%AE3-%E7%BB%93%E5%B0%BE"><span
                              class="toc-text">插桩位置3-结尾</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link"
                        href="#%E6%8F%92%E6%A1%A9%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">插桩的内容</span></a>
                      <ol class="toc-child">
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#trampoline-fmt-64"><span
                              class="toc-text">trampoline_fmt_64</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#afl-setup"><span
                              class="toc-text">__afl_setup</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#afl-forkserver"><span
                              class="toc-text">__afl_forkserver</span></a></li>
                        <li class="toc-item toc-level-3"><a class="toc-link" href="#afl-store"><span
                              class="toc-text">__afl_store</span></a></li>
                      </ol>
                    </li>
                    <li class="toc-item toc-level-2"><a class="toc-link"
                        href="#%E5%91%BD%E4%B8%AD%E6%AC%A1%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97"><span
                          class="toc-text">命中次数的计算</span></a></li>
                  </ol>
                </li>
                <li class="toc-item toc-level-1"><a class="toc-link" href="#AFL%E6%80%BB%E7%BB%93"><span
                      class="toc-text">AFL总结</span></a></li>
                <li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span
                      class="toc-text">参考</span></a></li>
              </ol>
            </div>
          </div>
          <div class="card-widget card-recent-post">
            <div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div>
            <div class="aside-list">
              <div class="aside-list-item"><a class="thumbnail" href="/posts/95726211.html" title="AFL源码及流程分析"><img
                    src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-3.jpeg"
                    onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AFL源码及流程分析" /></a>
                <div class="content"><a class="title" href="/posts/95726211.html" title="AFL源码及流程分析">AFL源码及流程分析</a><time
                    datetime="2022-05-26T07:20:45.000Z" title="发表于 2022-05-26 15:20:45">2022-05-26</time></div>
              </div>
              <div class="aside-list-item"><a class="thumbnail" href="/posts/1029211104.html"
                  title="V8 重新入门-2019 starCTF oob 题解"><img
                    src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-37.jpeg"
                    onerror="this.onerror=null;this.src='/img/404.jpg'" alt="V8 重新入门-2019 starCTF oob 题解" /></a>
                <div class="content"><a class="title" href="/posts/1029211104.html"
                    title="V8 重新入门-2019 starCTF oob 题解">V8 重新入门-2019 starCTF oob 题解</a><time
                    datetime="2021-11-05T14:20:21.000Z" title="发表于 2021-11-05 22:20:21">2021-11-05</time></div>
              </div>
              <div class="aside-list-item"><a class="thumbnail" href="/posts/1864456601.html"
                  title="2021 0CTF/TCTF Final Naive Heap"><img
                    src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-57.jpeg"
                    onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 0CTF/TCTF Final Naive Heap" /></a>
                <div class="content"><a class="title" href="/posts/1864456601.html"
                    title="2021 0CTF/TCTF Final Naive Heap">2021 0CTF/TCTF Final Naive Heap</a><time
                    datetime="2021-09-29T02:18:50.000Z" title="发表于 2021-09-29 10:18:50">2021-09-29</time></div>
              </div>
              <div class="aside-list-item"><a class="thumbnail" href="/posts/2427305175.html"
                  title="虚拟机逃逸&amp;漏洞复现"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-17.jpeg"
                    onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机逃逸&amp;漏洞复现" /></a>
                <div class="content"><a class="title" href="/posts/2427305175.html"
                    title="虚拟机逃逸&amp;漏洞复现">虚拟机逃逸&amp;漏洞复现</a><time datetime="2021-08-18T05:34:33.000Z"
                    title="发表于 2021-08-18 13:34:33">2021-08-18</time></div>
              </div>
              <div class="aside-list-item"><a class="thumbnail" href="/posts/3705072996.html"
                  title="2021 XCTF Final 线下WP"><img
                    src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-32.jpeg"
                    onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 XCTF Final 线下WP" /></a>
                <div class="content"><a class="title" href="/posts/3705072996.html" title="2021 XCTF Final 线下WP">2021
                    XCTF Final 线下WP</a><time datetime="2021-07-30T07:26:18.000Z"
                    title="发表于 2021-07-30 15:26:18">2021-07-30</time></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
    <footer id="footer">
      <div id="footer-wrap">
        <div class="copyright">&copy;2020 - 2022 By LYYL</div>
        <div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer"
            href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank"
            rel="noopener external nofollow noreferrer"
            href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div>
      </div>
    </footer>
  </div>
  <div id="rightside">
    <div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i
          class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i
          class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i
          class="fas fa-arrows-alt-h"></i></button></div>
    <div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i
          class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button"
        title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i
          class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i
          class="fas fa-arrow-up"></i></button></div>
  </div>
  <div>
    <script src="/js/utils.js"></script>
    <script src="/js/main.js"></script>
    <div class="js-pjax">
      <script>function loadDisqus() {
          var disqus_config = function () {
            this.page.url = 'https://www.lyyl.online/posts/95726211.html'
            this.page.identifier = 'posts/95726211.html'
            this.page.title = 'AFL源码及流程分析'
          };

          window.disqusReset = () => {
            DISQUS.reset({
              reload: true,
              config: disqus_config
            })
          }

          if (window.DISQUS) disqusReset()
          else {
            (function () {
              var d = document, s = d.createElement('script');
              s.src = 'https://lyyl-online.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
            })();
          }
        }

        if ('Disqus' === 'Disqus' || !false) {
          if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
          else loadDisqus()
        } else {
          function loadOtherComment() {
            loadDisqus()
          }
        }
      </script>
    </div>
    <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  </div>
</body>

</html>